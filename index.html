<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"lessisbetter.site","root":"/","scheme":"Pisces","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="区块链、Go语言">
<meta property="og:type" content="website">
<meta property="og:title" content="Go语言充电站">
<meta property="og:url" content="http://lessisbetter.site/index.html">
<meta property="og:site_name" content="Go语言充电站">
<meta property="og:description" content="区块链、Go语言">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="大彬">
<meta property="article:tag" content="区块链 Go语言 后端 技术 人生 编程">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://lessisbetter.site/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false
  };
</script>

  <title>Go语言充电站 - 大彬 less is better</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Go语言充电站" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Go语言充电站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">大彬 less is better</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-主页">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>主页</a>

  </li>
        <li class="menu-item menu-item-标签云">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签云</a>

  </li>
        <li class="menu-item menu-item-专题文章">

    <a href="/subject/" rel="section"><i class="fa fa-fw fa-th"></i>专题文章</a>

  </li>
        <li class="menu-item menu-item-文章列表">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>文章列表</a>

  </li>
        <li class="menu-item menu-item-关于">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-大牛博客">

    <a href="/blogs/" rel="section"><i class="fa fa-fw fa-sitemap"></i>大牛博客</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

  
</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2020/09/28/misunderstanding-iowait/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.lessisbetter.site/gzh-qrcode-logo-small.png">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="区块链、Go语言">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Go语言充电站">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/28/misunderstanding-iowait/" class="post-title-link" itemprop="url">被误解的iowait</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-09-28 16:57:19 / 修改时间：17:33:05" itemprop="dateCreated datePublished" datetime="2020-09-28T16:57:19+08:00">2020-09-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>有一个cpu指标叫<code>iowait</code>或者<code>wa</code>，在top、iostat、vmstat命令中都可以看到这一项。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[~]$ top</span><br><span class="line">top - 08:58:06 up 26 days, 23:20,  1 user,  load average: 0.07, 0.23, 0.26</span><br><span class="line">Tasks: 164 total,   1 running, 111 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  2.5 us,  1.2 sy,  0.0 ni, 96.2 id,  0.1 wa,  0.0 hi,  0.1 si,  0.0 st</span><br><span class="line">KiB Mem :  8167548 total,   698220 free,   996640 used,  6472688 buff&#x2F;cache</span><br><span class="line">KiB Swap:        0 total,        0 free,        0 used.  7061988 avail Mem</span><br><span class="line"></span><br><span class="line">[~]$ iostat</span><br><span class="line">Linux 4.15.0-112-generic (shitaibin-x) 	09&#x2F;28&#x2F;20 	_x86_64_	(4 CPU)</span><br><span class="line"></span><br><span class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class="line">           1.02    0.00    0.55    0.86    0.00   97.56</span><br><span class="line"></span><br><span class="line">Device             tps    kB_read&#x2F;s    kB_wrtn&#x2F;s    kB_read    kB_wrtn</span><br><span class="line">loop0             0.00         0.00         0.00          5          0</span><br><span class="line">vda              13.32         2.65        84.15    6182326  196098973</span><br><span class="line"></span><br><span class="line">[~]$</span><br><span class="line">[~]$</span><br><span class="line">[~]$ vmstat</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> 0  0      0 685616 177356 6306652    0    0     1    21    5    3  1  1 98  1  0</span><br></pre></td></tr></table></figure>
<p>这个指标的字面含义是等待IO的时间（百分比），很多人会认为这个指标暗示这IO瓶颈，然而这是有一定无解的，iowait高不一定有IO瓶颈。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iowait &#x3D; CPU空闲时间 &#x2F; CPU总时间 ，前提CPU在等待至少一项IO操作完成</span><br></pre></td></tr></table></figure>
<p>所以它真正的含义是有未完成的IO操作时，CPU空闲的时间。</p>
<p>这2个资料都把iowait讲解的很清晰，并且举例iowait和IO瓶颈无关的例子。</p>
<ul>
<li><a href="http://linuxperf.com/?p=33" target="_blank" rel="noopener">理解iowait</a></li>
<li><a href="https://www.inspurpower.com/upload/file/1583309942.pdf" target="_blank" rel="noopener">浪潮：CPU iowait详解</a></li>
</ul>
<p>例子：</p>
<ul>
<li>低iowait，高IO的例子：IO高同时CPU计算也高，这样CPU的空闲时间少，造成iowait比较低，CPU密集掩盖了IO密集。</li>
<li>高iowait，低IO的例子：CPU计算很少，CPU基本空闲，但也有1个进程在IO，所以iowait高，但实际IO根本没任何瓶颈。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2020/09/06/deloy-k8s-on-ubuntu16/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.lessisbetter.site/gzh-qrcode-logo-small.png">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="区块链、Go语言">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Go语言充电站">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/06/deloy-k8s-on-ubuntu16/" class="post-title-link" itemprop="url">Ubuntu 16.04上部署单机Kubernetes</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-06 08:33:55" itemprop="dateCreated datePublished" datetime="2020-09-06T08:33:55+08:00">2020-09-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-10-09 10:27:08" itemprop="dateModified" datetime="2020-10-09T10:27:08+08:00">2020-10-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在公司都是用现成的K8s集群，没自己搭过，想知道搭建集群涉及哪些组件、做了什么，于是自己搭了一下，没想象的顺利，动作做到位了，也就不会有太多问题。</p>
<p>许多资料都是基于Centos7的，包括《Kubernetes权威指南》，手头只有Ubuntu 16.04，刚好也是支持K8s最低Ubuntu版本，就在Ubuntu上面部署。Ubuntu与Centos部署K8s并没有太大区别，唯一区别是安装kubeadm等软件的不同，由于k8s本身也是运行在容器中，其他的过程二者都相同了，这种设计也极大的方便了k8s集群的搭建。</p>
<p><strong>没有阿里云，搭建一个K8s集群还是挺费劲的</strong>。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol>
<li><code>/etc/hosts</code>中加入：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 k8s-master</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>关闭防火墙：<code>ufw status</code></p>
</li>
<li><p><a href="https://lessisbetter.site/2020/09/05/docker-proxy-and-registry-mirror/">安装Docker，并设置镜像加速器</a>。</p>
</li>
</ol>
<h2 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h2><p>Ubuntu 16.04上利用阿里云安装kubeadm、kubelet、kubectl</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update &amp;&amp; sudo apt-get install -y apt-transport-https curl</span><br><span class="line">curl -s http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;apt&#x2F;doc&#x2F;apt-key.gpg | sudo apt-key add -</span><br><span class="line">cat &lt;&lt;EOF | sudo tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;kubernetes.list</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;apt&#x2F; kubernetes-xenial main</span><br><span class="line">EOF</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y kubelet kubeadm kubectl</span><br><span class="line">sudo apt-mark hold kubelet kubeadm kubectl</span><br></pre></td></tr></table></figure>
<p>centos 7上利用阿里云镜像安装kubeadm、kubelet、kubectl</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt; &#x2F;etc&#x2F;yum.repos.d&#x2F;kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name&#x3D;Kubernetes</span><br><span class="line">baseurl&#x3D;http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;yum&#x2F;repos&#x2F;kubernetes-el7-x86_64</span><br><span class="line">enabled&#x3D;1</span><br><span class="line">gpgcheck&#x3D;1</span><br><span class="line">repo_gpgcheck&#x3D;1</span><br><span class="line">gpgkey&#x3D;http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;yum&#x2F;doc&#x2F;yum-key.gpg http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;yum&#x2F;doc&#x2F;rpm-package-key.gpg</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"># 将 SELinux 设置为 permissive 模式（相当于将其禁用）</span><br><span class="line">setenforce 0</span><br><span class="line">sed -i &#39;s&#x2F;^SELINUX&#x3D;enforcing$&#x2F;SELINUX&#x3D;permissive&#x2F;&#39; &#x2F;etc&#x2F;selinux&#x2F;config</span><br><span class="line"></span><br><span class="line">yum install -y kubelet kubeadm kubectl --disableexcludes&#x3D;kubernetes</span><br><span class="line"></span><br><span class="line">systemctl enable --now kubelet</span><br></pre></td></tr></table></figure>
<p>二进制程序安装位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[~]$ which kubectl kubeadm kubectl</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;kubectl</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;kubeadm</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;kubectl</span><br></pre></td></tr></table></figure>
<h2 id="部署Master节点"><a href="#部署Master节点" class="headerlink" title="部署Master节点"></a>部署Master节点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init \</span><br><span class="line">  --kubernetes-version&#x3D;v1.19.0 \</span><br><span class="line">  --image-repository registry.cn-hangzhou.aliyuncs.com&#x2F;google_containers \</span><br><span class="line">  --pod-network-cidr&#x3D;10.24.0.0&#x2F;16 \</span><br><span class="line">  --ignore-preflight-errors&#x3D;Swap</span><br></pre></td></tr></table></figure>
<ul>
<li><code>--image-repository</code> ： 由于<code>k8s.gcr.io</code>由于网络原因无法访问，使用阿里云提供的k8s镜像仓库，快速下载k8s相关的镜像</li>
<li><code>--ignore-preflight-errors</code> ： 部署时忽略swap问题</li>
<li><code>--pod-network-cidr</code> ：设置pod的ip区间</li>
</ul>
<p>遇到错误需要重置集群：<code>kubeadm reset</code></p>
<p>遇到错误参考：<a href="https://www.cnblogs.com/pu20065226/p/10641312.html" target="_blank" rel="noopener">kubernetes安装过程报错及解决方法</a></p>
<h2 id="拷贝kubectl配置"><a href="#拷贝kubectl配置" class="headerlink" title="拷贝kubectl配置"></a>拷贝kubectl配置</h2><p>切回普通用户，拷贝当前集群的配置给kubectl使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p $HOME&#x2F;.kube</span><br><span class="line">sudo cp -i &#x2F;etc&#x2F;kubernetes&#x2F;admin.conf $HOME&#x2F;.kube&#x2F;config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME&#x2F;.kube&#x2F;config</span><br></pre></td></tr></table></figure>
<p>查看集群信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dabin@ubuntu:~$ kubectl cluster-info</span><br><span class="line">Kubernetes master is running at https:&#x2F;&#x2F;192.168.0.103:6443</span><br><span class="line">KubeDNS is running at https:&#x2F;&#x2F;192.168.0.103:6443&#x2F;api&#x2F;v1&#x2F;namespaces&#x2F;kube-system&#x2F;services&#x2F;kube-dns:dns&#x2F;proxy</span><br></pre></td></tr></table></figure>
<h2 id="安装CNI网络插件"><a href="#安装CNI网络插件" class="headerlink" title="安装CNI网络插件"></a>安装CNI网络插件</h2><p>k8s本身不负责容器之间的通信，集群启动后，集群的Pod直接还不能通信，需要安装网络插件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dabin@ubuntu:~$ kubectl get node</span><br><span class="line">NAME         STATUS     ROLES    AGE    VERSION</span><br><span class="line">k8s-master   NotReady   master   5m8s   v1.19.0</span><br></pre></td></tr></table></figure>
<p>k8s的<a href="https://kubernetes.io/zh/docs/concepts/cluster-administration/addons/" target="_blank" rel="noopener">文档</a>列举了多种选择，这里提供2种：</p>
<p>weave:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f &quot;https:&#x2F;&#x2F;cloud.weave.works&#x2F;k8s&#x2F;net?k8s-version&#x3D;$(kubectl version | base64 | tr -d &#39;\n&#39;)&quot;</span><br></pre></td></tr></table></figure>
<p>flannel:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;coreos&#x2F;flannel&#x2F;master&#x2F;Documentation&#x2F;kube-flannel.yml</span><br></pre></td></tr></table></figure>
<p>本机选择了weave：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dabin@ubuntu:~$ kubectl apply -f &quot;https:&#x2F;&#x2F;cloud.weave.works&#x2F;k8s&#x2F;net?k8s-version&#x3D;$(kubectl version | base64 | tr -d &#39;\n&#39;)&quot;</span><br><span class="line">serviceaccount&#x2F;weave-net created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io&#x2F;weave-net created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io&#x2F;weave-net created</span><br><span class="line">role.rbac.authorization.k8s.io&#x2F;weave-net created</span><br><span class="line">rolebinding.rbac.authorization.k8s.io&#x2F;weave-net created</span><br><span class="line">daemonset.apps&#x2F;weave-net created</span><br></pre></td></tr></table></figure>
<p>安装之后节点变为Ready：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">dabin@ubuntu:~$ kubectl get node</span><br><span class="line">NAME         STATUS   ROLES    AGE   VERSION</span><br><span class="line">k8s-master   Ready    master   10m   v1.19.0</span><br><span class="line">dabin@ubuntu:~$</span><br><span class="line">dabin@ubuntu:~$ kubectl get -n kube-system pods</span><br><span class="line">NAME                                 READY   STATUS    RESTARTS   AGE</span><br><span class="line">coredns-6d56c8448f-bdgwj             1&#x2F;1     Running   0          10m</span><br><span class="line">coredns-6d56c8448f-w6nnb             1&#x2F;1     Running   0          10m</span><br><span class="line">etcd-k8s-master                      1&#x2F;1     Running   0          10m</span><br><span class="line">kube-apiserver-k8s-master            1&#x2F;1     Running   0          10m</span><br><span class="line">kube-controller-manager-k8s-master   1&#x2F;1     Running   0          10m</span><br><span class="line">kube-proxy-xtgwn                     1&#x2F;1     Running   0          10m</span><br><span class="line">kube-scheduler-k8s-master            1&#x2F;1     Running   0          10m</span><br><span class="line">weave-net-4gtcq                      2&#x2F;2     Running   0          93s</span><br></pre></td></tr></table></figure>
<h2 id="开启master调度"><a href="#开启master调度" class="headerlink" title="开启master调度"></a>开启master调度</h2><p>master节点默认是不可调度的，不可在master上部署任务，在单节点下，需要开启master可被调度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl taint nodes --all node-role.kubernetes.io&#x2F;master-</span><br></pre></td></tr></table></figure>
<p>以上集群搭建完毕。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>部署一个Pod进行测试，Pod能Running，代表Docker、K8s的配置基本没问题了：</p>
<p>声明文件为<code>twocontainers.yaml</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1 #指定当前描述文件遵循v1版本的Kubernetes API</span><br><span class="line">kind: Pod #我们在描述一个pod</span><br><span class="line">metadata:</span><br><span class="line">  name: twocontainers #指定pod的名称</span><br><span class="line">  namespace: default #指定当前描述的pod所在的命名空间</span><br><span class="line">  labels: #指定pod标签</span><br><span class="line">    app: twocontainers</span><br><span class="line">  annotations: #指定pod注释</span><br><span class="line">    version: v0.5.0</span><br><span class="line">    releasedBy: david</span><br><span class="line">    purpose: demo</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">    - name: sise #容器的名称</span><br><span class="line">      image: quay.io&#x2F;openshiftlabs&#x2F;simpleservice:0.5.0 #创建容器所使用的镜像</span><br><span class="line">      ports:</span><br><span class="line">        - containerPort: 9876 #应用监听的端口</span><br><span class="line">    - name: shell #容器的名称</span><br><span class="line">      image: centos:7 #创建容器所使用的镜像</span><br><span class="line">      command: #容器启动命令</span><br><span class="line">        - &quot;bin&#x2F;bash&quot;</span><br><span class="line">        - &quot;-c&quot;</span><br><span class="line">        - &quot;sleep 10000&quot;</span><br></pre></td></tr></table></figure>
<p>部署Pod：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f twocontainers.yaml</span><br></pre></td></tr></table></figure>
<p>几分钟后可以看pod状态是否为running。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dabin@k8s-master:~&#x2F;workspace&#x2F;notes&#x2F;kubernetes&#x2F;examples$ kubectl get pods</span><br><span class="line">NAME            READY   STATUS    RESTARTS   AGE</span><br><span class="line">twocontainers   2&#x2F;2     Running   2          83m</span><br></pre></td></tr></table></figure>
<p>如果不是，查看Pod部署遇到的问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe pod twocontainers</span><br></pre></td></tr></table></figure>
<h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><ol>
<li>人人必备的神书《Kuerbenetes权威指南》</li>
<li><a href="https://kubernetes.io/zh/docs/setup/independent/create-cluster-kubeadm/" target="_blank" rel="noopener">K8S中文文档</a></li>
<li><a href="https://www.cnblogs.com/pu20065226/p/10641312.html" target="_blank" rel="noopener">kubernetes安装过程报错及解决方法</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2020/09/05/docker-proxy-and-registry-mirror/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.lessisbetter.site/gzh-qrcode-logo-small.png">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="区块链、Go语言">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Go语言充电站">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/05/docker-proxy-and-registry-mirror/" class="post-title-link" itemprop="url">Docker网络代理和仓库镜像加速</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-05 14:48:04" itemprop="dateCreated datePublished" datetime="2020-09-05T14:48:04+08:00">2020-09-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-06 08:30:50" itemprop="dateModified" datetime="2020-09-06T08:30:50+08:00">2020-09-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>对于Docker官方镜像仓库<code>Registry</code>，没有仓库镜像加速，寸步难行。</p>
<p>对于国外非Docker官方镜像仓库，并且还被墙的仓库<code>Registry</code>，没有网络代理，寸步难行。</p>
<p>镜像仓库加速器<code>Registry Mirrors</code>，是国内对官方<code>Registry</code>的”镜像(mirror)”，当拉取image时，Docker Daemon先去 <code>Registry Mirrors</code> 拉去镜像，如果没找到镜像，<code>Registry Mirrors</code>找官方<code>Registry</code>拉去镜像，然后再返回给本地。</p>
<p>网络代理是给Docker设置http和https代理，最原始的方式，适合有代理的情况。主要用于服务器上有<strong>稳定可访问</strong>的代理或者当前主机上有稳定代理的情况。对于代理和docker不在同一台机器上时，稳定可访问就成了一个问题，比如代理在笔记本上，IP随时都可能变化，服务器连接笔记本做代理，就算法上稳定可访问，而docker也在笔记本上运行，通过环回地址就能稳定访问。</p>
<p><strong>不推荐给Docker设置代理，而应当优先使用<code>Registry Mirrors</code></strong>。代理也是有副作用的，你需要保证非本机能稳定连接到代理，并且能够转发数据，不然端口拒绝访问、TLS握手失败等问题，需要花费更多的时间。</p>
<p>可访问的Registry有：</p>
<ul>
<li><a href="https://quay.io/" target="_blank" rel="noopener">quay.io</a> : 只是访问慢一些而已，可以拉下镜像来</li>
</ul>
<h2 id="镜像仓库加速器-推荐"><a href="#镜像仓库加速器-推荐" class="headerlink" title="镜像仓库加速器(推荐)"></a>镜像仓库加速器(推荐)</h2><p>如果指定拉某个镜像仓库的镜像，镜像加速器是用不上的。如果该仓库可以访问，非本机有代理的情况，无需配置网络代理。</p>
<p>看如何配置<a href="https://yeasy.gitbooks.io/docker_practice/install/mirror.html" target="_blank" rel="noopener">Docker镜像加速器</a>。</p>
<p>推荐使用阿里云、七牛、DaoCloud的镜像仓库加速器。</p>
<p><code>/etc/docker/daemon.json</code> 配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;insecure-registries&quot;:[&quot;192.168.9.8:80&quot;],</span><br><span class="line">    &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;a90tkz28.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后冲抵daemon：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
<h2 id="网络代理-不推荐"><a href="#网络代理-不推荐" class="headerlink" title="网络代理(不推荐)"></a>网络代理(不推荐)</h2><p>我Mac上的http、https、socks5代理，http和https监听的是7890端口，sock5监听的是7891端口。</p>
<p>拉镜像时，可以看到docker连接了7890端口走http代理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;private&#x2F;tmp]$ lsof -i:7890</span><br><span class="line">COMMAND     PID      USER   FD   TYPE             DEVICE SIZE&#x2F;OFF NODE NAME</span><br><span class="line">....</span><br><span class="line">com.docke 73371 shitaibin   50u  IPv4 0xa8184ba4240fbe99      0t0  TCP localhost:58847-&gt;localhost:7890 (ESTABLISHED)</span><br><span class="line">com.docke 73371 shitaibin   53u  IPv4 0xa8184ba4035deb09      0t0  TCP localhost:58857-&gt;localhost:7890 (ESTABLISHED)</span><br><span class="line">com.docke 73371 shitaibin   58u  IPv4 0xa8184ba42d889861      0t0  TCP localhost:58893-&gt;localhost:7890 (ESTABLISHED)</span><br></pre></td></tr></table></figure>
<p><a href="https://docs.docker.com/network/proxy/" target="_blank" rel="noopener">官方设置代理教程</a>，2选1:</p>
<ol>
<li>给Docker客户端设置代理，拉去镜像、创建新容器时，客户端会把变量发送给Daemon。支持17.07及以上版本，这是官方推荐方式。</li>
<li>给Daemon设置代理，通过环境变量的方式。支持17.06及以下版本，不推荐。</li>
</ol>
<p>给Daemon设置的代理的另外方法：</p>
<p>创建Daemon的代理配置文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;docker.service.d</span><br><span class="line">sudo touch &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;docker.service.d&#x2F;http-proxy.conf</span><br></pre></td></tr></table></figure>
<p>内容为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">Environment&#x3D;&quot;HTTP_PROXY&#x3D;http:&#x2F;&#x2F;proxy.server.com:913&#x2F;&quot; &quot;HTTPS_PROXY&#x3D;http:&#x2F;&#x2F;proxy.server.com:913&#x2F;&quot; &quot;NO_PROXY&#x3D;localhost,127.0.0.1,10.96.0.0&#x2F;16, 10.244.0.0&#x2F;16&quot;</span><br></pre></td></tr></table></figure>
<p>然后重启Daemon：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br><span class="line"></span><br><span class="line">systemctl show --property&#x3D;Environment docker</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2020/09/01/cgroup-3-cpu-md/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.lessisbetter.site/gzh-qrcode-logo-small.png">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="区块链、Go语言">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Go语言充电站">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/01/cgroup-3-cpu-md/" class="post-title-link" itemprop="url">Docker容器基础3：Cgroup - cpu, cpuacct, cpuset子系统</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-09-01 23:00:24 / 修改时间：23:19:56" itemprop="dateCreated datePublished" datetime="2020-09-01T23:00:24+08:00">2020-09-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h2><p>Ubuntu 18.04，内核版本4.15，机器拥有4核。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[~]$ cat &#x2F;proc&#x2F;version</span><br><span class="line">Linux version 4.15.0-112-generic (buildd@lcy01-amd64-027) (gcc version 7.5.0 (Ubuntu 7.5.0-3ubuntu1~18.04)) #113-Ubuntu SMP Thu Jul 9 23:41:39 UTC 2020</span><br><span class="line">[~]$</span><br><span class="line">[~]$ cat &#x2F;etc&#x2F;os-release</span><br><span class="line">NAME&#x3D;&quot;Ubuntu&quot;</span><br><span class="line">VERSION&#x3D;&quot;18.04.3 LTS (Bionic Beaver)&quot;</span><br><span class="line">...</span><br><span class="line">[~]$ cat &#x2F;proc&#x2F;cpuinfo | grep &quot;processor&quot; | wc -l</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<h2 id="CPU相关子系统简介"><a href="#CPU相关子系统简介" class="headerlink" title="CPU相关子系统简介"></a>CPU相关子系统简介</h2><p>有关CPU的cgroup subsystem有3个：</p>
<ul>
<li>cpu : 用来<strong>限制</strong>cgroup的CPU使用率</li>
<li>cpuacct : 用来<strong>统计</strong>cgroup的CPU的使用率</li>
<li>cpuset : 用来绑定cgroup到指定CPU的哪个核上和NUMA节点</li>
</ul>
<p>每个子系统都有多个配置项和指标文件，主要介绍下图常用的配置项：</p>
<p><img src="http://img.lessisbetter.site/2020-09-cgroup-cpux.png" alt="cpu、cpuacct、cpuset的指标"></p>
<h3 id="cpu"><a href="#cpu" class="headerlink" title="cpu"></a>cpu</h3><p>cpu子系统用来限制cgroup如何使用CPU的时间，也就是调度，它提供了3种调度办法，并且这3种调度办法都可以在启动容器时进行配置，分别是：</p>
<ul>
<li>share ：相对权重的CPU调度</li>
<li>cfs ：完全公平调度</li>
<li>rt ：实时调度</li>
</ul>
<p>share调度的配置项和原理如下：</p>
<p><img src="http://img.lessisbetter.site/2020-09-cgroup-cpu-share.png" alt="cpu share调度"></p>
<p>cfs 是Completely Fair Scheduler的缩写，代表完全公平调度，它利用 <code>cpu.cfs_quota_us</code> 和 <code>cpu.cfs_period_us</code> 实现公平调度，这两个文件内容组合使用可以限制进程在长度为 <code>cfs_period_us</code> 的时间内，只能被分配到总量为 <code>cfs_quota_us</code> 的 CPU 时间。CFS的指标如下：</p>
<p><img src="http://img.lessisbetter.site/2020-09-cgroup-cpu-cfs.png" alt="cpu cfs调度"></p>
<p><strong>注意</strong>： </p>
<ol>
<li><code>cfs_period_us</code> 取值范围1000~1000000：1ms ~ 1s，<code>cfs_quota_us</code>的最小值为1000，当设置的值不在取值范围时，会报 <code>write xxx: invalid argument</code> 的错误。</li>
<li>只有这2个参数都有意义时，才能把任务写入到 tasks 文件。</li>
</ol>
<p>rt 是RealTime的缩写，它是实时调度，它与cfs调度的区别是cfs不会保证进程的CPU使用率一定要达到设置的比率，而rt会严格保证，让进程的占用率达到这个比率，适合实时性较强的任务，它包含 <code>cpu.rt_period_us</code> 和 <code>cpu.rt_runtime_us</code> 2个配置项。</p>
<h3 id="cpuacct"><a href="#cpuacct" class="headerlink" title="cpuacct"></a>cpuacct</h3><p>cpuacct包含非常多的统计指标，常用的有以下4个文件：</p>
<p><img src="http://img.lessisbetter.site/2020-09-cgroup-cpuacct.png" alt="cpuacct常用指标文件"></p>
<h3 id="cpuset"><a href="#cpuset" class="headerlink" title="cpuset"></a>cpuset</h3><p>为啥需要cpuset？</p>
<p>比如：</p>
<ol>
<li>多核可以提高并发、并行，但是核太多了，会影响进程执行的局部性，降低效率。</li>
<li>一个服务器上部署多种应用，不同的应用不同的核。</li>
</ol>
<p>cpuset也包含居多的配置项，主要是分为cpu和mem 2类，mem与NUMA有关，其常用的配置项如下图:</p>
<p><img src="http://img.lessisbetter.site/2020-09-cgroup-cpuset.png" alt="cpuset常用配置项"></p>
<h2 id="利用Docker演示Cgroup-CPU限制"><a href="#利用Docker演示Cgroup-CPU限制" class="headerlink" title="利用Docker演示Cgroup CPU限制"></a>利用Docker演示Cgroup CPU限制</h2><h3 id="cpu-1"><a href="#cpu-1" class="headerlink" title="cpu"></a>cpu</h3><h4 id="不限制cpu的情况"><a href="#不限制cpu的情况" class="headerlink" title="不限制cpu的情况"></a>不限制cpu的情况</h4><p>stress为基于ubuntu:16.04安装stress做出来的镜像，利用stress来测试cpu限制。</p>
<p>Dockerfile如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">From</span> ubuntu:<span class="number">16.04</span></span><br><span class="line"><span class="comment"># Using Aliyun mirror</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mv /etc/apt/sources.list /root/sources.list.bak</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> sed -e s/security.ubuntu/mirrors.aliyun/ -e s/archive.ubuntu/mirrors.aliyun/ -e s/archive.canonical/mirrors.aliyun/ -e s/esm.ubuntu/mirrors.aliyun/ /root/sources.list.bak &gt; /etc/apt/sources.list</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get install -y stress</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /root</span></span><br></pre></td></tr></table></figure>
<p>启动容器不做任何cpu限制，利用 <code>stress -c 2</code> 开启另外2个stress线程，共3个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu]$ docker run --rm -it stress:16.04</span><br><span class="line">root@5fad38726740:&#x2F;# stress -c 2</span><br><span class="line">stress: info: [12] dispatching hogs: 2 cpu, 0 io, 1 vm, 0 hdd</span><br></pre></td></tr></table></figure>
<p>在<code>cgroup/cpu,cpuacct</code>下，找到该容器对应的目录，查看 <code>cfs_period_us</code> 和 <code>cfs_quota_us</code> 的默认值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu,cpuacct&#x2F;system.slice&#x2F;docker-5fad38726740b90b93c06972fe4a9f11391a38aaeb3e922f10c3269fa32e1873.scope]$ cat cpu.cfs_period_us</span><br><span class="line">100000</span><br><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu,cpuacct&#x2F;system.slice&#x2F;docker-5fad38726740b90b93c06972fe4a9f11391a38aaeb3e922f10c3269fa32e1873.scope]$ cat cpu.cfs_quota_us</span><br><span class="line">-1</span><br></pre></td></tr></table></figure>
<p>查看主机CPU利用率，为3个stress进程，每1个都100%，它们属于同一个cgroup：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line">5616 root      20   0  109872 102336     36 R 100.0  1.3   0:07.46 stress</span><br><span class="line">5617 root      20   0    7468     88      0 R 100.0  0.0   0:07.45 stress</span><br><span class="line">5615 root      20   0    7468     88      0 R 100.0  0.0   0:07.45 stress</span><br></pre></td></tr></table></figure>
<h4 id="限制cpu的情况"><a href="#限制cpu的情况" class="headerlink" title="限制cpu的情况"></a>限制cpu的情况</h4><p><code>--cpu-quota</code>设置5000，开stress分配到另外2个核。</p>
<p>[/sys/fs/cgroup/cpu]$ docker run –rm -it –cpu-quota=5000 stress:16.04<br>root@7e79005d7ca1:/#<br>root@7e79005d7ca1:/# stress  -c 2<br>stress: info: [13] dispatching hogs: 2 cpu, 0 io, 1 vm, 0 hdd</p>
<p>查看 <code>cfs_period_us</code> 和 <code>cfs_quota_us</code> 的设置，<code>5000/100000 = 5%</code> ， 即限制该容器的CPU使用率不得超过5%。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu,cpuacct&#x2F;system.slice&#x2F;docker-7e79005d7ca1b338d870d3dc79af3f1cd38ace195ebd685a09575f6acee36a07.scope]$ cat cpu.cfs_quota_us</span><br><span class="line">5000</span><br><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu,cpuacct&#x2F;system.slice&#x2F;docker-7e79005d7ca1b338d870d3dc79af3f1cd38ace195ebd685a09575f6acee36a07.scope]$ cat cpu.cfs_period_us</span><br><span class="line">100000</span><br></pre></td></tr></table></figure>
<p>利用top可以看到3个进程总cpu使用率5.1%。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line">5411 root      20   0    7468     92      0 R   1.7  0.0   0:00.53 stress</span><br><span class="line">5412 root      20   0  109872 102500     36 R   1.7  1.3   0:00.30 stress</span><br><span class="line">5413 root      20   0    7468     92      0 R   1.7  0.0   0:00.35 stress</span><br></pre></td></tr></table></figure>
<h3 id="cpuacct-1"><a href="#cpuacct-1" class="headerlink" title="cpuacct"></a>cpuacct</h3><p>查看<code>cpuacct.stat, cpuacct.usage, cpuacct.usage_percpu</code>，一定要同时输出这几个文件，不然可能有时间差，利用python可以计算每个核上的时间之和为<code>usage</code>，即该容器占用的cpu总时间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu,cpuacct]$ cat cpuacct.*</span><br><span class="line">user 20244450 &#x2F;&#x2F; cpuacct.stat</span><br><span class="line">system 52361  &#x2F;&#x2F; cpuacct.stat</span><br><span class="line">204310768947624  &#x2F;&#x2F; cpuacct.usage</span><br><span class="line">61143521333219 32616883199042 73804985004267 36745379411096 &#x2F;&#x2F; cpuacct.usage_percpu</span><br><span class="line"></span><br><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu,cpuacct]$ python</span><br><span class="line">Python 2.7.5 (default, Apr 11 2018, 07:36:10)</span><br><span class="line">[GCC 4.8.5 20150623 (Red Hat 4.8.5-28)] on linux2</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt; sum &#x3D; 61143521333219+32616883199042+73804985004267+36745379411096</span><br><span class="line">&gt;&gt;&gt; dist &#x3D; sum - 204310768947624</span><br><span class="line">&gt;&gt;&gt; dist</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; sum</span><br><span class="line">204310768947624</span><br><span class="line">&gt;&gt;&gt; sum2 &#x3D; 20244450+52361</span><br><span class="line">&gt;&gt;&gt; sum2</span><br><span class="line">20296811</span><br></pre></td></tr></table></figure>
<h3 id="cpuset-1"><a href="#cpuset-1" class="headerlink" title="cpuset"></a>cpuset</h3><p>启动容器，然后使用stress占用1个核：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu]$ docker run --rm -it stress:16.04</span><br><span class="line">root@a907df624697:~#</span><br><span class="line">root@a907df624697:~# stress -c 1</span><br><span class="line">stress: info: [12] dispatching hogs: 1 cpu, 0 io, 0 vm, 0 hdd</span><br></pre></td></tr></table></figure>
<p>top显示占用100%CPU。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line">6633 root      20   0    7480     92      0 R 100.0  0.0   0:12.13 stress</span><br></pre></td></tr></table></figure>
<p>cpuset 能看到可使用的核为： 0~3。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset&#x2F;docker&#x2F;a907df624697a19631929c1e9e971d2893afddbf6befb0dd44be3cf0024a3e0d]$ cat cpuset.cpus</span><br><span class="line">0-3</span><br></pre></td></tr></table></figure>
<p>使用cpuacct查看CPU情况使用统计，可以看到用了4个核上的使用时间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu&#x2F;docker&#x2F;a907df624697a19631929c1e9e971d2893afddbf6befb0dd44be3cf0024a3e0d]$ cat cpuacct.usage cpuacct.usage_all</span><br><span class="line">153015464879</span><br><span class="line">cpu user system</span><br><span class="line">0 45900415963 0</span><br><span class="line">1 4675002 0</span><br><span class="line">2 63537634967 0</span><br><span class="line">3 43572738947 0</span><br></pre></td></tr></table></figure>
<p>现在创建一个新容器，限制只能用1，3这2个核：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu]$ docker run --rm -it --cpuset-cpus 1,3 stress:16.04</span><br><span class="line">root@0ce61a38e7c9:~# stress -c 1</span><br><span class="line">stress: info: [10] dispatching hogs: 1 cpu, 0 io, 0 vm, 0 hdd</span><br></pre></td></tr></table></figure>
<p>查看可以使用的核：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset&#x2F;docker&#x2F;0ce61a38e7c9621334871ab40d5b7d287d89a1e994148833ddf3ca4941a39c89]$ cat cpuset.cpus</span><br><span class="line">1,3</span><br></pre></td></tr></table></figure>
<p><code>cpuacct.usage_all</code> 显示只有1、3两个核的数据在使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu&#x2F;docker&#x2F;0ce61a38e7c9621334871ab40d5b7d287d89a1e994148833ddf3ca4941a39c89]$ cat cpuacct.usage_all</span><br><span class="line">cpu user system</span><br><span class="line">0 0 0</span><br><span class="line">1 37322884717 0</span><br><span class="line">2 0 0</span><br><span class="line">3 21332956940 0</span><br></pre></td></tr></table></figure>
<p>现在切换到root账号，把 <code>sched_load_balance</code> 标记设置为0，不进行核间的负载均衡，然后利用 <code>cpuacct.usage_all</code> 查看每个核上的时间，隔几秒前后查询2次，可以发现3号核的cpu使用时间停留在<code>21332956940</code>，而核1的cpu使用时间从<code>185084024837</code> 增加到 <code>221479683602</code>， 说明设置之后stress线程一致在核1上运行，不再进行负载均衡。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset&#x2F;docker&#x2F;0ce61a38e7c9621334871ab40d5b7d287d89a1e994148833ddf3ca4941a39c89]$ echo 0 &gt; cpuset.sched_load_balance</span><br><span class="line"></span><br><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu&#x2F;docker&#x2F;0ce61a38e7c9621334871ab40d5b7d287d89a1e994148833ddf3ca4941a39c89]$ cat cpuacct.usage_all</span><br><span class="line">cpu user system</span><br><span class="line">0 0 0</span><br><span class="line">1 185084024837 0</span><br><span class="line">2 0 0</span><br><span class="line">3 21332956940 0</span><br><span class="line"></span><br><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu&#x2F;docker&#x2F;0ce61a38e7c9621334871ab40d5b7d287d89a1e994148833ddf3ca4941a39c89]$ cat cpuacct.usage_all</span><br><span class="line">cpu user system</span><br><span class="line">0 0 0</span><br><span class="line">1 221479683602 0</span><br><span class="line">2 0 0</span><br><span class="line">3 21332956940 0</span><br></pre></td></tr></table></figure>
<h2 id="利用Go演示Cgroup-CPU限制"><a href="#利用Go演示Cgroup-CPU限制" class="headerlink" title="利用Go演示Cgroup CPU限制"></a>利用Go演示Cgroup CPU限制</h2><p>测试程序：<a href="https://github.com/Shitaibin/notes/blob/master/docker/codes/02.2.cgroup_cpu.go" target="_blank" rel="noopener">02.2.cgroup_cpu.go</a> 。</p>
<p>该程序接受1个入参，代表测试类型：</p>
<ul>
<li>空或<code>nolimit</code>: 无限制</li>
<li><code>cpu</code> : 执行cpu限制，利用cfs把cpu使用率控制在5%</li>
<li><code>cpuset</code> : 限制只使用核1和核3</li>
</ul>
<p>测试程序的执行动作如下：</p>
<ol>
<li>程序首先在cpu和cpuset中创建2个cgroup，</li>
<li>按传入的参数设置限制或不设置限制</li>
<li>利用<code>/proc/self/exe</code>启动进程</li>
<li>把进程加入到2个cgroup的tasks，即加入cgroup</li>
<li>进程会创建3个goroutine不断的去消耗cpu，它们会占用3个线程</li>
</ol>
<p>当CPU使用率不限制时，3个线程会分配到3个核上执行，所以进程的CPU使用率应当达到300%。</p>
<p>利用测试程序分3组实验，然后利用 <code>top</code>、<code>cpuacct.usage_all</code>、<code>cpuset.cpu</code> 3个角度查看CPU限制和使用情况。</p>
<h3 id="不限制CPU"><a href="#不限制CPU" class="headerlink" title="不限制CPU"></a>不限制CPU</h3><ol>
<li>启动测试程序，进程id为4805，进入Namespace后进程id变为1，可以看到启动了3个worker协程。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;home&#x2F;ubuntu&#x2F;workspace&#x2F;notes&#x2F;docker&#x2F;codes]$ go run 02.2.cgroup_cpu.go</span><br><span class="line">---------- 1 ------------</span><br><span class="line">Test type: No limit</span><br><span class="line">cmdPid: 4805</span><br><span class="line">---------- 2 ------------</span><br><span class="line">Current pid: 1</span><br><span class="line">worker 2 start</span><br><span class="line">worker 0 start</span><br><span class="line">worker 1 start</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>top查看进程的CPU占用率为300%，符合预期。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line">4805 root      20   0    3376   1004    836 R 300.0  0.0   4:41.09 exe</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>利用cpuacct查看每个核上的使用时间：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuacct]$ cat test_cpu_limit&#x2F;cpuacct.usage_all</span><br><span class="line">cpu user system</span><br><span class="line">0 8046597390 0</span><br><span class="line">1 34269979109 0</span><br><span class="line">2 26597651949 0</span><br><span class="line">3 33886705168 0</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>利用cpuset.cpus查看使用的cpu核：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset]$ cat test_cpuset_limit&#x2F;cpuset.cpus</span><br><span class="line">0-3</span><br></pre></td></tr></table></figure>
<h3 id="使用cpu限制CPU使用率"><a href="#使用cpu限制CPU使用率" class="headerlink" title="使用cpu限制CPU使用率"></a>使用cpu限制CPU使用率</h3><ol>
<li>启动测试程序：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;home&#x2F;ubuntu&#x2F;workspace&#x2F;notes&#x2F;docker&#x2F;codes]$ go run 02.2.cgroup_cpu.go cpu</span><br><span class="line">---------- 1 ------------</span><br><span class="line">Test type: Cpu limit</span><br><span class="line">cmdPid: 4937</span><br><span class="line">---------- 2 ------------</span><br><span class="line">Current pid: 1</span><br><span class="line">worker 2 start</span><br><span class="line">worker 1 start</span><br><span class="line">worker 0 start</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>top查看进程的CPU占用率为5.0%，符合预期。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line">4937 root      20   0    3376   1004    836 R   5.3  0.0   0:08.40 exe</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>利用cpuacct查看每个核上的使用时间，由于没有限制使用的cpu核，所以每个核上都还有运行时间</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuacct]$ cat test_cpu_limit&#x2F;cpuacct.usage_all</span><br><span class="line">cpu user system</span><br><span class="line">0 2036903414 0</span><br><span class="line">1 44170 0</span><br><span class="line">2 4428266075 0</span><br><span class="line">3 4356927661 0</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>利用cpuset.cpus查看使用的cpu核</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset]$ cat test_cpuset_limit&#x2F;cpuset.cpus</span><br><span class="line">0-3</span><br></pre></td></tr></table></figure>
<h3 id="使用cpuset限制CPU占用的核"><a href="#使用cpuset限制CPU占用的核" class="headerlink" title="使用cpuset限制CPU占用的核"></a>使用cpuset限制CPU占用的核</h3><ol>
<li>启动测试程序，这次与前面的不同，看到只起来了2个worker协程在运行，因为机器上的Go版本是go1.10，还不支持抢占，当协程为for循环时，2个协程都持续运行，不让出cpu，只有2个核时，第3个协程无法运行。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;home&#x2F;ubuntu&#x2F;workspace&#x2F;notes&#x2F;docker&#x2F;codes]$ go run 02.2.cgroup_cpu.go cpuset</span><br><span class="line">---------- 1 ------------</span><br><span class="line">Test type: Cpuset limit</span><br><span class="line">cmdPid: 5063</span><br><span class="line">---------- 2 ------------</span><br><span class="line">Current pid: 1</span><br><span class="line">worker 2 start</span><br><span class="line">worker 0 start</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>top查看进程的CPU占用率为200%，符合只使用2个核的预期。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line">5063 root      20   0    3376   1004    836 R 199.7  0.0   4:21.49 exe</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>利用cpuacct查看每个核上的使用时间，只有核1和3上有时间统计，说明只使用了核1和3</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuacct]$ cat test_cpu_limit&#x2F;cpuacct.usage_all</span><br><span class="line">cpu user system</span><br><span class="line">0 0 0</span><br><span class="line">1 24172994458 0</span><br><span class="line">2 0 0</span><br><span class="line">3 24213057511 0</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>利用cpuset.cpus查看使用的cpu核</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset]$ cat test_cpuset_limit&#x2F;cpuset.cpus</span><br><span class="line">1,3</span><br></pre></td></tr></table></figure>
<h2 id="推荐资料"><a href="#推荐资料" class="headerlink" title="推荐资料"></a>推荐资料</h2><ol>
<li><a href="https://kernel.googlesource.com/pub/scm/linux/kernel/git/glommer/memcg/+/cpu_stat/Documentation/cgroups/" target="_blank" rel="noopener">Linux Kernel关于cgroup cpu、cpuset的文档</a></li>
<li><a href="https://union-click.jd.com/jdc?e=&amp;p=AyIGZRtSFwsWB1EcXhUyFQ5WEloVCxMBURxrUV1KWQorAlBHU0VeBUVNR0ZbSkdETlcNVQtHRVNSUVNLXANBRA1XB14DS10cQQVYD21XHgBcGFIUAhsGUx9cJQEbBTJbEmFdcHkRSANGBhBDCnkmEVQeC2UaaxUDEwVWEl8RBhM3ZRtcJUN8B1QaUxMCFAFlGmsVBhoOUx9fFwESB1IfaxICGzeDtdnBl4nT2YZrJTIRN2UrWyUBIkU7HQxBABEGBhILHVdGAgcaXB0DQARWHQ4QVhFVVhkLEVciBVQaXxw%3D" target="_blank" rel="noopener">阿里同学的书《自己动手写Docker》</a></li>
<li><a href="https://my.oschina.net/xiaominmin/blog/3068364" target="_blank" rel="noopener">解决写 cpu.cfs_quota_us <code>invalid argument</code>问题</a></li>
<li><a href="https://blog.csdn.net/xftony/article/details/80536562" target="_blank" rel="noopener">解决写 cpuset.tasks <code>No space</code> 问题</a></li>
<li><a href="https://www.cnblogs.com/raymondshiquan/articles/2727037.html" target="_blank" rel="noopener">cgroup使用踩坑</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2020/08/30/cgroup-2-memory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.lessisbetter.site/gzh-qrcode-logo-small.png">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="区块链、Go语言">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Go语言充电站">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/30/cgroup-2-memory/" class="post-title-link" itemprop="url">Docker容器基础2：Cgroup - memory子系统</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-30 10:45:08" itemprop="dateCreated datePublished" datetime="2020-08-30T10:45:08+08:00">2020-08-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-01 23:16:28" itemprop="dateModified" datetime="2020-09-01T23:16:28+08:00">2020-09-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="测试环境版本"><a href="#测试环境版本" class="headerlink" title="测试环境版本"></a>测试环境版本</h2><p>测试机采用的Ubuntu 16.04 与 Linux 4.4.0 内核版本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[~]$ cat &#x2F;etc&#x2F;issue</span><br><span class="line">Ubuntu 16.04.4 LTS \n \l</span><br><span class="line">[~]$</span><br><span class="line">[~]$ cat &#x2F;proc&#x2F;version</span><br><span class="line">Linux version 4.4.0-117-generic (buildd@lgw01-amd64-057) (gcc version 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.9) ) #141-Ubuntu SMP Tue Mar 13 12:01:47 UTC 2018</span><br></pre></td></tr></table></figure>
<p><strong>提醒</strong>：Linux内核版本至少要大于 4.3 这样cgroup的功能才是全的，否则Linux内核版本过低，由于功能不全可能无法运行提供的Demo，目前已知无法运行的内核版本有：<code>Linux version 3.10.0</code>。</p>
<h2 id="Cgroup-memory子系统介绍"><a href="#Cgroup-memory子系统介绍" class="headerlink" title="Cgroup memory子系统介绍"></a>Cgroup memory子系统介绍</h2><p>cgroup的memory子系统全称为 Memory Resource Controller ，它能够限制cgroup中所有任务的使用的内存和交换内存进行限制，并且采取control措施：当OOM时，是否要kill进程。</p>
<p>memroy包含了很多设置指标和统计指标：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory&#x2F;system.slice&#x2F;docker-fda7bbf297d9300894c10c5514c32c70a50987ae99cad5731234058d9f6e2b7f.scope]$ ls memory.*</span><br><span class="line">memory.failcnt                  memory.kmem.tcp.limit_in_bytes      memory.memsw.limit_in_bytes      memory.soft_limit_in_bytes</span><br><span class="line">memory.force_empty              memory.kmem.tcp.max_usage_in_bytes  memory.memsw.max_usage_in_bytes  memory.stat</span><br><span class="line">memory.kmem.failcnt             memory.kmem.tcp.usage_in_bytes      memory.memsw.usage_in_bytes      memory.swappiness</span><br><span class="line">memory.kmem.limit_in_bytes      memory.kmem.usage_in_bytes          memory.move_charge_at_immigrate  memory.usage_in_bytes</span><br><span class="line">memory.kmem.max_usage_in_bytes  memory.limit_in_bytes               memory.numa_stat                 memory.use_hierarchy</span><br><span class="line">memory.kmem.slabinfo            memory.max_usage_in_bytes           memory.oom_control</span><br><span class="line">memory.kmem.tcp.failcnt         memory.memsw.failcnt                memory.pressure_level</span><br></pre></td></tr></table></figure>
<p>下图进行了汇总，虚线所圈出的指标为常用指标，每个指标的含义也如图所标注：</p>
<p><img src="http://img.lessisbetter.site/2020-08-cgroup-memory.png" alt="cgroup memory subsystem"></p>
<p>所有指标的含义可以参考<a href="https://kernel.googlesource.com/pub/scm/linux/kernel/git/glommer/memcg/+/cpu_stat/Documentation/cgroups/memory.txt" target="_blank" rel="noopener">Linux Kernel关于cgroup memory</a>的介绍。</p>
<h2 id="利用Docker演示Cgroup内存限制"><a href="#利用Docker演示Cgroup内存限制" class="headerlink" title="利用Docker演示Cgroup内存限制"></a>利用Docker演示Cgroup内存限制</h2><ol>
<li>创建一个容器，限制为内存为128MB</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[~]$ docker run --rm -itd -m 128m stress:16.04</span><br><span class="line">fda7bbf297d9300894c10c5514c32c70a50987ae99cad5731234058d9f6e2b7f</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>容器内利用<code>stress</code>使用100MB内存</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[~]$ docker exec -it fda7bbf29 bash</span><br><span class="line">root@fda7bbf297d9:&#x2F;# stress --vm-bytes 100m --vm-keep -m 1</span><br><span class="line">stress: info: [23739] dispatching hogs: 0 cpu, 0 io, 1 vm, 0 hdd</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>在memory子系统目录下，利用容器id找到与当前容器相关的cgroup目录</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory&#x2F;system.slice]$ find . -name &quot;*fda7bbf29*&quot; -print</span><br><span class="line">.&#x2F;var-lib-docker-containers-fda7bbf297d9300894c10c5514c32c70a50987ae99cad5731234058d9f6e2b7f-shm.mount</span><br><span class="line">.&#x2F;docker-fda7bbf297d9300894c10c5514c32c70a50987ae99cad5731234058d9f6e2b7f.scope</span><br></pre></td></tr></table></figure>
<p><code>./docker-fda7bbf297d9300894c10c5514c32c70a50987ae99cad5731234058d9f6e2b7f.scope</code> 目录为当前容器的内存cgroup节点。</p>
<ol start="4">
<li>查看该容器的内存使用量、限制，以及统计信息</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory&#x2F;system.slice&#x2F;docker-fda7bbf297d9300894c10c5514c32c70a50987ae99cad5731234058d9f6e2b7f.scope]$ cat memory.usage_in_bytes memory.limit_in_bytes memory.stat</span><br><span class="line">106049536 &#x2F;&#x2F; memory.usage_in_bytes</span><br><span class="line">134217728 &#x2F;&#x2F; memory.limit_in_bytes</span><br><span class="line">cache 0   &#x2F;&#x2F; 以下为memory.stat</span><br><span class="line">rss 105943040</span><br><span class="line">swap 0</span><br><span class="line">...</span><br><span class="line">hierarchical_memory_limit 134217728</span><br><span class="line">hierarchical_memsw_limit 268435456</span><br><span class="line">...</span><br><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory&#x2F;system.slice&#x2F;docker-fda7bbf297d9300894c10c5514c32c70a50987ae99cad5731234058d9f6e2b7f.scope]$</span><br></pre></td></tr></table></figure>
<ul>
<li>使用量为 ： 106049536 / 1024 / 1024 = 101.14 MB</li>
<li>限制为 ： 134217728 / 1024 / 1024 = 128MB</li>
</ul>
<p>stat文件：</p>
<ul>
<li>rss ：105943040 / 1024 / 1024 = 101.03 MB</li>
<li>hierarchical_memory_limit ： 134217728 / 1024 / 1024 = 128MB</li>
</ul>
<p>stat中rss的值与 <code>usage_in_bytes</code> 有稍微的出入，原因是 <code>usage_in_bytes</code> 的值为近视值，而之所以近似，是因为内核采用的是异步统计，造成统计值和当下的值存在误差。</p>
<p>该cgroup中所有tasks所占用的真实内存可以使用：<code>stat.rss + stat.cache + stat.swap</code> ，在上面的例子中 cache 和 swap 都为0，所以 rss 的值就是真实的内存使用量。</p>
<p>之所以存在 <code>usage_in_bytes</code> ， 这样做的目的是通过一个值可以快速获取内存的使用量，而无需进行计算。</p>
<p>利用<code>docker.stats</code> 查看内存占用情况:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory&#x2F;system.slice&#x2F;docker-fda7bbf297d9300894c10c5514c32c70a50987ae99cad5731234058d9f6e2b7f.scope]$ docker stats</span><br><span class="line">CONTAINER           CPU %               MEM USAGE &#x2F; LIMIT     MEM %               NET I&#x2F;O             BLOCK I&#x2F;O           PIDS</span><br><span class="line">fda7bbf297d9        99.50%              101.1 MiB &#x2F; 128 MiB   79.01%              648 B &#x2F; 648 B       0 B &#x2F; 0 B           4</span><br></pre></td></tr></table></figure>
<p>可以看到usage和limit分别为101.1MB和128MB，usage与cgroup中 <code>usage_in_bytes</code> 是一致的，limit与容器启动时的配置一致。</p>
<p>top命令查看进程占用内存情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory&#x2F;system.slice&#x2F;docker-fda7bbf297d9300894c10c5514c32c70a50987ae99cad5731234058d9f6e2b7f.scope]$ top</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line">13025 root      20   0  109872 102336     36 R  93.8  1.3   6:39.09 stress</span><br></pre></td></tr></table></figure>
<p>可以看到<code>RES</code>为 102336 KB，即 99.9 MB，小于cgroup中统计的内存使用量，原因是因为cgroup中除了stress还有其他任务，比如docker中运行的ssh。</p>
<p>可以查看该group的进程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory&#x2F;system.slice&#x2F;docker-fda7bbf297d9300894c10c5514c32c70a50987ae99cad5731234058d9f6e2b7f.scope]$ cat cgroup.procs</span><br><span class="line">13780</span><br><span class="line">13792</span><br><span class="line">13793</span><br><span class="line">21124</span><br><span class="line">21221</span><br></pre></td></tr></table></figure>
<p>从 <code>pstree -p</code> 可以查看整个进程树:</p>
<p><img src="http://img.lessisbetter.site/2020-cgroup-memory-pstree.png" alt=""></p>
<h2 id="利用Go演示Cgroup内存限制"><a href="#利用Go演示Cgroup内存限制" class="headerlink" title="利用Go演示Cgroup内存限制"></a>利用Go演示Cgroup内存限制</h2><h3 id="测试源码"><a href="#测试源码" class="headerlink" title="测试源码"></a>测试源码</h3><p>cgroup的演示<a href="https://github.com/Shitaibin/notes/blob/master/docker/codes/02.1.cgroup.go" target="_blank" rel="noopener">源码</a> ，关于源码中的<code>/proc/self/exe</code>看<a href="#补充小知识">补充小知识</a>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参考《自动动手写Docker》</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"io/ioutil"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	<span class="string">"os/exec"</span></span><br><span class="line">	<span class="string">"path"</span></span><br><span class="line">	<span class="string">"strconv"</span></span><br><span class="line">	<span class="string">"syscall"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CgroupMemoryHierarchyMount = <span class="string">"/sys/fs/cgroup/memory"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> os.Args[<span class="number">0</span>] == <span class="string">"/proc/self/exe"</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"---------- 2 ------------"</span>)</span><br><span class="line">		fmt.Printf(<span class="string">"Current pid: %d\n"</span>, syscall.Getpid())</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建stress子进程，施加内存压力</span></span><br><span class="line">		allocMemSize := <span class="string">"99m"</span> <span class="comment">// 另外1项测试为99m</span></span><br><span class="line">		fmt.Printf(<span class="string">"allocMemSize: %v\n"</span>, allocMemSize)</span><br><span class="line">		stressCmd := fmt.Sprintf(<span class="string">"stress --vm-bytes %s --vm-keep -m 1"</span>, allocMemSize)</span><br><span class="line">		cmd := exec.Command(<span class="string">"sh"</span>, <span class="string">"-c"</span>, stressCmd)</span><br><span class="line">		cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;&#125;</span><br><span class="line">		cmd.Stdin = os.Stdin</span><br><span class="line">		cmd.Stdout = os.Stdout</span><br><span class="line">		cmd.Stderr = os.Stderr</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err := cmd.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"stress run error: %v"</span>, err)</span><br><span class="line">			os.Exit(<span class="number">-1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"---------- 1 ------------"</span>)</span><br><span class="line">	cmd := exec.Command(<span class="string">"/proc/self/exe"</span>)</span><br><span class="line">	cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;</span><br><span class="line">		Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWNS | syscall.CLONE_NEWPID,</span><br><span class="line">	&#125;</span><br><span class="line">	cmd.Stdin = os.Stdin</span><br><span class="line">	cmd.Stdout = os.Stdout</span><br><span class="line">	cmd.Stderr = os.Stderr</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动子进程</span></span><br><span class="line">	<span class="keyword">if</span> err := cmd.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"/proc/self/exe start error: %v"</span>, err)</span><br><span class="line">		os.Exit(<span class="number">-1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cmdPid := cmd.Process.Pid</span><br><span class="line">	fmt.Printf(<span class="string">"cmdPid: %d\n"</span>, cmdPid)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建子cgroup</span></span><br><span class="line">	memoryGroup := path.Join(CgroupMemoryHierarchyMount, <span class="string">"test_memory_limit"</span>)</span><br><span class="line">	os.Mkdir(memoryGroup, <span class="number">0755</span>)</span><br><span class="line">	<span class="comment">// 设定内存限制</span></span><br><span class="line">	ioutil.WriteFile(path.Join(memoryGroup, <span class="string">"memory.limit_in_bytes"</span>),</span><br><span class="line">		[]<span class="keyword">byte</span>(<span class="string">"100m"</span>), <span class="number">0644</span>)</span><br><span class="line">	<span class="comment">// 将进程加入cgroup</span></span><br><span class="line">	ioutil.WriteFile(path.Join(memoryGroup, <span class="string">"tasks"</span>),</span><br><span class="line">		[]<span class="keyword">byte</span>(strconv.Itoa(cmdPid)), <span class="number">0644</span>)</span><br><span class="line"></span><br><span class="line">	cmd.Process.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源码运行解读：</p>
<ol>
<li>使用<code>go run</code>运行程序，或build后运行程序时，程序的名字是<code>02.1.cgroup</code>，所以不满足<code>os.Args[0] == &quot;/proc/self/exe&quot;</code>会被跳过。</li>
<li>然后使用<code>&quot;/proc/self/exe&quot;</code>新建了子进程，子进程此时叫：<code>&quot;/proc/self/exe&quot;</code></li>
<li>创建cgroup <code>test_memory_limit</code>，然后设置内存限制为100MB</li>
<li>把子进程加入到cgroup <code>test_memory_limit</code></li>
<li>等待子进程结束</li>
<li>子进程干了啥呢？子进程其实还是当前程序，只不过它的名字是<code>&quot;/proc/self/exe&quot;</code>，符合最初的if语句，之后它会创建stress子进程，然后运行stress，可以修改<code>allocMemSize</code>设置stress所要占用的内存</li>
</ol>
<h3 id="不超越内存限制情况"><a href="#不超越内存限制情况" class="headerlink" title="不超越内存限制情况"></a>不超越内存限制情况</h3><p>源码默认在启动stress时，stress占用99m内存，cgroup限制最多使用100m内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[~&#x2F;workspace&#x2F;notes&#x2F;docker&#x2F;codes]$ go run 02.1.cgroup.go</span><br><span class="line">---------- 1 ------------</span><br><span class="line">cmdPid: 2533</span><br><span class="line">---------- 2 ------------</span><br><span class="line">Current pid: 1</span><br><span class="line">allocMemSize: 99m</span><br><span class="line">stress: info: [6] dispatching hogs: 0 cpu, 0 io, 1 vm, 0 hdd</span><br></pre></td></tr></table></figure>
<p>可以看到，子进程<code>&quot;/proc/self/exe&quot;</code>运行后取得的pid为 <strong>2533</strong> ，在新的Namespace中，子进程<code>&quot;/proc/self/exe&quot;</code>的pid已经变成1，然后利用stress打了99M内存。</p>
<p>使用top查看资源使用情况，stress进程内存RES大约为99M，pid 为 <strong>2539</strong> 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND</span><br><span class="line">2539 root      20   0  103940 101680    284 R 93.8  9.9   0:06.09 stress</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory&#x2F;test_memory_limit]$ cat memory.limit_in_bytes</span><br><span class="line">104857600</span><br><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory&#x2F;test_memory_limit]$ # 104857600 刚好为100MB</span><br><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory&#x2F;test_memory_limit]$ cat memory.usage_in_bytes</span><br><span class="line">2617344</span><br><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory&#x2F;test_memory_limit]$ cat tasks</span><br><span class="line">2533 &lt;--- &#x2F;prof&#x2F;self&#x2F;exe进程</span><br><span class="line">2534</span><br><span class="line">2535</span><br><span class="line">2536</span><br><span class="line">2537</span><br><span class="line">2538</span><br><span class="line">2539 &lt;--- stress进程</span><br></pre></td></tr></table></figure>
<p>tasks下都是在cgroup <code>test_memory_limit</code> 中的进程，这些是Host中真实的进程号，通过<code>pstree -p</code>查看进程树，看看这些都是哪些进程：</p>
<p><img src="http://img.lessisbetter.site/2020-08-cgroup.png" alt="Cgroup限制内存的进程树"></p>
<p>进程树佐证了前面的代码执行流程分析大致是对的，只不过这其中还涉及一些创建子进程的具体手段，比如stress是通过sh命令创建出来的。</p>
<h3 id="内存超过限制被Kill情况"><a href="#内存超过限制被Kill情况" class="headerlink" title="内存超过限制被Kill情况"></a>内存超过限制被Kill情况</h3><p>内存超过cgroup限制的内存会怎么样？会OOM吗？</p>
<p>如果将stress内存提高到占用101MB，大于cgroup中内存的限制100M时，整个group中的进程就会被Kill。</p>
<p>修改代码，将 <code>allocMemSize</code> 设置为 <code>101m</code> ，然后重新运行程序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[~&#x2F;notes&#x2F;docker&#x2F;codes]$ go run 02.1.cgroup.go                                                                        *[master]</span><br><span class="line">---------- 1 ------------</span><br><span class="line">cmdPid: 21492</span><br><span class="line">---------- 2 ------------</span><br><span class="line">Current pid: 1</span><br><span class="line">allocMemSize: 101m</span><br><span class="line">stress: info: [6] dispatching hogs: 0 cpu, 0 io, 1 vm, 0 hdd</span><br><span class="line">stress: FAIL: [6] (415) &lt;-- worker 7 got signal 9</span><br><span class="line">stress: WARN: [6] (417) now reaping child worker processes</span><br><span class="line">stress: FAIL: [6] (421) kill error: No such process</span><br><span class="line">stress: FAIL: [6] (451) failed run completed in 0s</span><br><span class="line">2020&#x2F;08&#x2F;27 17:38:52 exit status 1</span><br></pre></td></tr></table></figure>
<p><code>stress: FAIL: [6] (415) &lt;-- worker 7 got signal 9</code> 说明收到了信号9，即SIGKILL 。</p>
<h2 id="补充小知识"><a href="#补充小知识" class="headerlink" title="补充小知识"></a>补充小知识</h2><p>在演示源码中，使用到<code>&quot;/proc/self/exe&quot;</code>，它在Linux是一个特殊的软链接，它指向当前正在运行的程序，比如执行<code>ll</code>查看该文件时，它就执行了<code>/usr/bin/ls</code>，因为当前的程序是<code>ls</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[~]$ ll &#x2F;proc&#x2F;self&#x2F;exe</span><br><span class="line">lrwxrwxrwx 1 centos centos 0 8月  27 12:44 &#x2F;proc&#x2F;self&#x2F;exe -&gt; &#x2F;usr&#x2F;bin&#x2F;ls</span><br></pre></td></tr></table></figure>
<p>演示代码中的技巧就是通过<code>&quot;/proc/self/exe&quot;</code>重新启动一个子进程，只不过进程名称叫<code>&quot;/proc/self/exe&quot;</code>而已。如果代码中没有那句if判断，又会执行到创建子进程，最终会导致递归溢出。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>memory是cgroup的一个子系统，主要用来控制一组进程的内存资源，对最大使用量进行限制和控制。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://kernel.googlesource.com/pub/scm/linux/kernel/git/glommer/memcg/+/cpu_stat/Documentation/cgroups/memory.txt" target="_blank" rel="noopener">Linux Kernel关于cgroup memory</a></li>
<li><a href="https://union-click.jd.com/jdc?e=&amp;p=AyIGZRtSFwsWB1EcXhUyFQ5WEloVCxMBURxrUV1KWQorAlBHU0VeBUVNR0ZbSkdETlcNVQtHRVNSUVNLXANBRA1XB14DS10cQQVYD21XHgBcGFIUAhsGUx9cJQEbBTJbEmFdcHkRSANGBhBDCnkmEVQeC2UaaxUDEwVWEl8RBhM3ZRtcJUN8B1QaUxMCFAFlGmsVBhoOUx9fFwESB1IfaxICGzeDtdnBl4nT2YZrJTIRN2UrWyUBIkU7HQxBABEGBhILHVdGAgcaXB0DQARWHQ4QVhFVVhkLEVciBVQaXxw%3D" target="_blank" rel="noopener">阿里同学的书《自己动手写Docker》</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2020/08/27/cgroup-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.lessisbetter.site/gzh-qrcode-logo-small.png">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="区块链、Go语言">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Go语言充电站">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/27/cgroup-1/" class="post-title-link" itemprop="url">Docker容器基础1：Cgroup - 资源控制简介</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-27 21:43:52" itemprop="dateCreated datePublished" datetime="2020-08-27T21:43:52+08:00">2020-08-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-31 20:13:27" itemprop="dateModified" datetime="2020-08-31T20:13:27+08:00">2020-08-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="什么是Cgroup"><a href="#什么是Cgroup" class="headerlink" title="什么是Cgroup"></a>什么是Cgroup</h2><p>Cgroup 是 Control Group 的缩写，提供对一组进程，及未来子进程的资源<strong>限制、控制、统计</strong>能力，包括CPU、内存、磁盘、网络。</p>
<ul>
<li>限制：限制的资源最大使用量阈值。比如不能超过128MB内存，CPU使用率不得超过50%，或者只能是否CPU的某哪几个核。</li>
<li>控制：超过资源使用最大阈值时，进程会被控制，不任由它发展。比如cgroup内所有tasks的内存使用量超过阈值的结果就是被KILL，CPU使用率不得超过设定值。</li>
<li>统计：统计资源的使用情况等指标。比如cgroup内tasks的内存使用量，占用CPU的时间。</li>
</ul>
<p>Cgroup 包含3个组件：</p>
<ul>
<li>cgroup ：一组进程，可以加上subsystem</li>
<li>subsystem ：一组资源控制模块，CPU、内存…</li>
<li>hierarchy ： 把一组cgroup串成树状结构，这样就能实现cgroup的继承。为什么要继承呢？就如同docker镜像的继承，站在前人的基础之上，免去重复的配置</li>
</ul>
<h2 id="为什么需要Cgroup"><a href="#为什么需要Cgroup" class="headerlink" title="为什么需要Cgroup"></a>为什么需要Cgroup</h2><p>为什么需要Cgroup的问题等价于：为什么需要限制一组进程的资源？</p>
<p>有多种原因，比如：</p>
<ol>
<li>Linux是一个可以多用户登录的系统，如何限制不同的用户使用不同量的系统资源呢？</li>
<li>某个系统有64核，由于局部性原理，如果一组进程在64个核上调度，效率比较低，但把这些进程只允许在某几个核上调度，就有较好的局部性，提高效率。这类似与在分布式系统中，某个有状态的请求，最好能分配到上一次处理该请求的机器上一样的道理。</li>
</ol>
<p>cgroup的文档中还提到一个思路：实现资源限制的技术有多种，为什么使用cgroup？</p>
<p>cgroup是内核实现的，它更轻量、更高效、对内核的热点路径影响最小。</p>
<h2 id="你的Linux支持哪些Cgroup-subsystem"><a href="#你的Linux支持哪些Cgroup-subsystem" class="headerlink" title="你的Linux支持哪些Cgroup subsystem"></a>你的Linux支持哪些Cgroup subsystem</h2><p>查看当前系统支持的subsystem，共12个子系统。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup]$ cat &#x2F;proc&#x2F;cgroups</span><br><span class="line">#subsys_name	hierarchy	num_cgroups	enabled</span><br><span class="line">cpuset	8	4	1</span><br><span class="line">cpu	2	74	1</span><br><span class="line">cpuacct	2	74	1</span><br><span class="line">memory	11	74	1</span><br><span class="line">devices	6	69	1</span><br><span class="line">freezer	10	4	1</span><br><span class="line">net_cls	4	4	1</span><br><span class="line">blkio	9	69	1</span><br><span class="line">perf_event	5	4	1</span><br><span class="line">hugetlb	7	4	1</span><br><span class="line">pids	3	69	1</span><br><span class="line">net_prio	4	4	1</span><br></pre></td></tr></table></figure>
<p>从左到右字段的含义分别是：</p>
<ol>
<li>subsys_name: subsystem的名字</li>
<li>hierarchy: subsystem所关联到的cgroup树的ID，如果多个subsystem关联到同一颗cgroup树，那么他们的这个字段将一样，比如这里的cpu和cpuacct就一样，表示他们绑定到了同一颗树。如果出现下面的情况，这个字段将为0：<ul>
<li>当前subsystem没有和任何cgroup树绑定</li>
<li>当前subsystem已经和cgroup v2的树绑定</li>
<li>当前subsystem没有被内核开启</li>
</ul>
</li>
<li>num_cgroups: subsystem所关联的cgroup树中进程组的个数，也即树上节点的个数</li>
<li>enabled: 1表示开启，0表示没有被开启(可以通过设置内核的启动参数“cgroup_disable”来控制subsystem的开启).</li>
</ol>
<p><a href="https://www.kernel.org/doc/Documentation/cgroup-v1/" target="_blank" rel="noopener">Cgroup的内核文档</a>对各 cgroup 和 subsystem 有详细的介绍，以下是每个 subsystem 功能简记：</p>
<ol>
<li>cpu ：用来<strong>限制</strong>cgroup的CPU使用率</li>
<li>cpuacct ：用来<strong>统计</strong>cgroup的CPU的使用率</li>
<li>cpuset ： 用来绑定cgroup到指定CPU哪个核上和NUMA节点</li>
<li>memory ：限制和统计cgroup的内存的使用率，包括process memory, kernel memory, 和swap</li>
<li>devices ： 限制cgroup创建(mknod)和访问设备的权限</li>
<li>freezer ： suspend和restore一个cgroup中的所有进程</li>
<li>net_cls ： 将一个cgroup中进程创建的所有网络包加上一个classid标记，用于tc和iptables。 只对发出去的网络包生效，对收到的网络包不起作用</li>
<li>blkio ： 限制cgroup访问块设备的IO速度</li>
<li>perf_event ： 对cgroup进行性能监控</li>
<li>net_prio ： 针对每个网络接口设置cgroup的访问优先级</li>
<li>hugetlb ： 限制cgroup的huge pages的使用量</li>
<li>pids ：限制一个cgroup及其子孙cgroup中的总进程数</li>
</ol>
<p>这些子系统的排列顺序，就是引入Linux内核顺序，最早的是cpu subsystem ，引入自Linux 2.6.24，最晚的是pid subsystem ，引入自 Linux 4.3。</p>
<h2 id="查看子系统和cgroup的挂载"><a href="#查看子系统和cgroup的挂载" class="headerlink" title="查看子系统和cgroup的挂载"></a>查看子系统和cgroup的挂载</h2><p>cgroup是通过文件系统实现的，每个目录都是一个cgroup节点，目录中的子目录都是子cgroup节点，这样就形成了 cgroup的 hierarchy 特性。</p>
<p>cgroup会挂载到 <code>/sys/fs/cgroup/</code>目录，该目录下的目录基本都是subsystem，<code>systemd</code>目录除外（它是 systemd 自建在cgroup下的目录，但不是子系统）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup]$ ll</span><br><span class="line">total 0</span><br><span class="line">dr-xr-xr-x 6 root root  0 Aug 30 09:30 blkio</span><br><span class="line">lrwxrwxrwx 1 root root 11 Aug 30 09:30 cpu -&gt; cpu,cpuacct</span><br><span class="line">lrwxrwxrwx 1 root root 11 Aug 30 09:30 cpuacct -&gt; cpu,cpuacct</span><br><span class="line">dr-xr-xr-x 7 root root  0 Aug 30 09:30 cpu,cpuacct</span><br><span class="line">dr-xr-xr-x 3 root root  0 Aug 30 09:30 cpuset</span><br><span class="line">dr-xr-xr-x 6 root root  0 Aug 30 09:30 devices</span><br><span class="line">dr-xr-xr-x 3 root root  0 Aug 30 09:30 freezer</span><br><span class="line">dr-xr-xr-x 3 root root  0 Aug 30 09:30 hugetlb</span><br><span class="line">dr-xr-xr-x 6 root root  0 Aug 30 09:30 memory</span><br><span class="line">lrwxrwxrwx 1 root root 16 Aug 30 09:30 net_cls -&gt; net_cls,net_prio</span><br><span class="line">dr-xr-xr-x 3 root root  0 Aug 30 09:30 net_cls,net_prio</span><br><span class="line">lrwxrwxrwx 1 root root 16 Aug 30 09:30 net_prio -&gt; net_cls,net_prio</span><br><span class="line">dr-xr-xr-x 3 root root  0 Aug 30 09:30 perf_event</span><br><span class="line">dr-xr-xr-x 6 root root  0 Aug 30 09:30 pids</span><br><span class="line">dr-xr-xr-x 6 root root  0 Aug 30 09:30 systemd</span><br></pre></td></tr></table></figure>
<p>发现cpu、cpuacct都指向了 <code>cpu,cpuacct</code> 目录，把它们合成了1个cgroup节点。另外 net_cls 和 net_prio 也都合到了 <code>net_cls,net_prio</code> 节点，也就形成了下面这幅图的样子，并把资源控制分成了5个类别：CPU、内存、网络、进程控制、设备，另外的<code>perf_event</code>是cgroup对自身的监控，不归于资源控制。</p>
<p><img src="http://img.lessisbetter.site/2020-08-30-cgroup-subsystem.png" alt=""></p>
<p>子系统挂载到cgroup的虚拟文件系统是通过mount命令实现的，系统启动时自动挂载subsystem到cgroup，查看已经挂载的Cgroup：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[~]$ mount -t cgroup</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,release_agent&#x3D;&#x2F;lib&#x2F;systemd&#x2F;systemd-cgroups-agent,name&#x3D;systemd)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory type cgroup (rw,nosuid,nodev,noexec,relatime,memory)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;pids type cgroup (rw,nosuid,nodev,noexec,relatime,pids)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu,cpuacct type cgroup (rw,nosuid,nodev,noexec,relatime,cpu,cpuacct)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;freezer type cgroup (rw,nosuid,nodev,noexec,relatime,freezer)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;net_cls,net_prio type cgroup (rw,nosuid,nodev,noexec,relatime,net_cls,net_prio)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;devices type cgroup (rw,nosuid,nodev,noexec,relatime,devices)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,cpuset)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;blkio type cgroup (rw,nosuid,nodev,noexec,relatime,blkio)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;hugetlb type cgroup (rw,nosuid,nodev,noexec,relatime,hugetlb)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;perf_event type cgroup (rw,nosuid,nodev,noexec,relatime,perf_event)</span><br></pre></td></tr></table></figure>
<p>查看某个进程所属的cgroup：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup]$ # $$代表当前进程</span><br><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup]$ cat &#x2F;proc&#x2F;$$&#x2F;cgroup</span><br><span class="line">11:memory:&#x2F;user.slice&#x2F;user-1000.slice&#x2F;session-269.scope</span><br><span class="line">10:freezer:&#x2F;</span><br><span class="line">9:blkio:&#x2F;user.slice</span><br><span class="line">8:cpuset:&#x2F;</span><br><span class="line">7:hugetlb:&#x2F;</span><br><span class="line">6:devices:&#x2F;user.slice</span><br><span class="line">5:perf_event:&#x2F;</span><br><span class="line">4:net_prio,net_cls:&#x2F;</span><br><span class="line">3:pids:&#x2F;user.slice</span><br><span class="line">2:cpuacct,cpu:&#x2F;user.slice&#x2F;user-1000.slice&#x2F;session-269.scope</span><br><span class="line">1:name&#x3D;systemd:&#x2F;user.slice&#x2F;user-1000.slice&#x2F;session-269.scope</span><br></pre></td></tr></table></figure>
<p>每一行从左到右，用<code>:</code>分割依次是：</p>
<ul>
<li><code>11</code>： cgroup继承树的节点的ID</li>
<li><code>memory</code>: 当前节点上挂载的子系统</li>
<li><code>/user.slice/user-1000.slice/session-269.scope</code>: cgroup节点相对于cgroup根目录下子系统的相对路径，转换成绝对路径就是：<code>/sys/fs/cgroup/memory/user.slice/user-1000.slice/session-269.scope</code></li>
</ul>
<h2 id="再聊cgroup-hierarchy"><a href="#再聊cgroup-hierarchy" class="headerlink" title="再聊cgroup hierarchy"></a>再聊cgroup hierarchy</h2><p>在 cpu,cpuacct 子系统下创建一个测试cgroup节点：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[/sys/fs/cgroup/cpu,cpuacct]$ sudo mkdir dabin_test_cpu_cgroup</span><br><span class="line">[/sys/fs/cgroup/cpu,cpuacct]$ <span class="built_in">cd</span> dabin_test_cpu_cgroup</span><br><span class="line">[/sys/fs/cgroup/cpu,cpuacct/dabin_test_cpu_cgroup]$ ls</span><br><span class="line">[/sys/fs/cgroup/cpu,cpuacct/dabin_test_cpu_cgroup]$ ls cgroup.*</span><br><span class="line">cgroup.clone_children  cgroup.event_control  cgroup.procs</span><br><span class="line">[/sys/fs/cgroup/cpu,cpuacct/dabin_test_cpu_cgroup]$ cat cgroup.clone_children</span><br><span class="line">0</span><br><span class="line">[/sys/fs/cgroup/cpu,cpuacct/dabin_test_cpu_cgroup]$ cat cgroup.procs</span><br><span class="line">[/sys/fs/cgroup/cpu,cpuacct/dabin_test_cpu_cgroup]$</span><br><span class="line">[/sys/fs/cgroup/cpu,cpuacct/dabin_test_cpu_cgroup]$ ls notify_on_release tasks</span><br><span class="line">notify_on_release  tasks</span><br><span class="line">[/sys/fs/cgroup/cpu,cpuacct/dabin_test_cpu_cgroup]$</span><br><span class="line">[/sys/fs/cgroup/cpu,cpuacct/dabin_test_cpu_cgroup]$ cat tasks</span><br><span class="line">[/sys/fs/cgroup/cpu,cpuacct/dabin_test_cpu_cgroup]$ cat notify_on_release</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>cgroup hierarchy (继承树)结构，每个cgroup节点都包含以下几个文件：</p>
<ul>
<li>cgroup.clone_children : 被cpuset控制器使用，值为1时子cgroup初始化时拷贝父cgroup的配置</li>
<li>cgroup.procs : cgroup中的线程组id</li>
<li>tasks : 当前cgroup包含的进程列表</li>
<li>notify_on_release : 值为0或1，1代表当cgroup中的最后1个task退出，并且子cgroup移除时，内核会在继承树根目录运行<code>release_agent</code>文件</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>cgroup对一组进程的资源进行控制，包括但不限于CPU、内存、网络、磁盘等资源，共12种资源，通过12个subsystem去进行限制、控制。</p>
<p>cgroup由内核使用文件系统实现，文件系统的层级结构实现了cgroup的层级结构，它默认挂载到 <code>/sys/fs/cgroup</code> 目录。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://kernel.googlesource.com/pub/scm/linux/kernel/git/glommer/memcg/+/cpu_stat/Documentation/cgroups" target="_blank" rel="noopener">Linux Kernel Cgroup的文档</a></li>
<li><a href="https://union-click.jd.com/jdc?e=&amp;p=AyIGZRtSFwsWB1EcXhUyFQ5WEloVCxMBURxrUV1KWQorAlBHU0VeBUVNR0ZbSkdETlcNVQtHRVNSUVNLXANBRA1XB14DS10cQQVYD21XHgBcGFIUAhsGUx9cJQEbBTJbEmFdcHkRSANGBhBDCnkmEVQeC2UaaxUDEwVWEl8RBhM3ZRtcJUN8B1QaUxMCFAFlGmsVBhoOUx9fFwESB1IfaxICGzeDtdnBl4nT2YZrJTIRN2UrWyUBIkU7HQxBABEGBhILHVdGAgcaXB0DQARWHQ4QVhFVVhkLEVciBVQaXxw%3D" target="_blank" rel="noopener">阿里同学的书《自己动手写Docker》</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2020/08/27/play-minikube/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.lessisbetter.site/gzh-qrcode-logo-small.png">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="区块链、Go语言">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Go语言充电站">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/27/play-minikube/" class="post-title-link" itemprop="url">玩转minikube</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-27 21:30:41" itemprop="dateCreated datePublished" datetime="2020-08-27T21:30:41+08:00">2020-08-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-10-24 22:06:17" itemprop="dateModified" datetime="2020-10-24T22:06:17+08:00">2020-10-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>minikube很好，但某些原因造成国内用起来比较慢，要各种挂代理、Docker镜像加速。</p>
<h2 id="minikube原理"><a href="#minikube原理" class="headerlink" title="minikube原理"></a>minikube原理</h2><p><img src="http://img.lessisbetter.site/2020-08-minikube.jpeg" alt=""></p>
<p>kubectl和kube-apiserver是CS架构，kubectl是操作k8s集群的客户端，kube-apiserver是服务端。</p>
<p>minikube是创建了一个虚拟机<code>minikube vm</code>，然后在虚拟机里创建了1个单机的k8s集群，并把集群部署信息写到<code>~/.kube/config</code>文件，它是kubectl默认使用的配置文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[~]$ ls ~&#x2F;.kube&#x2F;config</span><br><span class="line">&#x2F;Users&#x2F;shitaibin&#x2F;.kube&#x2F;config</span><br><span class="line">[~]$ cat ~&#x2F;.kube&#x2F;config</span><br><span class="line">apiVersion: v1</span><br><span class="line">clusters:</span><br><span class="line">- cluster:</span><br><span class="line">    certificate-authority: &#x2F;Users&#x2F;shitaibin&#x2F;.minikube&#x2F;ca.crt</span><br><span class="line">    server: https:&#x2F;&#x2F;192.168.99.103:8443</span><br><span class="line">  name: minikube</span><br><span class="line">contexts:</span><br><span class="line">- context:</span><br><span class="line">    cluster: minikube</span><br><span class="line">    user: minikube</span><br><span class="line">  name: minikube</span><br><span class="line">current-context: minikube</span><br><span class="line">kind: Config</span><br><span class="line">preferences: &#123;&#125;</span><br><span class="line">users:</span><br><span class="line">- name: minikube</span><br><span class="line">  user:</span><br><span class="line">    client-certificate: &#x2F;Users&#x2F;shitaibin&#x2F;.minikube&#x2F;profiles&#x2F;minikube&#x2F;client.crt</span><br><span class="line">    client-key: &#x2F;Users&#x2F;shitaibin&#x2F;.minikube&#x2F;profiles&#x2F;minikube&#x2F;client.key</span><br></pre></td></tr></table></figure>
<p>文件内容也可以使用 <code>kubectl config view</code> 命令查看。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[~]$ kubectl config view</span><br><span class="line">apiVersion: v1</span><br><span class="line">clusters:</span><br><span class="line">- cluster:</span><br><span class="line">    certificate-authority: &#x2F;Users&#x2F;shitaibin&#x2F;.minikube&#x2F;ca.crt</span><br><span class="line">    server: https:&#x2F;&#x2F;192.168.99.103:8443</span><br><span class="line">  name: minikube</span><br><span class="line">contexts:</span><br><span class="line">- context:</span><br><span class="line">    cluster: minikube</span><br><span class="line">    user: minikube</span><br><span class="line">  name: minikube</span><br><span class="line">current-context: minikube</span><br><span class="line">kind: Config</span><br><span class="line">preferences: &#123;&#125;</span><br><span class="line">users:</span><br><span class="line">- name: minikube</span><br><span class="line">  user:</span><br><span class="line">    client-certificate: &#x2F;Users&#x2F;shitaibin&#x2F;.minikube&#x2F;profiles&#x2F;minikube&#x2F;client.crt</span><br><span class="line">    client-key: &#x2F;Users&#x2F;shitaibin&#x2F;.minikube&#x2F;profiles&#x2F;minikube&#x2F;client.key</span><br><span class="line">[~]$</span><br></pre></td></tr></table></figure>
<h2 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h2><ol>
<li><p>安装minikube，1分钟，如果提供的命令行下载不下来，就浏览器下载下来，放到增加可执行，然后放到bin目录即可：<br><a href="https://yq.aliyun.com/articles/691500" target="_blank" rel="noopener">https://yq.aliyun.com/articles/691500</a></p>
</li>
<li><p>centos安装virtualbox，2分钟安装完成:<br><a href="https://wiki.centos.org/zh/HowTos/Virtualization/VirtualBox" target="_blank" rel="noopener">https://wiki.centos.org/zh/HowTos/Virtualization/VirtualBox</a></p>
</li>
<li><p>安装kubectl：<br><a href="https://blog.csdn.net/yuanjunlai141/article/details/79469071" target="_blank" rel="noopener">https://blog.csdn.net/yuanjunlai141/article/details/79469071</a></p>
</li>
</ol>
<h2 id="首次启动"><a href="#首次启动" class="headerlink" title="首次启动"></a>首次启动</h2><p>启动命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">minikube start --image-mirror-country cn \</span><br><span class="line">    --iso-url&#x3D;https:&#x2F;&#x2F;kubernetes.oss-cn-hangzhou.aliyuncs.com&#x2F;minikube&#x2F;iso&#x2F;minikube-v1.7.3.iso \</span><br><span class="line">    --registry-mirror&#x3D;&quot;https:&#x2F;&#x2F;a90tkz28.mirror.aliyuncs.com&quot; \</span><br><span class="line">    --image-repository&#x3D;&quot;registry.cn-hangzhou.aliyuncs.com&#x2F;google_containers&quot; \</span><br><span class="line">    --kubernetes-version&#x3D;v1.18.3</span><br></pre></td></tr></table></figure></p>
<p>使用minikube可以查看帮助flag帮助信息：</p>
<ul>
<li><code>--image-mirror-country</code>: 需要使用的镜像镜像的国家/地区代码。留空以使用全球代码。对于中国大陆用户，请将其设置为<br>cn</li>
<li><code>--registry-mirror</code>: 传递给 Docker 守护进程的注册表镜像。效果最好的镜像加速器：<code>--registry-mirror=&quot;https://a90tkz28.mirror.aliyuncs.com&quot;</code> 。使用加速器的原理是，docker deamon会先去加速器寻找镜像，如果找不到才从docker官方仓库拉镜像。如果指定拉某个镜像仓库的镜像，镜像加速器是用不上的。</li>
<li><code>--image-repository</code> : 如果不能从gcr.io拉镜像，配置minikube中docker拉镜像的地方</li>
<li><code>--kubernetes-version</code>： 指定要部署的k8s版本，可以省略</li>
</ul>
<p>minikube内拉不到镜像的报错:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl describe pod</span><br><span class="line">  Type     Reason     Age                    From               Message</span><br><span class="line">  ----     ------     ----                   ----               -------</span><br><span class="line">  Warning  Failed     2m59s (x4 over 4m36s)  kubelet, minikube  Failed to pull image &quot;kubeguide&#x2F;redis-master&quot;: rpc error: code &#x3D; Unknown desc &#x3D; Error response from daemon: Get https:&#x2F;&#x2F;registry-1.docker.io&#x2F;v2&#x2F;: proxyconnect tcp: dial tcp 192.168.0.104:1087: connect: connection refused</span><br></pre></td></tr></table></figure>
<p>启动日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ minikube start --image-mirror-country cn \</span><br><span class="line">    --iso-url&#x3D;https:&#x2F;&#x2F;kubernetes.oss-cn-hangzhou.aliyuncs.com&#x2F;minikube&#x2F;iso&#x2F;minikube-v1.7.3.iso \</span><br><span class="line">    --registry-mirror&#x3D;&quot;https:&#x2F;&#x2F;a90tkz28.mirror.aliyuncs.com&quot; \</span><br><span class="line">    --image-repository&#x3D;&quot;registry.cn-hangzhou.aliyuncs.com&#x2F;google_containers&quot;</span><br><span class="line">😄  Darwin 10.15.3 上的 minikube v1.12.3</span><br><span class="line">✨  根据用户配置使用 virtualbox 驱动程序</span><br><span class="line">✅  正在使用镜像存储库 registry.cn-hangzhou.aliyuncs.com&#x2F;google_containers</span><br><span class="line">👍  Starting control plane node minikube in cluster minikube</span><br><span class="line">🔥  Creating virtualbox VM (CPUs&#x3D;2, Memory&#x3D;4000MB, Disk&#x3D;20000MB) ...</span><br><span class="line">💡  Existing disk is missing new features (lz4). To upgrade, run &#39;minikube delete&#39;</span><br><span class="line">🐳  正在 Docker 19.03.6 中准备 Kubernetes v1.18.3…</span><br><span class="line">🔎  Verifying Kubernetes components...</span><br><span class="line">🌟  Enabled addons: default-storageclass, storage-provisioner</span><br><span class="line">🏄  完成！kubectl 已经配置至 &quot;minikube&quot;</span><br></pre></td></tr></table></figure>
<p>做哪些事？</p>
<ol>
<li>创建虚拟机”minikube”</li>
<li>生成kubectl使用的配置文件，使用该配置连接集群：~/.kube/config</li>
<li>在虚拟机里的容器上启动k8s</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">$ minikube ssh</span><br><span class="line">                         _             _</span><br><span class="line">            _         _ ( )           ( )</span><br><span class="line">  ___ ___  (_)  ___  (_)| |&#x2F;&#39;)  _   _ | |_      __</span><br><span class="line">&#x2F;&#39; _ &#96; _ &#96;\| |&#x2F;&#39; _ &#96;\| || , &lt;  ( ) ( )| &#39;_&#96;\  &#x2F;&#39;__&#96;\</span><br><span class="line">| ( ) ( ) || || ( ) || || |\&#96;\ | (_) || |_) )(  ___&#x2F;</span><br><span class="line">(_) (_) (_)(_)(_) (_)(_)(_) (_)&#96;\___&#x2F;&#39;(_,__&#x2F;&#39;&#96;\____)</span><br><span class="line"></span><br><span class="line">$</span><br><span class="line">$ docker info</span><br><span class="line">Client:</span><br><span class="line"> Debug Mode: false</span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line"> Containers: 18</span><br><span class="line">  Running: 15</span><br><span class="line">  Paused: 0</span><br><span class="line">  Stopped: 3</span><br><span class="line"> Images: 11</span><br><span class="line"> Server Version: 19.03.6</span><br><span class="line"> Storage Driver: overlay2</span><br><span class="line">  Backing Filesystem: extfs</span><br><span class="line">  Supports d_type: true</span><br><span class="line">  Native Overlay Diff: true</span><br><span class="line"> Logging Driver: json-file</span><br><span class="line"> Cgroup Driver: cgroupfs</span><br><span class="line"> Plugins:</span><br><span class="line">  Volume: local</span><br><span class="line">  Network: bridge host ipvlan macvlan null overlay</span><br><span class="line">  Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog</span><br><span class="line"> Swarm: inactive</span><br><span class="line"> Runtimes: runc</span><br><span class="line"> Default Runtime: runc</span><br><span class="line"> Init Binary: docker-init</span><br><span class="line"> containerd version: 35bd7a5f69c13e1563af8a93431411cd9ecf5021</span><br><span class="line"> runc version: dc9208a3303feef5b3839f4323d9beb36df0a9dd</span><br><span class="line"> init version: fec3683</span><br><span class="line"> Security Options:</span><br><span class="line">  seccomp</span><br><span class="line">   Profile: default</span><br><span class="line"> Kernel Version: 4.19.94</span><br><span class="line"> Operating System: Buildroot 2019.02.9</span><br><span class="line"> OSType: linux</span><br><span class="line"> Architecture: x86_64</span><br><span class="line"> CPUs: 2</span><br><span class="line"> Total Memory: 3.754GiB</span><br><span class="line"> Name: minikube</span><br><span class="line"> ID: 6GOT:L6SH:NPBW:ZM44:PVKY:LSEZ:MXW7:LWOB:GB4N:CNXU:S6NJ:KASG</span><br><span class="line"> Docker Root Dir: &#x2F;var&#x2F;lib&#x2F;docker</span><br><span class="line"> Debug Mode: false</span><br><span class="line"> Registry: https:&#x2F;&#x2F;index.docker.io&#x2F;v1&#x2F;</span><br><span class="line"> Labels:</span><br><span class="line">  provider&#x3D;virtualbox</span><br><span class="line"> Experimental: false</span><br><span class="line"> Insecure Registries:</span><br><span class="line">  10.96.0.0&#x2F;12</span><br><span class="line">  127.0.0.0&#x2F;8</span><br><span class="line"> Registry Mirrors:</span><br><span class="line">  https:&#x2F;&#x2F;a90tkz28.mirror.aliyuncs.com&#x2F;</span><br><span class="line"> Live Restore Enabled: false</span><br><span class="line"> Product License: Community Engine</span><br><span class="line"></span><br><span class="line">$ exit</span><br><span class="line">logout</span><br></pre></td></tr></table></figure>
<p>Registry Mirrors对应的是阿里云镜像加速，HTTP proxy也配置上了，如果启动后，发现没有改变，需要删除过去创建的minikube，全部清理一遍。</p>
<h2 id="minikube常用命令"><a href="#minikube常用命令" class="headerlink" title="minikube常用命令"></a>minikube常用命令</h2><ul>
<li>集群状态： minikube status</li>
<li>暂停和恢复集群，不用的时候把它暂停掉，节约主机的CPU和内存： minikube pause， minikube unpause</li>
<li>停止集群： minikube stop</li>
<li>删除集群，遇到问题时，清理一波数据： minikube delete</li>
<li>查看集群IP，kubectl就是连这个IP： minikube ip</li>
<li>进入minikube虚拟机，整个k8s集群跑在这里面： minikube ssh</li>
</ul>
<h2 id="kubectl自动补全"><a href="#kubectl自动补全" class="headerlink" title="kubectl自动补全"></a>kubectl自动补全</h2><p>zsh在配置文件 <code>~/.zshrc</code> 中增加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source &lt;(kubectl completion zsh)  # 在 zsh 中设置当前 shell 的自动补全</span><br><span class="line">echo &quot;if [ $commands[kubectl] ]; then source &lt;(kubectl completion zsh); fi&quot; &gt;&gt; ~&#x2F;.zshrc # 在您的 zsh shell 中永久的添加自动补全</span><br></pre></td></tr></table></figure>
<p>bash 在 <code>~/.bashrc</code> 中增加:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source &lt;(kubectl completion bash) # 在 bash 中设置当前 shell 的自动补全，要先安装 bash-completion 包。</span><br><span class="line">echo &quot;source &lt;(kubectl completion bash)&quot; &gt;&gt; ~&#x2F;.bashrc # 在您的 bash shell 中永久的添加自动补全</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2020/08/27/sync-code-to-server-with-sftp-in-vscode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.lessisbetter.site/gzh-qrcode-logo-small.png">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="区块链、Go语言">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Go语言充电站">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/27/sync-code-to-server-with-sftp-in-vscode/" class="post-title-link" itemprop="url">VSCode利用SFTP上传代码到服务器</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-27 20:24:00 / 修改时间：20:37:00" itemprop="dateCreated datePublished" datetime="2020-08-27T20:24:00+08:00">2020-08-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>VSCode已经支持远程开发，可以把代码自动从本地和服务器进行同步。</p>
<p>为了某些实验搞了一条Ubuntu 14.04的服务器，结果VSCode说远程服务器不支持，就只能另谋它路了，利用SFTP实现本地和服务器端的代码同步。</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>VSCode应用市场安装SFTP插件</li>
<li>在项目目录下建立SFTP的配置文件：<code>.vscode/sftp.json</code>，内容如下</li>
</ol>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"root"</span>,</span><br><span class="line">    <span class="attr">"host"</span>: <span class="string">"192.168.9.xxx"</span>,</span><br><span class="line">    <span class="attr">"protocol"</span>: <span class="string">"sftp"</span>,</span><br><span class="line">    <span class="attr">"port"</span>: <span class="number">22</span>,</span><br><span class="line">    <span class="attr">"username"</span>: <span class="string">"centos"</span>,</span><br><span class="line">    <span class="attr">"privateKeyPath"</span>: <span class="string">"/Users/shitaibin/.ssh/id_xxx"</span>,</span><br><span class="line">    <span class="attr">"remotePath"</span>: <span class="string">"/home/centos/workspace/docker/notes"</span>,</span><br><span class="line">    <span class="attr">"uploadOnSave"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"ignore"</span>: [<span class="string">".vscode"</span>, <span class="string">".git"</span>, <span class="string">".DS_Store"</span>, <span class="string">"node_modules"</span>, <span class="string">"vendor"</span>],</span><br><span class="line">    <span class="attr">"localPath"</span>:<span class="string">"."</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>登录服务器可以使用密码或者私钥，上面文件的示例使用私钥，如果使用密码，增加一项<code>password</code>即可。</p>
<p><code>uploadOnSave</code>配置项设置为true，能够确保文件保存时，自动上传到服务器，无需手动上传。</p>
<ol start="3">
<li><p>初次上传到服务器</p>
<p> a. Ctrl + Shift + P，输入<code>SFTP</code>，选择<code>Sync Local -&gt; Remote</code>即可<br> b. VSCode底部状态栏，会显示SFTP，如果在动态变化，说明在上传文件</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2020/07/29/go-time-date-timestamp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.lessisbetter.site/gzh-qrcode-logo-small.png">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="区块链、Go语言">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Go语言充电站">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/29/go-time-date-timestamp/" class="post-title-link" itemprop="url">Go语言日期和时间戳转换</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-07-29 19:48:59 / 修改时间：19:49:32" itemprop="dateCreated datePublished" datetime="2020-07-29T19:48:59+08:00">2020-07-29</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>字符串格式日期、time.Time类型、整形时间戳三者之间的转换如下图：</p>
<p><img src="http://img.lessisbetter.site/2020-07-go-time-date-transform.png" alt=""></p>
<p>有2点要注意：</p>
<ol>
<li>字符串日期和时间戳之间不能直接转换，需要通过time.Time完成。</li>
<li>涉及字符串日期的时候，字符串日期格式一定要以Go诞生的时间为基准，而不是随意的时间，否则会导致时间转换不正确。所以，以下Demo中的日期格式是通用的。</li>
<li>字符串日期格式要与真实的日期格式完全匹配，否则会解析时间不正确。比如设置的格式为<code>2006-01-02</code>，实际日期格式为<code>2006-1-2</code>时会解析错误。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Date2Time</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"&gt;&gt; Date2Time"</span>)</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">"&lt;&lt; Date2Time"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 一定要以Go诞生的时间为基准</span></span><br><span class="line">	<span class="comment">// 2006年1月2号，MST时区，下午3:04分为基准</span></span><br><span class="line">	<span class="keyword">const</span> dateFormat = <span class="string">"Jan 2, 2006 at 3:04pm (MST)"</span></span><br><span class="line">	t, _ := time.Parse(dateFormat, <span class="string">"May 20, 2020 at 0:00am (UTC)"</span>)</span><br><span class="line">	fmt.Println(t)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> shortForm = <span class="string">"2006-Jan-02"</span></span><br><span class="line">	t, _ = time.Parse(shortForm, <span class="string">"2020-May-20"</span>)</span><br><span class="line">	fmt.Println(t)</span><br><span class="line"></span><br><span class="line">	t, _ = time.Parse(<span class="string">"01/02/2006"</span>, <span class="string">"05/20/2020"</span>)</span><br><span class="line">	fmt.Println(t)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Time2Date</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"&gt;&gt; Time2Date"</span>)</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">"&lt;&lt; Time2Date"</span>)</span><br><span class="line"></span><br><span class="line">	tm := time.Now()</span><br><span class="line">	fmt.Println(tm.Format(<span class="string">"2006-01-02 03:04:05 PM"</span>))</span><br><span class="line">	fmt.Println(tm.Format(<span class="string">"2006-1-2 03:04:05 PM"</span>))</span><br><span class="line">	fmt.Println(tm.Format(<span class="string">"2006-Jan-02 03:04:05 PM"</span>))</span><br><span class="line">	fmt.Println(tm.Format(<span class="string">"02/01/2006 03:04:05 PM"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Timestamp2Time</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"&gt;&gt; Timestamp2Time"</span>)</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">"&lt;&lt; Timestamp2Time"</span>)</span><br><span class="line"></span><br><span class="line">	ts := <span class="keyword">int64</span>(<span class="number">1595900001</span>)</span><br><span class="line">	tm := time.Unix(ts, <span class="number">0</span>)</span><br><span class="line">	fmt.Println(tm)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Time2Timestamp</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"&gt;&gt; Time2Timestamp"</span>)</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">"&lt;&lt; Time2Timestamp"</span>)</span><br><span class="line"></span><br><span class="line">	tm := time.Now()</span><br><span class="line">	ts := tm.Unix()</span><br><span class="line">	fmt.Println(ts)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	Date2Time()</span><br><span class="line">	Time2Date()</span><br><span class="line">	Timestamp2Time()</span><br><span class="line">	Time2Timestamp()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; Date2Time</span><br><span class="line">2020-05-20 00:00:00 +0000 UTC</span><br><span class="line">2020-05-20 00:00:00 +0000 UTC</span><br><span class="line">2020-05-20 00:00:00 +0000 UTC</span><br><span class="line">&lt;&lt; Date2Time</span><br><span class="line">&gt;&gt; Time2Date</span><br><span class="line">2020-07-28 09:35:46 AM</span><br><span class="line">2020-7-28 09:35:46 AM</span><br><span class="line">2020-Jul-28 09:35:46 AM</span><br><span class="line">28&#x2F;07&#x2F;2020 09:35:46 AM</span><br><span class="line">&lt;&lt; Time2Date</span><br><span class="line">&gt;&gt; Timestamp2Time</span><br><span class="line">2020-07-28 09:33:21 +0800 CST</span><br><span class="line">&lt;&lt; Timestamp2Time</span><br><span class="line">&gt;&gt; Time2Timestamp</span><br><span class="line">1595900146</span><br><span class="line">&lt;&lt; Time2Timestamp</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2020/07/28/about-ssh/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.lessisbetter.site/gzh-qrcode-logo-small.png">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="区块链、Go语言">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Go语言充电站">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/28/about-ssh/" class="post-title-link" itemprop="url">SSH常用命令和配置</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-07-28 21:11:15 / 修改时间：21:12:11" itemprop="dateCreated datePublished" datetime="2020-07-28T21:11:15+08:00">2020-07-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="生成SSH密钥"><a href="#生成SSH密钥" class="headerlink" title="生成SSH密钥"></a>生成SSH密钥</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -f ~/.ssh/id_rsa -C <span class="string">"temp user"</span> -N <span class="string">""</span></span><br></pre></td></tr></table></figure>
<p>-t：指定加密算法<br>-f：指定路径<br>-C：注释，可以填写用户名或邮箱<br>-N：密码</p>
<p>指定以上<code>f、C、N</code>这3个参数，可以避免交互式问答，快速生成密钥，在脚本中使用很方便。</p>
<h2 id="SSH客户端配置文件"><a href="#SSH客户端配置文件" class="headerlink" title="SSH客户端配置文件"></a>SSH客户端配置文件</h2><p><code>~/.ssh/config</code>文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Read more about SSH config files: https:&#x2F;&#x2F;linux.die.net&#x2F;man&#x2F;5&#x2F;ssh_config</span><br><span class="line">Host 个人VM</span><br><span class="line">    HostName 192.168.9.137</span><br><span class="line">    User centos</span><br><span class="line"></span><br><span class="line">Host 阿里云</span><br><span class="line">    HostName 139.224.105.10</span><br><span class="line">    User root</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">Host 腾讯云</span><br><span class="line">    HostName 140.143.6.185</span><br><span class="line">    User root</span><br><span class="line">    Port 22</span><br><span class="line">    IdentityFile ~&#x2F;.ssh&#x2F;id_rsa_tencent</span><br></pre></td></tr></table></figure>
<ul>
<li>Host：自定义命名</li>
<li>HostName：机器IP或者域名</li>
<li>User：登录机器的用户名</li>
<li>Port：登录机器的端口，默认为22，可省略</li>
<li>IdentityFile：登录机器时使用的私钥，默认为<code>~/.ssh/id_rsa</code>，可省略；当某台机器使用单独密钥时，很有用</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="大彬"
      src="http://img.lessisbetter.site/gzh-qrcode-logo-small.png">
  <p class="site-author-name" itemprop="name">大彬</p>
  <div class="site-description" itemprop="description">区块链、Go语言</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">134</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">77</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="http://img.lessisbetter.site/gzh-qrcode-logo-small.png" title="公众号 → http://img.lessisbetter.site/gzh-qrcode-logo-small.png" rel="noopener" target="_blank"><i class="fa fa-fw fa-wechat"></i>公众号</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://github.com/shitaibin" title="GitHub → https://github.com/shitaibin" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://segmentfault.com/u/lessisbetter" title="SegmentFault → https://segmentfault.com/u/lessisbetter" rel="noopener" target="_blank"><i class="fa fa-fw fa-crosshairs"></i>SegmentFault</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.jianshu.com/u/947f3ccdd481" title="简书 → https://www.jianshu.com/u/947f3ccdd481" rel="noopener" target="_blank"><i class="fa fa-fw fa-heartbeat"></i>简书</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/4296218/james-shi" title="StackOverflow → https://stackoverflow.com/users/4296218/james-shi" rel="noopener" target="_blank"><i class="fa fa-fw fa-stack-overflow"></i>StackOverflow</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hz_stb@163.com" title="E-Mail → mailto:hz_stb@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      友链
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://xargin.com" title="https://xargin.com" rel="noopener" target="_blank">Xargin曹大博客</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://pingcap.com/blog-cn/" title="https://pingcap.com/blog-cn/" rel="noopener" target="_blank">PingCap技术博客</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://qcrao.github.io/" title="https://qcrao.github.io/" rel="noopener" target="_blank">码农桃花源博客</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://book.eddycjy.com/golang/" title="https://book.eddycjy.com/golang/" rel="noopener" target="_blank">煎鱼的迷之博客</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://dave.cheney.net" title="https://dave.cheney.net" rel="noopener" target="_blank">Dave Cheney的博客</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://theme-next.iissnan.com/getting-started.html" title="http://theme-next.iissnan.com/getting-started.html" rel="noopener" target="_blank">Hexo Next主题配置</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        
  <div class="beian"><a href="http://www.beian.miit.gov.cn" rel="noopener" target="_blank">浙ICP </a><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=18051706" rel="noopener" target="_blank">备18051706 </a>
  </div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">大彬</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.2
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>


  <div style="display: none;">
    <script src="//s95.cnzz.com/z_stat.php?id=1275814754&web_id=1275814754"></script>
  </div>






      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>












<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'default',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  


</body>
</html>
