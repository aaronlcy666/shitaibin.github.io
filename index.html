<!DOCTYPE html>













<html class="theme-next pisces" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">
































<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=6.6.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.6.0" color="#222">









<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.6.0',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="技术与人生 | 区块链架构师">
<meta name="keywords" content="区块链 Golang 后端 技术 人生 编程">
<meta property="og:type" content="website">
<meta property="og:title" content="大彬 LIB">
<meta property="og:url" content="http://lessisbetter.site/index.html">
<meta property="og:site_name" content="大彬 LIB">
<meta property="og:description" content="技术与人生 | 区块链架构师">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="大彬 LIB">
<meta name="twitter:description" content="技术与人生 | 区块链架构师">






  <link rel="canonical" href="http://lessisbetter.site/"/>



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>大彬 LIB – 大道至简 less is better</title>
  












  <noscript>
  <style>
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion .logo-line-before i { left: initial; }
    .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">大彬 LIB</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">大道至简 less is better</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-主页 menu-item-active">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br />主页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-标签云">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签云</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-专题文章">

    
    
    
      
    

    

    <a href="/subject/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br />专题文章</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-文章列表">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br />文章列表</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-关于">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-内推">

    
    
    
      
    

    

    <a href="/jobs/" rel="section"><i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />内推</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    
  
  
  
  

  

    <a href="https://github.com/Shitaibin" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" style="fill: #222; color: #fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2019/07/13/better-brew/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="技术与人生 | 区块链架构师">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大彬 LIB">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/13/better-brew/" class="post-title-link" itemprop="url">让Homebrew飞</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-13 11:12:17 / 修改时间：11:12:54" itemprop="dateCreated datePublished" datetime="2019-07-13T11:12:17+08:00">2019-07-13</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Homebrew源"><a href="#Homebrew源" class="headerlink" title="Homebrew源"></a>Homebrew源</h2><p>homebrew默认使用的是Github，虽然已经科学上网了，速度依然是KB级别的，相当的慢。使用国内的源，速度有质的提升，推荐2个国内的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://mirrors.cloud.tencent.com/homebrew/brew.git</span><br><span class="line">git://mirrors.ustc.edu.cn/brew.git</span><br></pre></td></tr></table></figure>
<p>腾讯源更多信息见：<a href="https://mirrors.cloud.tencent.com/help/homebrew-bottles.html" target="_blank" rel="noopener">https://mirrors.cloud.tencent.com/help/homebrew-bottles.html</a></p>
<p>建议ping一下以上2个源，选延时小的。</p>
<h2 id="下载和修改安装脚本"><a href="#下载和修改安装脚本" class="headerlink" title="下载和修改安装脚本"></a>下载和修改安装脚本</h2><p>下载官方安装脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install &gt;&gt; brew_install</span><br></pre></td></tr></table></figure>
<p>修改官方脚本，把Github源替换为腾讯源：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/ruby</span><br><span class="line"># This script installs to /usr/local only. To install elsewhere (which is</span><br><span class="line"># unsupported) you can untar https://github.com/Homebrew/brew/tarball/master</span><br><span class="line"># anywhere you like.</span><br><span class="line">HOMEBREW_PREFIX = &quot;/usr/local&quot;.freeze</span><br><span class="line">HOMEBREW_REPOSITORY = &quot;/usr/local/Homebrew&quot;.freeze</span><br><span class="line">HOMEBREW_CORE_TAP = &quot;/usr/local/Homebrew/Library/Taps/homebrew/homebrew-core&quot;.freeze</span><br><span class="line">HOMEBREW_CACHE = &quot;#&#123;ENV[&quot;HOME&quot;]&#125;/Library/Caches/Homebrew&quot;.freeze</span><br><span class="line">BREW_REPO = &quot;https://github.com/Homebrew/brew.git&quot;.freeze</span><br></pre></td></tr></table></figure>
<p>把<code>BREW_REPO = &quot;https://github.com/Homebrew/brew.git&quot;.freeze</code>替换为<code>BREW_REPO = &quot;https://mirrors.cloud.tencent.com/homebrew/brew.git&quot;.freeze</code>。</p>
<h2 id="运行脚本安装"><a href="#运行脚本安装" class="headerlink" title="运行脚本安装"></a>运行脚本安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby ~/brew_install</span><br></pre></td></tr></table></figure>
<p>这个版本的安装脚本已经没有CORE_TAP_REPO了，所以下载homebrew core的时候依然去Github下载，非常慢，可以在brew.git下载完，control-c结束掉。</p>
<p>把仓库<code>https://mirrors.cloud.tencent.com/homebrew/homebrew-core.git</code>克隆到<code>/usr/local/Homebrew/Library/Taps/homebrew/</code>目录，然后再执行上面的安装脚本。</p>
<h2 id="更换brew源"><a href="#更换brew源" class="headerlink" title="更换brew源"></a>更换brew源</h2><p>如果brew已经安装了，直接修改源就行了。</p>
<p>1、替换brew.git和homebrew-core.git的源:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="string">"<span class="variable">$(brew --repo)</span>"</span></span><br><span class="line">git remote <span class="built_in">set</span>-url origin https://mirrors.cloud.tencent.com/homebrew/brew.git</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> <span class="string">"<span class="variable">$(brew --repo)</span>/Library/Taps/homebrew/homebrew-core"</span></span><br><span class="line">git remote <span class="built_in">set</span>-url origin https://mirrors.cloud.tencent.com/homebrew/homebrew-core.git</span><br></pre></td></tr></table></figure>
<p>2、更新 bottles源</p>
<p>对于bash用户：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.cloud.tencent.com/homebrew-bottles'</span> &gt;&gt; ~/.bash_profile</span><br><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure>
<p>对于zsh用户</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.cloud.tencent.com/homebrew-bottles'</span> &gt;&gt; ~/.zshrc</span><br><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2019/07/12/do-not-abuse-of-log/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="技术与人生 | 区块链架构师">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大彬 LIB">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/12/do-not-abuse-of-log/" class="post-title-link" itemprop="url">你滥用log了吗</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-12 18:17:24 / 修改时间：08:39:22" itemprop="dateCreated datePublished" datetime="2019-07-12T18:17:24+08:00">2019-07-12</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>代码Review的时候，遇到过一些log滥用的情况，今天聊一聊滥用（过渡使用）日志。</p>
<blockquote>
<p>好的log能够帮助开发人员快速定位bug，而差的log各有各的不同。</p>
</blockquote>
<h2 id="你滥用日志了吗？"><a href="#你滥用日志了吗？" class="headerlink" title="你滥用日志了吗？"></a>你滥用日志了吗？</h2><p>是什么导致了滥用log？是不是存在这些误解：</p>
<p><strong>1. 害怕出了问题，现有的log无法定位</strong>，要多加一些log，恨不得每段都有一个log，log数简直越多越好，看日志有一种，每一步都非常清晰的错觉。</p>
<p><strong>2. 不知道log多了，定位效率更低</strong>，试问你有没有经历过几分钟刷出了G级别日志文件？在这种日志文件里定位bug，简直是大海捞针，这让log的价值非常低。</p>
<p><strong>3. 不知道log多了会影响性能</strong>，log自身涉及格式化和文件读写，虽然现在各log库都已经比较高效了，但是，这也扛不住“海量”的log啊，积少成多，势必影响程序性能。</p>
<p><strong>4. 对log级别错误的认知</strong>：日志级别设置为Info，Debug、Trace级别的日志不会打印，Debug、Trace级别日志多没关系。虽然日志不会输出，并不代表相关代码没执行啊。</p>
<p>第4点重点解释一下：</p>
<p><img src="http://img.lessisbetter.site/2019-07-debug-demo.png" alt="debug-demo"></p>
<p>这是一个打印Debug级别的日志，它还有1项日志信息，是来自<code>func()</code>的结果，请问：</p>
<ol>
<li>日志级别设置为Info，log.Debug会执行吗？<code>func()</code>还会执行吗？</li>
<li>如果这行日志频繁被执行，是不是浪费了CPU做无用功？</li>
</ol>
<p>如果你认为不会执行，看下面的Demo，log使用zap。</p>
<p><img src="http://img.lessisbetter.site/2019-07-log-test.png" alt="log-test"></p>
<p>结果：</p>
<p><img src="http://img.lessisbetter.site/2019-07-log-ret.png" alt="log-ret"></p>
<p>事实证明无论限制的日志级别是什么，<code>log.***</code>一定会被调用，它入参中的函数也一定会被调用，只不过是日记级别不满足打印时，不会打印而已。被调函数的结果只被这条<code>log.***</code>使用，结果这个日志根本不打印，这就浪费了CPU。</p>
<p>日志级别都设置为Info了，Debug级别的日志为何还会打印？</p>
<p>如果你有这个问题，你可能没有理解2个地方。</p>
<p>日志级别设置为Info，不代表<code>log.Debug</code>函数不执行。<code>log.Debug</code>函数一定会执行，看下图，<code>log.Info，Error</code>等接口会调用相同的真实实现函数<code>log.log</code>，<code>log.log</code>的入参包含了<code>log.Info</code>等接口的入参，以及当前的<code>log_level</code>，比如以下2种是等价的：</p>
<p><img src="http://img.lessisbetter.site/2019-07-log-log.png" alt="log-log"></p>
<p>所以，无论设置的是什么日志级别控制，<code>log.Debug</code>一定会被执行，至于当前日志是否会打印，会在<code>log.log</code>里决定。</p>
<p><img src="http://img.lessisbetter.site/2019-07-log-call.png" alt="image-20190712072742045"></p>
<p>日志为Warn级别，Debug日志不会打印，<code>func()</code>会不会执行？</p>
<p>日志打印本质是函数调用，会先计算入参，再调用函数。比如：</p>
<p><img src="http://img.lessisbetter.site/2019-07-log-debug.png" alt="log-debug"></p>
<p>所以<code>func()</code>一定会被调用。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>针对滥用日志的情况给几点建议：</p>
<ol>
<li>1条日志描述清when、where、what，提供有效信息，这就对定位很有帮助了。</li>
<li>只在“可能”出问题的地方打印日志，一些能根据上下文日志推断的地方，就无需再增加日志。</li>
<li>日志打印不要调用函数。</li>
</ol>
<blockquote>
<ol>
<li>如果这篇文章对你有帮助，不妨关注下我的Github，有文章会收到通知。</li>
<li>本文作者：<a href="http://lessisbetter.site/about/">大彬</a></li>
<li>如果喜欢本文，随意转载，但请保留此原文链接：<a href="http://lessisbetter.site/2019/07/12/do-not-abuse-of-log/">http://lessisbetter.site/2019/07/12/do-not-abuse-of-log/</a></li>
</ol>
</blockquote>
<p><div style="color:#0096FF; text-align:center">关注公众号，获取最新Golang文章</div><br><img src="http://img.lessisbetter.site/2019-01-article_qrcode.jpg" style="border:0" align="center"></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2019/07/06/go-memory-allocation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="技术与人生 | 区块链架构师">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大彬 LIB">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/06/go-memory-allocation/" class="post-title-link" itemprop="url">Go内存分配那些事，就这么简单！</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-06 23:19:39" itemprop="dateCreated datePublished" datetime="2019-07-06T23:19:39+08:00">2019-07-06</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-07 11:13:14" itemprop="dateModified" datetime="2019-07-07T11:13:14+08:00">2019-07-07</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>新老朋友好久不见，我是大彬，这篇文章准备了很久，不是在拖延，而是中间做了一些其他事情，耽搁了一些。</p>
<p>这篇文章<strong>主要介绍Go内存分配和Go内存管理</strong>，会轻微涉及内存申请和释放，以及Go垃圾回收。</p>
<p>从非常宏观的角度看，Go的内存管理就是下图这个样子，我们今天主要关注其中标红的部分。</p>
<p><img src="http://img.lessisbetter.site/2019-07-go-memory-manage.png" alt="Go内存管理"></p>
<blockquote>
<p>友情提醒：</p>
<p>文章有点长，建议先收藏，后阅读，绝对是学习内存管理的好资料。</p>
</blockquote>
<p><strong>本文基于go1.11.2，不同版本Go的内存管理可能存在差别，比如1.9与1.11的mheap定义就是差别比较大的，后续看源码的时候，请注意你的go版本，但无论你用哪个go版本，这都是一个优秀的资料，因为内存管理的思想和框架始终未变。</strong></p>
<p>Go这门语言抛弃了C/C++中的开发者管理内存的方式：主动申请与主动释放，增加了逃逸分析和GC，将开发者从内存管理中释放出来，让开发者有更多的精力去关注软件设计，而不是底层的内存问题。这是Go语言成为高生产力语言的原因之一。</p>
<p>我们不需要精通内存的管理，因为它确实很复杂，但掌握内存的管理，可以让你写出更高质量的代码，另外，还能助你定位Bug。</p>
<p><strong>这篇文章采用层层递进的方式，依次会介绍关于存储的基本知识，Go内存管理的“前辈”TCMalloc，然后是Go的内存管理和分配，最后是总结。这么做的目的是，希望各位能通过全局的认识和思考，拥有更好的编码思维和架构思维。</strong></p>
<p>最后，这不是一篇源码分析文章，因为Go源码分析的文章已经有很多了，这些源码文章能够帮助你去学习具体的工程实践和奇淫巧计了，文章的末尾会推荐一些优秀文章，如果你对内存感兴趣，建议每一篇都去看一下，挑出自己喜欢的，多花时间研究下。</p>
<h2 id="1-存储基础知识回顾"><a href="#1-存储基础知识回顾" class="headerlink" title="1. 存储基础知识回顾"></a>1. 存储基础知识回顾</h2><p>这部分我们简单回顾一下计算机存储体系、虚拟内存、栈和堆，以及堆内存的管理，这部分内容对理解和掌握Go内存管理比较重要，建议忘记或不熟悉的朋友不要跳过。</p>
<h3 id="存储金字塔"><a href="#存储金字塔" class="headerlink" title="存储金字塔"></a>存储金字塔</h3><p><img src="http://img.lessisbetter.site/2019-07-data-heirarchy.jpg" alt="img"></p>
<p>这幅图表达了计算机的存储体系，从上至下依次是：</p>
<ul>
<li>CPU寄存器</li>
<li>Cache</li>
<li>内存</li>
<li>硬盘等辅助存储设备</li>
<li>鼠标等外接设备</li>
</ul>
<p>从上至下，访问速度越来越慢，访问时间越来越长。</p>
<p>你有没有思考过下面2个简单的问题，如果没有不妨想想：</p>
<ol>
<li>如果CPU直接访问硬盘，CPU能充分利用吗？</li>
<li>如果CPU直接访问内存，CPU能充分利用吗？</li>
</ol>
<p>CPU速度很快，但硬盘等持久存储很慢，如果CPU直接访问磁盘，磁盘可以拉低CPU的速度，机器整体性能就会低下，为了弥补这2个硬件之间的速率差异，所以在CPU和磁盘之间增加了比磁盘快很多的内存。</p>
<p><img src="http://img.lessisbetter.site/2019-07-CPU-DRAM.png" alt="CPU和内存速率差异"></p>
<p>然而，CPU跟内存的速率也不是相同的，从上图可以看到，CPU的速率提高的很快（摩尔定律），然而内存速率增长的很慢，<em>虽然CPU的速率现在增加的很慢了，但是内存的速率也没增加多少，速率差距很大</em>，从1980年开始CPU和内存速率差距在不断拉大，为了弥补这2个硬件之间的速率差异，所以在CPU跟内存之间增加了比内存更快的Cache，Cache是内存数据的缓存，可以降低CPU访问内存的时间。</p>
<p>不要以为有了<a href="https://zh.wikipedia.org/wiki/CPU缓存" target="_blank" rel="noopener">Cache</a>就万事大吉了，CPU的速率还在不断增大，Cache也在不断改变，从最初的1级，到后来的2级，到当代的3级Cache，<em><a href="https://zh.wikipedia.org/wiki/CPU%E7%BC%93%E5%AD%98#%E5%8E%86%E5%8F%B2%E5%92%8C%E6%9C%AA%E6%9D%A5" target="_blank" rel="noopener">（有兴趣看cache历史）</a></em>。</p>
<p><img src="http://img.lessisbetter.site/2019-07-mbp-memory.png" alt="MBP的CPU和Cache信息"></p>
<p>三级Cache分别是L1、L2、L3，它们的速率是三个不同的层级，L1速率最快，与CPU速率最接近，是RAM速率的100倍，L2速率就降到了RAM的25倍，L3的速率更靠近RAM的速率。</p>
<p>看到这了，你有没有Get到整个<strong>存储体系的分层设计</strong>？<strong>自顶向下，速率越来越低，访问时间越来越长，从磁盘到CPU寄存器，上一层都可以看做是下一层的缓存。</strong></p>
<p>看了分层设计，我们看一下内存，毕竟我们是介绍内存管理的文章。</p>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>虚拟内存是当代操作系统必备的一项重要功能了，它向进程屏蔽了底层了RAM和磁盘，并向进程提供了远超物理内存大小的内存空间。我们看一下虚拟内存的<strong>分层设计</strong>。</p>
<p><img src="http://img.lessisbetter.site/2019-07-Virtual-Memory-in-OS-Operating-System.png" alt="虚拟内存原理"></p>
<p>上图展示了某进程访问数据，当Cache没有命中的时候，访问虚拟内存获取数据的过程。</p>
<p>访问内存，实际访问的是虚拟内存，虚拟内存通过页表查看，当前要访问的虚拟内存地址，是否已经加载到了物理内存，如果已经在物理内存，则取物理内存数据，如果没有对应的物理内存，则从磁盘加载数据到物理内存，并把物理内存地址和虚拟内存地址更新到页表。</p>
<p>有没有Get到：<strong>物理内存就是磁盘存储缓存层</strong>。</p>
<p>另外，在没有虚拟内存的时代，物理内存对所有进程是共享的，多进程同时访问同一个物理内存存在并发访问问题。<strong>引入虚拟内存后，每个进程都要各自的虚拟内存，内存的并发访问问题的粒度从多进程级别，可以降低到多线程级别</strong>。</p>
<h3 id="栈和堆"><a href="#栈和堆" class="headerlink" title="栈和堆"></a>栈和堆</h3><p>我们现在从虚拟内存，再进一层，看虚拟内存中的栈和堆，也就是进程对内存的管理。</p>
<p><img src="http://img.lessisbetter.site/2019-07-figure_6-1.png" alt="虚拟内存布局"></p>
<p>上图展示了一个进程的虚拟内存划分，代码中使用的内存地址都是虚拟内存地址，而不是实际的物理内存地址。栈和堆只是虚拟内存上2块不同功能的内存区域：</p>
<ul>
<li><p>栈在高地址，从高地址向低地址增长。</p>
</li>
<li><p>堆在低地址，从低地址向高地址增长。</p>
</li>
</ul>
<p><strong>栈和堆相比有这么几个好处</strong>：</p>
<ol>
<li>栈的内存管理简单，分配比堆上快。</li>
<li>栈的内存不需要回收，而堆需要，无论是主动free，还是被动的垃圾回收，这都需要花费额外的CPU。</li>
<li>栈上的内存有更好的局部性，堆上内存访问就不那么友好了，CPU访问的2块数据可能在不同的页上，CPU访问数据的时间可能就上去了。</li>
</ol>
<h3 id="堆内存管理"><a href="#堆内存管理" class="headerlink" title="堆内存管理"></a>堆内存管理</h3><p><img src="http://img.lessisbetter.site/2019-07-Mutator-Allocator-Collector.png" alt="内存管理"></p>
<p>我们再进一层，当我们说内存管理的时候，主要是指堆内存的管理，因为栈的内存管理不需要程序去操心。这小节看下堆内存管理干的是啥，如上图所示主要是3部分：<strong>分配内存块，回收内存块和组织内存块</strong>。</p>
<p>在一个最简单的内存管理中，堆内存最初会是一个完整的大块，即未分配内存，当来申请的时候，就会从未分配内存，分割出一个小内存块(block)，然后用链表把所有内存块连接起来。需要一些信息描述每个内存块的基本信息，比如大小(size)、是否使用中(used)和下一个内存块的地址(next)，内存块实际数据存储在data中。</p>
<p><img src="http://img.lessisbetter.site/2019-07-Memory_Blocks.png" alt="内存块链表"></p>
<p>一个内存块包含了3类信息，如下图所示，元数据、用户数据和对齐字段，内存对齐是为了提高访问效率。下图申请5Byte内存的时候，就需要进行内存对齐。</p>
<p><img src="http://img.lessisbetter.site/2019-07-Alignment-Header.png" alt="内存块和对齐"></p>
<p>释放内存实质是把使用的内存块从链表中取出来，然后标记为未使用，当分配内存块的时候，可以从未使用内存块中有先查找大小相近的内存块，如果找不到，再从未分配的内存中分配内存。</p>
<p>上面这个简单的设计中还没考虑内存碎片的问题，因为随着内存不断的申请和释放，内存上会存在大量的碎片，降低内存的使用率。为了解决内存碎片，可以将2个连续的未使用的内存块合并，减少碎片。</p>
<p>以上就是内存管理的基本思路，关于基本的内存管理，想了解更多，可以阅读这篇文章《<a href="http://dmitrysoshnikov.com/compilers/writing-a-memory-allocator/" target="_blank" rel="noopener">Writing a Memory Allocator</a>》，本节的3张图片也是来自这片文章。</p>
<h2 id="2-TCMalloc"><a href="#2-TCMalloc" class="headerlink" title="2. TCMalloc"></a>2. TCMalloc</h2><p><strong>TCMalloc是Thread Cache Malloc的简称，是Go内存管理的起源</strong>，Go的内存管理是借鉴了TCMalloc，随着Go的迭代，Go的内存管理与TCMalloc不一致地方在不断扩大，但<strong>其主要思想、原理和概念都是和TCMalloc一致的</strong>，如果跳过TCMalloc直接去看Go的内存管理，也许你会似懂非懂。</p>
<p>掌握TCMalloc的理念，<em>无需去关注过多的源码细节</em>，就可以为掌握Go的内存管理打好基础，基础打好了，后面知识才扎实。</p>
<p>在Linux里，其实有不少的内存管理库，比如glibc的ptmalloc，FreeBSD的jemalloc，Google的tcmalloc等等，为何会出现这么多的内存管理库？本质都是<strong>在多线程编程下，追求更高内存管理效率</strong>：更快的分配是主要目的。</p>
<p>那如何更快的分配内存？</p>
<p>我们前面提到：</p>
<blockquote>
<p>引入虚拟内存后，让内存的并发访问问题的粒度从多进程级别，降低到多线程级别。</p>
</blockquote>
<p>这是<strong>更快分配内存的第一个层次</strong>。</p>
<p>同一进程的所有线程共享相同的内存空间，他们申请内存时需要加锁，如果不加锁就存在同一块内存被2个线程同时访问的问题。</p>
<p>TCMalloc的做法是什么呢？<strong>为每个线程预分配一块缓存，线程申请小内存时，可以从缓存分配内存</strong>，这样有2个好处：</p>
<ol>
<li>为线程预分配缓存需要进行1次系统调用，后续线程申请小内存时，从缓存分配，都是在用户态执行，没有系统调用，<strong>缩短了内存总体的分配和释放时间，这是快速分配内存的第二个层次</strong>。</li>
<li>多个线程同时申请小内存时，从各自的缓存分配，访问的是不同的地址空间，无需加锁，<strong>把内存并发访问的粒度进一步降低了，这是快速分配内存的第三个层次</strong>。</li>
</ol>
<h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>下面就简单介绍下TCMalloc，细致程度够我们理解Go的内存管理即可。</p>
<blockquote>
<p>声明：我没有研究过TCMalloc，以下介绍根据TCMalloc官方资料和其他博主资料总结而来，错误之处请朋友告知我。</p>
</blockquote>
<p><img src="http://img.lessisbetter.site/2019-07-tcmalloc-Overview.svg" alt="TCMalloc概要图"></p>
<p>结合上图，介绍TCMalloc的几个重要概念：</p>
<ol>
<li><strong>Page</strong>：操作系统对内存管理以页为单位，TCMalloc也是这样，只不过TCMalloc里的Page大小与操作系统里的大小并不一定相等，而是倍数关系。《<a href="https://wallenwang.com/2018/11/tcmalloc/" target="_blank" rel="noopener">TCMalloc解密</a>》里称x64下Page大小是8KB。</li>
<li><strong>Span</strong>：一组连续的Page被称为Span，比如可以有2个页大小的Span，也可以有16页大小的Span，Span比Page高一个层级，是为了方便管理一定大小的内存区域，Span是TCMalloc中内存管理的基本单位。</li>
<li><strong>ThreadCache</strong>：每个线程各自的Cache，一个Cache包含多个空闲内存块链表，每个链表连接的都是内存块，同一个链表上内存块的大小是相同的，也可以说按内存块大小，给内存块分了个类，这样可以根据申请的内存大小，快速从合适的链表选择空闲内存块。由于每个线程有自己的ThreadCache，所以ThreadCache访问是无锁的。</li>
<li><strong>CentralCache</strong>：是所有线程共享的缓存，也是保存的空闲内存块链表，链表的数量与ThreadCache中链表数量相同，当ThreadCache内存块不足时，可以从CentralCache取，当ThreadCache内存块多时，可以放回CentralCache。由于CentralCache是共享的，所以它的访问是要加锁的。</li>
<li><strong>PageHeap</strong>：PageHeap是堆内存的抽象，PageHeap存的也是若干链表，链表保存的是Span，当CentralCache没有内存的时，会从PageHeap取，把1个Span拆成若干内存块，添加到对应大小的链表中，当CentralCache内存多的时候，会放回PageHeap。如下图，分别是1页Page的Span链表，2页Page的Span链表等，最后是large span set，这个是用来保存中大对象的。毫无疑问，PageHeap也是要加锁的。</li>
</ol>
<p><img src="http://img.lessisbetter.site/2019-07-tcmalloc-PageHeap.svg" alt="PageHeap"></p>
<p>上文提到了小、中、大对象，Go内存管理中也有类似的概念，我们瞄一眼TCMalloc的定义：</p>
<ol>
<li>小对象大小：0~256KB</li>
<li>中对象大小：257~1MB</li>
<li>大对象大小：&gt;1MB</li>
</ol>
<p>小对象的分配流程：ThreadCache -&gt; CentralCache -&gt; HeapPage，大部分时候，ThreadCache缓存都是足够的，不需要去访问CentralCache和HeapPage，无锁分配加无系统调用，分配效率是非常高的。</p>
<p>中对象分配流程：直接在PageHeap中选择适当的大小即可，128 Page的Span所保存的最大内存就是1MB。</p>
<p>大对象分配流程：从large span set选择合适数量的页面组成span，用来存储数据。</p>
<p>通过本节的介绍，你应当对TCMalloc主要思想有一定了解了，我建议再回顾一下上面的内容。</p>
<p><strong><em>本节图片皆来自《<a href="https://wallenwang.com/2018/11/tcmalloc/" target="_blank" rel="noopener">TCMalloc解密</a>》，图片版权归原作者所有。</em></strong></p>
<h3 id="精彩文章推荐"><a href="#精彩文章推荐" class="headerlink" title="精彩文章推荐"></a>精彩文章推荐</h3><p>本文对于TCMalloc的介绍并不多，<strong>重要的是3个快速分配内存的层次</strong>，如果想了解更多，可阅读下面文章。</p>
<ol>
<li><a href="http://goog-perftools.sourceforge.net/doc/tcmalloc.html" target="_blank" rel="noopener">TCMalloc</a><br><strong>必读</strong>，通过这篇你能掌握TCMalloc的原理和性能，对掌握Go的内存管理有非常大的帮助，虽然如今Go的内存管理与TCMalloc已经相差很大，但是，这是<strong>Go内存管理的起源和“大道”</strong>，这篇文章顶看十几篇Go内存管理的文章。</li>
<li><a href="https://wallenwang.com/2018/11/tcmalloc/" target="_blank" rel="noopener">TCMalloc解密</a><br><strong>可选</strong>，<strong>异常详细，包含大量精美图片</strong>，看完得花小时级别，理解就需要更多时间了，看完这篇不需要看其他TCMalloc的文章了。</li>
<li><a href="https://blog.csdn.net/aaronjzhang/article/details/8696212" target="_blank" rel="noopener">TCMalloc介绍</a><br><strong>可选</strong>，算是TCMalloc的文档的中文版，多数是从英文版翻译过来的，如果你英文不好，看看。</li>
</ol>
<h2 id="3-Go内存管理"><a href="#3-Go内存管理" class="headerlink" title="3. Go内存管理"></a>3. Go内存管理</h2><p>前面铺垫了那么多，终于到了本文核心的地方。前面的铺垫不是不重要，相反它们很重要，Go语言内存管理源自前面的基础知识和内存管理思维，如果你跳过了前面的内容，建议你回头看一看，它可以帮助你更好的掌握Go内存管理。</p>
<p>前文提到<strong>Go内存管理源自<a href="#TCMalloc">TCMalloc</a>，但它比TCMalloc还多了2件东西：逃逸分析和垃圾回收</strong>，这是2项提高生产力的绝佳武器。</p>
<p>这一大章节，我们先介绍Go内存管理和Go内存分配，最后涉及一点垃圾回收和内存释放。</p>
<h3 id="Go内存管理的基本概念"><a href="#Go内存管理的基本概念" class="headerlink" title="Go内存管理的基本概念"></a>Go内存管理的基本概念</h3><p>前面计算机基础知识回顾，是一种自上而下，从宏观到微观的介绍方式，把目光引入到今天的主题。</p>
<p>Go内存管理的许多概念在TCMalloc中已经有了，含义是相同的，只是名字有一些变化。先给大家上一幅宏观的图，借助图一起来介绍。</p>
<p><img src="http://img.lessisbetter.site/2019-07-go-memory-detail.png" alt="Go内存管理"></p>
<h4 id="Page"><a href="#Page" class="headerlink" title="Page"></a>Page</h4><p>与TCMalloc中的Page相同，x64下1个Page的大小是8KB。上图的最下方，1个浅蓝色的长方形代表1个Page。</p>
<h4 id="Span"><a href="#Span" class="headerlink" title="Span"></a>Span</h4><p>与TCMalloc中的Span相同，<strong>Span是内存管理的基本单位</strong>，代码中为<code>mspan</code>，<strong>一组连续的Page组成1个Span</strong>，所以上图一组连续的浅蓝色长方形代表的是一组Page组成的1个Span，另外，1个淡紫色长方形为1个Span。</p>
<h4 id="mcache"><a href="#mcache" class="headerlink" title="mcache"></a>mcache</h4><p>mcache与TCMalloc中的ThreadCache类似，<strong>mcache保存的是各种大小的Span，并按Span class分类，小对象直接从mcache分配内存，它起到了缓存的作用，并且可以无锁访问</strong>。</p>
<p>但mcache与ThreadCache也有不同点，TCMalloc中是每个线程1个ThreadCache，Go中是<strong>每个P拥有1个mcache</strong>，因为在Go程序中，当前最多有GOMAXPROCS个线程在用户态运行，所以最多需要GOMAXPROCS个mcache就可以保证各线程对mcache的无锁访问，线程的运行又是与P绑定的，把mcache交给P刚刚好。</p>
<h4 id="mcentral"><a href="#mcentral" class="headerlink" title="mcentral"></a>mcentral</h4><p>mcentral与TCMalloc中的CentralCache类似，<strong>是所有线程共享的缓存，需要加锁访问</strong>，它按Span class对Span分类，串联成链表，当mcache的某个级别Span的内存被分配光时，它会向mcentral申请1个当前级别的Span。</p>
<p>但mcentral与CentralCache也有不同点，CentralCache是每个级别的Span有1个链表，mcache是每个级别的Span有2个链表，这和mcache申请内存有关，稍后我们再解释。</p>
<h4 id="mheap"><a href="#mheap" class="headerlink" title="mheap"></a>mheap</h4><p>mheap与TCMalloc中的PageHeap类似，<strong>它是堆内存的抽象，把从OS申请出的内存页组织成Span，并保存起来</strong>。当mcentral的Span不够用时会向mheap申请，mheap的Span不够用时会向OS申请，向OS的内存申请是按页来的，然后把申请来的内存页生成Span组织起来，同样也是需要加锁访问的。</p>
<p>但mheap与PageHeap也有不同点：mheap把Span组织成了树结构，而不是链表，并且还是2棵树，然后把Span分配到heapArena进行管理，它包含地址映射和span是否包含指针等位图，这样做的主要原因是为了更高效的利用内存：分配、回收和再利用。</p>
<h4 id="大小转换"><a href="#大小转换" class="headerlink" title="大小转换"></a>大小转换</h4><p>除了以上内存块组织概念，还有几个重要的大小概念，一定要拿出来讲一下，不要忽视他们的重要性，他们是内存分配、组织和地址转换的基础。</p>
<p><img src="http://img.lessisbetter.site/2019-07-go-memory-sizes.png" alt="Go内存大小转换"></p>
<ol>
<li><strong>object size</strong>：代码里简称<code>size</code>，指申请内存的对象大小。</li>
<li><strong>size class</strong>：代码里简称<code>class</code>，它是size的级别，相当于把size归类到一定大小的区间段，比如size[1,8]属于size class 1，size(8,16]属于size class 2。</li>
<li><strong>span class</strong>：指span的级别，但span class的大小与span的大小并没有正比关系。span class主要用来和size class做对应，1个size class对应2个span class，2个span class的span大小相同，只是功能不同，1个用来存放包含指针的对象，一个用来存放不包含指针的对象，不包含指针对象的Span就无需GC扫描了。</li>
<li><strong>num of page</strong>：代码里简称<code>npage</code>，代表Page的数量，其实就是Span包含的页数，用来分配内存。</li>
</ol>
<p>在介绍这几个大小之间的换算前，我们得先看下图这个表，这个表决定了映射关系。</p>
<p>最上面2行是我手动加的，前3列分别是size class，object size和span size，根据这3列做size、size class和num of page之间的转换。</p>
<p><em>另外，第4列num of objects代表是当前size class级别的Span可以保存多少对象数量，第5列tail waste是<code>span%obj</code>计算的结果，因为span的大小并不一定是对象大小的整数倍。最后一列max waste代表最大浪费的内存百分比，计算方法在<code>printComment</code>函数中，没搞清为何这样计算。</em></p>
<p>仔细看一遍这个表，再向下看转换是如何实现的。</p>
<p><img src="http://img.lessisbetter.site/2019-07-go-sizetable.png" alt="Go内存分配表"></p>
<p>在Go内存大小转换那幅图中已经标记各大小之间的转换，分别是数组：<code>class_to_size</code>，<code>size_to_class*</code>和<code>class_to_allocnpages</code>，这3个数组内容，就是跟上表的映射关系匹配的。比如<code>class_to_size</code>，从上表看class 1对应的保存对象大小为8，所以<code>class_to_size[1]=8</code>，span大小为8192Byte，即8KB，为1页，所以<code>class_to_allocnpages[1]=1</code>。</p>
<p><img src="http://img.lessisbetter.site/2019-07-size_tranform.png" alt="Size转换"></p>
<p><strong>为何不使用函数计算各种转换，而是写成数组？</strong></p>
<p>有1个很重要的原因：<strong>空间换时间</strong>。你如果仔细观察了，上表中的转换，并不能通过简单的公式进行转换，比如size和size class的关系，并不是正比的。这些数据是使用较复杂的公式计算出来的，公式在<code>makesizeclass.go</code>中，这其中存在指数运算与for循环，造成每次大小转换的时间复杂度为O(N*2^N)。另外，对一个程序而言，内存的申请和管理操作是很多的，如果不能快速完成，就是非常的低效。把以上大小转换写死到数组里，做到了把大小转换的时间复杂度直接降到O(1)。</p>
<h3 id="Go内存分配"><a href="#Go内存分配" class="headerlink" title="Go内存分配"></a>Go内存分配</h3><p>涉及的概念已经讲完了，我们看下Go内存分配原理。</p>
<p>Go中的内存分类并不像TCMalloc那样分成小、中、大对象，但是它的小对象里又细分了一个Tiny对象，Tiny对象指大小在1Byte到16Byte之间并且不包含指针的对象。小对象和大对象只用大小划定，无其他区分。</p>
<p><img src="http://img.lessisbetter.site/2019-07-go-memory-classify.png" alt="Go内存对象分类"></p>
<p>小对象是在mcache中分配的，而大对象是直接从mheap分配的，从小对象的内存分配看起。</p>
<h4 id="小对象分配"><a href="#小对象分配" class="headerlink" title="小对象分配"></a>小对象分配</h4><p><img src="http://img.lessisbetter.site/2019-07-go-memory-detail.png" alt="Go内存管理"></p>
<p><a href="#大小转换">大小转换</a>这一小节，我们介绍了转换表，size class从1到66共66个，代码中<code>_NumSizeClasses=67</code>代表了实际使用的size class数量，即67个，从0到67，size class 0实际并未使用到。</p>
<p>上文提到1个size class对应2个span class：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numSpanClasses = _NumSizeClasses * <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><code>numSpanClasses</code>为span class的数量为134个，所以span class的下标是从0到133，所以上图中mcache标注了的span class是，<code>span class 0</code>到<code>span class 133</code>。每1个span class都指向1个span，也就是mcache最多有134个span。</p>
<h5 id="为对象寻找span"><a href="#为对象寻找span" class="headerlink" title="为对象寻找span"></a>为对象寻找span</h5><p>寻找span的流程如下：</p>
<ol>
<li>计算对象所需内存大小size </li>
<li>根据size到size class映射，计算出所需的size class</li>
<li>根据size class和对象是否包含指针计算出span class</li>
<li>获取该span class指向的span。</li>
</ol>
<p>以分配一个不包含指针的，大小为24Byte的对象为例。</p>
<p>根据映射表：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class  bytes/obj  bytes/span  objects  tail waste  max waste</span></span><br><span class="line"><span class="comment">//     1          8        8192     1024           0     87.50%</span></span><br><span class="line"><span class="comment">//     2         16        8192      512           0     43.75%</span></span><br><span class="line"><span class="comment">//     3         32        8192      256           0     46.88%</span></span><br><span class="line"><span class="comment">//     4         48        8192      170          32     31.52%</span></span><br></pre></td></tr></table></figure>
<p>size class 3，它的对象大小范围是(16,32]Byte，24Byte刚好在此区间，所以此对象的size class为3。</p>
<p>Size class到span class的计算如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// noscan为true代表对象不包含指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeSpanClass</span><span class="params">(sizeclass <span class="keyword">uint8</span>, noscan <span class="keyword">bool</span>)</span> <span class="title">spanClass</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> spanClass(sizeclass&lt;&lt;<span class="number">1</span>) | spanClass(bool2int(noscan))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，对应的span class为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">span class = <span class="number">3</span> &lt;&lt; <span class="number">1</span> | <span class="number">1</span> = <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>所以该对象需要的是span class 7指向的span。</p>
<h5 id="从span分配对象空间"><a href="#从span分配对象空间" class="headerlink" title="从span分配对象空间"></a>从span分配对象空间</h5><p>Span可以按对象大小切成很多份，这些都可以从映射表上计算出来，以size class 3对应的span为例，span大小是8KB，每个对象实际所占空间为32Byte，这个span就被分成了256块，可以根据span的起始地址计算出每个对象块的内存地址。</p>
<p><img src="http://img.lessisbetter.site/2019-07-go-memory-objs.png" alt="Span内对象"></p>
<p>随着内存的分配，span中的对象内存块，有些被占用，有些未被占用，比如上图，整体代表1个span，蓝色块代表已被占用内存，绿色块代表未被占用内存。</p>
<p>当分配内存时，只要快速找到第一个可用的绿色块，并计算出内存地址即可，如果需要还可以对内存块数据清零。</p>
<h5 id="span没有空间怎么分配对象"><a href="#span没有空间怎么分配对象" class="headerlink" title="span没有空间怎么分配对象"></a>span没有空间怎么分配对象</h5><p>span内的所有内存块都被占用时，没有剩余空间继续分配对象，mcache会向mcentral申请1个span，mcache拿到span后继续分配对象。</p>
<h5 id="mcentral向mcache提供span"><a href="#mcentral向mcache提供span" class="headerlink" title="mcentral向mcache提供span"></a>mcentral向mcache提供span</h5><p>mcentral和mcache一样，都是0~133这134个span class级别，但每个级别都保存了2个span list，即2个span链表：</p>
<ol>
<li><code>nonempty</code>：这个链表里的span，所有span都至少有1个空闲的对象空间。这些span是mcache释放span时加入到该链表的。</li>
<li><code>empty</code>：这个链表里的span，所有的span都不确定里面是否有空闲的对象空间。当一个span交给mcache的时候，就会加入到empty链表。</li>
</ol>
<p>这2个东西名称一直有点绕，建议直接把empty理解为没有对象空间就好了。</p>
<p><img src="http://img.lessisbetter.site/2019-07-go-mcentral.png" alt="mcentral"></p>
<p><em>实际代码中每1个span class对应1个mcentral，图里把所有mcentral抽象成1个整体了。</em></p>
<p>mcache向mcentral要span时，mcentral会先从<code>nonempty</code>搜索满足条件的span，如果每找到再从<code>emtpy</code>搜索满足条件的span，然后把找到的span交给mcache。</p>
<h5 id="mheap的span管理"><a href="#mheap的span管理" class="headerlink" title="mheap的span管理"></a>mheap的span管理</h5><p>mheap里保存了2棵<strong>二叉排序树</strong>，按span的page数量进行排序：</p>
<ol>
<li><code>free</code>：free中保存的span是空闲并且非垃圾回收的span。</li>
<li><code>scav</code>：scav中保存的是空闲并且已经垃圾回收的span。</li>
</ol>
<p>如果是垃圾回收导致的span释放，span会被加入到<code>scav</code>，否则加入到<code>free</code>，比如刚从OS申请的的内存也组成的Span。</p>
<p><img src="http://img.lessisbetter.site/2019-07-go-mheap.png" alt="mheap"></p>
<p>mheap中还有arenas，有一组heapArena组成，每一个heapArena都包含了连续的<code>pagesPerArena</code>个span，这个主要是为mheap管理span和垃圾回收服务。</p>
<p>mheap本身是一个全局变量，它其中的数据，也都是从OS直接申请来的内存，并不在mheap所管理的那部分内存内。</p>
<h5 id="mcentral向mheap要span"><a href="#mcentral向mheap要span" class="headerlink" title="mcentral向mheap要span"></a>mcentral向mheap要span</h5><p>mcentral向mcache提供span时，如果<code>emtpy</code>里也没有符合条件的span，mcentral会向mheap申请span。</p>
<p>mcentral需要向mheap提供需要的内存页数和span class级别，然后它优先从<code>free</code>中搜索可用的span，如果没有找到，会从<code>scav</code>中搜索可用的span，如果还没有找到，它会向OS申请内存，再重新搜索2棵树，必然能找到span。如果找到的span比需求的span大，则把span进行分割成2个span，其中1个刚好是需求大小，把剩下的span再加入到<code>free</code>中去，然后设置需求span的基本信息，然后交给mcentral。</p>
<h5 id="mheap向OS申请内存"><a href="#mheap向OS申请内存" class="headerlink" title="mheap向OS申请内存"></a>mheap向OS申请内存</h5><p>当mheap没有足够的内存时，mheap会向OS申请内存，把申请的内存页保存到span，然后把span插入到<code>free</code>树 。</p>
<p>在32位系统上，mheap还会预留一部分空间，当mheap没有空间时，先从预留空间申请，如果预留空间内存也没有了，才向OS申请。</p>
<h4 id="大对象分配"><a href="#大对象分配" class="headerlink" title="大对象分配"></a>大对象分配</h4><p>大对象的分配比小对象省事多了，99%的流程与mcentral向mheap申请内存的相同，所以不重复介绍了，不同的一点在于mheap会记录一点大对象的统计信息，见<code>mheap.alloc_m()</code>。</p>
<h3 id="Go垃圾回收和内存释放"><a href="#Go垃圾回收和内存释放" class="headerlink" title="Go垃圾回收和内存释放"></a>Go垃圾回收和内存释放</h3><p>如果只申请和分配内存，内存终将枯竭，Go使用垃圾回收收集不再使用的span，调用<code>mspan.scavenge()</code>把span释放给OS（并非真释放，只是告诉OS这片内存的信息无用了，如果你需要的话，收回去好了），然后交给mheap，mheap对span进行span的合并，把合并后的span加入<code>scav</code>树中，等待再分配内存时，由mheap进行内存再分配，Go垃圾回收也是一个很强的主题，计划后面单独写一篇文章介绍。</p>
<p>现在我们关注一下，Go程序是怎么把内存释放给操作系统的？</p>
<p>释放内存的函数是<code>sysUnused</code>，它会被<code>mspan.scavenge()</code>调用:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MAC下的实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysUnused</span><span class="params">(v unsafe.Pointer, n <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// MADV_FREE_REUSABLE is like MADV_FREE except it also propagates</span></span><br><span class="line">	<span class="comment">// accounting information about the process to task_info.</span></span><br><span class="line">	madvise(v, n, _MADV_FREE_REUSABLE)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释说<code>_MADV_FREE_REUSABLE</code>与<code>MADV_FREE</code>的功能类似，它的功能是给内核提供一个建议：<strong>这个内存地址区间的内存已经不再使用，可以回收。但内核是否回收，以及什么时候回收，这就是内核的事情了</strong>。如果内核真把这片内存回收了，当Go程序再使用这个地址时，内核会重新进行虚拟地址到物理地址的映射。所以在内存充足的情况下，内核也没有必要立刻回收内存。</p>
<h2 id="4-Go栈内存"><a href="#4-Go栈内存" class="headerlink" title="4. Go栈内存"></a>4. Go栈内存</h2><p>最后提一下栈内存。从一个宏观的角度看，内存管理不应当只有堆，也应当有栈。</p>
<p>每个goroutine都有自己的栈，栈的初始大小是2KB，100万的goroutine会占用2G，但goroutine的栈会在2KB不够用时自动扩容，当扩容为4KB的时候，百万goroutine会占用4GB。</p>
<p>关于goroutine栈内存管理，有篇很好的文章，饿了么框架技术部的专栏文章：《<a href="https://zhuanlan.zhihu.com/p/28409657" target="_blank" rel="noopener">聊一聊goroutine stack</a>》，把里面的一段内容摘录下，你感受下：</p>
<blockquote>
<p>可以看到在rpc调用(<em>grpc invoke</em>)时，栈会发生扩容(<em>runtime.morestack</em>)，也就意味着在读写routine内的任何rpc调用都会导致栈扩容， 占用的内存空间会扩大为原来的两倍，4kB的栈会变为8kB，100w的连接的内存占用会从8G扩大为16G（全双工，不考虑其他开销），这简直是噩梦。</p>
</blockquote>
<p>另外，再推荐一篇曹大翻译的一篇汇编入门文章，里面也介绍了扩栈：<a href="https://github.com/go-internals-cn/go-internals/blob/master/chapter1_assembly_primer/README.md#%E5%85%B3%E4%BA%8E%E5%8D%8F%E7%A8%8B-%E6%A0%88%E5%8F%8A%E6%A0%88%E5%88%86%E8%A3%82" target="_blank" rel="noopener">第一章: Go 汇编入门</a> ，顺便<strong>入门</strong>一下汇编。</p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>内存分配原理就不再回顾了，强调2个重要的思想：</p>
<ol>
<li><strong>使用缓存提高效率</strong>。在存储的整个体系中到处可见缓存的思想，Go内存分配和管理也使用了缓存，利用缓存一是减少了系统调用的次数，二是降低了锁的粒度，减少加锁的次数，从这2点提高了内存管理效率。</li>
<li><strong>以空间换时间，提高内存管理效率</strong>。空间换时间是一种常用的性能优化思想，这种思想其实非常普遍，比如Hash、Map、二叉排序树等数据结构的本质就是空间换时间，在数据库中也很常见，比如数据库索引、索引视图和数据缓存等，再如Redis等缓存数据库也是空间换时间的思想。</li>
</ol>
<h2 id="6-参考资料"><a href="#6-参考资料" class="headerlink" title="6. 参考资料"></a>6. 参考资料</h2><p>除了文章中已经推荐的文章，再推荐几篇值得读的文章：</p>
<ol>
<li>全成的内存分配文章，有不少帮助：<a href="https://juejin.im/post/5c888a79e51d456ed11955a8#heading-5" target="_blank" rel="noopener">https://juejin.im/post/5c888a79e51d456ed11955a8#heading-5</a></li>
<li>异常详细的源码分析文章，看完这篇我就不想写源码分析的文章了：<a href="https://www.cnblogs.com/zkweb/p/7880099.html" target="_blank" rel="noopener">https://www.cnblogs.com/zkweb/p/7880099.html</a></li>
<li>从硬件讲起的一篇文章，也是有点意思：<a href="https://www.infoq.cn/article/IEhRLwmmIM7-11RYaLHR" target="_blank" rel="noopener">https://www.infoq.cn/article/IEhRLwmmIM7-11RYaLHR</a></li>
<li>这篇文章的总流程图很棒：<a href="http://media.newbmiao.com/blog/malloc.png" target="_blank" rel="noopener">http://media.newbmiao.com/blog/malloc.png</a></li>
</ol>
<h2 id="7-彩蛋"><a href="#7-彩蛋" class="headerlink" title="7. 彩蛋"></a>7. 彩蛋</h2><p>在查阅资料时，多篇文章都提到了这本书《<a href="http://man7.org/tlpi/" target="_blank" rel="noopener">The Linux Programming Interface</a>》，关于Thread Cache有兴趣去读一下本书第31章。</p>
<hr>
<blockquote>
<ol>
<li>如果这篇文章对你有帮助，不妨关注下我的Github，有文章会收到通知。</li>
<li>本文作者：<a href="http://lessisbetter.site/about/">大彬</a></li>
<li>如果喜欢本文，随意转载，但请保留此原文链接：<a href="http://lessisbetter.site/2019/07/06/go-memory-allocation/">http://lessisbetter.site/2019/07/06/go-memory-allocation/</a></li>
</ol>
</blockquote>
<p><div style="color:#0096FF; text-align:center">关注公众号，获取最新Golang文章</div><br><img src="http://img.lessisbetter.site/2019-01-article_qrcode.jpg" style="border:0" align="center"></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2019/06/09/golang-first-class-function/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="技术与人生 | 区块链架构师">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大彬 LIB">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/06/09/golang-first-class-function/" class="post-title-link" itemprop="url">First class function in Go</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-06-09 22:00:26" itemprop="dateCreated datePublished" datetime="2019-06-09T22:00:26+08:00">2019-06-09</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-12 08:34:47" itemprop="dateModified" datetime="2019-07-12T08:34:47+08:00">2019-07-12</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://img.lessisbetter.site/2019-06-09-photo.jpeg" alt="合照"></p>
<p>6月2日Go语言中文网在杭州举办了线下的MeetUp活动，这次活动办很成功，感谢站长polaris在杭州举办活动的提议，感谢Seekload的筹备与主持，感谢Aaron提供场地，感谢所有到场者的技术经验分享，没有你们就没有这次精彩的活动。</p>
<p>在活动上，我做了个主题分享，今天把分享整理成文章，分享给学习Go语言的各位朋友。</p>
<p>参加本次活动的朋友，大多是刚接触Go，少数几个朋友把玩Go 2~3年了，所以我把主题定位到能让所有人听懂的主题。另外，大家所处行业各有不同，这就要求专注介绍Go本身的特性，这才是大家通用的地方。</p>
<p>最后选题为First class function in Go，这次没有做中文翻译，避免翻译后有误解。这个特性浅显易懂，但掌握Go语言的思维，才能把它用好。</p>
<p>线下分享后，证明选题选对了，大家都能听懂，所以现在不了解First class function的朋友不用着急，后面我会层层推进的方式介绍，相信你一定能理解，那就进入正文吧。</p>
<h1 id="First-class-function-in-Go"><a href="#First-class-function-in-Go" class="headerlink" title="First class function in Go"></a>First class function in Go</h1><h2 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h2><p><img src="http://img.lessisbetter.site/2019-06-09-幻灯片04.png" alt="幻灯片04"></p>
<p>某个编程语言拥有First class function特性指可以把函数作为变量对待。也就说，函数与变量没有差别，它们是一样的，变量出现的地方都可以替换成函数，并且编译也是可以通过的，没有任何语法问题。</p>
<p>在Go里，变量可以存在于哪些地方？</p>
<p><img src="http://img.lessisbetter.site/2019-06-09-幻灯片05.png" alt="幻灯片05"></p>
<p>变量可以被声明、定义，可以使用<code>type</code>创建变量的类型，可以作为函数的入参和返回值，可以存在<code>slice</code>, <code>array</code>, <code>map</code>等数据结构里，可以被动态的创建。</p>
<p>在Go中，函数也可以被声明、定义，可以使用<code>type</code>创建一个函数类型，可以作为其他函数的入参和返回值，可以保存在其他类型的数据结构里，最后，函数是可以被动态创建的。</p>
<p>简要归类一下就是下图的样子，除了上面提到的内容，还有匿名函数和闭包，将按下图顺序介绍每一个小特性。</p>
<p><img src="http://img.lessisbetter.site/2019-06-09-幻灯片06.png" alt="幻灯片06"></p>
<h2 id="定义函数类型"><a href="#定义函数类型" class="headerlink" title="定义函数类型"></a>定义函数类型</h2><p><img src="http://img.lessisbetter.site/2019-06-09-幻灯片07.png" alt="幻灯片07"></p>
<p>使用<code>type</code>定义一个函数类型，<code>type</code>后是类型名称，本例中是<code>Operation</code>，再后面是类型的定义，对于函数而言，被称为signature，即函数签名，这个函数签名表示：Operation类型的函数，它以2个int类型为入参，以1个int为返回值。所有满足该函数签名的函数，都是Operation类型的函数。</p>
<p><img src="http://img.lessisbetter.site/2019-06-09-幻灯片08.png" alt="幻灯片08"></p>
<p>函数<code>Add</code>和<code>Sub</code>都符合<code>Operation</code>的签名，所以<code>Add</code>和<code>Sub</code>都是<code>Operation</code>类型。</p>
<h2 id="声明函数类型的变量和为变量赋值"><a href="#声明函数类型的变量和为变量赋值" class="headerlink" title="声明函数类型的变量和为变量赋值"></a>声明函数类型的变量和为变量赋值</h2><p><img src="http://img.lessisbetter.site/2019-06-09-幻灯片09.png" alt="幻灯片09"></p>
<p>变量<code>op</code>是<code>Operation</code>类型的，可以把<code>Add</code>作为值赋值给变量<code>op</code>，执行<code>op</code>等价于执行<code>Add</code>。</p>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>高阶函数分为函数作为入参和函数作为返回值2部分。</p>
<h3 id="函数作为其他函数入参"><a href="#函数作为其他函数入参" class="headerlink" title="函数作为其他函数入参"></a>函数作为其他函数入参</h3><p><img src="http://img.lessisbetter.site/2019-06-09-幻灯片10.png" alt="幻灯片10"></p>
<p>定义一个<code>Calculator</code>结构体，它始终保持计算后的结果。</p>
<p>它有一个方法<code>Do</code>，入参为一个<code>Operation</code>类型的函数<code>op</code>和1个<code>int</code>类型的变量a，使用计算器的值<code>c.v</code>和<code>a</code>作为<code>op</code>的入参，进行指定运算，并把结果保存会<code>c.v</code>。</p>
<p><code>main</code>中，声明了一个变量<code>calc</code>，<code>calc.v</code>初始值为0，然后运行了加1和减2的操作，加减法的完成使用的我们之前定义的函数<code>Add</code>和<code>Sub</code>。操作等价于：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">calc.v = Add(calc.v, <span class="number">1</span>)</span><br><span class="line">calc.v = Sub(calc.v, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h3 id="函数作为返回值-动态创建"><a href="#函数作为返回值-动态创建" class="headerlink" title="函数作为返回值+动态创建"></a>函数作为返回值+动态创建</h3><p><img src="http://img.lessisbetter.site/2019-06-09-幻灯片11.png" alt="幻灯片11"></p>
<p>这次，改变<code>Operation</code>的定义，修改为接收1个<code>int</code>类型的入参，返回1个<code>int</code>类型的返回值。</p>
<p>同时修改函数<code>Add</code>和<code>Sub</code>，它们接收1个<code>int</code>类型的入参，返回1个<code>Operation</code>类型的函数，这个函数是动态创建出来的。</p>
<p>以<code>Add</code>为例介绍，在<code>Add</code>里动态创建了一个函数，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(a <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数实现了在变量a基础上加b的操作，并返回结果，我们把这个函数赋值给<strong>变量<code>addB</code></strong>，把<code>addB</code>作为返回值返回。</p>
<p>所以本例实现了以函数作为返回值和动态创建函数。</p>
<p><img src="http://img.lessisbetter.site/2019-06-09-幻灯片12.png" alt="幻灯片12"></p>
<p><code>Operation</code>，<code>Add</code>和<code>Sub</code>修改后，<code>Calculator</code>也要同步修改，方法<code>Do</code>修改为只接收<code>Operation</code>类型的函数。</p>
<p><code>main</code>函数里，注意<code>Do</code>的入参：<code>Add(1)</code>，它实现的效果是，创建了1个函数，该函数接收1个值，然后把这个值+1返回，如果用数学表示就是这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add(1)</span></span><br><span class="line">add1(x) = x + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>同理，<code>Sub(2)</code>的数学表示如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sub(2)</span></span><br><span class="line">sub2(x) = x - <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>所以2次<code>Do</code>操作等价于：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// calc.Do(Add(1))</span></span><br><span class="line">calc.v = add1(calc.v)</span><br><span class="line"><span class="comment">// calc.Do(Sub(2))</span></span><br><span class="line">calc.v = sub2(calc.v)</span><br></pre></td></tr></table></figure>
<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p><img src="http://img.lessisbetter.site/2019-06-09-幻灯片13.png" alt="幻灯片13"></p>
<p>上图左边是普通函数，<code>func</code>后为函数名，然后为函数签名。右边只有<code>func</code>和函数签名，缺少函数名，右边的情况为匿名函数。</p>
<p><img src="http://img.lessisbetter.site/2019-06-09-幻灯片14.png" alt="幻灯片14"></p>
<p>以<code>Add</code>函数其中定义的函数为例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(a <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是1个匿名函数，它没有名字。<strong><code>addB</code>并不是函数的名字，只是1个变量名而已，只不过这个变量名的类型是没有显示定义出来的</strong>。</p>
<p><code>Add</code>通常简写为右边的形式。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p><img src="http://img.lessisbetter.site/2019-06-09-幻灯片15.png" alt="幻灯片15"></p>
<p>很多人搞不清什么是匿名函数，什么是闭包，所以这里分开介绍这2个概念。</p>
<p><strong>闭包指有权访问另一个函数作用域中的变量的函数</strong>。大白话就是，可以创建1个函数，它可以访问其他函数遍历，但不需要传值。</p>
<p>仍然是<code>Add</code>函数为例，比如匿名函数里直接使用了变量b，该匿名函数也是闭包函数。</p>
<p>闭包的特性注定了，闭包函数要定义在一个函数里面，定义在一个函数里面又只能是匿名函数。</p>
<p><strong>那，匿名函数和闭包是不是就等价了？</strong></p>
<p><strong>No，一个函数可以是匿名函数，但不是闭包函数，因为闭包有时是有副作用的。</strong></p>
<p><img src="http://img.lessisbetter.site/2019-06-09-幻灯片16.png" alt="幻灯片16"></p>
<p>我们想并发的把sl中的值打印出来，结果为何会是右边这样？</p>
<p>因为并发的匿名函数，使用的是<code>test1</code>中的<code>i,v</code>，即这是闭包函数，所有的goroutine都共享这2个值，并且启动1个goroutine后，这2个值变为下一个位置的值。你运行的结果也许不是9 9 9….，因为这个goroutine的调度有关。</p>
<p>如何才能符合预期的打印？只使用匿名函数进行传值，不使用闭包。</p>
<p><img src="http://img.lessisbetter.site/2019-06-09-幻灯片17.png" alt="幻灯片17"></p>
<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><p>接下来以一个实际的场景，和3种实现版本看如何用Go的思维去解决问题。</p>
<h2 id="场景介绍"><a href="#场景介绍" class="headerlink" title="场景介绍"></a>场景介绍</h2><p><img src="http://img.lessisbetter.site/2019-06-09-幻灯片19.png" alt="幻灯片19"></p>
<p>做Go语言工作，尤其是跟网络打交道的工作，连接管理是逃不开的。我做区块链相关的技术工作，区块链中也有网络管理，所以我就以区块链的网络管理为场景进行介绍，但不涉及具体的技术细节，大家莫慌，只需要理解2个概念就行。</p>
<p>区块链是构建在P2P网络之上，在P2P网络中：</p>
<ol>
<li>一个节点即可以是服务器也可以是客户端，被称为<strong>Host</strong>，</li>
<li>和本节点连接的所有节点都被称为<strong>Peer</strong>。</li>
</ol>
<p><strong>具体的场景是：Host需要保存所有建立连接的Peer，并对这些Peer进行维护：增加和删除Peer，并且提供Peer的查询和向所有Peer广播消息的接口</strong>。</p>
<p>针对这个问题场景，我写了3个版本的Demo，我们依次来介绍，再看的时候，可以思考其中的不同。</p>
<h2 id="版本1"><a href="#版本1" class="headerlink" title="版本1"></a>版本1</h2><p><img src="http://img.lessisbetter.site/2019-06-09-幻灯片20.png" alt="幻灯片20"></p>
<p>先看<code>Peer</code>定义，<code>Peer</code>中保存了<code>ID</code>，我们可以通过<code>ID</code>来表示全网中所有的节点，<code>Peer</code>中还有其他字段，比如网络连接、地址、协议版本等信息，此处已经省略掉。</p>
<p><code>Peer</code>有一个<code>WriteMsg</code>的方法，实现向该<code>Peer</code>发送消息的功能，例子中使用打印替代。</p>
<p><strong>Peer的定义在3个版本中都不会发生变化，所以后面就不再展示</strong>。</p>
<p><img src="http://img.lessisbetter.site/2019-06-09-幻灯片21.png" alt="幻灯片21"></p>
<p><code>Host</code>通过<code>peers</code>保存了所有连接的Peer，可以通过<code>Peer.ID</code>对Peer进行索引。Peer的管理是并发场景，比如，我们可能同时接收到多个Peer的连接，又同时需要向所有Peer广播消息，需要对<code>peers</code>加锁保护。最后，我们省略了<code>Host</code>的其他字段。</p>
<p><code>NewHost()</code>用来创建一个<code>Host</code>对象，用来代表当前节点。</p>
<p><em>友情提醒：<code>Host</code>在每一个版本都会不同。</em></p>
<p><img src="http://img.lessisbetter.site/2019-06-09-幻灯片22.png" alt="幻灯片22"></p>
<p><code>Host</code>有4个方法，分别是：</p>
<ol>
<li><code>AddPeer</code>: 增加1个Peer。</li>
<li><code>RemovePeer</code>: 删除1个Peer。</li>
<li><code>GetPeer</code>: 通过Peer.ID查询1个Peer。</li>
<li><code>BroadcastMsg</code>: 向所有Peer发送消息。</li>
</ol>
<p>每一个方法都需要获取<code>lock</code>，然后访问<code>peers</code>，如果只读取<code>peers</code>则使用读锁。</p>
<p><strong>第1个版本已经介绍完了，大家可以思考一下版本1的缺点。</strong></p>
<p><img src="http://img.lessisbetter.site/2019-06-09-幻灯片23.png" alt="幻灯片23"></p>
<p>第1个版本跟其他语言实现其实没有本质区别，用C++、Java等也能写出上面逻辑的代码，只不过这个是Go语言实现的罢了。</p>
<p><strong>这个版本是一个communicate by sharing memory的体现</strong>，具体来讲，每个goroutine都是1个实体，它们同时运行，调用<code>Host</code>的不同方法来访问<code>peers</code>，只有拿到当前<code>lock</code>的goroutine才能访问peers，仿佛当前goroutine在同其他goroutine讲：我现在有访问权，你们等一下。本质上就是，通过共享<code>Host.lock</code>这块内存，各goroutine进行交流（表明自己拥有访问权）。</p>
<h2 id="版本2"><a href="#版本2" class="headerlink" title="版本2"></a>版本2</h2><p><img src="http://img.lessisbetter.site/2019-06-09-幻灯片24.png" alt="幻灯片24"></p>
<p>很多Go老手都听过这句话了，这是Go的“联合创始人”<strong>Rob Pike</strong>某个会议上说的。</p>
<p><strong>在Go中，推荐使用CSP实现并发，而不是习惯性的使用Lock，使用channel传递数据，达到多goroutine间共享数据的目的，也就是share memory by communicating</strong>。</p>
<p>所以，我们版本2，就使用channel的方式，来实现Peer的管理。</p>
<p><img src="http://img.lessisbetter.site/2019-06-09-幻灯片25.png" alt="幻灯片25"></p>
<p>在版本1中，<code>peers</code>是大家都想访问的，并且Host有4个方法，画到了上面的图中，我们看下怎么用CSP实现。</p>
<p><code>peers</code>需要在单独的goroutine中，其他的4个方法在其他的goroutine中调用，它们之间进行通信。</p>
<p>我对使用CSP有一个好的实践，就是把数据流动画出来，并把要流动的数据标上，然后那些数据流动的线条，就是channel，线条上的数据就是channel要传递的数据，图中也把这些线条和数据标上了。具体的细节，可以识别图片中的二维码，看看这篇老文，还有就是并不是所有的并发场景都适合使用channel，有些用锁更好，这篇文章也有介绍。</p>
<p><img src="http://img.lessisbetter.site/2019-06-09-幻灯片26.png" alt="幻灯片26"></p>
<p>重新定义Host，增加了4个channel，从上到下分别用于增加Peer、广播消息、删除Peer和停止Host。</p>
<p><img src="http://img.lessisbetter.site/2019-06-09-幻灯片27.png" alt="幻灯片27"></p>
<p>Host增加了2个方法：</p>
<ol>
<li><code>Start()</code>用于启动1个goroutine运行<code>loop()</code>，<code>loop</code>保存所有的<code>peers</code>。</li>
<li><code>Stop()</code>用于关闭Host，让<code>loop</code>退出。</li>
</ol>
<p><img src="http://img.lessisbetter.site/2019-06-09-幻灯片28.png" alt="幻灯片28"></p>
<p>左边是<code>loop()</code>的实现，它从4个channel里接收数据，然后做不同的操作。</p>
<p>右边是<code>AddPeer</code>， <code>RemovePeer</code>, <code>BroadcastMsg</code>的实现。</p>
<p>利用1分钟的事件，左右两边对照着看，理解增加1个Peer的全过程。</p>
<p>这就是版本2的全部实现了，思考一下版本2有什么问题，原因是啥？</p>
<p><img src="http://img.lessisbetter.site/2019-06-09-幻灯片29.png" alt="幻灯片29"></p>
<p><img src="http://img.lessisbetter.site/2019-06-09-幻灯片30.png" alt="幻灯片30"></p>
<p>问题就是我们没有实现<code>GetPeer</code>这个方法，聪明的你一定在Host的定义就发现了，只有增加、删除和广播消息的channel。</p>
<p><strong>没能实现<code>GetPeer</code>的原因下图中进行了介绍，你有没有解决办法？</strong></p>
<p><img src="http://img.lessisbetter.site/2019-06-09-幻灯片31.png" alt="幻灯片31"></p>
<p><img src="http://img.lessisbetter.site/2019-06-09-幻灯片32.png" alt="幻灯片32"></p>
<p><img src="http://img.lessisbetter.site/2019-06-09-幻灯片33.png" alt="幻灯片33"></p>
<p>可能会有很多goroutine调用<code>GetPeer</code>，我们需要向每一个goroutine发送结果，这就需要每一个goroutine都需要对应的1个接收结果的channel。</p>
<p>所以<strong>我们可以增加1个query channel，channel里传递Peer.ID和接收结果的channel。</strong></p>
<p><strong>还有没有其他办法？</strong>我们今天的主题<code>First class function</code>还有入场，你有办法用这个特性实现吗？</p>
<h2 id="版本3"><a href="#版本3" class="headerlink" title="版本3"></a>版本3</h2><p><img src="http://img.lessisbetter.site/2019-06-09-幻灯片34.png" alt="幻灯片34"></p>
<p>First class function: 函数可以向变量一样使用。那channel里面是不是可以传递函数呢？当然可以。</p>
<p><img src="http://img.lessisbetter.site/2019-06-09-幻灯片35.png" alt="幻灯片35"></p>
<p>我们可以建立一个channel，用这个channel向<code>loop</code>传递操作<code>peers</code>的函数，所以函数的入参是<code>peers map[string]*Peer</code>，无需返回值，因为函数是在<code>loop</code>里面调用的，调用<code>AddPeer</code>等函数的goroutine是接收不到返回值的。我们把这个类型的函数定义为<code>Operation</code>。</p>
<p><code>Host</code>修改为只有2个channel，<code>stop</code>功能如版本2，<code>opCh</code>用来传递<code>Operation</code>类型的函数。</p>
<p><img src="http://img.lessisbetter.site/2019-06-09-幻灯片36.png" alt="幻灯片36"></p>
<p><code>loop</code>函数可以简化为左边的形式了，右边是<code>AddPeer</code>和<code>RemovePeer</code>，以<code>AddPeer</code>为例进行介绍，创建了一个匿名函数，向<code>peers</code>里增加<code>p</code>，然后把函数发送到<code>opCh</code>。</p>
<p><img src="http://img.lessisbetter.site/2019-06-09-幻灯片37.png" alt="幻灯片37"></p>
<p><code>BroadcastMsg</code>与<code>AddPeer</code>类似。</p>
<p><img src="http://img.lessisbetter.site/2019-06-09-幻灯片38.png" alt="幻灯片38"></p>
<p>我们重点看一下<code>GetPeer</code>，创建了<code>retCh</code>用于接收查询的结果，创建了匿名函数进行查询，并把查询结果发送到<code>retCh</code>，然后启动1个goroutine把匿名函数写入到<code>opCh</code>，最后等待从<code>retCh</code>读取查询结果。</p>
<p>这样就实现了向每个调用<code>GetPeer</code>的goroutine发送查询结果。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="http://img.lessisbetter.site/2019-06-09-幻灯片40.png" alt="幻灯片40"></p>
<p>总结都在上面了，不多说了。</p>
<p><strong>友情提醒：这3种方式本身并无优劣之分，具体要用那种实现，要依赖自身的实际场景进行取舍。</strong></p>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>识别下图二维码。</p>
<p><img src="http://img.lessisbetter.site/2019-06-09-幻灯片41.png" alt="幻灯片41"></p>
<h2 id="PPT下载"><a href="#PPT下载" class="headerlink" title="PPT下载"></a>PPT下载</h2><p>下载链接：<a href="http://img.lessisbetter.site/Go%E8%AF%AD%E8%A8%80%E6%80%9D%E7%BB%B4First-class-function.pdf" target="_blank" rel="noopener">http://img.lessisbetter.site/Go%E8%AF%AD%E8%A8%80%E6%80%9D%E7%BB%B4First-class-function.pdf</a></p>
<p>或<strong>阅读原文</strong>下载。</p>
<h1 id="云象介绍"><a href="#云象介绍" class="headerlink" title="云象介绍"></a>云象介绍</h1><p>广告时间，云象区块链持续招人，欢迎来撩。</p>
<p><img src="http://img.lessisbetter.site/2019-06-09-幻灯片42.png" alt="幻灯片42"></p>
<h1 id="活动总结"><a href="#活动总结" class="headerlink" title="活动总结"></a>活动总结</h1><p>最后奉上Seekload关于本次活动的总结：<a href="https://mp.weixin.qq.com/s/wfDW4cKjzuEE1K94anuImA" target="_blank" rel="noopener">Gopher杭州线下面基第一期</a>。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2019/05/18/linux-simulate-bad-network/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="技术与人生 | 区块链架构师">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大彬 LIB">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/18/linux-simulate-bad-network/" class="post-title-link" itemprop="url">Linux内网测试环境模拟网络丢包和延时</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-05-18 15:37:05" itemprop="dateCreated datePublished" datetime="2019-05-18T15:37:05+08:00">2019-05-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-17 11:33:05" itemprop="dateModified" datetime="2019-05-17T11:33:05+08:00">2019-05-17</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本文源自同事分享，在此基础之上做简要修改而成。</p>
</blockquote>
<p>Linux下有2traffic control（简写TC）和netem这2个工具。Netem 是 Linux 2.6 及以上内核版本提供的一个网络模拟功能模块，该功能模块可以用来在性能良好的局域网中，模拟出复杂的互联网传输性能，诸如低带宽、传输延迟、丢包等等情况。使用 Linux 2.6 (或以上) 版本内核的很多发行版 Linux 都开启了该内核功能，比如Fedora、Ubuntu、Redhat、OpenSuse、CentOS、Debian等等。TC可以用来控制 netem 的工作模式，可完成如下功能：（故障模拟） 模拟时延，丢包，重复包，乱序，控制带宽等。</p>
<p>本文介绍简单的使用方法，更详细的介绍及用法见：<a href="https://wiki.linuxfoundation.org/networking/netem" target="_blank" rel="noopener">wiki:network emulation</a>。</p>
<h1 id="TC实现原理"><a href="#TC实现原理" class="headerlink" title="TC实现原理"></a>TC实现原理</h1><p>TC用于Linux内核的流量控制，主要是通过在输出端口处建立一个队列来实现流量控制。接收包从输入接口（Input Interface）进来后，经过流量限制（Ingress Policing）丢弃不符合规定的数据包，由输入多路分配器（Input De-Multiplexing）进行判断选择：如果接收包的目的是本主机，那么将该包送给上层处理；否则需要进行转发，将接收包交到转发块（Forwarding Block）处理。转发块同时也接收本主机上层（TCP、UDP等）产生的包。转发块通过查看路由表，决定所处理包的下一跳。然后，对包进行排列以便将它们传送到输出接口（Output Interface）。一般我们只能限制网卡发送的数据包，不能限制网卡接收的数据包，所以我们可以通过改变发送次序来控制传输速率。Linux流量控制主要是在输出接口排列时进行处理和实现的。</p>
<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><p>以下模拟命令可配合使用，实现即延迟又丢包等情况。</p>
<h2 id="模拟延迟传输"><a href="#模拟延迟传输" class="headerlink" title="模拟延迟传输"></a>模拟延迟传输</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tc qdisc add dev eth0 root netem delay 100ms</span><br></pre></td></tr></table></figure>
<p>该命令将 eth0 网卡的传输设置为延迟100毫秒发送。<br>更真实的情况下，延迟值不会这么精确，会有一定的波动，我们可以用下面的情况来模拟出带有波动性的延迟值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tc qdisc add dev eth0 root netem delay 100ms 50ms</span><br></pre></td></tr></table></figure>
<p>该命令将 eth0 网卡的传输设置为延迟 100ms ± 50ms （50 ~ 150 ms 之间的任意值）发送。<br>还可以更进一步加强这种波动的随机性：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tc qdisc add dev eth0 root netem delay 100ms 50ms 30%</span><br></pre></td></tr></table></figure>
<p>该命令将 eth0 网卡的传输设置为 100ms ，同时，大约有 30% 的包会延迟 ± 50ms 发送。
　　</p>
<h2 id="模拟网络丢包"><a href="#模拟网络丢包" class="headerlink" title="模拟网络丢包"></a>模拟网络丢包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tc qdisc add dev eth0 root netem loss 10%</span><br></pre></td></tr></table></figure>
<p>该命令将 eth0 网卡的传输设置为随机丢掉 10% 的数据包。<br>也可以设置丢包的成功率：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tc qdisc add dev eth0 root netem loss 10% 30%</span><br></pre></td></tr></table></figure>
<h2 id="模拟包重复"><a href="#模拟包重复" class="headerlink" title="模拟包重复"></a>模拟包重复</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tc qdisc add dev eth0 root netem duplicate 10%</span><br></pre></td></tr></table></figure>
<p>该命令将 eth0 网卡的传输设置为随机产生 10% 的重复数据包 。</p>
<h2 id="模拟包损坏"><a href="#模拟包损坏" class="headerlink" title="模拟包损坏"></a>模拟包损坏</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tc qdisc add dev eth0 root netem corrupt 1%</span><br></pre></td></tr></table></figure>
<h2 id="模拟包乱序"><a href="#模拟包乱序" class="headerlink" title="模拟包乱序"></a>模拟包乱序</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tc qdisc change dev eth0 root netem delay 10ms reorder 10% 50%</span><br></pre></td></tr></table></figure>
<p>该命令将 eth0 网卡的传输设置为:有 10% 的数据包（50%相关）会被立即发送，其他的延迟 10 秒。</p>
<h2 id="删除设备及显示设置"><a href="#删除设备及显示设置" class="headerlink" title="删除设备及显示设置"></a>删除设备及显示设置</h2><p>显示配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tc qdisc sh dev eth0</span><br></pre></td></tr></table></figure>
<p>删除配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tc qd del dev eth0 root</span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cnblogs.com/fsw-blog/p/4788036.html" target="_blank" rel="noopener">Linux网络流量控制工具—Netem</a></p>
<blockquote>
<ol>
<li>如果这篇文章对你有帮助，不妨关注下我的Github，有文章会收到通知。</li>
<li>本文作者：<a href="http://lessisbetter.site/about/">大彬</a></li>
<li>如果喜欢本文，随意转载，但请保留此原文链接：<a href="http://lessisbetter.site/2019/05/18/linux-simulate-bad-network/">http://lessisbetter.site/2019/05/18/linux-simulate-bad-network/</a></li>
</ol>
</blockquote>
<p><div style="color:#0096FF; text-align:center">关注公众号，获取最新Golang文章</div><br><img src="http://img.lessisbetter.site/2019-01-article_qrcode.jpg" style="border:0" align="center"></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2019/05/18/go-goroutine-leak/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="技术与人生 | 区块链架构师">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大彬 LIB">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/18/go-goroutine-leak/" class="post-title-link" itemprop="url">实战Go内存泄露</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-05-18 10:30:47" itemprop="dateCreated datePublished" datetime="2019-05-18T10:30:47+08:00">2019-05-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-12 08:34:47" itemprop="dateModified" datetime="2019-07-12T08:34:47+08:00">2019-07-12</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近解决了我们项目中的一个内存泄露问题，事实再次证明pprof是一个好工具，但掌握好工具的正确用法，才能发挥好工具的威力，不然就算你手里有屠龙刀，也成不了天下第一，本文就是带你用pprof定位内存泄露问题。</p>
<p>关于Go的内存泄露有这么一句话不知道你听过没有：</p>
<blockquote>
<p>10次内存泄露，有9次是goroutine泄露。</p>
</blockquote>
<p>我所解决的问题，也是goroutine泄露导致的内存泄露，所以<strong>这篇文章主要介绍Go程序的goroutine泄露，掌握了如何定位和解决goroutine泄露，就掌握了内存泄露的大部分场景</strong>。</p>
<blockquote>
<p>本文草稿最初数据都是生产坏境数据，为了防止敏感内容泄露，全部替换成了demo数据，demo的数据比生产环境数据简单多了，更适合入门理解，有助于掌握pprof。</p>
</blockquote>
<hr>
<h1 id="go-pprof基本知识"><a href="#go-pprof基本知识" class="headerlink" title="go pprof基本知识"></a>go pprof基本知识</h1><p>定位goroutine泄露会使用到pprof，pprof是Go的性能工具，在开始介绍内存泄露前，先简单介绍下pprof的基本使用，更详细的使用给大家推荐了资料。</p>
<h2 id="什么是pprof"><a href="#什么是pprof" class="headerlink" title="什么是pprof"></a>什么是pprof</h2><p>pprof是Go的性能分析工具，在程序运行过程中，可以记录程序的运行信息，可以是CPU使用情况、内存使用情况、goroutine运行情况等，当需要性能调优或者定位Bug时候，这些记录的信息是相当重要。</p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>使用pprof有多种方式，Go已经现成封装好了1个：<code>net/http/pprof</code>，使用简单的几行命令，就可以开启pprof，记录运行信息，并且提供了Web服务，能够通过浏览器和命令行2种方式获取运行数据。</p>
<p>看个最简单的pprof的例子：</p>
<p><em>文件：<a href="https://github.com/Shitaibin/golang_step_by_step/blob/master/pprof/pprof/demo.go" target="_blank" rel="noopener">golang_step_by_step/pprof/pprof/demo.go</a></em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	_ <span class="string">"net/http/pprof"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 开启pprof，监听请求</span></span><br><span class="line">	ip := <span class="string">"0.0.0.0:6060"</span></span><br><span class="line">	<span class="keyword">if</span> err := http.ListenAndServe(ip, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"start pprof failed on %s\n"</span>, ip)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>提醒：本文所有代码部分可左右滑动</em></p>
<h3 id="浏览器方式"><a href="#浏览器方式" class="headerlink" title="浏览器方式"></a>浏览器方式</h3><p><img src="http://img.lessisbetter.site/2019-05-image-20190516173924325-7999564.png" alt="image-20190516173924325"></p>
<p>输入网址<code>ip:port/debug/pprof/</code>打开pprof主页，从上到下依次是<strong>5类profile信息</strong>：</p>
<ol>
<li><strong>block</strong>：goroutine的阻塞信息，本例就截取自一个goroutine阻塞的demo，但block为0，没掌握block的用法</li>
<li><strong>goroutine</strong>：所有goroutine的信息，下面的<code>full goroutine stack dump</code>是输出所有goroutine的调用栈，是goroutine的debug=2，后面会详细介绍。</li>
<li><strong>heap</strong>：堆内存的信息</li>
<li><strong>mutex</strong>：锁的信息</li>
<li><strong>threadcreate</strong>：线程信息</li>
</ol>
<p>这篇文章我们主要关注goroutine和heap，这两个都会打印调用栈信息，goroutine里面还会包含goroutine的数量信息，heap则是内存分配信息，本文用不到的地方就不展示了，最后推荐几篇文章大家去看。</p>
<h3 id="命令行方式"><a href="#命令行方式" class="headerlink" title="命令行方式"></a>命令行方式</h3><p>当连接在服务器终端上的时候，是没有浏览器可以使用的，Go提供了命令行的方式，能够获取以上5类信息，这种方式用起来更方便。</p>
<p>使用命令<code>go tool pprof url</code>可以获取指定的profile文件，此命令会发起http请求，然后下载数据到本地，之后进入交互式模式，就像gdb一样，可以使用命令查看运行信息，以下是5类请求的方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载cpu profile，默认从当前开始收集30s的cpu使用情况，需要等待30s</span></span><br><span class="line">go tool pprof http://localhost:6060/debug/pprof/profile   <span class="comment"># 30-second CPU profile</span></span><br><span class="line">go tool pprof http://localhost:6060/debug/pprof/profile?seconds=120     <span class="comment"># wait 120s</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载heap profile</span></span><br><span class="line">go tool pprof http://localhost:6060/debug/pprof/heap      <span class="comment"># heap profile</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载goroutine profile</span></span><br><span class="line">go tool pprof http://localhost:6060/debug/pprof/goroutine <span class="comment"># goroutine profile</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载block profile</span></span><br><span class="line">go tool pprof http://localhost:6060/debug/pprof/block     <span class="comment"># goroutine blocking profile</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载mutex profile</span></span><br><span class="line">go tool pprof http://localhost:6060/debug/pprof/mutex</span><br></pre></td></tr></table></figure>
<p>上面的<code>pprof/demo.go</code>太简单了，如果去获取内存profile，几乎获取不到什么，换一个Demo进行内存profile的展示：</p>
<p><em>文件：<a href="https://github.com/Shitaibin/golang_step_by_step/blob/master/pprof/heap/demo2.go" target="_blank" rel="noopener">golang_step_by_step/pprof/heap/demo2.go</a></em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 展示内存增长和pprof，并不是泄露</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	_ <span class="string">"net/http/pprof"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行一段时间：fatal error: runtime: out of memory</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 开启pprof</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		ip := <span class="string">"0.0.0.0:6060"</span></span><br><span class="line">		<span class="keyword">if</span> err := http.ListenAndServe(ip, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"start pprof failed on %s\n"</span>, ip)</span><br><span class="line">			os.Exit(<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	tick := time.Tick(time.Second / <span class="number">100</span>)</span><br><span class="line">	<span class="keyword">var</span> buf []<span class="keyword">byte</span></span><br><span class="line">	<span class="keyword">for</span> <span class="keyword">range</span> tick &#123;</span><br><span class="line">		buf = <span class="built_in">append</span>(buf, <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>*<span class="number">1024</span>)...)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个demo会不断的申请内存，把它编译运行起来，然后执行：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> tool pprof http:<span class="comment">//localhost:6060/debug/pprof/heap</span></span><br><span class="line"></span><br><span class="line">Fetching profile over HTTP from http:<span class="comment">//localhost:6060/debug/pprof/heap</span></span><br><span class="line">Saved profile in /home/ubuntu/pprof/pprof.demo.alloc_objects.alloc_space.inuse_objects.inuse_space<span class="number">.001</span>.pb.gz       <span class="comment">//&lt;--- 下载到的内存profile文件</span></span><br><span class="line">File: demo <span class="comment">// 程序名称</span></span><br><span class="line">Build ID: a9069a125ee9c0df3713b2149ca859e8d4d11d5a</span><br><span class="line">Type: inuse_space</span><br><span class="line">Time: May <span class="number">16</span>, <span class="number">2019</span> at <span class="number">8</span>:<span class="number">55</span>pm (CST)</span><br><span class="line">Entering interactive mode (<span class="keyword">type</span> <span class="string">"help"</span> <span class="keyword">for</span> commands, <span class="string">"o"</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof)</span><br><span class="line">(pprof)</span><br><span class="line">(pprof) help  <span class="comment">// 使用help打印所有可用命令</span></span><br><span class="line">  Commands:</span><br><span class="line">    callgrind        Outputs a graph in callgrind format</span><br><span class="line">    comments         Output all profile comments</span><br><span class="line">    disasm           Output assembly listings annotated with samples</span><br><span class="line">    dot              Outputs a graph in DOT format</span><br><span class="line">    eog              Visualize graph through eog</span><br><span class="line">    evince           Visualize graph through evince</span><br><span class="line">    gif              Outputs a graph image in GIF format</span><br><span class="line">    gv               Visualize graph through gv</span><br><span class="line">    kcachegrind      Visualize report in KCachegrind</span><br><span class="line">    list             Output annotated source <span class="keyword">for</span> functions matching regexp</span><br><span class="line">    pdf              Outputs a graph in PDF format</span><br><span class="line">    peek             Output callers/callees of functions matching regexp</span><br><span class="line">    png              Outputs a graph image in PNG format</span><br><span class="line">    proto            Outputs the profile in compressed protobuf format</span><br><span class="line">    ps               Outputs a graph in PS format</span><br><span class="line">    raw              Outputs a text representation of the raw profile</span><br><span class="line">    svg              Outputs a graph in SVG format</span><br><span class="line">    tags             Outputs all tags in the profile</span><br><span class="line">    text             Outputs top entries in text form</span><br><span class="line">    top              Outputs top entries in text form</span><br><span class="line">    topproto         Outputs top entries in compressed protobuf format</span><br><span class="line">    traces           Outputs all profile samples in text form</span><br><span class="line">    tree             Outputs a text rendering of call graph</span><br><span class="line">    web              Visualize graph through web browser</span><br><span class="line">    weblist          Display annotated source in a web browser</span><br><span class="line">    o/options        List options and their current values</span><br><span class="line">    quit/exit/^D     Exit pprof</span><br><span class="line">    </span><br><span class="line">    ....</span><br></pre></td></tr></table></figure>
<p>以上信息我们只关注2个地方：</p>
<ol>
<li>下载得到的文件：<code>/home/ubuntu/pprof/pprof.demo.alloc_objects.alloc_space.inuse_objects.inuse_space.001.pb.gz</code>，这其中包含了程序名<code>demo</code>，profile类型<code>alloc</code>已分配的内存，<code>inuse</code>代表使用中的内存。</li>
<li><code>help</code>可以获取帮助，最先会列出支持的命令，想掌握pprof，要多看看，多尝试。</li>
</ol>
<p>关于命令，本文只会用到3个，我认为也是最常用的：<code>top</code>、<code>list</code>、<code>traces</code>，分别介绍一下。</p>
<h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><p>按指标大小列出前10个函数，比如内存是按内存占用多少，CPU是按执行时间多少。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(pprof) top</span><br><span class="line">Showing nodes accounting <span class="keyword">for</span> <span class="number">814.62</span>MB, <span class="number">100</span>% of <span class="number">814.62</span>MB total</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">  <span class="number">814.62</span>MB   <span class="number">100</span>%   <span class="number">100</span>%   <span class="number">814.62</span>MB   <span class="number">100</span>%  main.main</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%   <span class="number">100</span>%   <span class="number">814.62</span>MB   <span class="number">100</span>%  runtime.main</span><br></pre></td></tr></table></figure>
<p>top会列出5个统计数据：</p>
<ul>
<li>flat: 本函数占用的内存量。</li>
<li>flat%: 本函数内存占使用中内存总量的百分比。</li>
<li>sum%: 前面每一行flat百分比的和，比如第2行虽然的100% 是 100% + 0%。</li>
<li>cum: 是累计量，加入main函数调用了函数f，函数f占用的内存量，也会记进来。</li>
<li>cum%: 是累计量占总量的百分比。</li>
</ul>
<h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>查看某个函数的代码，以及该函数每行代码的指标信息，如果函数名不明确，会进行模糊匹配，比如<code>list main</code>会列出<code>main.main</code>和<code>runtime.main</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">(pprof) list main.main  <span class="comment">// 精确列出函数</span></span><br><span class="line">Total: <span class="number">814.62</span>MB</span><br><span class="line">ROUTINE ======================== main.main in /home/ubuntu/heap/demo2.<span class="keyword">go</span></span><br><span class="line">  <span class="number">814.62</span>MB   <span class="number">814.62</span>MB (flat, cum)   <span class="number">100</span>% of Total</span><br><span class="line">         .          .     <span class="number">20</span>:	&#125;()</span><br><span class="line">         .          .     <span class="number">21</span>:</span><br><span class="line">         .          .     <span class="number">22</span>:	tick := time.Tick(time.Second / <span class="number">100</span>)</span><br><span class="line">         .          .     <span class="number">23</span>:	<span class="keyword">var</span> buf []<span class="keyword">byte</span></span><br><span class="line">         .          .     <span class="number">24</span>:	<span class="keyword">for</span> <span class="keyword">range</span> tick &#123;</span><br><span class="line">  <span class="number">814.62</span>MB   <span class="number">814.62</span>MB     <span class="number">25</span>:		buf = <span class="built_in">append</span>(buf, <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>*<span class="number">1024</span>)...)</span><br><span class="line">         .          .     <span class="number">26</span>:	&#125;</span><br><span class="line">         .          .     <span class="number">27</span>:&#125;</span><br><span class="line">         .          .     <span class="number">28</span>:</span><br><span class="line">(pprof) list main  <span class="comment">// 匹配所有函数名带main的函数</span></span><br><span class="line">Total: <span class="number">814.62</span>MB</span><br><span class="line">ROUTINE ======================== main.main in /home/ubuntu/heap/demo2.<span class="keyword">go</span></span><br><span class="line">  <span class="number">814.62</span>MB   <span class="number">814.62</span>MB (flat, cum)   <span class="number">100</span>% of Total</span><br><span class="line">         .          .     <span class="number">20</span>:	&#125;()</span><br><span class="line">         .          .     <span class="number">21</span>:</span><br><span class="line">..... <span class="comment">// 省略几行</span></span><br><span class="line">         .          .     <span class="number">28</span>:</span><br><span class="line">ROUTINE ======================== runtime.main in /usr/lib/<span class="keyword">go</span><span class="number">-1.10</span>/src/runtime/proc.<span class="keyword">go</span></span><br><span class="line">         <span class="number">0</span>   <span class="number">814.62</span>MB (flat, cum)   <span class="number">100</span>% of Total</span><br><span class="line">         .          .    <span class="number">193</span>:		<span class="comment">// A program compiled with -buildmode=c-archive or c-shared</span></span><br><span class="line">..... <span class="comment">// 省略几行</span></span><br></pre></td></tr></table></figure>
<p>可以看到在<code>main.main</code>中的第25行占用了814.62MB内存，左右2个数据分别是flat和cum，含义和top中解释的一样。</p>
<h4 id="traces"><a href="#traces" class="headerlink" title="traces"></a>traces</h4><p>打印所有调用栈，以及调用栈的指标信息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(pprof) traces</span><br><span class="line">File: demo2</span><br><span class="line">Type: inuse_space</span><br><span class="line">Time: May <span class="number">16</span>, <span class="number">2019</span> at <span class="number">7</span>:<span class="number">08</span>pm (CST)</span><br><span class="line">-----------+-------------------------------------------------------</span><br><span class="line">     bytes:  <span class="number">813.46</span>MB</span><br><span class="line">  <span class="number">813.46</span>MB   main.main</span><br><span class="line">             runtime.main</span><br><span class="line">-----------+-------------------------------------------------------</span><br><span class="line">     bytes:  <span class="number">650.77</span>MB</span><br><span class="line">         <span class="number">0</span>   main.main</span><br><span class="line">             runtime.main</span><br><span class="line">....... <span class="comment">// 省略几十行</span></span><br></pre></td></tr></table></figure>
<p>每个<code>- - - - -</code> 隔开的是一个调用栈，能看到<code>runtime.main</code>调用了<code>main.main</code>，并且<code>main.main</code>中占用了813.46MB内存。</p>
<p>其他的profile操作和内存是类似的，这里就不展示了。</p>
<p>这里只是简单介绍本文用到的pprof的功能，pprof功能很强大，也经常和benchmark结合起来，但这不是本文的重点，所以就不多介绍了，为大家推荐几篇文章，一定要好好研读、实践：</p>
<ol>
<li>Go官方博客关于pprof的介绍，很详细，也包含样例，可以实操：<a href="https://blog.golang.org/profiling-go-programs" target="_blank" rel="noopener">Profiling Go Programs</a>。</li>
<li>跟煎鱼也讨论过pprof，煎鱼的这篇文章也很适合入门： <a href="https://github.com/EDDYCJY/blog/blob/master/golang/2018-09-15-Golang%20%E5%A4%A7%E6%9D%80%E5%99%A8%E4%B9%8B%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90%20PProf.md" target="_blank" rel="noopener">Golang 大杀器之性能剖析 PProf</a>。</li>
</ol>
<hr>
<h1 id="什么是内存泄露"><a href="#什么是内存泄露" class="headerlink" title="什么是内存泄露"></a>什么是内存泄露</h1><p>内存泄露指的是程序运行过程中已不再使用的内存，没有被释放掉，导致这些内存无法被使用，直到程序结束这些内存才被释放的问题。</p>
<p>Go虽然有GC来回收不再使用的堆内存，减轻了开发人员对内存的管理负担，但这并不意味着Go程序不再有内存泄露问题。在Go程序中，如果没有Go语言的编程思维，也不遵守良好的编程实践，就可能埋下隐患，造成内存泄露问题。</p>
<h1 id="怎么发现内存泄露"><a href="#怎么发现内存泄露" class="headerlink" title="怎么发现内存泄露"></a>怎么发现内存泄露</h1><p>在Go中发现内存泄露有2种方法，一个是通用的监控工具，另一个是go pprof：</p>
<ol>
<li><strong>监控工具</strong>：固定周期对进程的内存占用情况进行采样，数据可视化后，根据内存占用走势（持续上升），很容易发现是否发生内存泄露。</li>
<li><strong>go pprof</strong>：适合没有监控工具的情况，使用Go提供的pprof工具判断是否发生内存泄露。</li>
</ol>
<p>这2种方式分别介绍一下。</p>
<h2 id="监控工具查看进程内在占用情况"><a href="#监控工具查看进程内在占用情况" class="headerlink" title="监控工具查看进程内在占用情况"></a>监控工具查看进程内在占用情况</h2><p><strong>如果使用云平台部署Go程序</strong>，云平台都提供了内存查看的工具，可以查看OS的内存占用情况和某个进程的内存占用情况，比如阿里云，我们在1个云主机上只部署了1个Go服务，所以OS的内存占用情况，基本是也反映了进程内存占用情况，OS内存占用情况如下，可以看到<strong>随着时间的推进，内存的占用率在不断的提高，这是内存泄露的最明显现象</strong>：</p>
<p><img src="http://img.lessisbetter.site/2019-05-image-20190512111200988-7630721.png" alt="image-20190512111200988"></p>
<p><strong>如果没有云平台这种内存监控工具，可以制作一个简单的内存记录工具。</strong></p>
<p>1、建立一个脚本<code>prog_mem.sh</code>，获取进程占用的物理内存情况，脚本内容如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">prog_name=<span class="string">"your_programe_name"</span></span><br><span class="line">prog_mem=$(pidstat  -r -u -h -C <span class="variable">$prog_name</span> |awk <span class="string">'NR==4&#123;print $12&#125;'</span>)</span><br><span class="line">time=$(date <span class="string">"+%Y-%m-%d %H:%M:%S"</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$time</span><span class="string">"\tmemory(Byte)\t"</span><span class="variable">$prog_mem</span> &gt;&gt;~/record/prog_mem.log</span><br></pre></td></tr></table></figure>
<p>2、然后使用<code>crontab</code>建立定时任务，每分钟记录1次。使用<code>crontab -e</code>编辑crontab配置，在最后增加1行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*/1 * * * * ~/record/prog_mem.sh</span><br></pre></td></tr></table></figure>
<p>脚本输出的内容保存在<code>prog_mem.log</code>，只要大体浏览一下就可以发现内存的增长情况，判断是否存在内存泄露。如果需要可视化，可以直接黏贴<code>prog_mem.log</code>内容到Excel等表格工具，绘制内存占用图。</p>
<p><img src="http://img.lessisbetter.site/2019-05-image-20190512172935195-7653375.png" alt="image-20190512172935195"></p>
<h2 id="go-pprof发现存在内存问题"><a href="#go-pprof发现存在内存问题" class="headerlink" title="go pprof发现存在内存问题"></a>go pprof发现存在内存问题</h2><blockquote>
<p>有情提醒：如果对pprof不了解，可以先看<a href="#go pprof基本知识">go pprof基本知识</a>，这是下一节，看完再倒回来看。</p>
</blockquote>
<p>如果你Google或者百度，Go程序内存泄露的文章，它总会告诉你使用<strong>pprof heap</strong>，能够生成漂亮的调用路径图，火焰图等等，然后你根据调用路径就能定位内存泄露问题，我最初也是对此深信不疑，尝试了若干天后，只是发现内存泄露跟某种场景有关，根本找不到内存泄露的根源，<strong>如果哪位朋友用heap就能定位内存泄露的线上问题，麻烦介绍下</strong>。</p>
<p>后来读了Dave的<a href="https://dave.cheney.net/high-performance-go-workshop/dotgo-paris.html#using_more_than_one_cpu" target="_blank" rel="noopener">《High Performance Go Workshop》</a>，刷新了对heap的认识，内存pprof的简要内容如下：</p>
<p><img src="http://img.lessisbetter.site/2019-05-image-20190512114048868-7632448.png" alt="image-20190512114048868"></p>
<p>Dave讲了以下几点：</p>
<ol>
<li><strong>内存profiling记录的是堆内存分配的情况，以及调用栈信息</strong>，并不是进程完整的内存情况，猜测这也是在go pprof中称为heap而不是memory的原因。</li>
<li><strong>栈内存的分配是在调用栈结束后会被释放的内存，所以并不在内存profile中</strong>。</li>
<li>内存profiling是基于抽样的，默认是每1000次堆内存分配，执行1次profile记录。</li>
<li>因为内存profiling是基于抽样和它跟踪的是已分配的内存，而不是使用中的内存，（比如有些内存已经分配，看似使用，但实际以及不使用的内存，比如内存泄露的那部分），所以<strong>不能使用内存profiling衡量程序总体的内存使用情况</strong>。</li>
<li><strong>Dave个人观点：使用内存profiling不能够发现内存泄露</strong>。</li>
</ol>
<p>基于目前对heap的认知，我有2个观点：</p>
<ol>
<li><strong>heap能帮助我们发现内存问题，但不一定能发现内存泄露问题</strong>，这个看法与Dave是类似的。heap记录了内存分配的情况，我们能通过heap观察内存的变化，增长与减少，内存主要被哪些代码占用了，程序存在内存问题，这只能说明内存有使用不合理的地方，但并不能说明这是内存泄露。</li>
<li><strong>heap在帮助定位内存泄露原因上贡献的力量微乎其微</strong>。如第一条所言，能通过heap找到占用内存多的位置，但这个位置通常不一定是内存泄露，就算是内存泄露，也只是内存泄露的结果，并不是真正导致内存泄露的根源。</li>
</ol>
<p>接下来，我介绍怎么用heap发现问题，然后再解释为什么heap几乎不能定位内存泄露的根因。</p>
<h3 id="怎么用heap发现内存问题"><a href="#怎么用heap发现内存问题" class="headerlink" title="怎么用heap发现内存问题"></a>怎么用heap发现内存问题</h3><p>使用pprof的heap能够获取程序运行时的内存信息，在程序平稳运行的情况下，每个一段时间使用heap获取内存的profile，<strong>然后使用<code>base</code>能够对比两个profile文件的差别，就像<code>diff</code>命令一样显示出增加和减少的变化</strong>，使用一个简单的demo来说明heap和base的使用，依然使用demo2进行展示。</p>
<p><em>文件：<a href="https://github.com/Shitaibin/golang_step_by_step/blob/master/pprof/heap/demo2.go" target="_blank" rel="noopener">golang_step_by_step/pprof/heap/demo2.go</a></em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 展示内存增长和pprof，并不是泄露</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	_ <span class="string">"net/http/pprof"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行一段时间：fatal error: runtime: out of memory</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 开启pprof</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		ip := <span class="string">"0.0.0.0:6060"</span></span><br><span class="line">		<span class="keyword">if</span> err := http.ListenAndServe(ip, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"start pprof failed on %s\n"</span>, ip)</span><br><span class="line">			os.Exit(<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	tick := time.Tick(time.Second / <span class="number">100</span>)</span><br><span class="line">	<span class="keyword">var</span> buf []<span class="keyword">byte</span></span><br><span class="line">	<span class="keyword">for</span> <span class="keyword">range</span> tick &#123;</span><br><span class="line">		buf = <span class="built_in">append</span>(buf, <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>*<span class="number">1024</span>)...)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将上面代码运行起来，执行以下命令获取profile文件，Ctrl-D退出，1分钟后再获取1次。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool pprof http://localhost:6060/debug/pprof/heap</span><br></pre></td></tr></table></figure>
<p>我已经获取到了两个profile文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">pprof.demo2.alloc_objects.alloc_space.inuse_objects.inuse_space.001.pb.gz</span><br><span class="line">pprof.demo2.alloc_objects.alloc_space.inuse_objects.inuse_space.002.pb.gz</span><br></pre></td></tr></table></figure>
<p>使用<code>base</code>把001文件作为基准，然后用002和001对比，先执行<code>top</code>看<code>top</code>的对比，然后执行<code>list main</code>列出<code>main</code>函数的内存对比，结果如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> tool pprof -base pprof.demo2.alloc_objects.alloc_space.inuse_objects.inuse_space<span class="number">.001</span>.pb.gz pprof.demo2.alloc_objects.alloc_space.inuse_objects.inuse_space<span class="number">.002</span>.pb.gz</span><br><span class="line"></span><br><span class="line">File: demo2</span><br><span class="line">Type: inuse_space</span><br><span class="line">Time: May <span class="number">14</span>, <span class="number">2019</span> at <span class="number">2</span>:<span class="number">33</span>pm (CST)</span><br><span class="line">Entering interactive mode (<span class="keyword">type</span> <span class="string">"help"</span> <span class="keyword">for</span> commands, <span class="string">"o"</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof)</span><br><span class="line">(pprof)</span><br><span class="line">(pprof) top</span><br><span class="line">Showing nodes accounting <span class="keyword">for</span> <span class="number">970.34</span>MB, <span class="number">32.30</span>% of <span class="number">3003.99</span>MB total</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">  <span class="number">970.34</span>MB <span class="number">32.30</span>% <span class="number">32.30</span>%   <span class="number">970.34</span>MB <span class="number">32.30</span>%  main.main   <span class="comment">// 看这</span></span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>% <span class="number">32.30</span>%   <span class="number">970.34</span>MB <span class="number">32.30</span>%  runtime.main</span><br><span class="line">(pprof)</span><br><span class="line">(pprof)</span><br><span class="line">(pprof) list main.main</span><br><span class="line">Total: <span class="number">2.93</span>GB</span><br><span class="line">ROUTINE ======================== main.main in /home/ubuntu/heap/demo2.<span class="keyword">go</span></span><br><span class="line">  <span class="number">970.34</span>MB   <span class="number">970.34</span>MB (flat, cum) <span class="number">32.30</span>% of Total</span><br><span class="line">         .          .     <span class="number">20</span>:	&#125;()</span><br><span class="line">         .          .     <span class="number">21</span>:</span><br><span class="line">         .          .     <span class="number">22</span>:	tick := time.Tick(time.Second / <span class="number">100</span>)</span><br><span class="line">         .          .     <span class="number">23</span>:	<span class="keyword">var</span> buf []<span class="keyword">byte</span></span><br><span class="line">         .          .     <span class="number">24</span>:	<span class="keyword">for</span> <span class="keyword">range</span> tick &#123;</span><br><span class="line">  <span class="number">970.34</span>MB   <span class="number">970.34</span>MB     <span class="number">25</span>:		buf = <span class="built_in">append</span>(buf, <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>*<span class="number">1024</span>)...) <span class="comment">// 看这</span></span><br><span class="line">         .          .     <span class="number">26</span>:	&#125;</span><br><span class="line">         .          .     <span class="number">27</span>:&#125;</span><br><span class="line">         .          .     <span class="number">28</span>:</span><br></pre></td></tr></table></figure>
<p><code>top</code>列出了<code>main.main</code>和<code>runtime.main</code>，<code>main.main</code>就是我们编写的main函数，<code>runtime.main</code>是runtime包中的main函数，也就是所有main函数的入口，这里不多介绍了，有兴趣可以看之前的调度器文章<a href="http://lessisbetter.site/2019/03/26/golang-scheduler-2-macro-view/">《Go调度器系列（2）宏观看调度器》</a>。</p>
<p><code>top</code>显示<code>main.main</code> 第2次内存占用，比第1次内存占用多了970.34MB。</p>
<p><code>list main.main</code>告诉了我们增长的内存都在这一行：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf = <span class="built_in">append</span>(buf, <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>*<span class="number">1024</span>)...)</span><br></pre></td></tr></table></figure>
<p>001和002 profile的文件不进去看了，你本地测试下计算差值，绝对是刚才对比出的970.34MB。</p>
<h3 id="heap“不能”定位内存泄露"><a href="#heap“不能”定位内存泄露" class="headerlink" title="heap“不能”定位内存泄露"></a>heap“不能”定位内存泄露</h3><p>heap能显示内存的分配情况，以及哪行代码占用了多少内存，我们能轻易的找到占用内存最多的地方，如果这个地方的数值还在不断怎大，基本可以认定这里就是内存泄露的位置。</p>
<p>曾想按图索骥，从内存泄露的位置，根据调用栈向上查找，总能找到内存泄露的原因，这种方案看起来是不错的，但实施起来却找不到内存泄露的原因，结果是事半功倍。</p>
<p>原因在于一个Go程序，其中有大量的goroutine，这其中的调用关系也许有点复杂，也许内存泄露是在某个三方包里。举个栗子，比如下面这幅图，每个椭圆代表1个goroutine，其中的数字为编号，箭头代表调用关系。heap profile显示g111（最下方标红节点）这个协程的代码出现了泄露，任何一个从g101到g111的调用路径都可能造成了g111的内存泄露，有2类可能：</p>
<ol>
<li>该goroutine只调用了少数几次，但消耗了大量的内存，说明每个goroutine调用都消耗了不少内存，<strong>内存泄露的原因基本就在该协程内部</strong>。</li>
<li>该goroutine的调用次数非常多，虽然每个协程调用过程中消耗的内存不多，但该调用路径上，协程数量巨大，造成消耗大量的内存，并且这些goroutine由于某种原因无法退出，占用的内存不会释放，<strong>内存泄露的原因在到g111调用路径上某段代码实现有问题，造成创建了大量的g111</strong>。</li>
</ol>
<p><strong>第2种情况，就是goroutine泄露，这是通过heap无法发现的，所以heap在定位内存泄露这件事上，发挥的作用不大</strong>。</p>
<p><img src="http://img.lessisbetter.site/2019-05-image-20190512144150064-7643310.png" alt="image-20190512144150064"></p>
<hr>
<h1 id="goroutine泄露怎么导致内存泄露"><a href="#goroutine泄露怎么导致内存泄露" class="headerlink" title="goroutine泄露怎么导致内存泄露"></a>goroutine泄露怎么导致内存泄露</h1><h2 id="什么是goroutine泄露"><a href="#什么是goroutine泄露" class="headerlink" title="什么是goroutine泄露"></a>什么是goroutine泄露</h2><p>如果你启动了1个goroutine，但并没有符合预期的退出，直到程序结束，此goroutine才退出，这种情况就是goroutine泄露。</p>
<blockquote>
<p>提前思考：什么会导致goroutine无法退出/阻塞？</p>
</blockquote>
<h2 id="goroutine泄露怎么导致内存泄露-1"><a href="#goroutine泄露怎么导致内存泄露-1" class="headerlink" title="goroutine泄露怎么导致内存泄露"></a>goroutine泄露怎么导致内存泄露</h2><p>每个goroutine占用2KB内存，泄露1百万goroutine至少泄露<code>2KB * 1000000 = 2GB</code>内存，为什么说至少呢？</p>
<p>goroutine执行过程中还存在一些变量，如果这些变量指向堆内存中的内存，GC会认为这些内存仍在使用，不会对其进行回收，这些内存谁都无法使用，造成了内存泄露。</p>
<p>所以goroutine泄露有2种方式造成内存泄露：</p>
<ol>
<li>goroutine本身的栈所占用的空间造成内存泄露。</li>
<li>goroutine中的变量所占用的堆内存导致堆内存泄露，这一部分是能通过heap profile体现出来的。</li>
</ol>
<p>Dave在文章中也提到了，如果不知道何时停止一个goroutine，这个goroutine就是潜在的内存泄露：</p>
<blockquote>
<p><a href="https://dave.cheney.net/high-performance-go-workshop/dotgo-paris.html#know_when_to_stop_a_goroutine" target="_blank" rel="noopener">7.1.1 Know when to stop a goroutine</a></p>
<p>If you don’t know the answer, that’s a potential memory leak as the goroutine will pin its stack’s memory on the heap, as well as any heap allocated variables reachable from the stack.</p>
</blockquote>
<h2 id="怎么确定是goroutine泄露引发的内存泄露"><a href="#怎么确定是goroutine泄露引发的内存泄露" class="headerlink" title="怎么确定是goroutine泄露引发的内存泄露"></a>怎么确定是goroutine泄露引发的内存泄露</h2><p>掌握了前面的pprof命令行的基本用法，很快就可以确认是否是goroutine泄露导致内存泄露，如果你不记得了，马上回去看一下<a href="#go pprof基本知识">go pprof基本知识</a>。</p>
<p><strong>判断依据：在节点正常运行的情况下，隔一段时间获取goroutine的数量，如果后面获取的那次，某些goroutine比前一次多，如果多获取几次，是持续增长的，就极有可能是goroutine泄露</strong>。</p>
<p>goroutine导致内存泄露的demo：</p>
<p><em>文件：<a href="https://github.com/Shitaibin/golang_step_by_step/blob/master/pprof/goroutine/leak_demo1.go" target="_blank" rel="noopener">golang_step_by_step/pprof/goroutine/leak_demo1.go</a></em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// goroutine泄露导致内存泄露</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	_ <span class="string">"net/http/pprof"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 开启pprof</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		ip := <span class="string">"0.0.0.0:6060"</span></span><br><span class="line">		<span class="keyword">if</span> err := http.ListenAndServe(ip, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"start pprof failed on %s\n"</span>, ip)</span><br><span class="line">			os.Exit(<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	outCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="comment">// 死代码，永不读取</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="literal">false</span> &#123;</span><br><span class="line">			&lt;-outCh</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">select</span> &#123;&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 每s起100个goroutine，goroutine会阻塞，不释放内存</span></span><br><span class="line">	tick := time.Tick(time.Second / <span class="number">100</span>)</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> <span class="keyword">range</span> tick &#123;</span><br><span class="line">		i++</span><br><span class="line">		fmt.Println(i)</span><br><span class="line">		alloc1(outCh)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">alloc1</span><span class="params">(outCh <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> alloc2(outCh)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">alloc2</span><span class="params">(outCh <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> fmt.Println(<span class="string">"alloc-fm exit"</span>)</span><br><span class="line">		<span class="comment">// 分配内存，假用一下</span></span><br><span class="line">		buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>*<span class="number">1024</span>*<span class="number">10</span>)</span><br><span class="line">		_ = <span class="built_in">len</span>(buf)</span><br><span class="line">		fmt.Println(<span class="string">"alloc done"</span>)</span><br><span class="line"></span><br><span class="line">		outCh &lt;- <span class="number">0</span> <span class="comment">// 53行</span></span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译并运行以上代码，然后使用<code>go tool pprof</code>获取gorourine的profile文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool pprof http://localhost:6060/debug/pprof/goroutine</span><br></pre></td></tr></table></figure>
<p>已经通过pprof命令获取了2个goroutine的profile文件:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">/home/ubuntu/pprof/pprof.leak_demo.goroutine.001.pb.gz</span><br><span class="line">/home/ubuntu/pprof/pprof.leak_demo.goroutine.002.pb.gz</span><br></pre></td></tr></table></figure>
<p>同heap一样，我们可以使用<code>base</code>对比2个goroutine profile文件：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$<span class="keyword">go</span> tool pprof -base pprof.leak_demo.goroutine<span class="number">.001</span>.pb.gz pprof.leak_demo.goroutine<span class="number">.002</span>.pb.gz</span><br><span class="line"></span><br><span class="line">File: leak_demo</span><br><span class="line">Type: goroutine</span><br><span class="line">Time: May <span class="number">16</span>, <span class="number">2019</span> at <span class="number">2</span>:<span class="number">44</span>pm (CST)</span><br><span class="line">Entering interactive mode (<span class="keyword">type</span> <span class="string">"help"</span> <span class="keyword">for</span> commands, <span class="string">"o"</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof)</span><br><span class="line">(pprof) top</span><br><span class="line">Showing nodes accounting <span class="keyword">for</span> <span class="number">20312</span>, <span class="number">100</span>% of <span class="number">20312</span> total</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">     <span class="number">20312</span>   <span class="number">100</span>%   <span class="number">100</span>%      <span class="number">20312</span>   <span class="number">100</span>%  runtime.gopark</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%   <span class="number">100</span>%      <span class="number">20312</span>   <span class="number">100</span>%  main.alloc2</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%   <span class="number">100</span>%      <span class="number">20312</span>   <span class="number">100</span>%  main.alloc2.func1</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%   <span class="number">100</span>%      <span class="number">20312</span>   <span class="number">100</span>%  runtime.chansend</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%   <span class="number">100</span>%      <span class="number">20312</span>   <span class="number">100</span>%  runtime.chansend1</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%   <span class="number">100</span>%      <span class="number">20312</span>   <span class="number">100</span>%  runtime.goparkunlock</span><br><span class="line">(pprof)</span><br></pre></td></tr></table></figure>
<p>可以看到运行到<code>runtime.gopark</code>的goroutine数量增加了20312个。再通过002文件，看一眼执行到<code>gopark</code>的goroutine数量，即挂起的goroutine数量：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> tool pprof pprof.leak_demo.goroutine<span class="number">.002</span>.pb.gz</span><br><span class="line">File: leak_demo</span><br><span class="line">Type: goroutine</span><br><span class="line">Time: May <span class="number">16</span>, <span class="number">2019</span> at <span class="number">2</span>:<span class="number">47</span>pm (CST)</span><br><span class="line">Entering interactive mode (<span class="keyword">type</span> <span class="string">"help"</span> <span class="keyword">for</span> commands, <span class="string">"o"</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof) top</span><br><span class="line">Showing nodes accounting <span class="keyword">for</span> <span class="number">24330</span>, <span class="number">100</span>% of <span class="number">24331</span> total</span><br><span class="line">Dropped <span class="number">32</span> nodes (cum &lt;= <span class="number">121</span>)</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">     <span class="number">24330</span>   <span class="number">100</span>%   <span class="number">100</span>%      <span class="number">24330</span>   <span class="number">100</span>%  runtime.gopark</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%   <span class="number">100</span>%      <span class="number">24326</span>   <span class="number">100</span>%  main.alloc2</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%   <span class="number">100</span>%      <span class="number">24326</span>   <span class="number">100</span>%  main.alloc2.func1</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%   <span class="number">100</span>%      <span class="number">24326</span>   <span class="number">100</span>%  runtime.chansend</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%   <span class="number">100</span>%      <span class="number">24326</span>   <span class="number">100</span>%  runtime.chansend1</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%   <span class="number">100</span>%      <span class="number">24327</span>   <span class="number">100</span>%  runtime.goparkunlock</span><br></pre></td></tr></table></figure>
<p>显示有24330个goroutine被挂起，这不是goroutine泄露这是啥？已经能确定八九成goroutine泄露了。</p>
<p>是什么导致如此多的goroutine被挂起而无法退出？接下来就看怎么定位goroutine泄露。</p>
<hr>
<h1 id="定位goroutine泄露的2种方法"><a href="#定位goroutine泄露的2种方法" class="headerlink" title="定位goroutine泄露的2种方法"></a>定位goroutine泄露的2种方法</h1><p>使用pprof有2种方式，一种是web网页，一种是<code>go tool pprof</code>命令行交互，这两种方法查看goroutine都支持，但有轻微不同，也有各自的优缺点。</p>
<p>我们先看Web的方式，再看命令行交互的方式，这两种都很好使用，结合起来用也不错。</p>
<h2 id="Web可视化查看"><a href="#Web可视化查看" class="headerlink" title="Web可视化查看"></a>Web可视化查看</h2><p>Web方式适合web服务器的端口能访问的情况，使用起来方便，有2种方式：</p>
<ol>
<li><strong>查看某条调用路径上，当前阻塞在此goroutine的数量</strong></li>
<li>查看所有goroutine的运行栈（调用路径），可以<strong>显示阻塞在此的时间</strong></li>
</ol>
<h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><p>url请求中设置debug=1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://ip:port/debug/pprof/goroutine?debug=1</span><br></pre></td></tr></table></figure></p>
<p>效果如下：</p>
<p><img src="http://img.lessisbetter.site/2019-05-image-20190516143740567-7988660.png" alt=""></p>
<p>看起来密密麻麻的，其实简单又十分有用，看上图标出来的部分，手机上图看起来可能不方便，那就放大图片，或直接看下面各字段的含义：</p>
<ol>
<li><code>goroutine profile: total 32023</code>：32023是<strong>goroutine的总数量</strong>，</li>
<li><code>32015 @ 0x42e15a 0x42e20e 0x40534b 0x4050e5 ...</code>：32015代表当前有32015个goroutine运行这个调用栈，并且停在相同位置，@后面的十六进制，现在用不到这个数据，所以暂不深究了。</li>
<li>下面是当前goroutine的<strong>调用栈</strong>，列出了<strong>函数和所在文件的行数，这个行数对定位很有帮助</strong>，如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">32015 @ 0x42e15a 0x42e20e 0x40534b 0x4050e5 0x6d8559 0x6d831b 0x45abe1</span><br><span class="line">#	0x6d8558	main.alloc2.func1+0xf8	/home/ubuntu/heap/leak_demo.go:53</span><br><span class="line">#	0x6d831a	main.alloc2+0x2a	/home/ubuntu/heap/leak_demo.go:54</span><br></pre></td></tr></table></figure>
<p>根据上面的提示，就能判断32015个goroutine运行到<code>leak_demo.go</code>的53行：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">alloc2</span><span class="params">(outCh <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> fmt.Println(<span class="string">"alloc-fm exit"</span>)</span><br><span class="line">		<span class="comment">// 分配内存，假用一下</span></span><br><span class="line">		buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>*<span class="number">1024</span>*<span class="number">10</span>)</span><br><span class="line">		_ = <span class="built_in">len</span>(buf)</span><br><span class="line">		fmt.Println(<span class="string">"alloc done"</span>)</span><br><span class="line"></span><br><span class="line">		outCh &lt;- <span class="number">0</span> <span class="comment">// 53行</span></span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>阻塞的原因是outCh这个写操作无法完成，outCh是无缓冲的通道，并且由于以下代码是死代码，所以goroutine始终没有从outCh读数据，造成outCh阻塞，进而造成无数个alloc2的goroutine阻塞，形成内存泄露：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">false</span> &#123;</span><br><span class="line">    &lt;-outCh</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><p>url请求中设置debug=2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://ip:port/debug/pprof/goroutine?debug=2</span><br></pre></td></tr></table></figure>
<p><img src="http://img.lessisbetter.site/2019-05-image-20190516143537339-7988537.png" alt=""></p>
<p>第2种方式和第1种方式是互补的，它可以看到每个goroutine的信息：</p>
<ol>
<li><code>goroutine 20 [chan send, 2 minutes]</code>：20是goroutine id，<code>[]</code>中是当前goroutine的状态，阻塞在写channel，并且阻塞了2分钟，长时间运行的系统，你能看到阻塞时间更长的情况。</li>
<li>同时，也可以看到调用栈，看当前执行停到哪了：<code>leak_demo.go</code>的53行，</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">goroutine <span class="number">20</span> [<span class="keyword">chan</span> send, <span class="number">2</span> minutes]:</span><br><span class="line">main.alloc2.func1(<span class="number">0xc42015e060</span>)</span><br><span class="line">	/home/ubuntu/heap/leak_demo.<span class="keyword">go</span>:<span class="number">53</span> +<span class="number">0xf9</span>  <span class="comment">// 这</span></span><br><span class="line">main.alloc2(<span class="number">0xc42015e060</span>)</span><br><span class="line">	/home/ubuntu/heap/leak_demo.<span class="keyword">go</span>:<span class="number">54</span> +<span class="number">0x2b</span></span><br><span class="line">created by main.alloc1</span><br><span class="line">	/home/ubuntu/heap/leak_demo.<span class="keyword">go</span>:<span class="number">42</span> +<span class="number">0x3f</span></span><br></pre></td></tr></table></figure>
<h2 id="命令行交互式方法"><a href="#命令行交互式方法" class="headerlink" title="命令行交互式方法"></a>命令行交互式方法</h2><p>Web的方法是简单粗暴，无需登录服务器，浏览器打开看看就行了。但就像前面提的，没有浏览器可访问时，命令行交互式才是最佳的方式，并且也是手到擒来，感觉比Web一样方便。</p>
<p>命令行交互式只有1种获取goroutine profile的方法，不像Web网页分<code>debug=1</code>和<code>debug=2</code>2中方式，并将profile文件保存到本地：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意命令没有`debug=1`，debug=1，加debug有些版本的go不支持</span></span><br><span class="line">$ <span class="keyword">go</span> tool pprof http:<span class="comment">//0.0.0.0:6060/debug/pprof/goroutine</span></span><br><span class="line">Fetching profile over HTTP from http:<span class="comment">//localhost:6061/debug/pprof/goroutine</span></span><br><span class="line">Saved profile in /home/ubuntu/pprof/pprof.leak_demo.goroutine<span class="number">.001</span>.pb.gz  <span class="comment">// profile文件保存位置</span></span><br><span class="line">File: leak_demo</span><br><span class="line">Type: goroutine</span><br><span class="line">Time: May <span class="number">16</span>, <span class="number">2019</span> at <span class="number">2</span>:<span class="number">44</span>pm (CST)</span><br><span class="line">Entering interactive mode (<span class="keyword">type</span> <span class="string">"help"</span> <span class="keyword">for</span> commands, <span class="string">"o"</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof)</span><br></pre></td></tr></table></figure>
<p>命令行只需要掌握3个命令就好了，上面介绍过了，详细的倒回去看<a href="#top">top</a>, <a href="#list">list</a>, <a href="#traces">traces</a>：</p>
<ol>
<li><strong>top</strong>：显示正运行到某个函数goroutine的数量</li>
<li><strong>traces</strong>：显示所有goroutine的调用栈</li>
<li><strong>list</strong>：列出代码详细的信息。</li>
</ol>
<p>我们依然使用<code>leak_demo.go</code>这个demo，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$  <span class="keyword">go</span> tool pprof -base pprof.leak_demo.goroutine<span class="number">.001</span>.pb.gz pprof.leak_demo.goroutine<span class="number">.002</span>.pb.gz</span><br><span class="line">File: leak_demo</span><br><span class="line">Type: goroutine</span><br><span class="line">Time: May <span class="number">16</span>, <span class="number">2019</span> at <span class="number">2</span>:<span class="number">44</span>pm (CST)</span><br><span class="line">Entering interactive mode (<span class="keyword">type</span> <span class="string">"help"</span> <span class="keyword">for</span> commands, <span class="string">"o"</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof)</span><br><span class="line">(pprof)</span><br><span class="line">(pprof) top</span><br><span class="line">Showing nodes accounting <span class="keyword">for</span> <span class="number">20312</span>, <span class="number">100</span>% of <span class="number">20312</span> total</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">     <span class="number">20312</span>   <span class="number">100</span>%   <span class="number">100</span>%      <span class="number">20312</span>   <span class="number">100</span>%  runtime.gopark</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%   <span class="number">100</span>%      <span class="number">20312</span>   <span class="number">100</span>%  main.alloc2</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%   <span class="number">100</span>%      <span class="number">20312</span>   <span class="number">100</span>%  main.alloc2.func1</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%   <span class="number">100</span>%      <span class="number">20312</span>   <span class="number">100</span>%  runtime.chansend</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%   <span class="number">100</span>%      <span class="number">20312</span>   <span class="number">100</span>%  runtime.chansend1</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%   <span class="number">100</span>%      <span class="number">20312</span>   <span class="number">100</span>%  runtime.goparkunlock</span><br><span class="line">(pprof)</span><br><span class="line">(pprof) traces</span><br><span class="line">File: leak_demo</span><br><span class="line">Type: goroutine</span><br><span class="line">Time: May <span class="number">16</span>, <span class="number">2019</span> at <span class="number">2</span>:<span class="number">44</span>pm (CST)</span><br><span class="line">-----------+-------------------------------------------------------</span><br><span class="line">     <span class="number">20312</span>   runtime.gopark</span><br><span class="line">             runtime.goparkunlock</span><br><span class="line">             runtime.chansend</span><br><span class="line">             runtime.chansend1 <span class="comment">// channel发送</span></span><br><span class="line">             main.alloc2.func1 <span class="comment">// alloc2中的匿名函数</span></span><br><span class="line">             main.alloc2</span><br><span class="line">-----------+-------------------------------------------------------</span><br></pre></td></tr></table></figure>
<p>top命令在<a href="#怎么确定是goroutine泄露引发的内存泄露">怎么确定是goroutine泄露引发的内存泄露</a>介绍过了，直接看traces命令，traces能列出002中比001中多的那些goroutine的调用栈，这里只有1个调用栈，有20312个goroutine都执行这个调用路径，可以看到alloc2中的匿名函数<code>alloc2.func1</code>调用了写channel的操作，然后阻塞挂起了goroutine，使用list列出<code>alloc2.func1</code>的代码，显示有20312个goroutine阻塞在53行：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(pprof) list main.alloc2.func1</span><br><span class="line">Total: <span class="number">20312</span></span><br><span class="line">ROUTINE ======================== main.alloc2.func1 in /home/ubuntu/heap/leak_demo.<span class="keyword">go</span></span><br><span class="line">         <span class="number">0</span>      <span class="number">20312</span> (flat, cum)   <span class="number">100</span>% of Total</span><br><span class="line">         .          .     <span class="number">48</span>:		<span class="comment">// 分配内存，假用一下</span></span><br><span class="line">         .          .     <span class="number">49</span>:		buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>*<span class="number">1024</span>*<span class="number">10</span>)</span><br><span class="line">         .          .     <span class="number">50</span>:		_ = <span class="built_in">len</span>(buf)</span><br><span class="line">         .          .     <span class="number">51</span>:		fmt.Println(<span class="string">"alloc done"</span>)</span><br><span class="line">         .          .     <span class="number">52</span>:</span><br><span class="line">         .      <span class="number">20312</span>     <span class="number">53</span>:		outCh &lt;- <span class="number">0</span>  <span class="comment">// 看这</span></span><br><span class="line">         .          .     <span class="number">54</span>:	&#125;()</span><br><span class="line">         .          .     <span class="number">55</span>:&#125;</span><br><span class="line">         .          .     <span class="number">56</span>:</span><br></pre></td></tr></table></figure>
<p><strong>友情提醒：使用list命令的前提是程序的源码在当前机器，不然可没法列出源码。</strong>服务器上，通常没有源码，那我们咋办呢？刚才介绍了Web查看的方式，那里会列出代码行数，我们可以使用<code>wget</code>下载网页：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget http://localhost:6060/debug/pprof/goroutine?debug=1</span><br></pre></td></tr></table></figure>
<p>下载网页后，使用编辑器打开文件，使用关键字<code>main.alloc2.func1</code>进行搜索，找到与当前相同的调用栈，就可以看到该goroutine阻塞在哪一行了，不要忘记使用<code>debug=2</code>还可以看到阻塞了多久和原因，Web方式中已经介绍了，此处省略代码几十行。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>文章略长，但全是干货，感谢阅读到这。然读到着了，跟定很想掌握pprof，建议实践一把，现在和大家温习一把本文的主要内容。</p>
<h2 id="goroutine泄露的本质"><a href="#goroutine泄露的本质" class="headerlink" title="goroutine泄露的本质"></a>goroutine泄露的本质</h2><p>goroutine泄露的本质是channel阻塞，无法继续向下执行，导致此goroutine关联的内存都无法释放，进一步造成内存泄露。</p>
<h2 id="goroutine泄露的发现和定位"><a href="#goroutine泄露的发现和定位" class="headerlink" title="goroutine泄露的发现和定位"></a>goroutine泄露的发现和定位</h2><p>利用好go pprof获取goroutine profile文件，然后利用3个命令top、traces、list定位内存泄露的原因。</p>
<h2 id="goroutine泄露的场景"><a href="#goroutine泄露的场景" class="headerlink" title="goroutine泄露的场景"></a>goroutine泄露的场景</h2><p>泄露的场景不仅限于以下两类，但因channel相关的泄露是最多的。</p>
<ol>
<li>channel的读或者写：<ol>
<li>无缓冲channel的阻塞通常是写操作因为没有读而阻塞</li>
<li>有缓冲的channel因为缓冲区满了，写操作阻塞</li>
<li>期待从channel读数据，结果没有goroutine写</li>
</ol>
</li>
<li>select操作，select里也是channel操作，如果所有case上的操作阻塞，goroutine也无法继续执行。</li>
</ol>
<h2 id="编码goroutine泄露的建议"><a href="#编码goroutine泄露的建议" class="headerlink" title="编码goroutine泄露的建议"></a>编码goroutine泄露的建议</h2><p>为避免goroutine泄露造成内存泄露，启动goroutine前要思考清楚：</p>
<ol>
<li>goroutine如何退出？</li>
<li>是否会有阻塞造成无法退出？如果有，那么这个路径是否会创建大量的goroutine？</li>
</ol>
<h1 id="示例源码"><a href="#示例源码" class="headerlink" title="示例源码"></a>示例源码</h1><p><strong>本文所有示例源码，及历史文章、代码都存储在Github，阅读原文可直接跳转</strong>，Github：<a href="https://github.com/Shitaibin/golang_step_by_step/tree/master/pprof" target="_blank" rel="noopener">https://github.com/Shitaibin/golang_step_by_step/tree/master/pprof</a> 。</p>
<h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><p>这些既是参考资料也是推荐阅读的文章，不容错过。</p>
<p>【Go Blog关于pprof详细介绍和Demo】 <a href="https://blog.golang.org/profiling-go-programs" target="_blank" rel="noopener">https://blog.golang.org/profiling-go-programs</a></p>
<p>【Dave关于高性能Go程序的workshop】 <a href="https://dave.cheney.net/high-performance-go-workshop/dotgo-paris.html#using_more_than_one_cpu" target="_blank" rel="noopener">https://dave.cheney.net/high-performance-go-workshop/dotgo-paris.html#using_more_than_one_cpu</a></p>
<p>【煎鱼pprof文章，很适合入门 Golang大杀器之性能剖析PProf】 <a href="https://segmentfault.com/a/1190000016412013" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016412013</a></p>
<p>【SO上goroutine调用栈各字段的介绍】<a href="https://stackoverflow.com/a/38414527/4296218" target="_blank" rel="noopener">https://stackoverflow.com/a/38414527/4296218</a></p>
<p>【我的老文，有runtime.main的介绍，想学习调度器，可以看下系列文章 Go调度器系列（2）宏观看调度器】<a href="http://lessisbetter.site/2019/03/26/golang-scheduler-2-macro-view/">http://lessisbetter.site/2019/03/26/golang-scheduler-2-macro-view/</a></p>
<blockquote>
<ol>
<li>如果这篇文章对你有帮助，不妨关注下我的Github，有文章会收到通知。</li>
<li>本文作者：<a href="http://lessisbetter.site/about/">大彬</a></li>
<li>如果喜欢本文，随意转载，但请保留此原文链接：<a href="http://lessisbetter.site/2019/05/18/go-goroutine-leak/">http://lessisbetter.site/2019/05/18/go-goroutine-leak/</a></li>
</ol>
</blockquote>
<p><div style="color:#0096FF; text-align:center">关注公众号，获取最新Golang文章</div><br><img src="http://img.lessisbetter.site/2019-01-article_qrcode.jpg" style="border:0" align="center"></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2019/05/03/go-concurrent-problems1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="技术与人生 | 区块链架构师">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大彬 LIB">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/03/go-concurrent-problems1/" class="post-title-link" itemprop="url">Go面试题：并发</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-05-03 09:23:17" itemprop="dateCreated datePublished" datetime="2019-05-03T09:23:17+08:00">2019-05-03</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-12 08:34:47" itemprop="dateModified" datetime="2019-07-12T08:34:47+08:00">2019-07-12</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Once"><a href="#Once" class="headerlink" title="Once"></a>Once</h3><p>这个once的实现有没有什么问题？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Once <span class="keyword">struct</span> &#123;</span><br><span class="line">	m    sync.Mutex</span><br><span class="line">	done <span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">Do</span><span class="params">(f <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> o.done == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	o.m.Lock()</span><br><span class="line">	<span class="keyword">defer</span> o.m.Unlock()</span><br><span class="line">	<span class="keyword">if</span> o.done == <span class="number">0</span> &#123;</span><br><span class="line">		o.done = <span class="number">1</span></span><br><span class="line">		f()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有。讨论见这里：<a href="https://github.com/smallnest/gitalk/issues/101#issuecomment-490738912" target="_blank" rel="noopener">https://github.com/smallnest/gitalk/issues/101#issuecomment-490738912</a></p>
<p>正确的姿势是使用原子操作，原子操作在修改变量的值后，会也让其他核立马看到数据的变动。Once.Do的官方实现就使用的原子操作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">Do</span><span class="params">(f <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> atomic.LoadUint32(&amp;o.done) == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Slow-path.</span></span><br><span class="line">	o.m.Lock()</span><br><span class="line">	<span class="keyword">defer</span> o.m.Unlock()</span><br><span class="line">	<span class="keyword">if</span> o.done == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> atomic.StoreUint32(&amp;o.done, <span class="number">1</span>)</span><br><span class="line">		f()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于缓存，可以看鸟窝的<a href="https://colobu.com/2019/01/24/cacheline-affects-performance-in-go/" target="_blank" rel="noopener">《cacheline 对 Go 程序的影响》</a>和知乎<a href="https://zhuanlan.zhihu.com/p/31875174" target="_blank" rel="noopener">《细说Cache-L1/L2/L3/TLB》</a>。</p>
<h3 id="Wait-Group"><a href="#Wait-Group" class="headerlink" title="Wait Group"></a>Wait Group</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		time.Sleep(time.Millisecond)</span><br><span class="line">		wg.Done()</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会panic：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">panic: sync: WaitGroup is reused before previous Wait has returned</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">sync.(*WaitGroup).Wait(0xc000018090)</span><br><span class="line">	/Users/shitaibin/go/src/github.com/golang/go/src/sync/waitgroup.go:132 +0xae</span><br><span class="line">main.main()</span><br><span class="line">	/Users/shitaibin/Workspace/golang_step_by_step/problems/concurrent/waitgroup0.go:16 +0x79</span><br><span class="line">exit status 2</span><br></pre></td></tr></table></figure>
<p>原因：第13行执行<code>wg.Done()</code>后，wg的计数已经变成了0，<code>wg.Wait()</code>实际以及完成并返回，14行再次使用此<code>wg.Add()</code>报错。</p>
<h3 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">	count <span class="keyword">int</span></span><br><span class="line">	sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> mu MyMutex</span><br><span class="line">	mu.Lock()</span><br><span class="line">	<span class="keyword">var</span> mu2 = mu</span><br><span class="line">	mu.count++</span><br><span class="line">	mu.Unlock()</span><br><span class="line">	mu2.Lock()</span><br><span class="line">	mu2.count++</span><br><span class="line">	mu2.Unlock()</span><br><span class="line">	fmt.Println(mu.count, mu2.count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果panic：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br><span class="line"></span><br><span class="line">goroutine 1 [semacquire]:</span><br><span class="line">sync.runtime_SemacquireMutex(0xc0000180ac, 0x100ae00)</span><br><span class="line">	/Users/shitaibin/go/src/github.com/golang/go/src/runtime/sema.go:71 +0x3d</span><br><span class="line">sync.(*Mutex).Lock(0xc0000180a8)</span><br><span class="line">	/Users/shitaibin/go/src/github.com/golang/go/src/sync/mutex.go:134 +0x109</span><br><span class="line">main.main()</span><br><span class="line">	/Users/shitaibin/Workspace/golang_step_by_step/problems/concurrent/mutex0.go:19 +0xb4</span><br></pre></td></tr></table></figure>
<p>原因：<code>MyMutex</code>和<code>sync.Mutex</code>都是结构体，不包含指针，第16行根据mu新建了mu2对象，2者占用不同的内存区域，但2者的“内容”是相同的，所以mu2新建后就已经是Lock状态。第19行<code>mu2.Lock()</code>所以会死锁。</p>
<p>修改：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">gopackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">	count <span class="keyword">int</span></span><br><span class="line">	sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> mu MyMutex</span><br><span class="line">	mu.Lock()</span><br><span class="line">	<span class="keyword">var</span> mu2 = mu</span><br><span class="line">	mu.count++</span><br><span class="line">	mu.Unlock()</span><br><span class="line">	mu2.Unlock() <span class="comment">// 先解锁，或新建mu2时移动到mu.Lock之前</span></span><br><span class="line">	mu2.Lock()</span><br><span class="line">	mu2.count++</span><br><span class="line">	mu2.Unlock()</span><br><span class="line">	fmt.Println(mu.count, mu2.count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Pool"><a href="#Pool" class="headerlink" title="Pool"></a>Pool</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"bytes"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"runtime"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pool = sync.Pool&#123;New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123; <span class="keyword">return</span> <span class="built_in">new</span>(bytes.Buffer) &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			processRequest(<span class="number">1</span> &lt;&lt; <span class="number">28</span>) <span class="comment">// 256MiB</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				processRequest(<span class="number">1</span> &lt;&lt; <span class="number">10</span>) <span class="comment">// 1KiB</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> stats runtime.MemStats</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; ; i++ &#123;</span><br><span class="line">		runtime.ReadMemStats(&amp;stats)</span><br><span class="line">		fmt.Printf(<span class="string">"Cycle %d: %d MB\n"</span>, i, stats.Alloc/<span class="number">1024</span>/<span class="number">1024</span>)</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		runtime.GC()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processRequest</span><span class="params">(size <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	b := pool.Get().(*bytes.Buffer)</span><br><span class="line">	time.Sleep(<span class="number">500</span> * time.Millisecond)</span><br><span class="line">	b.Grow(size)</span><br><span class="line">	pool.Put(b)</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Millisecond)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以编译，运行时内存先暴涨，但是过一会会回收掉。结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Cycle 0: 0 MB</span><br><span class="line">Cycle 1: 256 MB</span><br><span class="line">Cycle 2: 513 MB</span><br><span class="line">Cycle 3: 769 MB</span><br><span class="line">Cycle 4: 1281 MB</span><br><span class="line">Cycle 5: 1281 MB</span><br><span class="line">Cycle 6: 1281 MB</span><br><span class="line">Cycle 7: 1537 MB</span><br><span class="line">Cycle 8: 1793 MB</span><br><span class="line">Cycle 9: 2049 MB</span><br><span class="line">Cycle 10: 2049 MB</span><br><span class="line">......</span><br><span class="line">Cycle 107: 14593 MB</span><br><span class="line">Cycle 108: 15105 MB</span><br><span class="line">Cycle 109: 2304 MB</span><br><span class="line">Cycle 110: 0 MB</span><br><span class="line">Cycle 111: 256 MB</span><br><span class="line">Cycle 112: 513 MB</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p><code>sync.Pool</code>用来存放经常使用的临时对象，如果每次这些内存被GC回收，会加大GC的压力，Pool的出现就是为<strong>减缓</strong>GC的压力，而不是完全不让GC回收Pool的内存。</p>
<p>关于Pool不可错过Dave在<a href="https://dave.cheney.net/high-performance-go-workshop/gopherchina-2019.html#using_sync_pool" target="_blank" rel="noopener">高性能Go程序的这段介绍</a>。</p>
<h3 id="channel-1"><a href="#channel-1" class="headerlink" title="channel 1"></a>channel 1</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"runtime"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">		ch &lt;- <span class="number">1</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		&lt;-ch</span><br><span class="line">	&#125;(ch)</span><br><span class="line">	c := time.Tick(<span class="number">1</span> * time.Second)</span><br><span class="line">	<span class="keyword">for</span> <span class="keyword">range</span> c &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"#goroutines: %d\n"</span>, runtime.NumGoroutine())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2个闭包goroutine可运行并结束。最后只有main和定时器协程，所以最终有2个协程在运行，持续打印<code>#goroutines: 2</code>。</p>
<h3 id="channel-2"><a href="#channel-2" class="headerlink" title="channel 2"></a>channel 2</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> count <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		ch &lt;- <span class="number">1</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		count++</span><br><span class="line">		<span class="built_in">close</span>(ch)</span><br><span class="line">	&#125;()</span><br><span class="line">	&lt;-ch</span><br><span class="line">	fmt.Println(count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ch只声明，未进行初始化，所以panic：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">panic: close of nil channel</span><br><span class="line"></span><br><span class="line">goroutine 34 [running]:</span><br><span class="line">main.main.func2(0xc000096000, 0x0)</span><br><span class="line">	/Users/shitaibin/Workspace/golang_step_by_step/problems/concurrent/channel1.go:13 +0x33</span><br><span class="line">created by main.main</span><br><span class="line">	/Users/shitaibin/Workspace/golang_step_by_step/problems/concurrent/channel1.go:11 +0x87</span><br><span class="line">exit status 2</span><br></pre></td></tr></table></figure>
<p>修改为下面这样，还有问题吗？：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// var ch chan int</span></span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">var</span> count <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		ch &lt;- <span class="number">1</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		count++</span><br><span class="line">		<span class="built_in">close</span>(ch)</span><br><span class="line">	&#125;()</span><br><span class="line">	&lt;-ch</span><br><span class="line">	fmt.Println(count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样会panic，典型的channel由非发送者关闭，造成在关闭的channel上写数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">panic: send on closed channel</span><br><span class="line"></span><br><span class="line">goroutine 4 [running]:</span><br><span class="line">main.main.func1(0xc000070060)</span><br><span class="line">	/Users/shitaibin/Workspace/golang_step_by_step/problems/concurrent/channel1.go:10 +0x37</span><br><span class="line">created by main.main</span><br><span class="line">	/Users/shitaibin/Workspace/golang_step_by_step/problems/concurrent/channel1.go:9 +0x80</span><br><span class="line">exit status 2</span><br></pre></td></tr></table></figure>
<h3 id="Map-1"><a href="#Map-1" class="headerlink" title="Map 1"></a>Map 1</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> m sync.Map</span><br><span class="line">	m.LoadOrStore(<span class="string">"a"</span>, <span class="number">1</span>)</span><br><span class="line">	m.Delete(<span class="string">"a"</span>)</span><br><span class="line">	fmt.Println(m.Len())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无法编译，因为Map没有Len()方法。</p>
<h3 id="Map-2"><a href="#Map-2" class="headerlink" title="Map 2"></a>Map 2</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">	m <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span></span><br><span class="line">	sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	m.Lock()</span><br><span class="line">	<span class="keyword">defer</span> m.Unlock()</span><br><span class="line">	i, ok := m.m[key]</span><br><span class="line">	<span class="keyword">return</span> i, ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Put</span><span class="params">(key, value <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	m.Lock()</span><br><span class="line">	<span class="keyword">defer</span> m.Unlock()</span><br><span class="line">	m.m[key] = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(m.m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">2</span>)</span><br><span class="line">	m := Map&#123;m: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)&#125;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++ &#123;</span><br><span class="line">			m.Put(i, i)</span><br><span class="line">		&#125;</span><br><span class="line">		wg.Done()</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++ &#123;</span><br><span class="line">			m.Len()</span><br><span class="line">		&#125;</span><br><span class="line">		wg.Done()</span><br><span class="line">	&#125;()</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>能正常编译和运行。map不是协程安全的，需要锁的保护，但Len()的实现并没有加锁，当map写数据时，并且调用Len读长度，则存在map的并发读写问题，因为不是同时读写map所存的内容，所以可以编译和运行，但存在读取的map内存长度不准确问题。map定义和len的声明如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A header for a Go map.</span></span><br><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go.</span></span><br><span class="line">	<span class="comment">// Make sure this stays in sync with the compiler's definition.</span></span><br><span class="line">	count     <span class="keyword">int</span> <span class="comment">// # live cells == size of map.  Must be first (used by len() builtin)</span></span><br><span class="line">	flags     <span class="keyword">uint8</span></span><br><span class="line">	B         <span class="keyword">uint8</span>  <span class="comment">// log_2 of # of buckets (can hold up to loadFactor * 2^B items)</span></span><br><span class="line">	noverflow <span class="keyword">uint16</span> <span class="comment">// approximate number of overflow buckets; see incrnoverflow for details</span></span><br><span class="line">	hash0     <span class="keyword">uint32</span> <span class="comment">// hash seed</span></span><br><span class="line"></span><br><span class="line">	buckets    unsafe.Pointer <span class="comment">// array of 2^B Buckets. may be nil if count==0.</span></span><br><span class="line">	oldbuckets unsafe.Pointer <span class="comment">// previous bucket array of half the size, non-nil only when growing</span></span><br><span class="line">	nevacuate  <span class="keyword">uintptr</span>        <span class="comment">// progress counter for evacuation (buckets less than this have been evacuated)</span></span><br><span class="line"></span><br><span class="line">	extra *mapextra <span class="comment">// optional fields</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The len built-in function returns the length of v, according to its type:</span></span><br><span class="line"><span class="comment">//	Array: the number of elements in v.</span></span><br><span class="line"><span class="comment">//	Pointer to array: the number of elements in *v (even if v is nil).</span></span><br><span class="line"><span class="comment">//	Slice, or map: the number of elements in v; if v is nil, len(v) is zero.</span></span><br><span class="line"><span class="comment">//	String: the number of bytes in v.</span></span><br><span class="line"><span class="comment">//	Channel: the number of elements queued (unread) in the channel buffer;</span></span><br><span class="line"><span class="comment">//	if v is nil, len(v) is zero.</span></span><br><span class="line"><span class="comment">// For some arguments, such as a string literal or a simple array expression, the</span></span><br><span class="line"><span class="comment">// result can be a constant. See the Go language specification's "Length and</span></span><br><span class="line"><span class="comment">// capacity" section for details.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">len</span><span class="params">(v Type)</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure>
<h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">var</span> ints = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">1000</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">			ints = <span class="built_in">append</span>(ints, i)</span><br><span class="line">		&#125;</span><br><span class="line">		wg.Done()</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">			ints = <span class="built_in">append</span>(ints, i)</span><br><span class="line">		&#125;</span><br><span class="line">		wg.Done()</span><br><span class="line">	&#125;()</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(ints))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，slice不是协程安全的，自身也又没锁的保护，多协程访问存在并发问题：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">	array unsafe.Pointer</span><br><span class="line">	<span class="built_in">len</span>   <span class="keyword">int</span></span><br><span class="line">	<span class="built_in">cap</span>   <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其次，append中有可能还会分配新的内存空间，切片可能指向了新的内存区域：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The append built-in function appends elements to the end of a slice. If</span></span><br><span class="line"><span class="comment">// it has sufficient capacity, the destination is resliced to accommodate the</span></span><br><span class="line"><span class="comment">// new elements. If it does not, a new underlying array will be allocated.</span></span><br><span class="line"><span class="comment">// Append returns the updated slice. It is therefore necessary to store the</span></span><br><span class="line"><span class="comment">// result of append, often in the variable holding the slice itself:</span></span><br><span class="line"><span class="comment">//	slice = append(slice, elem1, elem2)</span></span><br><span class="line"><span class="comment">//	slice = append(slice, anotherSlice...)</span></span><br><span class="line"><span class="comment">// As a special case, it is legal to append a string to a byte slice, like this:</span></span><br><span class="line"><span class="comment">//	slice = append([]byte("hello "), "world"...)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(slice []Type, elems ...Type)</span> []<span class="title">Type</span></span></span><br></pre></td></tr></table></figure>
<p>所以，两个协程同时写，是不安全的，并且大概率可能存在数据丢失，所以结果可能不是2000。</p>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p><a href="https://github.com/Shitaibin/golang_step_by_step/tree/master/problems" target="_blank" rel="noopener">golang_step_by_step</a></p>
<blockquote>
<ol>
<li>如果这篇文章对你有帮助，不妨关注下我的Github，有文章会收到通知。</li>
<li>本文作者：<a href="http://lessisbetter.site/about/">大彬</a></li>
<li>如果喜欢本文，随意转载，但请保留此原文链接：<a href="http://lessisbetter.site/2019/05/03/go-concurrent-problems1/">http://lessisbetter.site/2019/05/03/go-concurrent-problems1/</a></li>
</ol>
</blockquote>
<p><div style="color:#0096FF; text-align:center">关注公众号，获取最新Golang文章</div><br><img src="http://img.lessisbetter.site/2019-01-article_qrcode.jpg" style="border:0" align="center"></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2019/04/26/ethereum-keys-transform/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="技术与人生 | 区块链架构师">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大彬 LIB">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/26/ethereum-keys-transform/" class="post-title-link" itemprop="url">以太坊密钥转换</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-26 10:04:00 / 修改时间：18:35:03" itemprop="dateCreated datePublished" datetime="2019-04-26T10:04:00+08:00">2019-04-26</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>以太坊的每一个账号私钥都通过密码加密存放到一个keystore文件中，如果创建一个账户涉及：</p>
<ol>
<li>生成ECDSA密钥</li>
<li>使用密码</li>
<li>将加密信息生成json格式，等待写入到keystore文件</li>
<li>创建keystore文件</li>
<li>将信息写入到keystore文件</li>
</ol>
<p>经过测试，这一个过程需要耗时大约5s，也就是每创建一个账户都要耗时5s，如果要创建1万个测试账号，需要5万秒，需要将近14小时，需要进行并发，才能尽量减少时间浪费，但是，使用5s才生成1个账号，还是太浪费了。</p>
<p>读取1个keystore文件涉及：</p>
<ol>
<li>读keystore文件</li>
<li>对数据进行解密，将账号保存到内存</li>
</ol>
<p>经过测试，这个过程需要耗时大约3s，1万个账号顺序读取需要大约8小时。</p>
<p><strong>能不能并发读取？</strong><br>不能。读取keystore时，指定的是keystore文件所在的目录，它会读取所有的keystore文件，在内存中保存到1个<code>Keystore</code>对象中。</p>
<p>如果我们写一个测试程序，以太坊账号的管理，简直是一个噩梦。</p>
<p><strong>有没有其他办法，能够加快账号的读取，交易的签名等？</strong></p>
<p><strong>交易的签名本质</strong>是使用go的<code>ecdsa.PrivateKey</code>，没有以太坊这些账户加密和解密操作，这些操作是上述测试耗时的原因，直接使用<code>ecdsa.PrivateKey</code>，使用后保存到文件，使用时从文件读取，可以从若干小时，降低到不到1s。</p>
<p>我们使用<code>ecdsa.PrivateKey</code>的思路：</p>
<ol>
<li>使用<code>ecdsa.GenerateKey()</code>生成私钥</li>
<li>私钥能转为16进制字符串，把字符串保存到文本文件，每一行都是1个私钥的16进制</li>
<li>使用时从文件读取每一个账号的16进制字符串，然后转换成所有的私钥</li>
</ol>
<p><strong>16进制字符串和<code>ecdsa.PrivateKey</code>相互转换是非常简单的</strong>，<code>ecdsa.Private</code>和以太坊的账号转换，则是非常乱的，整理出来了一幅图，没这幅图，每次看都要梳理一段时间，浪费生命。</p>
<p><img src="http://img.lessisbetter.site/2019-04-eth-keys-transform.png" alt=""></p>
<p>图注：</p>
<ol>
<li><code>keystore</code>代表包名，<code>Keystore</code>代表类型</li>
<li>以<code>()</code>为函数，否则为类型</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2019/04/14/golang-scheduler-4-explore-source-code/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="技术与人生 | 区块链架构师">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大彬 LIB">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/14/golang-scheduler-4-explore-source-code/" class="post-title-link" itemprop="url">Go调度器系列（4）源码阅读与探索</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-14 15:38:59" itemprop="dateCreated datePublished" datetime="2019-04-14T15:38:59+08:00">2019-04-14</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-12 08:34:47" itemprop="dateModified" datetime="2019-07-12T08:34:47+08:00">2019-07-12</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>各位朋友，这次想跟大家分享一下Go调度器源码阅读相关的知识和经验，网络上已经有很多剖析源码的好文章，所以这篇文章<strong>不是又一篇源码剖析文章，注重的不是源码分析分享，而是带给大家一些学习经验，希望大家能更好的阅读和掌握Go调度器的实现</strong>。</p>
<p>本文主要分2个部分：</p>
<ol>
<li><strong>解决如何阅读源码的问题</strong>。阅读源码本质是把脑海里已经有的调度设计，看看到底是不是这么实现的，是怎么实现的。</li>
<li><strong>带给你一个探索Go调度器实现的办法</strong>。源码都到手了，你可以修改、<strong>窥探</strong>，通过这种方式解决阅读源码过程中的疑问，验证一些想法。比如：负责调度的是g0，怎么才能<code>schedule()</code>在执行时，当前是g0呢？</li>
</ol>
<h2 id="如何阅读源码"><a href="#如何阅读源码" class="headerlink" title="如何阅读源码"></a>如何阅读源码</h2><h3 id="阅读前提"><a href="#阅读前提" class="headerlink" title="阅读前提"></a>阅读前提</h3><p>阅读Go源码前，最好已经掌握Go调度器的设计和原理，如果你还无法回答以下问题：</p>
<ol>
<li>为什么需要Go调度器？</li>
<li>Go调度器与系统调度器有什么区别和关系/联系？</li>
<li>G、P、M是什么，三者的关系是什么？</li>
<li>P有默认几个？</li>
<li>M同时能绑定几个P？</li>
<li>M怎么获得G？</li>
<li>M没有G怎么办？</li>
<li>为什么需要全局G队列？</li>
<li>Go调度器中的负载均衡的2种方式是什么？</li>
<li>work stealing是什么？什么原理？</li>
<li>系统调用对G、P、M有什么影响？</li>
<li>Go调度器抢占是什么样的？一定能抢占成功吗？</li>
</ol>
<p>建议阅读Go调度器系列文章，以及文章中的参考资料：</p>
<ol>
<li><a href="http://lessisbetter.site/2019/03/10/golang-scheduler-1-history/">Go调度器系列（1）起源</a></li>
<li><a href="http://lessisbetter.site/2019/03/26/golang-scheduler-2-macro-view/">Go调度器系列（2）宏观看调度器</a></li>
<li><a href="http://lessisbetter.site/2019/04/04/golang-scheduler-3-principle-with-graph/">Go调度器系列（3）图解调度原理</a></li>
</ol>
<h3 id="优秀源码资料推荐"><a href="#优秀源码资料推荐" class="headerlink" title="优秀源码资料推荐"></a>优秀源码资料推荐</h3><p>既然你已经能回答以上问题，说明你对Go调度器的设计已经有了一定的掌握，关于Go调度器源码的优秀资料已经有很多，我这里推荐2个：</p>
<ol>
<li><strong>雨痕的Go源码剖析</strong>六章并发调度，不止是源码，是以源码为基础进行了详细的Go调度器介绍：ttps://github.com/qyuhen/book</li>
<li><strong>Go夜读</strong>第12期，golang中goroutine的调度，M、P、G各自的一生状态，以及转换关系：<a href="https://reading.developerlearning.cn/reading/12-2018-08-02-goroutine-gpm/" target="_blank" rel="noopener">https://reading.developerlearning.cn/reading/12-2018-08-02-goroutine-gpm/</a></li>
</ol>
<p>Go调度器的源码还涉及GC等，阅读源码时，可以暂时先跳过，主抓调度的逻辑。</p>
<p>另外，Go调度器涉及汇编，也许你不懂汇编，不用担心，雨痕的文章对汇编部分有进行解释。</p>
<p>最后，送大家一幅流程图，画出了主要的调度流程，大家也可边阅读边画，增加理解，<strong>高清版可到博客下载（原图原文跳转）</strong>。</p>
<p><img src="http://img.lessisbetter.site/2019-04-shcedule-flow.png" alt=""></p>
<h2 id="如何探索调度器"><a href="#如何探索调度器" class="headerlink" title="如何探索调度器"></a>如何探索调度器</h2><p>这部分教你探索Go调度器的源码，验证想法，主要思想就是，下载Go的源码，添加调试打印，编译修改的源文件，生成修改的go，然后使用修改go运行测试代码，观察结果。</p>
<h3 id="下载和编译Go"><a href="#下载和编译Go" class="headerlink" title="下载和编译Go"></a>下载和编译Go</h3><ol>
<li><p>Github下载，并且换到go1.11.2分支，本文所有代码修改都基于go1.11.2版本。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ GODIR=<span class="variable">$GOPATH</span>/src/github.com/golang/go</span><br><span class="line">$ mkdir -p <span class="variable">$GODIR</span></span><br><span class="line">$ <span class="built_in">cd</span> <span class="variable">$GODIR</span>/..</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/golang/go.git</span><br><span class="line">$ <span class="built_in">cd</span> go</span><br><span class="line">$ git fetch origin go1.11.2</span><br><span class="line">$ git checkout origin/go1.11.2</span><br><span class="line">$ git checkout -b go1.11.2</span><br><span class="line">$ git checkout go1.11.2</span><br></pre></td></tr></table></figure>
</li>
<li><p>初次编译，会跑测试，耗时长一点</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> <span class="variable">$GODIR</span>/src</span><br><span class="line">$ ./all.bash</span><br></pre></td></tr></table></figure>
</li>
<li><p>以后每次修改go源码后可以这样，4分钟左右可以编译完成</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span>  <span class="variable">$GODIR</span>/src</span><br><span class="line">$ time ./make.bash</span><br><span class="line">Building Go cmd/dist using /usr/<span class="built_in">local</span>/go.</span><br><span class="line">Building Go toolchain1 using /usr/<span class="built_in">local</span>/go.</span><br><span class="line">Building Go bootstrap cmd/go (go_bootstrap) using Go toolchain1.</span><br><span class="line">Building Go toolchain2 using go_bootstrap and Go toolchain1.</span><br><span class="line">Building Go toolchain3 using go_bootstrap and Go toolchain2.</span><br><span class="line">Building packages and commands <span class="keyword">for</span> linux/amd64.</span><br><span class="line">---</span><br><span class="line">Installed Go <span class="keyword">for</span> linux/amd64 <span class="keyword">in</span> /home/xxx/go/src/github.com/golang/go</span><br><span class="line">Installed commands <span class="keyword">in</span> /home/xxx/go/src/github.com/golang/go/bin</span><br><span class="line"></span><br><span class="line">real	1m11.675s</span><br><span class="line">user	4m4.464s</span><br><span class="line">sys	0m18.312s</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>编译好的go和gofmt在<code>$GODIR/bin</code>目录。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ll <span class="variable">$GODIR</span>/bin</span><br><span class="line">total 16044</span><br><span class="line">-rwxrwxr-x 1 vnt vnt 13049123 Apr 14 10:53 go</span><br><span class="line">-rwxrwxr-x 1 vnt vnt  3377614 Apr 14 10:53 gofmt</span><br></pre></td></tr></table></figure></p>
<ol start="4">
<li><p>为了防止我们修改的go和过去安装的go冲突，创建igo软连接，指向修改的go。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p ~/testgo/bin</span><br><span class="line">$ <span class="built_in">cd</span> ~/testgo/bin</span><br><span class="line">$ ln -sf <span class="variable">$GODIR</span>/bin/go igo</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后，把<code>~/testgo/bin</code>加入到<code>PATH</code>，就能使用<code>igo</code>来编译代码了，运行下igo，应当获得go1.11.2的版本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ igo version</span><br><span class="line">go version go1.11.2 linux/amd64</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>当前，已经掌握编译和使用修改的go的办法，接下来就以1个简单的例子，教大家如何验证想法。</p>
<h3 id="验证schedule-由g0执行"><a href="#验证schedule-由g0执行" class="headerlink" title="验证schedule()由g0执行"></a>验证schedule()由g0执行</h3><p>阅读源码的文章，你已经知道了g0是负责调度的，并且g0是全局变量，可在runtime包的任何地方直接使用，看到<code>schedule()</code>代码如下（所在文件：<code>$GODIR/src/runtime/proc.go</code>）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// One round of scheduler: find a runnable goroutine and execute it.</span></span><br><span class="line"><span class="comment">// Never returns.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 获取当前g，调度时这个g应当是g0</span></span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _g_.m.locks != <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">"schedule: holding locks"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// m已经被某个g锁定，先停止当前m，等待g可运行时，再执行g，并且还得到了g所在的p</span></span><br><span class="line">	<span class="keyword">if</span> _g_.m.lockedg != <span class="number">0</span> &#123;</span><br><span class="line">		stoplockedm()</span><br><span class="line">		execute(_g_.m.lockedg.ptr(), <span class="literal">false</span>) <span class="comment">// Never returns.</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>问题</strong>：既然g0是负责调度的，为何<code>schedule()</code>每次还都执行<code>_g_ := getg()</code>，直接使用g0不行吗？<code>schedule()</code>真的是g0执行的吗？</p>
<p>在<a href="http://lessisbetter.site/2019/03/26/golang-scheduler-2-macro-view/">《Go调度器系列（2）宏观看调度器》</a>这篇文章中我曾介绍了trace的用法，阅读代码时发现<strong>使用<code>debug.schedtrace</code>和<code>print()</code>函数可以用作打印调试信息</strong>，那我们是不是可以使用这种方法打印我们想获取的信息呢？当然可以。</p>
<p>另外，注意<code>print()</code>并不是<code>fmt.Print()</code>，也不是C语言的<code>printf</code>，所以不是格式化输出，它是汇编实现的，我们不深入去了解它的实现了，现在要掌握它的用法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The print built-in function formats its arguments in an</span></span><br><span class="line"><span class="comment">// implementation-specific way and writes the result to standard error.</span></span><br><span class="line"><span class="comment">// Print is useful for bootstrapping and debugging; it is not guaranteed</span></span><br><span class="line"><span class="comment">// to stay in the language.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">(args ...Type)</span></span></span><br></pre></td></tr></table></figure>
<p>从上面可以看到，它接受可变长参数，我们使用的时候只需要传进去即可，但要手动控制格式。</p>
<p>我们修改<code>schedule()</code>函数，使用<code>debug.schedtrace &gt; 0</code>控制打印，加入3行代码，把goid给打印出来，如果始终打印goid为0，则代表调度确实是由g0执行的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> debug.schedtrace &gt; <span class="number">0</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"schedule(): goid = "</span>, _g_.goid, <span class="string">"\n"</span>) <span class="comment">// 会是0吗？是的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>schedule()</code>如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// One round of scheduler: find a runnable goroutine and execute it.</span></span><br><span class="line"><span class="comment">// Never returns.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 获取当前g，调度时这个g应当是g0</span></span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> debug.schedtrace &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">"schedule(): goid = "</span>, _g_.goid, <span class="string">"\n"</span>) <span class="comment">// 会是0吗？是的</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _g_.m.locks != <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">"schedule: holding locks"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译igo：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd  $GODIR/src</span><br><span class="line">$ ./make.bash</span><br></pre></td></tr></table></figure></p>
<p>编写一个简单的demo（不能更简单）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下，你会发现所有的<code>schedule()</code>函数调用都打印<code>goid = 0</code>，足以证明Go调度器的调度由g0完成（如果你认为还是缺乏说服力，可以写复杂一些的demo）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ GODEBUG=schedtrace=1000 igo run demo1.go</span><br><span class="line">schedule(): goid = 0</span><br><span class="line">schedule(): goid = 0</span><br><span class="line">SCHED 0ms: gomaxprocs=8 idleprocs=6 threads=4 spinningthreads=1 idlethreads=0 runqueue=0 [0 0 0 0 0 0 0 0]</span><br><span class="line">schedule(): goid = 0</span><br><span class="line">schedule(): goid = 0</span><br><span class="line">schedule(): goid = 0</span><br><span class="line">schedule(): goid = 0</span><br><span class="line">schedule(): goid = 0</span><br><span class="line">schedule(): goid = 0</span><br><span class="line">schedule(): goid = 0</span><br><span class="line">schedule(): goid = 0</span><br><span class="line">schedule(): goid = 0</span><br><span class="line">schedule(): goid = 0</span><br><span class="line">schedule(): goid = 0</span><br><span class="line">schedule(): goid = 0</span><br><span class="line">schedule(): goid = 0</span><br><span class="line">schedule(): goid = 0</span><br><span class="line">// 省略几百行</span><br></pre></td></tr></table></figure></p>
<p><strong>启发比结论更重要，希望各位朋友在学习Go调度器的时候，能多一些自己的探索和研究，而不仅仅停留在看看别人文章之上</strong>。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="https://golang.org/doc/install/source" target="_blank" rel="noopener">Installing Go from source</a></li>
</ol>
<blockquote>
<ol>
<li>如果这篇文章对你有帮助，不妨关注下我的Github，有文章会收到通知。</li>
<li>本文作者：<a href="http://lessisbetter.site/about/">大彬</a></li>
<li>如果喜欢本文，随意转载，但请保留此原文链接：<a href="http://lessisbetter.site/2019/04/14/golang-scheduler-4-explore-source-code/">http://lessisbetter.site/2019/04/14/golang-scheduler-4-explore-source-code/</a></li>
</ol>
</blockquote>
<p><div style="color:#0096FF; text-align:center">关注公众号，获取最新Golang文章</div><br><img src="http://img.lessisbetter.site/2019-01-article_qrcode.jpg" style="border:0" align="center"></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2019/04/04/golang-scheduler-3-principle-with-graph/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="技术与人生 | 区块链架构师">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大彬 LIB">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/04/golang-scheduler-3-principle-with-graph/" class="post-title-link" itemprop="url">Go调度器系列（3）图解调度原理</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-04 13:02:19" itemprop="dateCreated datePublished" datetime="2019-04-04T13:02:19+08:00">2019-04-04</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-12 08:34:47" itemprop="dateModified" datetime="2019-07-12T08:34:47+08:00">2019-07-12</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>如果你已经阅读了前2篇文章：<a href="http://lessisbetter.site/2019/03/10/golang-scheduler-1-history/">《调度起源》</a>和<a href="http://lessisbetter.site/2019/03/26/golang-scheduler-2-macro-view/">《宏观看调度器》</a>，你对G、P、M肯定已经不再陌生，我们这篇文章就介绍Go调度器的基本原理，本文总结了12个主要的场景，覆盖了以下内容：</p>
<ol>
<li>G的创建和分配。</li>
<li>P的本地队列和全局队列的负载均衡。</li>
<li>M如何寻找G。</li>
<li>M如何从G1切换到G2。</li>
<li>work stealing，M如何去偷G。</li>
<li>为何需要自旋线程。</li>
<li>G进行系统调用，如何保证P的其他G’可以被执行，而不是饿死。</li>
<li>Go调度器的抢占。</li>
</ol>
<h3 id="12场景"><a href="#12场景" class="headerlink" title="12场景"></a>12场景</h3><blockquote>
<p>提示：图在前，场景描述在后。</p>
</blockquote>
<p><img src="http://img.lessisbetter.site/2019-04-image-20190331190809649-4030489.png" alt=""></p>
<blockquote>
<p>上图中三角形、正方形、圆形分别代表了M、P、G，正方形连接的绿色长方形代表了P的本地队列。</p>
</blockquote>
<p><strong>场景1</strong>：p1拥有g1，m1获取p1后开始运行g1，g1使用<code>go func()</code>创建了g2，为了局部性g2优先加入到p1的本地队列。</p>
<p><img src="http://img.lessisbetter.site/2019-04-image-20190331190826838-4030506.png" alt=""></p>
<p><strong>场景2</strong>：<strong>g1运行完成后(函数：<code>goexit</code>)，m上运行的goroutine切换为g0，g0负责调度时协程的切换（函数：<code>schedule</code>）</strong>。从p1的本地队列取g2，从g0切换到g2，并开始运行g2(函数：<code>execute</code>)。实现了<strong>线程m1的复用</strong>。</p>
<p><img src="http://img.lessisbetter.site/2019-04-image-20190331160718646-4019638.png" alt=""></p>
<p><strong>场景3</strong>：假设每个p的本地队列只能存4个g。g2要创建了6个g，前4个g（g3, g4, g5, g6）已经加入p1的本地队列，p1本地队列满了。</p>
<p><img src="http://img.lessisbetter.site/2019-04-image-20190331160728024-4019648.png" alt=""></p>
<blockquote>
<p>蓝色长方形代表全局队列。</p>
</blockquote>
<p><strong>场景4</strong>：g2在创建g7的时候，发现p1的本地队列已满，需要执行<strong>负载均衡</strong>，把p1中本地队列中前一半的g，还有新创建的g<strong>转移</strong>到全局队列（实现中并不一定是新的g，如果g是g2之后就执行的，会被保存在本地队列，利用某个老的g替换新g加入全局队列），这些g被转移到全局队列时，会被打乱顺序。所以g3,g4,g7被转移到全局队列。</p>
<p><img src="http://img.lessisbetter.site/2019-04-image-20190331161138353-4019898.png" alt=""></p>
<p><strong>场景5</strong>：g2创建g8时，p1的本地队列未满，所以g8会被加入到p1的本地队列。</p>
<p><img src="http://img.lessisbetter.site/2019-04-image-20190331162734830-4020854.png" alt=""></p>
<p><strong>场景6</strong>：<strong>在创建g时，运行的g会尝试唤醒其他空闲的p和m执行</strong>。假定g2唤醒了m2，m2绑定了p2，并运行g0，但p2本地队列没有g，m2此时为自旋线程（没有G但为运行状态的线程，不断寻找g，后续场景会有介绍）。</p>
<p><img src="http://img.lessisbetter.site/2019-04-image-20190331162717486-4020837.png" alt=""></p>
<p><strong>场景7</strong>：m2尝试从全局队列(GQ)取一批g放到p2的本地队列（函数：<code>findrunnable</code>）。m2从全局队列取的g数量符合下面的公式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n = min(len(GQ)/GOMAXPROCS + 1, len(GQ/2))</span><br></pre></td></tr></table></figure>
<p>公式的含义是，至少从全局队列取1个g，但每次不要从全局队列移动太多的g到p本地队列，给其他p留点。这是<strong>从全局队列到P本地队列的负载均衡</strong>。</p>
<p>假定我们场景中一共有4个P，所以m2只从能从全局队列取1个g（即g3）移动p2本地队列，然后完成从g0到g3的切换，运行g3。</p>
<p><img src="http://img.lessisbetter.site/2019-04-image-20190331163755555-4021475.png" alt=""></p>
<p><strong>场景8</strong>：假设g2一直在m1上运行，经过2轮后，m2已经把g7、g4也挪到了p2的本地队列并完成运行，全局队列和p2的本地队列都空了，如上图左边。</p>
<p><strong>全局队列已经没有g，那m就要执行work stealing：从其他有g的p哪里偷取一半g过来，放到自己的P本地队列</strong>。p2从p1的本地队列尾部取一半的g，本例中一半则只有1个g8，放到p2的本地队列，情况如上图右边。</p>
<p><img src="http://img.lessisbetter.site/2019-04-image-20190331170113457-4022873.png" alt=""></p>
<p><strong>场景9</strong>：p1本地队列g5、g6已经被其他m偷走并运行完成，当前m1和m2分别在运行g2和g8，m3和m4没有goroutine可以运行，m3和m4处于<strong>自旋状态</strong>，它们不断寻找goroutine。为什么要让m3和m4自旋，自旋本质是在运行，线程在运行却没有执行g，就变成了浪费CPU？销毁线程不是更好吗？可以节约CPU资源。创建和销毁CPU都是浪费时间的，我们<strong>希望当有新goroutine创建时，立刻能有m运行它</strong>，如果销毁再新建就增加了时延，降低了效率。当然也考虑了过多的自旋线程是浪费CPU，所以系统中最多有GOMAXPROCS个自旋的线程，多余的没事做线程会让他们休眠（见函数：<code>notesleep()</code>）。</p>
<p><img src="http://img.lessisbetter.site/2019-04-image-20190331182939318-4028179.png" alt=""></p>
<p><strong>场景10</strong>：假定当前除了m3和m4为自旋线程，还有m5和m6为自旋线程，g8创建了g9，g8进行了<strong>阻塞的系统调用</strong>，m2和p2立即解绑，p2会执行以下判断：如果p2本地队列有g、全局队列有g或有空闲的m，p2都会立马唤醒1个m和它绑定，否则p2则会加入到空闲P列表，等待m来获取可用的p。本场景中，p2本地队列有g，可以和其他自旋线程m5绑定。</p>
<p><strong>场景11</strong>：（无图场景）g8创建了g9，假如g8进行了<strong>非阻塞系统调用</strong>（CGO会是这种方式，见<code>cgocall()</code>），m2和p2会解绑，但m2会记住p，然后g8和m2进入系统调用状态。当g8和m2退出系统调用时，会尝试获取p2，如果无法获取，则获取空闲的p，如果依然没有，g8会被记为可运行状态，并加入到全局队列。</p>
<p><strong>场景12</strong>：（无图场景）Go调度在go1.12实现了抢占，应该更精确的称为<strong>请求式抢占</strong>，那是因为go调度器的抢占和OS的线程抢占比起来很柔和，不暴力，不会说线程时间片到了，或者更高优先级的任务到了，执行抢占调度。<strong>go的抢占调度柔和到只给goroutine发送1个抢占请求，至于goroutine何时停下来，那就管不到了</strong>。抢占请求需要满足2个条件中的1个：1）G进行系统调用超过20us，2）G运行超过10ms。调度器在启动的时候会启动一个单独的线程sysmon，它负责所有的监控工作，其中1项就是抢占，发现满足抢占条件的G时，就发出抢占请求。</p>
<h3 id="场景融合"><a href="#场景融合" class="headerlink" title="场景融合"></a>场景融合</h3><p>如果把上面所有的场景都融合起来，就能构成下面这幅图了，它从整体的角度描述了Go调度器各部分的关系。图的上半部分是G的创建、负债均衡和work stealing，下半部分是M不停寻找和执行G的迭代过程。</p>
<p>如果你看这幅图还有些似懂非懂，建议赶紧开始看<a href="github.com/qyuhen/book">雨痕大神的Golang源码剖析</a>，章节：并发调度。</p>
<p><img src="http://img.lessisbetter.site/2019-04-arch.png" alt=""></p>
<p>总结，Go调度器和OS调度器相比，是相当的轻量与简单了，但它已经足以撑起goroutine的调度工作了，并且让Go具有了原生（强大）并发的能力，这是伟大的。如果你记住的不多，你一定要记住这一点：<strong>Go调度本质是把大量的goroutine分配到少量线程上去执行，并利用多核并行，实现更强大的并发。</strong></p>
<h3 id="下集预告"><a href="#下集预告" class="headerlink" title="下集预告"></a>下集预告</h3><p>下篇会是源码层面的内容了，关于源码分析的书籍、文章可以先看起来了，先剧透一篇图，希望阅读下篇文章赶紧关注本公众号。</p>
<p><img src="http://img.lessisbetter.site/2019-04-flow.png" alt=""></p>
<h3 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h3><p><a href="http://lessisbetter.site/2019/03/10/golang-scheduler-1-history/">Go调度器系列（1）起源</a><br><a href="http://lessisbetter.site/2019/03/26/golang-scheduler-2-macro-view/">Go调度器系列（2）宏观看调度器</a></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>在学习调度器的时候，看了很多文章，这里列一些重要的：</p>
<ol>
<li><a href="https://morsmachine.dk/go-scheduler" target="_blank" rel="noopener">The Go scheduler</a></li>
<li><a href="https://rakyll.org/scheduler/" target="_blank" rel="noopener">Go’s work-stealing scheduler</a>，<a href="https://lingchao.xin/post/gos-work-stealing-scheduler.html" target="_blank" rel="noopener">中文翻译版</a></li>
<li><a href="https://reading.developerlearning.cn/reading/12-2018-08-02-goroutine-gpm/" target="_blank" rel="noopener">Go夜读：golang 中 goroutine 的调度</a></li>
<li><a href="https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part2.html" target="_blank" rel="noopener">Scheduling In Go : Part I、II、III </a>，<a href="https://www.jianshu.com/p/cb6881a2661d" target="_blank" rel="noopener">中文翻译版</a></li>
<li><a href="github.com/qyuhen/book">雨痕大神的golang源码剖析</a></li>
<li><a href="https://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/" target="_blank" rel="noopener">也谈goroutine调度器</a></li>
<li><a href="https://speakerdeck.com/kavya719/the-scheduler-saga" target="_blank" rel="noopener">kavya的调度PPT</a></li>
<li><a href="https://github.com/golang/proposal/blob/master/design/24543-non-cooperative-preemption.md" target="_blank" rel="noopener">抢占的设计提案，Proposal: Non-cooperative goroutine preemption</a></li>
</ol>
<blockquote>
<ol>
<li>如果这篇文章对你有帮助，不妨关注下我的Github，有文章会收到通知。</li>
<li>本文作者：<a href="http://lessisbetter.site/about/">大彬</a></li>
<li>如果喜欢本文，随意转载，但请保留此原文链接：<a href="http://lessisbetter.site/2019/04/04/golang-scheduler-3-principle-with-graph/">http://lessisbetter.site/2019/04/04/golang-scheduler-3-principle-with-graph/</a></li>
</ol>
</blockquote>
<p><div style="color:#0096FF; text-align:center">关注公众号，获取最新Golang文章</div><br><img src="http://img.lessisbetter.site/2019-01-article_qrcode.jpg" style="border:0" align="center"></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">大彬</p>
              <p class="site-description motion-element" itemprop="description">技术与人生 | 区块链架构师</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives">
                
                    <span class="site-state-item-count">85</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">57</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="http://img.lessisbetter.site/2019-01-article_qrcode.jpg" title="公众号 &rarr; http://img.lessisbetter.site/2019-01-article_qrcode.jpg" rel="noopener" target="_blank"><i class="fa fa-fw fa-wechat"></i>公众号</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/shitaibin" title="GitHub &rarr; https://github.com/shitaibin" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://segmentfault.com/u/lessisbetter" title="SegmentFault &rarr; https://segmentfault.com/u/lessisbetter" rel="noopener" target="_blank"><i class="fa fa-fw fa-crosshairs"></i>SegmentFault</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://www.jianshu.com/u/947f3ccdd481" title="简书 &rarr; https://www.jianshu.com/u/947f3ccdd481" rel="noopener" target="_blank"><i class="fa fa-fw fa-heartbeat"></i>简书</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://stackoverflow.com/users/4296218/james-shi" title="StackOverflow &rarr; https://stackoverflow.com/users/4296218/james-shi" rel="noopener" target="_blank"><i class="fa fa-fw fa-stack-overflow"></i>StackOverflow</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:hz_stb@163.com" title="E-Mail &rarr; mailto:hz_stb@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友链
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://segmentfault.com/u/lessisbetter" title="https://segmentfault.com/u/lessisbetter" rel="noopener" target="_blank">SF</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">[object Object]</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v6.6.0</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv" title="总访客量">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="site-pv" title="总访问量">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









  <div style="display: none;">
    <script src="//s95.cnzz.com/z_stat.php?id=1275814754&web_id=1275814754" language="JavaScript"></script>
  </div>



        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script src="/js/src/utils.js?v=6.6.0"></script>

  <script src="/js/src/motion.js?v=6.6.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.6.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.6.0"></script>



  

  


  <script src="/js/src/bootstrap.js?v=6.6.0"></script>



  



  











  





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  

  
  

  

  

  

  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  <script>
    $('.highlight').each(function (i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap');
      $(e).after($wrap);
      $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function (e) {
        var code = $(this).parent().find('.code').find('.line').map(function (i, e) {
          return $(e).text();
        }).toArray().join('\n');
        var ta = document.createElement('textarea');
        var range = document.createRange(); //For Chrome
        var sel = window.getSelection(); //For Chrome
        var yPosition = window.pageYOffset || document.documentElement.scrollTop;
        ta.style.top = yPosition + 'px'; //Prevent page scroll
        ta.style.position = 'absolute';
        ta.style.opacity = '0';
        ta.value = code;
        ta.textContent = code; //For FireFox
        ta.contentEditable = true;
        ta.readOnly = false;
        document.body.appendChild(ta);
        range.selectNode(ta);
        sel.removeAllRanges();
        sel.addRange(range);
        ta.setSelectionRange(0, code.length);
        var result = document.execCommand('copy');
        
        ta.blur(); //For iOS
        $(this).blur();
      })).on('mouseleave', function (e) {
        var $b = $(this).find('.copy-btn');
        setTimeout(function () {
          $b.text('复制');
        }, 300);
      }).append(e);
    })
  </script>


  

</body>
</html>
