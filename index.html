<!DOCTYPE html>













<html class="theme-next pisces" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">
































<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=6.6.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.6.0" color="#222">









<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.6.0',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="区块链、Go语言">
<meta name="keywords" content="区块链 Go语言 后端 技术 人生 编程">
<meta property="og:type" content="website">
<meta property="og:title" content="Go语言充电站">
<meta property="og:url" content="http://lessisbetter.site/index.html">
<meta property="og:site_name" content="Go语言充电站">
<meta property="og:description" content="区块链、Go语言">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Go语言充电站">
<meta name="twitter:description" content="区块链、Go语言">






  <link rel="canonical" href="http://lessisbetter.site/"/>



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Go语言充电站 – 大彬 less is better</title>
  












  <noscript>
  <style>
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion .logo-line-before i { left: initial; }
    .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Go语言充电站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">大彬 less is better</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-主页 menu-item-active">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br />主页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-标签云">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签云</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-专题文章">

    
    
    
      
    

    

    <a href="/subject/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br />专题文章</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-文章列表">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br />文章列表</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-关于">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-大牛博客">

    
    
    
      
    

    

    <a href="/blogs/" rel="section"><i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />大牛博客</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    
  
  
  
  

  

    <a href="https://github.com/Shitaibin" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" style="fill: #222; color: #fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2019/09/11/fabric-deploy-scc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="区块链、Go语言">
      <meta itemprop="image" content="http://img.lessisbetter.site/gzh-qrcode-logo-small.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Go语言充电站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/11/fabric-deploy-scc/" class="post-title-link" itemprop="url">详解Fabric部署系统链码SCC</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-09-11 11:37:27 / 修改时间：11:44:50" itemprop="dateCreated datePublished" datetime="2019-09-11T11:37:27+08:00">2019-09-11</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一份Peer节点启动的INFO级别日志如下，可以发现：</p>
<ol>
<li>先注册了scc目录下的lscc, cscc, qscc，未注册chaincode目录下的lifecycle</li>
<li>然后又依次部署了上述scc。</li>
</ol>
<p>本文的目的就是梳理出，系统链码的部署流程，这是peer节点提供背书、链码管理、配置、查询等功能的基础。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">2019-09-09 07:52:09.409 UTC [gossip.gossip] start -&gt; INFO 013 Gossip instance peer1.org1.example.com:8051 started</span><br><span class="line">2019-09-09 07:52:09.418 UTC [sccapi] deploySysCC -&gt; INFO 014 system chaincode lscc/(github.com/hyperledger/fabric/core/scc/lscc) deployed</span><br><span class="line">2019-09-09 07:52:09.420 UTC [cscc] Init -&gt; INFO 015 Init CSCC</span><br><span class="line">2019-09-09 07:52:09.422 UTC [sccapi] deploySysCC -&gt; INFO 016 system chaincode cscc/(github.com/hyperledger/fabric/core/scc/cscc) deployed</span><br><span class="line">2019-09-09 07:52:09.424 UTC [qscc] Init -&gt; INFO 017 Init QSCC</span><br><span class="line">2019-09-09 07:52:09.424 UTC [sccapi] deploySysCC -&gt; INFO 018 system chaincode qscc/(github.com/hyperledger/fabric/core/scc/qscc) deployed</span><br><span class="line">2019-09-09 07:52:09.425 UTC [sccapi] deploySysCC -&gt; INFO 019 system chaincode (+lifecycle,github.com/hyperledger/fabric/core/chaincode/lifecycle) disabled</span><br><span class="line">...</span><br><span class="line">2019-09-09 07:52:14.386 UTC [sccapi] deploySysCC -&gt; INFO 031 system chaincode lscc/mychannel(github.com/hyperledger/fabric/core/scc/lscc) deployed</span><br><span class="line">2019-09-09 07:52:14.386 UTC [cscc] Init -&gt; INFO 032 Init CSCC</span><br><span class="line">2019-09-09 07:52:14.386 UTC [sccapi] deploySysCC -&gt; INFO 033 system chaincode cscc/mychannel(github.com/hyperledger/fabric/core/scc/cscc) deployed</span><br><span class="line">2019-09-09 07:52:14.387 UTC [qscc] Init -&gt; INFO 034 Init QSCC</span><br><span class="line">2019-09-09 07:52:14.387 UTC [sccapi] deploySysCC -&gt; INFO 035 system chaincode qscc/mychannel(github.com/hyperledger/fabric/core/scc/qscc) deployed</span><br><span class="line">2019-09-09 07:52:14.387 UTC [sccapi] deploySysCC -&gt; INFO 036 system chaincode (+lifecycle,github.com/hyperledger/fabric/core/chaincode/lifecycle) disabled</span><br></pre></td></tr></table></figure>
<h2 id="宏观流程"><a href="#宏观流程" class="headerlink" title="宏观流程"></a>宏观流程</h2><blockquote>
<p>提醒，本文使用<strong>SCC代指系统链码</strong>，使用scc代指core.scc模块。</p>
</blockquote>
<p>在介绍源码之前，先给出总体流程，以便看源码的时候不会迷失。</p>
<p>部署SCC会涉及到4个模块：</p>
<ol>
<li>peer.node，它是peer的主程序，可以调用core.scc进行注册和部署SCC</li>
<li>core.scc，它包含了lscc、qscc、cscc这3个scc，以及SCC的注册和部署</li>
<li>core.chaincode，它是链码管理，普通链码和SCC都会走该模块，去部署和调用链码，和链码容器交互，并且它还提供了1个链码容器的工具shim</li>
<li>core.container，它是实现链码容器，有2种链码容器，SCC使用的InprocVM，和普通链码使用的DockerVM</li>
</ol>
<p>注册和部署的简要流程如下：</p>
<p><img src="http://img.lessisbetter.site/2019-09-deploy-scc-flow.png" alt=""></p>
<ol>
<li>peer运行启动程序</li>
<li>注册scc<ol>
<li>peer.node创建好lscc、cscc、qscc等scc实例，以及从配置文件读取的scc</li>
<li>peer.node调用core.scc依次注册每一个scc实例</li>
<li>core.scc调用core.container把scc实例信息注册到container</li>
</ol>
</li>
<li>部署scc<ol>
<li>peer.node调用core.scc依次部署每一个注册的scc</li>
<li>core.scc部署scc的流程复用普通链码部署流程，调用core.chaincode</li>
<li>core.chaincode执行启动链码容器，scc也有链码容器是Inproc类型，不是Docker类型</li>
<li>core.chaincode会调用core.container建立scc的Inproc容器实例</li>
<li>core.container调用core.chaincode.shim启动容器内的程序，并负责和peer通信</li>
<li>启动完成后，core.chaincode向容器发送Init消息，让容器初始化，容器初始化完成会发送响应消息给core.chaincode，core.chaincode部署scc完成</li>
</ol>
</li>
</ol>
<h2 id="总流程"><a href="#总流程" class="headerlink" title="总流程"></a>总流程</h2><blockquote>
<p>列出源码的过程，会省略大量不相关代码，用<code>...</code>代替。</p>
</blockquote>
<p>peer启动过程中，会调用<code>node.serve</code>，其中包含了为系统链码注册SCC和部署SCC。之后，还会为应用通道部署SCC，说明每个通道有各自的SCC，这里省略掉这部分。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serve</span><span class="params">(args []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 获取support，会注册SCC</span></span><br><span class="line">    <span class="comment">// Initialize chaincode service</span></span><br><span class="line">    chaincodeSupport, ccp, sccp, packageProvider := startChaincodeServer(peerHost, aclProvider, pr, opsSystem)</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 为系统通道部署已经注册的SCC</span></span><br><span class="line">    <span class="comment">// deploy system chaincodes</span></span><br><span class="line">	sccp.DeploySysCCs(<span class="string">""</span>, ccp)</span><br><span class="line">	logger.Infof(<span class="string">"Deployed system chaincodes"</span>)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注册SCC"><a href="#注册SCC" class="headerlink" title="注册SCC"></a>注册SCC</h2><p>注册SCC的流程：</p>
<p>peer.node -&gt; core.scc -&gt; core.container</p>
<h3 id="peer-node"><a href="#peer-node" class="headerlink" title="peer.node"></a>peer.node</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// startChaincodeServer will finish chaincode related initialization, including:</span></span><br><span class="line"><span class="comment">// 1) setup local chaincode install path</span></span><br><span class="line"><span class="comment">// 2) create chaincode specific tls CA</span></span><br><span class="line"><span class="comment">// 3) start the chaincode specific gRPC listening service</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startChaincodeServer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	peerHost <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	aclProvider aclmgmt.ACLProvider,</span></span></span><br><span class="line"><span class="function"><span class="params">	pr *platforms.Registry,</span></span></span><br><span class="line"><span class="function"><span class="params">	ops *operations.System,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(*chaincode.ChaincodeSupport, ccprovider.ChaincodeProvider, *scc.Provider, *persistence.PackageProvider)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="comment">// 会注册SCC</span></span><br><span class="line">	chaincodeSupport, ccp, sccp := registerChaincodeSupport(</span><br><span class="line">		ccSrv,</span><br><span class="line">		ccEndpoint,</span><br><span class="line">		ca,</span><br><span class="line">		packageProvider,</span><br><span class="line">		aclProvider,</span><br><span class="line">		pr,</span><br><span class="line">		lifecycleSCC,</span><br><span class="line">		ops,</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">go</span> ccSrv.Start()</span><br><span class="line">	<span class="keyword">return</span> chaincodeSupport, ccp, sccp, packageProvider</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">registerChaincodeSupport</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	grpcServer *comm.GRPCServer,</span></span></span><br><span class="line"><span class="function"><span class="params">	ccEndpoint <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	ca tlsgen.CA,</span></span></span><br><span class="line"><span class="function"><span class="params">	packageProvider *persistence.PackageProvider,</span></span></span><br><span class="line"><span class="function"><span class="params">	aclProvider aclmgmt.ACLProvider,</span></span></span><br><span class="line"><span class="function"><span class="params">	pr *platforms.Registry,</span></span></span><br><span class="line"><span class="function"><span class="params">	lifecycleSCC *lifecycle.SCC,</span></span></span><br><span class="line"><span class="function"><span class="params">	ops *operations.System,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(*chaincode.ChaincodeSupport, ccprovider.ChaincodeProvider, *scc.Provider)</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// SCC的VM provider</span></span><br><span class="line">	ipRegistry := inproccontroller.NewRegistry()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建SCC provider</span></span><br><span class="line">	sccp := scc.NewProvider(peer.Default, peer.DefaultSupport, ipRegistry)</span><br><span class="line">	<span class="comment">// 创建lscc实例</span></span><br><span class="line">    lsccInst := lscc.New(sccp, aclProvider, pr)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 普通链码，docker容器类型的VM provider</span></span><br><span class="line">	dockerProvider := dockercontroller.NewProvider(</span><br><span class="line">		viper.GetString(<span class="string">"peer.id"</span>),</span><br><span class="line">		viper.GetString(<span class="string">"peer.networkId"</span>),</span><br><span class="line">		ops.Provider,</span><br><span class="line">	)</span><br><span class="line">	dockerVM := dockercontroller.NewDockerVM(</span><br><span class="line">		dockerProvider.PeerID,</span><br><span class="line">		dockerProvider.NetworkID,</span><br><span class="line">		dockerProvider.BuildMetrics,</span><br><span class="line">	)</span><br><span class="line">    ...</span><br><span class="line">    chaincodeSupport := chaincode.NewChaincodeSupport(</span><br><span class="line">		chaincode.GlobalConfig(),</span><br><span class="line">		ccEndpoint,</span><br><span class="line">		userRunsCC,</span><br><span class="line">		ca.CertBytes(),</span><br><span class="line">		authenticator,</span><br><span class="line">		packageProvider,</span><br><span class="line">		lsccInst, <span class="comment">// chaincodeSupport的声明周期管理使用了lscc，而不是lifecycle</span></span><br><span class="line">		aclProvider,</span><br><span class="line">		container.NewVMController(</span><br><span class="line">			<span class="keyword">map</span>[<span class="keyword">string</span>]container.VMProvider&#123;</span><br><span class="line">				dockercontroller.ContainerType: dockerProvider,</span><br><span class="line">				inproccontroller.ContainerType: ipRegistry,</span><br><span class="line">			&#125;,</span><br><span class="line">		),</span><br><span class="line">		sccp,</span><br><span class="line">		pr,</span><br><span class="line">		peer.DefaultSupport,</span><br><span class="line">		ops.Provider,</span><br><span class="line">	)</span><br><span class="line">	ipRegistry.ChaincodeSupport = chaincodeSupport</span><br><span class="line">	<span class="comment">// chaincode provider，可以用来创建cscc</span></span><br><span class="line">	ccp := chaincode.NewProvider(chaincodeSupport)</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 创建cscc、qscc</span></span><br><span class="line">	csccInst := cscc.New(ccp, sccp, aclProvider)</span><br><span class="line">	qsccInst := qscc.New(aclProvider)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Now that chaincode is initialized, register all system chaincodes.</span></span><br><span class="line">	sccs := scc.CreatePluginSysCCs(sccp)</span><br><span class="line">	<span class="comment">// 加入lscc、cscc、qscc</span></span><br><span class="line">	<span class="comment">// lifecycleSCC在1.4中disable了</span></span><br><span class="line">	<span class="comment">// sccs是用户自定义的系统链码</span></span><br><span class="line">	<span class="keyword">for</span> _, cc := <span class="keyword">range</span> <span class="built_in">append</span>([]scc.SelfDescribingSysCC&#123;lsccInst, csccInst, qsccInst, lifecycleSCC&#125;, sccs...) &#123;</span><br><span class="line">		<span class="comment">// 注册每一个SCC</span></span><br><span class="line">		sccp.RegisterSysCC(cc)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">return</span> chaincodeSupport, ccp, sccp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="core-scc"><a href="#core-scc" class="headerlink" title="core.scc"></a>core.scc</h3><p>注册某1个系统合约。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Provider implements sysccprovider.SystemChaincodeProvider</span></span><br><span class="line"><span class="keyword">type</span> Provider <span class="keyword">struct</span> &#123;</span><br><span class="line">	Peer        peer.Operations</span><br><span class="line">	PeerSupport peer.Support</span><br><span class="line">	Registrar   Registrar             <span class="comment">// 注册</span></span><br><span class="line">	SysCCs      []SelfDescribingSysCC <span class="comment">// 注册的scc，包含失败的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RegisterSysCC registers a system chaincode with the syscc provider.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Provider)</span> <span class="title">RegisterSysCC</span><span class="params">(scc SelfDescribingSysCC)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 收集/注册scc到scc provider</span></span><br><span class="line">	p.SysCCs = <span class="built_in">append</span>(p.SysCCs, scc)</span><br><span class="line">	_, err := p.registerSysCC(scc)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		sysccLogger.Panicf(<span class="string">"Could not register system chaincode: %s"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// registerSysCC registers the given system chaincode with the peer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Provider)</span> <span class="title">registerSysCC</span><span class="params">(syscc SelfDescribingSysCC)</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 检测该scc是否开启或不在白名单</span></span><br><span class="line">	<span class="keyword">if</span> !syscc.Enabled() || !isWhitelisted(syscc) &#123;</span><br><span class="line">		sysccLogger.Info(fmt.Sprintf(<span class="string">"system chaincode (%s,%s,%t) disabled"</span>, syscc.Name(), syscc.Path(), syscc.Enabled()))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// XXX This is an ugly hack, version should be tied to the chaincode instance, not he peer binary</span></span><br><span class="line">	version := util.GetSysCCVersion()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// cc的描述信息</span></span><br><span class="line">	ccid := &amp;ccintf.CCID&#123;</span><br><span class="line">		Name:    syscc.Name(),</span><br><span class="line">		Version: version,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 注册scc的chaincode</span></span><br><span class="line">	err := p.Registrar.Register(ccid, syscc.Chaincode())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">//if the type is registered, the instance may not be... keep going</span></span><br><span class="line">		<span class="keyword">if</span> _, ok := err.(inproccontroller.SysCCRegisteredErr); !ok &#123;</span><br><span class="line">			errStr := fmt.Sprintf(<span class="string">"could not register (%s,%v): %s"</span>, syscc.Path(), syscc, err)</span><br><span class="line">			sysccLogger.Error(errStr)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>, fmt.Errorf(errStr)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sysccLogger.Infof(<span class="string">"system chaincode %s(%s) registered"</span>, syscc.Name(), syscc.Path())</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Registrar provides a way for system chaincodes to be registered</span></span><br><span class="line"><span class="keyword">type</span> Registrar <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Register registers a system chaincode</span></span><br><span class="line">	Register(ccid *ccintf.CCID, cc shim.Chaincode) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="core-container"><a href="#core-container" class="headerlink" title="core.container"></a>core.container</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Register registers system chaincode with given path. The deploy should be called to initialize</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Registry)</span> <span class="title">Register</span><span class="params">(ccid *ccintf.CCID, cc shim.Chaincode)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	r.mutex.Lock()</span><br><span class="line">	<span class="keyword">defer</span> r.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 注册系统链码</span></span><br><span class="line">	name := ccid.GetName()</span><br><span class="line">	inprocLogger.Debugf(<span class="string">"Registering chaincode instance: %s"</span>, name)</span><br><span class="line">	tmp := r.typeRegistry[name]</span><br><span class="line">	<span class="keyword">if</span> tmp != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> SysCCRegisteredErr(name)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	r.typeRegistry[name] = &amp;inprocContainer&#123;chaincode: cc&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Registry stores registered system chaincodes.</span></span><br><span class="line"><span class="comment">// It implements container.VMProvider and scc.Registrar</span></span><br><span class="line"><span class="keyword">type</span> Registry <span class="keyword">struct</span> &#123;</span><br><span class="line">	mutex        sync.Mutex</span><br><span class="line">	typeRegistry <span class="keyword">map</span>[<span class="keyword">string</span>]*inprocContainer <span class="comment">// 已注册链码映射</span></span><br><span class="line">	instRegistry <span class="keyword">map</span>[<span class="keyword">string</span>]*inprocContainer <span class="comment">// 链码示例映射</span></span><br><span class="line"></span><br><span class="line">	ChaincodeSupport ccintf.CCSupport</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="部署SCC"><a href="#部署SCC" class="headerlink" title="部署SCC"></a>部署SCC</h2><p>部署SCC的流程：</p>
<p>peer.node -&gt; core.scc -&gt; core.chaincode -&gt; core.container</p>
<h3 id="peer-node-1"><a href="#peer-node-1" class="headerlink" title="peer.node"></a>peer.node</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serve</span><span class="params">(args []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="comment">// 为系统通道部署已经注册的SCC</span></span><br><span class="line">	<span class="comment">// deploy system chaincodes</span></span><br><span class="line">	sccp.DeploySysCCs(<span class="string">""</span>, ccp)</span><br><span class="line">    logger.Infof(<span class="string">"Deployed system chaincodes"</span>)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="core-scc-1"><a href="#core-scc-1" class="headerlink" title="core.scc"></a>core.scc</h3><p><code>DeploySysCCs</code>会为chainID对应的channel，部署注册过程中收集的每一个SCC，它们在<code>p.SysCCs</code>中。</p>
<p>部署链码实际是一笔交易，为了复用普通链码的部署流程，core.scc使用<code>deploySysCC</code>封装部署链码需要的参数，链码是实际部署，走core.chaincode流程。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DeploySysCCs is the hook for system chaincodes where system chaincodes are registered with the fabric</span></span><br><span class="line"><span class="comment">//note the chaincode must still be deployed and launched like a user chaincode will be</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Provider)</span> <span class="title">DeploySysCCs</span><span class="params">(chainID <span class="keyword">string</span>, ccp ccprovider.ChaincodeProvider)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 部署每一个scc</span></span><br><span class="line">	<span class="keyword">for</span> _, sysCC := <span class="keyword">range</span> p.SysCCs &#123;</span><br><span class="line">		deploySysCC(chainID, ccp, sysCC)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// deploySysCC deploys the given system chaincode on a chain</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deploySysCC</span><span class="params">(chainID <span class="keyword">string</span>, ccprov ccprovider.ChaincodeProvider, syscc SelfDescribingSysCC)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// disable或不在白名单的scc不执行部署</span></span><br><span class="line">	<span class="keyword">if</span> !syscc.Enabled() || !isWhitelisted(syscc) &#123;</span><br><span class="line">		sysccLogger.Info(fmt.Sprintf(<span class="string">"system chaincode (%s,%s) disabled"</span>, syscc.Name(), syscc.Path()))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为scc生成txid，因为部署链码的过程需要txParams，与普通链码的流程相同</span></span><br><span class="line">	txid := util.GenerateUUID()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Note, this structure is barely initialized,</span></span><br><span class="line">	<span class="comment">// we omit the history query executor, the proposal</span></span><br><span class="line">	<span class="comment">// and the signed proposal</span></span><br><span class="line">	txParams := &amp;ccprovider.TransactionParams&#123;</span><br><span class="line">		TxID:      txid,</span><br><span class="line">		ChannelID: chainID,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置交易执行模拟器，系统通道chainID为""，所以系统通道的scc没有模拟器</span></span><br><span class="line">	<span class="keyword">if</span> chainID != <span class="string">""</span> &#123;</span><br><span class="line">		<span class="comment">// 获取链/通道的账本</span></span><br><span class="line">		lgr := peer.GetLedger(chainID)</span><br><span class="line">		<span class="keyword">if</span> lgr == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"syschain %s start up failure - unexpected nil ledger for channel %s"</span>, syscc.Name(), chainID))</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 根据交易id创建链码模拟器</span></span><br><span class="line">		txsim, err := lgr.NewTxSimulator(txid)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 指定链码执行模拟器</span></span><br><span class="line">		txParams.TXSimulator = txsim</span><br><span class="line">		<span class="keyword">defer</span> txsim.Done()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	chaincodeID := &amp;pb.ChaincodeID&#123;Path: syscc.Path(), Name: syscc.Name()&#125;</span><br><span class="line">	spec := &amp;pb.ChaincodeSpec&#123;Type: pb.ChaincodeSpec_Type(pb.ChaincodeSpec_Type_value[<span class="string">"GOLANG"</span>]), ChaincodeId: chaincodeID, Input: &amp;pb.ChaincodeInput&#123;Args: syscc.InitArgs()&#125;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ChaincodeDeploymentSpec_SYSTEM标明：部署SCC</span></span><br><span class="line">	chaincodeDeploymentSpec := &amp;pb.ChaincodeDeploymentSpec&#123;ExecEnv: pb.ChaincodeDeploymentSpec_SYSTEM, ChaincodeSpec: spec&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// XXX This is an ugly hack, version should be tied to the chaincode instance, not he peer binary</span></span><br><span class="line">	version := util.GetSysCCVersion()</span><br><span class="line"></span><br><span class="line">	cccid := &amp;ccprovider.CCContext&#123;</span><br><span class="line">		Name:    chaincodeDeploymentSpec.ChaincodeSpec.ChaincodeId.Name,</span><br><span class="line">		Version: version,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 部署SCC</span></span><br><span class="line">	resp, _, err := ccprov.ExecuteLegacyInit(txParams, cccid, chaincodeDeploymentSpec)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; resp.Status != shim.OK &#123;</span><br><span class="line">		err = errors.New(resp.Message)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sysccLogger.Infof(<span class="string">"system chaincode %s/%s(%s) deployed"</span>, syscc.Name(), chainID, syscc.Path())</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ChaincodeProvider provides an abstraction layer that is</span></span><br><span class="line"><span class="comment">// used for different packages to interact with code in the</span></span><br><span class="line"><span class="comment">// chaincode package without importing it; more methods</span></span><br><span class="line"><span class="comment">// should be added below if necessary</span></span><br><span class="line"><span class="keyword">type</span> ChaincodeProvider <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Execute executes a standard chaincode invocation for a chaincode and an input</span></span><br><span class="line">	Execute(txParams *TransactionParams, cccid *CCContext, input *pb.ChaincodeInput) (*pb.Response, *pb.ChaincodeEvent, error)</span><br><span class="line">	<span class="comment">// ExecuteLegacyInit is a special case for executing chaincode deployment specs,</span></span><br><span class="line">	<span class="comment">// which are not already in the LSCC, needed for old lifecycle</span></span><br><span class="line">	ExecuteLegacyInit(txParams *TransactionParams, cccid *CCContext, spec *pb.ChaincodeDeploymentSpec) (*pb.Response, *pb.ChaincodeEvent, error)</span><br><span class="line">	<span class="comment">// Stop stops the chaincode give</span></span><br><span class="line">	Stop(ccci *ChaincodeContainerInfo) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="core-chaincode"><a href="#core-chaincode" class="headerlink" title="core.chaincode"></a>core.chaincode</h3><p><code>CCProviderImpl</code>实现了<code>ChaincodeProvider</code>接口，可以用来部署链码，<code>ExecuteLegacyInit</code>会执行2项：</p>
<ol>
<li>启动链码容器</li>
<li>执行链码Init函数，链码容器启动后，peer和链码容器通过消息通信，<code>ChaincodeMessage_INIT</code>是执行链码容器的Init函数</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExecuteLegacyInit executes a chaincode which is not in the LSCC table</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CCProviderImpl)</span> <span class="title">ExecuteLegacyInit</span><span class="params">(txParams *ccprovider.TransactionParams, cccid *ccprovider.CCContext, spec *pb.ChaincodeDeploymentSpec)</span> <span class="params">(*pb.Response, *pb.ChaincodeEvent, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.cs.ExecuteLegacyInit(txParams, cccid, spec)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ExecuteLegacyInit is a temporary method which should be removed once the old style lifecycle</span></span><br><span class="line"><span class="comment">// is entirely deprecated.  Ideally one release after the introduction of the new lifecycle.</span></span><br><span class="line"><span class="comment">// It does not attempt to start the chaincode based on the information from lifecycle, but instead</span></span><br><span class="line"><span class="comment">// accepts the container information directly in the form of a ChaincodeDeploymentSpec.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *ChaincodeSupport)</span> <span class="title">ExecuteLegacyInit</span><span class="params">(txParams *ccprovider.TransactionParams, cccid *ccprovider.CCContext, spec *pb.ChaincodeDeploymentSpec)</span> <span class="params">(*pb.Response, *pb.ChaincodeEvent, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 部署链码需要的信息</span></span><br><span class="line">    ccci := ccprovider.DeploymentSpecToChaincodeContainerInfo(spec)</span><br><span class="line">	ccci.Version = cccid.Version</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动容器</span></span><br><span class="line">	err := cs.LaunchInit(ccci)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cname := ccci.Name + <span class="string">":"</span> + ccci.Version</span><br><span class="line">	h := cs.HandlerRegistry.Handler(cname)</span><br><span class="line">	<span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, errors.Wrapf(err, <span class="string">"[channel %s] claimed to start chaincode container for %s but could not find handler"</span>, txParams.ChannelID, cname)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用链码Init</span></span><br><span class="line">	resp, err := cs.execute(pb.ChaincodeMessage_INIT, txParams, cccid, spec.GetChaincodeSpec().Input, h)</span><br><span class="line">	<span class="keyword">return</span> processChaincodeExecutionResult(txParams.TxID, cccid.Name, resp, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>LaunchInit</code>是启动容器的一层检查，实际启动由<code>Launcher.Launch</code>完成。启动链码容器是异步的，会创建单独的goroutine去执行。</p>
<p>core.chaincode使用<code>Runtime</code>接口操控链码容器的启停。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LaunchInit bypasses getting the chaincode spec from the LSCC table</span></span><br><span class="line"><span class="comment">// as in the case of v1.0-v1.2 lifecycle, the chaincode will not yet be</span></span><br><span class="line"><span class="comment">// defined in the LSCC table</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *ChaincodeSupport)</span> <span class="title">LaunchInit</span><span class="params">(ccci *ccprovider.ChaincodeContainerInfo)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	cname := ccci.Name + <span class="string">":"</span> + ccci.Version</span><br><span class="line">	<span class="comment">// 已经有handler，即容器已经启动。调用链码的时候，也会获取handler</span></span><br><span class="line">	<span class="keyword">if</span> cs.HandlerRegistry.Handler(cname) != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 否则启动容器，设置handler</span></span><br><span class="line">	<span class="keyword">return</span> cs.Launcher.Launch(ccci)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RuntimeLauncher)</span> <span class="title">Launch</span><span class="params">(ccci *ccprovider.ChaincodeContainerInfo)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> startFailCh <span class="keyword">chan</span> error</span><br><span class="line">	<span class="keyword">var</span> timeoutCh &lt;-<span class="keyword">chan</span> time.Time</span><br><span class="line"></span><br><span class="line">	startTime := time.Now()</span><br><span class="line">	cname := ccci.Name + <span class="string">":"</span> + ccci.Version</span><br><span class="line">	launchState, alreadyStarted := r.Registry.Launching(cname)</span><br><span class="line">	<span class="comment">// 链码容器未启动，启动容器</span></span><br><span class="line">	<span class="keyword">if</span> !alreadyStarted &#123;</span><br><span class="line">		startFailCh = <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="number">1</span>)</span><br><span class="line">		timeoutCh = time.NewTimer(r.StartupTimeout).C</span><br><span class="line"></span><br><span class="line">		codePackage, err := r.getCodePackage(ccci)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="comment">// 启动容器</span></span><br><span class="line">			<span class="keyword">if</span> err := r.Runtime.Start(ccci, codePackage); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				startFailCh &lt;- errors.WithMessage(err, <span class="string">"error starting container"</span>)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			exitCode, err := r.Runtime.Wait(ccci)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				launchState.Notify(errors.Wrap(err, <span class="string">"failed to wait on container exit"</span>))</span><br><span class="line">			&#125;</span><br><span class="line">			launchState.Notify(errors.Errorf(<span class="string">"container exited with %d"</span>, exitCode))</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Runtime is used to manage chaincode runtime instances.</span></span><br><span class="line"><span class="keyword">type</span> Runtime <span class="keyword">interface</span> &#123;</span><br><span class="line">	Start(ccci *ccprovider.ChaincodeContainerInfo, codePackage []<span class="keyword">byte</span>) error</span><br><span class="line">	Stop(ccci *ccprovider.ChaincodeContainerInfo) error</span><br><span class="line">	Wait(ccci *ccprovider.ChaincodeContainerInfo) (<span class="keyword">int</span>, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ContainerRuntime</code>是core.chaincode封装出来和core.container交互的，在这里它会创建启动链码请求，交给container。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start launches chaincode in a runtime environment.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ContainerRuntime)</span> <span class="title">Start</span><span class="params">(ccci *ccprovider.ChaincodeContainerInfo, codePackage []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	cname := ccci.Name + <span class="string">":"</span> + ccci.Version</span><br><span class="line"></span><br><span class="line">	lc, err := c.LaunchConfig(cname, ccci.Type)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	chaincodeLogger.Debugf(<span class="string">"start container: %s"</span>, cname)</span><br><span class="line">	chaincodeLogger.Debugf(<span class="string">"start container with args: %s"</span>, strings.Join(lc.Args, <span class="string">" "</span>))</span><br><span class="line">	chaincodeLogger.Debugf(<span class="string">"start container with env:\n\t%s"</span>, strings.Join(lc.Envs, <span class="string">"\n\t"</span>))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动链码的请求</span></span><br><span class="line">	scr := container.StartContainerReq&#123;</span><br><span class="line">		Builder: &amp;container.PlatformBuilder&#123;</span><br><span class="line">			Type:             ccci.Type,</span><br><span class="line">			Name:             ccci.Name,</span><br><span class="line">			Version:          ccci.Version,</span><br><span class="line">			Path:             ccci.Path,</span><br><span class="line">			CodePackage:      codePackage,</span><br><span class="line">			PlatformRegistry: c.PlatformRegistry,</span><br><span class="line">		&#125;,</span><br><span class="line">		Args:          lc.Args,</span><br><span class="line">		Env:           lc.Envs,</span><br><span class="line">		FilesToUpload: lc.Files,</span><br><span class="line">		CCID: ccintf.CCID&#123;</span><br><span class="line">			Name:    ccci.Name,</span><br><span class="line">			Version: ccci.Version,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 处理容器操作请求</span></span><br><span class="line">	<span class="keyword">if</span> err := c.Processor.Process(ccci.ContainerType, scr); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.WithMessage(err, <span class="string">"error starting container"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Processor processes vm and container requests.</span></span><br><span class="line"><span class="keyword">type</span> Processor <span class="keyword">interface</span> &#123;</span><br><span class="line">	Process(vmtype <span class="keyword">string</span>, req container.VMCReq) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="core-container-1"><a href="#core-container-1" class="headerlink" title="core.container"></a>core.container</h3><p><code>VMController</code>实现了Processor，它会按指定的类型建立虚拟机，明明就是容器，为啥内部又叫VM，VM有2种：</p>
<ol>
<li>InprocVM，意思是运行在单独进程中的虚拟机，但不是指操作系统的进程，而是指一个隔离的环境，SCC是这类。</li>
<li>DockerVM，指利用Docker启动的容器，普通链码就是这类。</li>
</ol>
<p>类型是存在<code>ccci.ContainerType</code>中的，<code>ccci</code>包含了部署链码所需要的信息，这个信息在core.chaincode很早就获取到了，可以往前翻。</p>
<p><code>Process</code>就是创建VM，然后利用VM处理请求的过程。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据请求对VM进行某种操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(vmc *VMController)</span> <span class="title">Process</span><span class="params">(vmtype <span class="keyword">string</span>, req VMCReq)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建vm</span></span><br><span class="line">	v := vmc.newVM(vmtype)</span><br><span class="line">	ccid := req.GetCCID()</span><br><span class="line">	id := ccid.GetName()</span><br><span class="line"></span><br><span class="line">	vmc.lockContainer(id)</span><br><span class="line">	<span class="keyword">defer</span> vmc.unlockContainer(id)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 把vm传递给请求，即用该vm执行请求内容</span></span><br><span class="line">	<span class="keyword">return</span> req.Do(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="虚拟机创建"><a href="#虚拟机创建" class="headerlink" title="虚拟机创建"></a>虚拟机创建</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用指定类型的vm provider创建vm</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(vmc *VMController)</span> <span class="title">newVM</span><span class="params">(typ <span class="keyword">string</span>)</span> <span class="title">VM</span></span> &#123;</span><br><span class="line">	v, ok := vmc.vmProviders[typ]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		vmLogger.Panicf(<span class="string">"Programming error: unsupported VM type: %s"</span>, typ)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> v.NewVM()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewVMController creates a new instance of VMController</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewVMController</span><span class="params">(vmProviders <span class="keyword">map</span>[<span class="keyword">string</span>]VMProvider)</span> *<span class="title">VMController</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;VMController&#123;</span><br><span class="line">		containerLocks: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*refCountedLock),</span><br><span class="line">		vmProviders:    vmProviders,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建VM需要使用<code>NewVMController</code>，回过去找它的创建地方。</p>
<p>在注册SCC的过程中，调用<code>registerChaincodeSupport</code>创建了<code>chaincodeSupport</code>，其中一个字段为创建<code>NewVMController</code>，就包含了2类Vm provider：</p>
<ol>
<li>ipRegistry，SCC的</li>
<li>dockerProvider，普通链码的</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">registerChaincodeSupport</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	grpcServer *comm.GRPCServer,</span></span></span><br><span class="line"><span class="function"><span class="params">	ccEndpoint <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	ca tlsgen.CA,</span></span></span><br><span class="line"><span class="function"><span class="params">	packageProvider *persistence.PackageProvider,</span></span></span><br><span class="line"><span class="function"><span class="params">	aclProvider aclmgmt.ACLProvider,</span></span></span><br><span class="line"><span class="function"><span class="params">	pr *platforms.Registry,</span></span></span><br><span class="line"><span class="function"><span class="params">	lifecycleSCC *lifecycle.SCC,</span></span></span><br><span class="line"><span class="function"><span class="params">	ops *operations.System,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(*chaincode.ChaincodeSupport, ccprovider.ChaincodeProvider, *scc.Provider)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// SCC的VM provider</span></span><br><span class="line">	ipRegistry := inproccontroller.NewRegistry()</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 普通链码，docker容器类型的VM provider</span></span><br><span class="line">	dockerProvider := dockercontroller.NewProvider(</span><br><span class="line">		viper.GetString(<span class="string">"peer.id"</span>),</span><br><span class="line">		viper.GetString(<span class="string">"peer.networkId"</span>),</span><br><span class="line">		ops.Provider,</span><br><span class="line">	)</span><br><span class="line">    ...</span><br><span class="line">    chaincodeSupport := chaincode.NewChaincodeSupport(</span><br><span class="line">		chaincode.GlobalConfig(),</span><br><span class="line">		ccEndpoint,</span><br><span class="line">		userRunsCC,</span><br><span class="line">		ca.CertBytes(),</span><br><span class="line">		authenticator,</span><br><span class="line">		packageProvider,</span><br><span class="line">		lsccInst, <span class="comment">// chaincodeSupport的声明周期管理使用了lscc，而不是lifecycle</span></span><br><span class="line">		aclProvider,</span><br><span class="line">        <span class="comment">// 创建了VM controller，controller提供了inproc和docker 2中子controller，</span></span><br><span class="line">		<span class="comment">// 即2中链码运行方式</span></span><br><span class="line">		container.NewVMController(</span><br><span class="line">			<span class="keyword">map</span>[<span class="keyword">string</span>]container.VMProvider&#123;</span><br><span class="line">				dockercontroller.ContainerType: dockerProvider,</span><br><span class="line">				inproccontroller.ContainerType: ipRegistry,</span><br><span class="line">			&#125;,</span><br><span class="line">		),</span><br><span class="line">		sccp,</span><br><span class="line">		pr,</span><br><span class="line">		peer.DefaultSupport,</span><br><span class="line">		ops.Provider,</span><br><span class="line">	)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="VM处理操作虚拟机的请求"><a href="#VM处理操作虚拟机的请求" class="headerlink" title="VM处理操作虚拟机的请求"></a>VM处理操作虚拟机的请求</h4><p>core.container的请求，都实现了<code>VMCReq</code>接口，StartContainerReq、StopContainerReq、WaitContainerReq是实现VMCReq的3类请求。</p>
<p>启动实际是启动虚拟机接口，处理请求。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//VMCReq - all requests should implement this interface.</span></span><br><span class="line"><span class="comment">//The context should be passed and tested at each layer till we stop</span></span><br><span class="line"><span class="comment">//note that we'd stop on the first method on the stack that does not</span></span><br><span class="line"><span class="comment">//take context</span></span><br><span class="line"><span class="keyword">type</span> VMCReq <span class="keyword">interface</span> &#123;</span><br><span class="line">	Do(v VM) error</span><br><span class="line">	GetCCID() ccintf.CCID</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动容器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(si StartContainerReq)</span> <span class="title">Do</span><span class="params">(v VM)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> v.Start(si.CCID, si.Args, si.Env, si.FilesToUpload, si.Builder)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//VM is an abstract virtual image for supporting arbitrary virual machines</span></span><br><span class="line"><span class="keyword">type</span> VM <span class="keyword">interface</span> &#123;</span><br><span class="line">	Start(ccid ccintf.CCID, args []<span class="keyword">string</span>, env []<span class="keyword">string</span>, filesToUpload <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">byte</span>, builder Builder) error</span><br><span class="line">	Stop(ccid ccintf.CCID, timeout <span class="keyword">uint</span>, dontkill <span class="keyword">bool</span>, dontremove <span class="keyword">bool</span>) error</span><br><span class="line">	Wait(ccid ccintf.CCID) (<span class="keyword">int</span>, error)</span><br><span class="line">	HealthCheck(context.Context) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DockerVM和InprocVM都实现了VM接口，本文只关注InprocVM类型，即SCC的。</p>
<p>InprocVM会得到一个容器实例ipc，用它来运行SCC。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Start starts a previously registered system codechain</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(vm *InprocVM)</span> <span class="title">Start</span><span class="params">(ccid ccintf.CCID, args []<span class="keyword">string</span>, env []<span class="keyword">string</span>, filesToUpload <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">byte</span>, builder container.Builder)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	path := ccid.GetName()</span><br><span class="line"></span><br><span class="line">	ipctemplate := vm.registry.getType(path)</span><br><span class="line">	<span class="keyword">if</span> ipctemplate == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(fmt.Sprintf(<span class="string">"%s not registered"</span>, path))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 即ccid.Name</span></span><br><span class="line">	instName := vm.GetVMName(ccid)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取容器实例</span></span><br><span class="line">	ipc, err := vm.getInstance(ipctemplate, instName, args, env)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(fmt.Sprintf(<span class="string">"could not create instance for %s"</span>, instName))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 已经在运行了，还部署个啥！</span></span><br><span class="line">	<span class="keyword">if</span> ipc.running &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(fmt.Sprintf(<span class="string">"chaincode running %s"</span>, path))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ipc.running = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">				inprocLogger.Criticalf(<span class="string">"caught panic from chaincode  %s"</span>, instName)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">		<span class="comment">// 启动进程级容器</span></span><br><span class="line">		ipc.launchInProc(instName, args, env)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>inprocContainer</code>开启2个goroutine：</p>
<ol>
<li>第一个调用<code>shimStartInProc</code>，即利用core.chaincode.shim启动InProc类型的容器。</li>
<li>第二个调用<code>HandleChaincodeStream</code>，处理peer和Inproc容器间的通信数据，此处的stream是peer端的。</li>
</ol>
<p>这里可以看到创建了2个通道<code>peerRcvCCSend</code>和<code>ccRcvPeerSend</code>，它们表明了peer和scc的链码容器是通过通道直接通信的。peer和docker链码容器之间是走gRPC通信的，这个到普通链码的时候再介绍。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从进程启动链码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ipc *inprocContainer)</span> <span class="title">launchInProc</span><span class="params">(id <span class="keyword">string</span>, args []<span class="keyword">string</span>, env []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> ipc.ChaincodeSupport == <span class="literal">nil</span> &#123;</span><br><span class="line">		inprocLogger.Panicf(<span class="string">"Chaincode support is nil, most likely you forgot to set it immediately after calling inproccontroller.NewRegsitry()"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 和调用链码的上层通信的2个通道</span></span><br><span class="line">	peerRcvCCSend := <span class="built_in">make</span>(<span class="keyword">chan</span> *pb.ChaincodeMessage)</span><br><span class="line">	ccRcvPeerSend := <span class="built_in">make</span>(<span class="keyword">chan</span> *pb.ChaincodeMessage)</span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	ccchan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">	ccsupportchan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">	shimStartInProc := _shimStartInProc <span class="comment">// shadow to avoid race in test</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(ccchan)</span><br><span class="line">		<span class="comment">// 启动链码</span></span><br><span class="line">		inprocLogger.Debugf(<span class="string">"chaincode started for %s"</span>, id)</span><br><span class="line">		<span class="keyword">if</span> args == <span class="literal">nil</span> &#123;</span><br><span class="line">			args = ipc.args</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> env == <span class="literal">nil</span> &#123;</span><br><span class="line">			env = ipc.env</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 利用shim启动</span></span><br><span class="line">		err := shimStartInProc(env, args, ipc.chaincode, ccRcvPeerSend, peerRcvCCSend)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			err = fmt.Errorf(<span class="string">"chaincode-support ended with err: %s"</span>, err)</span><br><span class="line">			_inprocLoggerErrorf(<span class="string">"%s"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		inprocLogger.Debugf(<span class="string">"chaincode ended for %s with err: %s"</span>, id, err)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// shadow function to avoid data race</span></span><br><span class="line">	inprocLoggerErrorf := _inprocLoggerErrorf</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(ccsupportchan)</span><br><span class="line">		<span class="comment">// 处理scc和外部通信的消息流</span></span><br><span class="line">		inprocStream := newInProcStream(peerRcvCCSend, ccRcvPeerSend)</span><br><span class="line">		inprocLogger.Debugf(<span class="string">"chaincode-support started for  %s"</span>, id)</span><br><span class="line">		err := ipc.ChaincodeSupport.HandleChaincodeStream(inprocStream)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			err = fmt.Errorf(<span class="string">"chaincode ended with err: %s"</span>, err)</span><br><span class="line">			inprocLoggerErrorf(<span class="string">"%s"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		inprocLogger.Debugf(<span class="string">"chaincode-support ended for %s with err: %s"</span>, id, err)</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="利用shim启动Inproc链码容器中的程序"><a href="#利用shim启动Inproc链码容器中的程序" class="headerlink" title="利用shim启动Inproc链码容器中的程序"></a>利用shim启动Inproc链码容器中的程序</h4><p>shim是chaincode提供给容器，运行链码的工具，它运行在容器里。</p>
<p>利用shim启动InprocVM使用的函数是<code>StartInProc</code>，提取一些<strong>运行链码</strong>需要的数据，比如又一个stream，此处的stream是容器端的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动SCC的入口</span></span><br><span class="line"><span class="comment">// StartInProc is an entry point for system chaincodes bootstrap. It is not an</span></span><br><span class="line"><span class="comment">// API for chaincodes.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StartInProc</span><span class="params">(env []<span class="keyword">string</span>, args []<span class="keyword">string</span>, cc Chaincode, recv &lt;-<span class="keyword">chan</span> *pb.ChaincodeMessage, send <span class="keyword">chan</span>&lt;- *pb.ChaincodeMessage)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// 有点奇怪，这些日志都没有看到，因为已经在shim，不属于peer日志了</span></span><br><span class="line">	chaincodeLogger.Debugf(<span class="string">"in proc %v"</span>, args)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从环境变量获取cc name</span></span><br><span class="line">	<span class="keyword">var</span> chaincodename <span class="keyword">string</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> env &#123;</span><br><span class="line">		<span class="keyword">if</span> strings.Index(v, <span class="string">"CORE_CHAINCODE_ID_NAME="</span>) == <span class="number">0</span> &#123;</span><br><span class="line">			p := strings.SplitAfter(v, <span class="string">"CORE_CHAINCODE_ID_NAME="</span>)</span><br><span class="line">			chaincodename = p[<span class="number">1</span>]</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> chaincodename == <span class="string">""</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">"error chaincode id not provided"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建peer和chaincode通信的通道</span></span><br><span class="line">	stream := newInProcStream(recv, send)</span><br><span class="line">	chaincodeLogger.Debugf(<span class="string">"starting chat with peer using name=%s"</span>, chaincodename)</span><br><span class="line">	<span class="comment">// 与peer进行通信</span></span><br><span class="line">	err := chatWithPeer(chaincodename, stream, cc)</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>chatWithPeer</code>是通用的，普通的链码也调用这个程序。它创建了一个handler，用来处理消息（发送和接收），以及操作（调用）链码。</p>
<p>这个过程，它会向peer发送REGISTER消息，和peer先“握手”，也会从peer读消息，消息的处理函数就是里面的for循环，这样链码容器就运行起来了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用，SCC和CC都使用这个函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chatWithPeer</span><span class="params">(chaincodename <span class="keyword">string</span>, stream PeerChaincodeStream, cc Chaincode)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// 把stream和cc交给handler，handler可以发送和接收数据，即读写通道</span></span><br><span class="line">	<span class="comment">// Create the shim handler responsible for all control logic</span></span><br><span class="line">	handler := newChaincodeHandler(stream, cc)</span><br><span class="line">	<span class="keyword">defer</span> stream.CloseSend()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Send the ChaincodeID during register.</span></span><br><span class="line">	chaincodeID := &amp;pb.ChaincodeID&#123;Name: chaincodename&#125;</span><br><span class="line">	payload, err := proto.Marshal(chaincodeID)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.Wrap(err, <span class="string">"error marshalling chaincodeID during chaincode registration"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在stream上向peer发送注册消息</span></span><br><span class="line">	<span class="comment">// Register on the stream</span></span><br><span class="line">	chaincodeLogger.Debugf(<span class="string">"Registering.. sending %s"</span>, pb.ChaincodeMessage_REGISTER)</span><br><span class="line">	<span class="keyword">if</span> err = handler.serialSend(&amp;pb.ChaincodeMessage&#123;Type: pb.ChaincodeMessage_REGISTER, Payload: payload&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.WithMessage(err, <span class="string">"error sending chaincode REGISTER"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// holds return values from gRPC Recv below</span></span><br><span class="line">	<span class="keyword">type</span> recvMsg <span class="keyword">struct</span> &#123;</span><br><span class="line">		msg *pb.ChaincodeMessage</span><br><span class="line">		err error</span><br><span class="line">	&#125;</span><br><span class="line">	msgAvail := <span class="built_in">make</span>(<span class="keyword">chan</span> *recvMsg, <span class="number">1</span>)</span><br><span class="line">	errc := <span class="built_in">make</span>(<span class="keyword">chan</span> error)</span><br><span class="line"></span><br><span class="line">	receiveMessage := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		in, err := stream.Recv()</span><br><span class="line">		msgAvail &lt;- &amp;recvMsg&#123;in, err&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 异步读取1个消息</span></span><br><span class="line">	<span class="keyword">go</span> receiveMessage()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 循环处理peer发送的消息</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> rmsg := &lt;-msgAvail:</span><br><span class="line">			<span class="keyword">switch</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> rmsg.err == io.EOF:</span><br><span class="line">				err = errors.Wrapf(rmsg.err, <span class="string">"received EOF, ending chaincode stream"</span>)</span><br><span class="line">				chaincodeLogger.Debugf(<span class="string">"%+v"</span>, err)</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			<span class="keyword">case</span> rmsg.err != <span class="literal">nil</span>:</span><br><span class="line">				err := errors.Wrap(rmsg.err, <span class="string">"receive failed"</span>)</span><br><span class="line">				chaincodeLogger.Errorf(<span class="string">"Received error from server, ending chaincode stream: %+v"</span>, err)</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			<span class="keyword">case</span> rmsg.msg == <span class="literal">nil</span>:</span><br><span class="line">				err := errors.New(<span class="string">"received nil message, ending chaincode stream"</span>)</span><br><span class="line">				chaincodeLogger.Debugf(<span class="string">"%+v"</span>, err)</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="comment">// 处理消息</span></span><br><span class="line">				chaincodeLogger.Debugf(<span class="string">"[%s]Received message %s from peer"</span>, shorttxid(rmsg.msg.Txid), rmsg.msg.Type)</span><br><span class="line">				err := handler.handleMessage(rmsg.msg, errc)</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					err = errors.WithMessage(err, <span class="string">"error handling message"</span>)</span><br><span class="line">					<span class="keyword">return</span> err</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 读取下一个消息</span></span><br><span class="line">				<span class="keyword">go</span> receiveMessage()</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> sendErr := &lt;-errc:</span><br><span class="line">			<span class="keyword">if</span> sendErr != <span class="literal">nil</span> &#123;</span><br><span class="line">				err := errors.Wrap(sendErr, <span class="string">"error sending"</span>)</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的消息处理函数，先跳过，回过头来，关注scc容器和peer的通信。</p>
<h4 id="SCC和Peer的通信通道"><a href="#SCC和Peer的通信通道" class="headerlink" title="SCC和Peer的通信通道"></a>SCC和Peer的通信通道</h4><p>链码容器和Peer之间使用Stream进行通信，Stream有2种实现：</p>
<ol>
<li>使用channel封装的Stream</li>
<li>gRPC的Stream</li>
</ol>
<p><img src="http://img.lessisbetter.site/2019-09-peer-cc-communication.png" alt=""></p>
<p>链码容器和Peer通信的接口是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PeerChaincodeStream interface for stream between Peer and chaincode instance.</span></span><br><span class="line"><span class="keyword">type</span> PeerChaincodeStream <span class="keyword">interface</span> &#123;</span><br><span class="line">	Send(*pb.ChaincodeMessage) error</span><br><span class="line">	Recv() (*pb.ChaincodeMessage, error)</span><br><span class="line">	CloseSend() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>普通链码使用gRPC：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> chaincodeSupportRegisterClient <span class="keyword">struct</span> &#123;</span><br><span class="line">	grpc.ClientStream</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>系统链码直接使用通道通信，发送和接收消息都在下面了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// peer和chaincode之间通信的通道</span></span><br><span class="line"><span class="comment">// PeerChaincodeStream interface for stream between Peer and chaincode instance.</span></span><br><span class="line"><span class="keyword">type</span> inProcStream <span class="keyword">struct</span> &#123;</span><br><span class="line">	recv &lt;-<span class="keyword">chan</span> *pb.ChaincodeMessage</span><br><span class="line">	send <span class="keyword">chan</span>&lt;- *pb.ChaincodeMessage</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newInProcStream</span><span class="params">(recv &lt;-<span class="keyword">chan</span> *pb.ChaincodeMessage, send <span class="keyword">chan</span>&lt;- *pb.ChaincodeMessage)</span> *<span class="title">inProcStream</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;inProcStream&#123;recv, send&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送其实就是向send写数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *inProcStream)</span> <span class="title">Send</span><span class="params">(msg *pb.ChaincodeMessage)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	err = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//send may happen on a closed channel when the system is</span></span><br><span class="line">	<span class="comment">//shutting down. Just catch the exception and return error</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">			err = SendPanicFailure(fmt.Sprintf(<span class="string">"%s"</span>, r))</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	s.send &lt;- msg</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收是从recv读数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *inProcStream)</span> <span class="title">Recv</span><span class="params">()</span> <span class="params">(*pb.ChaincodeMessage, error)</span></span> &#123;</span><br><span class="line">	msg, ok := &lt;-s.recv</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"channel is closed"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> msg, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *inProcStream)</span> <span class="title">CloseSend</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// 实际啥也没做</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Peer和链码容器的交互，完成链码容器启动"><a href="#Peer和链码容器的交互，完成链码容器启动" class="headerlink" title="Peer和链码容器的交互，完成链码容器启动"></a>Peer和链码容器的交互，完成链码容器启动</h3><p>部署链码需要Peer和链码容器交互，不然Peer怎么知道链码容器已经启动。以下是一份peer的DEBUG日志，在下面标注了启动容器和链码Init过程中的消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">2019-09-09 07:52:09.915 UTC [chaincode] LaunchConfig -&gt; DEBU 098 launchConfig: executable:&quot;chaincode&quot;,Args:[chaincode,-peer.address=peer0.org1.example.com:7052],Envs:[CORE_CHAINCODE_LOGGING_LEVEL=info,CORE_CHAINCODE_LOGGING_SHIM=warning,CORE_CHAINCODE_LOGGING_FORMAT=%&#123;color&#125;%&#123;time:2006-01-02 15:04:05.000 MST&#125; [%&#123;module&#125;] %&#123;shortfunc&#125; -&gt; %&#123;level:.4s&#125; %&#123;id:03x&#125;%&#123;color:reset&#125; %&#123;message&#125;,CORE_CHAINCODE_ID_NAME=lscc:1.4.3,CORE_PEER_TLS_ENABLED=true,CORE_TLS_CLIENT_KEY_PATH=/etc/hyperledger/fabric/client.key,CORE_TLS_CLIENT_CERT_PATH=/etc/hyperledger/fabric/client.crt,CORE_PEER_TLS_ROOTCERT_FILE=/etc/hyperledger/fabric/peer.crt],Files:[/etc/hyperledger/fabric/client.crt /etc/hyperledger/fabric/client.key /etc/hyperledger/fabric/peer.crt]</span><br><span class="line">2019-09-09 07:52:09.915 UTC [chaincode] Start -&gt; DEBU 099 start container: lscc:1.4.3</span><br><span class="line">2019-09-09 07:52:09.915 UTC [chaincode] Start -&gt; DEBU 09a start container with args: chaincode -peer.address=peer0.org1.example.com:7052</span><br><span class="line">2019-09-09 07:52:09.915 UTC [chaincode] Start -&gt; DEBU 09b start container with env:</span><br><span class="line">	CORE_CHAINCODE_LOGGING_LEVEL=info</span><br><span class="line">	CORE_CHAINCODE_LOGGING_SHIM=warning</span><br><span class="line">	CORE_CHAINCODE_LOGGING_FORMAT=%&#123;color&#125;%&#123;time:2006-01-02 15:04:05.000 MST&#125; [%&#123;module&#125;] %&#123;shortfunc&#125; -&gt; %&#123;level:.4s&#125; %&#123;id:03x&#125;%&#123;color:reset&#125; %&#123;message&#125;</span><br><span class="line">	CORE_CHAINCODE_ID_NAME=lscc:1.4.3</span><br><span class="line">	CORE_PEER_TLS_ENABLED=true</span><br><span class="line">	CORE_TLS_CLIENT_KEY_PATH=/etc/hyperledger/fabric/client.key</span><br><span class="line">	CORE_TLS_CLIENT_CERT_PATH=/etc/hyperledger/fabric/client.crt</span><br><span class="line">	CORE_PEER_TLS_ROOTCERT_FILE=/etc/hyperledger/fabric/peer.crt</span><br><span class="line">2019-09-09 07:52:09.915 UTC [container] lockContainer -&gt; DEBU 09c waiting for container(lscc-1.4.3) lock</span><br><span class="line">2019-09-09 07:52:09.915 UTC [container] lockContainer -&gt; DEBU 09d got container (lscc-1.4.3) lock</span><br><span class="line">2019-09-09 07:52:09.915 UTC [inproccontroller] getInstance -&gt; DEBU 09e chaincode instance created for lscc-1.4.3</span><br><span class="line">2019-09-09 07:52:09.915 UTC [container] unlockContainer -&gt; DEBU 09f container lock deleted(lscc-1.4.3)</span><br><span class="line">2019-09-09 07:52:09.915 UTC [container] lockContainer -&gt; DEBU 0a0 waiting for container(lscc-1.4.3) lock</span><br><span class="line">2019-09-09 07:52:09.915 UTC [container] lockContainer -&gt; DEBU 0a1 got container (lscc-1.4.3) lock</span><br><span class="line">2019-09-09 07:52:09.915 UTC [container] unlockContainer -&gt; DEBU 0a2 container lock deleted(lscc-1.4.3)</span><br><span class="line">2019-09-09 07:52:09.915 UTC [inproccontroller] func2 -&gt; DEBU 0a3 chaincode-support started for  lscc-1.4.3</span><br><span class="line">2019-09-09 07:52:09.915 UTC [inproccontroller] func1 -&gt; DEBU 0a4 chaincode started for lscc-1.4.3</span><br><span class="line">// 以上日志对应的代码流程在上文都讲到了</span><br><span class="line"></span><br><span class="line">// 以下是交互过程peer日志</span><br><span class="line">// peer收到容器的注册消息</span><br><span class="line">2019-09-09 07:52:09.916 UTC [chaincode] handleMessage -&gt; DEBU 0a5 [] Fabric side handling ChaincodeMessage of type: REGISTER in state created</span><br><span class="line">2019-09-09 07:52:09.916 UTC [chaincode] HandleRegister -&gt; DEBU 0a6 Received REGISTER in state created</span><br><span class="line">2019-09-09 07:52:09.916 UTC [chaincode] Register -&gt; DEBU 0a7 registered handler complete for chaincode lscc:1.4.3</span><br><span class="line">2019-09-09 07:52:09.916 UTC [chaincode] HandleRegister -&gt; DEBU 0a8 Got REGISTER for chaincodeID = name:&quot;lscc:1.4.3&quot; , sending back REGISTERED</span><br><span class="line">2019-09-09 07:52:09.920 UTC [grpc] HandleSubConnStateChange -&gt; DEBU 0a9 pickfirstBalancer: HandleSubConnStateChange: 0xc0026318c0, READY</span><br><span class="line">2019-09-09 07:52:09.923 UTC [chaincode] HandleRegister -&gt; DEBU 0aa Changed state to established for name:&quot;lscc:1.4.3&quot;</span><br><span class="line"></span><br><span class="line">// peer发送ready消息</span><br><span class="line">2019-09-09 07:52:09.923 UTC [chaincode] sendReady -&gt; DEBU 0ab sending READY for chaincode name:&quot;lscc:1.4.3&quot;</span><br><span class="line">2019-09-09 07:52:09.923 UTC [chaincode] sendReady -&gt; DEBU 0ac Changed to state ready for chaincode name:&quot;lscc:1.4.3&quot;</span><br><span class="line"></span><br><span class="line">// 已经完成启动容器</span><br><span class="line">2019-09-09 07:52:09.923 UTC [chaincode] Launch -&gt; DEBU 0ad launch complete</span><br><span class="line">2019-09-09 07:52:09.924 UTC [chaincode] Execute -&gt; DEBU 0ae Entry</span><br><span class="line">// 收到容器COMPLETED消息</span><br><span class="line">2019-09-09 07:52:09.925 UTC [chaincode] handleMessage -&gt; DEBU 0af [01b03aae] Fabric side handling ChaincodeMessage of type: COMPLETED in state ready</span><br><span class="line"></span><br><span class="line">// 通知scc，部署已经完成</span><br><span class="line">2019-09-09 07:52:09.925 UTC [chaincode] Notify -&gt; DEBU 0b0 [01b03aae] notifying Txid:01b03aae-17a6-4b63-874e-dc20d6f5df0c, channelID:</span><br><span class="line">2019-09-09 07:52:09.925 UTC [chaincode] Execute -&gt; DEBU 0b1 Exit</span><br><span class="line">2019-09-09 07:52:09.925 UTC [sccapi] deploySysCC -&gt; INFO 0b2 system chaincode lscc/(github.com/hyperledger/fabric/core/scc/lscc) deployed</span><br></pre></td></tr></table></figure>
<p>可以到REGISTER、READY、COMPLETED等消息，以及状态的改变：created、ready。</p>
<p>但前面还没有介绍Peer和链码容器之间的通信，所以不展示代码了，展示一下Peer和链码容器的消息交互图：</p>
<p><img src="http://img.lessisbetter.site/2019-09-deploycc-msg.png" alt=""></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2019/09/06/fabric-source-endorser-policy-flow/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="区块链、Go语言">
      <meta itemprop="image" content="http://img.lessisbetter.site/gzh-qrcode-logo-small.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Go语言充电站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/06/fabric-source-endorser-policy-flow/" class="post-title-link" itemprop="url">Fabric源码解读 1：背书策略是怎么使用的</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-09-06 16:39:45 / 修改时间：16:45:58" itemprop="dateCreated datePublished" datetime="2019-09-06T16:39:45+08:00">2019-09-06</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://img.lessisbetter.site/2019-09-endorser-policy.png" alt="endorser policy"></p>
<p>背书策略是Fabric中的一个重要一环，想梳理一下背书策略的上链和使用流程。</p>
<p>背书策略是部署和升级链码时使用的，需要发送配置交易，所以尝试了从背书节点收到交易，然后处理交易的流程入手，找到背书策略的入口，结果毫无头绪。</p>
<p>换一种思路，从使用入手，向上追溯，这种就非常顺利了。</p>
<h2 id="从背书策略的使用入手"><a href="#从背书策略的使用入手" class="headerlink" title="从背书策略的使用入手"></a>从背书策略的使用入手</h2><p>VSCC会利用背书策略，并且背书策略不满足时会返回一个：背书策略不满足的错误，每一个上链的交易详细中都有这么一个Validation字段，为0代表有效交易，否则是无效交易，并用数字表示原因，背书策略不满足的序号就是10。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TxValidationCode <span class="keyword">int32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	...</span><br><span class="line">	TxValidationCode_ENDORSEMENT_POLICY_FAILURE   TxValidationCode = <span class="number">10</span></span><br><span class="line">	...</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><code>TxValidationCode_ENDORSEMENT_POLICY_FAILURE</code>被<code>VSCCValidateTx</code>使用，系统链码和普通链码都有背书策略需要满足，下面代码片是普通链码部分，可以发小调用<code>VSCCValidateTxForCC</code>验证交易。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// VSCCValidateTx executes vscc validation for transaction</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *VsccValidatorImpl)</span> <span class="title">VSCCValidateTx</span><span class="params">(seq <span class="keyword">int</span>, payload *common.Payload, envBytes []<span class="keyword">byte</span>, block *common.Block)</span> <span class="params">(error, peer.TxValidationCode)</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> err = v.VSCCValidateTxForCC(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> err.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> *commonerrors.VSCCEndorsementPolicyError:</span><br><span class="line">      <span class="keyword">return</span> err, peer.TxValidationCode_ENDORSEMENT_POLICY_FAILURE</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> err, peer.TxValidationCode_INVALID_OTHER_REASON</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个chaincode都会提供escc和vscc，现在都是默认的，也就是说escc和vscc都可以是具备可插拔的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode list -C mychannel --instantiated</span><br><span class="line">Get instantiated chaincodes on channel mychannel:</span><br><span class="line">Name: mycc, Version: 1.1, Path: github.com/chaincode/chaincode_example02/go/, Escc: escc, Vscc: vscc</span><br></pre></td></tr></table></figure>
<p><code>VSCCValidateTxForCC</code>会从交易的context中获取验证插件，然后利用插件验证交易。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *VsccValidatorImpl)</span> <span class="title">VSCCValidateTxForCC</span><span class="params">(ctx *Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	logger.Debug(<span class="string">"Validating"</span>, ctx, <span class="string">"with plugin"</span>)</span><br><span class="line">  <span class="comment">// 使用插件验证交易</span></span><br><span class="line">	err := v.pluginValidator.ValidateWithPlugin(ctx)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// If the error is a pluggable validation execution error, cast it to the common errors ExecutionFailureError.</span></span><br><span class="line">	<span class="keyword">if</span> e, isExecutionError := err.(*validation.ExecutionFailureError); isExecutionError &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;commonerrors.VSCCExecutionFailureError&#123;Err: e&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Else, treat it as an endorsement error.</span></span><br><span class="line">	<span class="keyword">return</span> &amp;commonerrors.VSCCEndorsementPolicyError&#123;Err: err&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pv *PluginValidator)</span> <span class="title">ValidateWithPlugin</span><span class="params">(ctx *Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// 获取vscc插件</span></span><br><span class="line">	plugin, err := pv.getOrCreatePlugin(ctx)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;validation.ExecutionFailureError&#123;</span><br><span class="line">			Reason: fmt.Sprintf(<span class="string">"plugin with name %s couldn't be used: %v"</span>, ctx.VSCCName, err),</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 利用插件验证</span></span><br><span class="line">	err = plugin.Validate(ctx.Block, ctx.Namespace, ctx.Seq, <span class="number">0</span>, SerializedPolicy(ctx.Policy))</span><br><span class="line">	validityStatus := <span class="string">"valid"</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		validityStatus = fmt.Sprintf(<span class="string">"invalid: %v"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	logger.Debug(<span class="string">"Transaction"</span>, ctx.TxID, <span class="string">"appears to be"</span>, validityStatus)</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Plugin validates transactions</span></span><br><span class="line"><span class="keyword">type</span> Plugin <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Validate returns nil if the action at the given position inside the transaction</span></span><br><span class="line">	<span class="comment">// at the given position in the given block is valid, or an error if not.</span></span><br><span class="line">	Validate(block *common.Block, namespace <span class="keyword">string</span>, txPosition <span class="keyword">int</span>, actionPosition <span class="keyword">int</span>, contextData ...ContextDatum) error</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Init injects dependencies into the instance of the Plugin</span></span><br><span class="line">	Init(dependencies ...Dependency) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当前验证插件有2种实现，<code>TxValidatorV1_2</code>和<code>V1_3Validation</code>,<code>Validate</code>还从context取出了序列化的背书策略，vscc会调用PolicyEvalutor交易的背书是否满足背书策略。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">func (v *DefaultValidation) Validate(block *common.Block, namespace string, txPosition int, actionPosition int, contextData ...validation.ContextDatum) error &#123;</span><br><span class="line">	if len(contextData) == 0 &#123;</span><br><span class="line">		logger.Panicf(&quot;Expected to receive policy bytes in context data&quot;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 拿到序列化后的policy</span><br><span class="line">	serializedPolicy, isSerializedPolicy := contextData[0].(SerializedPolicy)</span><br><span class="line">	if !isSerializedPolicy &#123;</span><br><span class="line">		logger.Panicf(&quot;Expected to receive a serialized policy in the first context data&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	if block == nil || block.Data == nil &#123;</span><br><span class="line">		return errors.New(&quot;empty block&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	if txPosition &gt;= len(block.Data.Data) &#123;</span><br><span class="line">		return errors.Errorf(&quot;block has only %d transactions, but requested tx at position %d&quot;, len(block.Data.Data), txPosition)</span><br><span class="line">	&#125;</span><br><span class="line">	if block.Header == nil &#123;</span><br><span class="line">		return errors.Errorf(&quot;no block header&quot;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 调用不同版本的validator进行验证</span><br><span class="line">	var err error</span><br><span class="line">	switch &#123;</span><br><span class="line">	case v.Capabilities.V1_3Validation():</span><br><span class="line">		err = v.TxValidatorV1_3.Validate(block, namespace, txPosition, actionPosition, serializedPolicy.Bytes())</span><br><span class="line"></span><br><span class="line">	case v.Capabilities.V1_2Validation():</span><br><span class="line">		fallthrough</span><br><span class="line"></span><br><span class="line">	default:</span><br><span class="line">		err = v.TxValidatorV1_2.Validate(block, namespace, txPosition, actionPosition, serializedPolicy.Bytes())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	logger.Debugf(&quot;block %d, namespace: %s, tx %d validation results is: %v&quot;, block.Header.Number, namespace, txPosition, err)</span><br><span class="line">	return convertErrorTypeOrPanic(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 验证代码使用v2/validation_logic.go中的实现</span><br><span class="line">// Validate validates the given envelope corresponding to a transaction with an endorsement</span><br><span class="line">// policy as given in its serialized form</span><br><span class="line">func (vscc *Validator) Validate(</span><br><span class="line">	block *common.Block,</span><br><span class="line">	namespace string,</span><br><span class="line">	txPosition int,</span><br><span class="line">	actionPosition int,</span><br><span class="line">	policyBytes []byte,</span><br><span class="line">) commonerrors.TxValidationError &#123;</span><br><span class="line">  ...</span><br><span class="line">  // evaluate the signature set against the policy</span><br><span class="line">  err = vscc.policyEvaluator.Evaluate(policyBytes, signatureSet)</span><br><span class="line">  if err != nil &#123;</span><br><span class="line">    logger.Warningf(&quot;Endorsement policy failure for transaction txid=%s, err: %s&quot;, chdr.GetTxId(), err.Error())</span><br><span class="line">    if len(signatureSet) &lt; len(cap.Action.Endorsements) &#123;</span><br><span class="line">      // Warning: duplicated identities exist, endorsement failure might be cause by this reason</span><br><span class="line">      return policyErr(errors.New(DUPLICATED_IDENTITY_ERROR))</span><br><span class="line">    &#125;</span><br><span class="line">    return policyErr(fmt.Errorf(&quot;VSCC error: endorsement policy failure, err: %s&quot;, err))</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// PolicyEvaluator evaluates policies</span><br><span class="line">type PolicyEvaluator interface &#123;</span><br><span class="line">	validation.Dependency</span><br><span class="line"></span><br><span class="line">	// Evaluate takes a set of SignedData and evaluates whether this set of signatures satisfies</span><br><span class="line">	// the policy with the given bytes</span><br><span class="line">	Evaluate(policyBytes []byte, signatureSet []*common.SignedData) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Evaluate</code>会创建背书策略实例，然后利用背书策略验证背书签名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// Evaluate takes a set of SignedData and evaluates whether this set of signatures satisfies the policy</span><br><span class="line">func (id *PolicyEvaluator) Evaluate(policyBytes []byte, signatureSet []*common.SignedData) error &#123;</span><br><span class="line">	pp := cauthdsl.NewPolicyProvider(id.IdentityDeserializer)</span><br><span class="line">	policy, _, err := pp.NewPolicy(policyBytes)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return err</span><br><span class="line">	&#125;</span><br><span class="line">	return policy.Evaluate(signatureSet)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Policy is used to determine if a signature is valid</span><br><span class="line">type Policy interface &#123;</span><br><span class="line">	// Evaluate takes a set of SignedData and evaluates whether this set of signatures satisfies the policy</span><br><span class="line">	Evaluate(signatureSet []*cb.SignedData) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Evaluate takes a set of SignedData and evaluates whether this set of signatures satisfies the policy</span><br><span class="line">func (p *policy) Evaluate(signatureSet []*cb.SignedData) error &#123;</span><br><span class="line">	if p == nil &#123;</span><br><span class="line">		return fmt.Errorf(&quot;No such policy&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	idAndS := make([]IdentityAndSignature, len(signatureSet))</span><br><span class="line">	for i, sd := range signatureSet &#123;</span><br><span class="line">		idAndS[i] = &amp;deserializeAndVerify&#123;</span><br><span class="line">			signedData:   sd,</span><br><span class="line">			deserializer: p.deserializer,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ok := p.evaluator(deduplicate(idAndS), make([]bool, len(signatureSet)))</span><br><span class="line">	if !ok &#123;</span><br><span class="line">		return errors.New(&quot;signature set did not satisfy policy&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体背书验证签名的实现，当下就先不关心了。<strong>回过头来想一下，VSCC从哪拿到了背书策略？</strong></p>
<h2 id="VSCC的背书策略哪来的？"><a href="#VSCC的背书策略哪来的？" class="headerlink" title="VSCC的背书策略哪来的？"></a>VSCC的背书策略哪来的？</h2><p>回到上文第一次出现背书策略的地方：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func (pv *PluginValidator) ValidateWithPlugin(ctx *Context) error &#123;</span><br><span class="line">  err = plugin.Validate(ctx.Block, ctx.Namespace, ctx.Seq, 0, SerializedPolicy(ctx.Policy))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Context defines information about a transaction</span><br><span class="line">// that is being validated</span><br><span class="line">type Context struct &#123;</span><br><span class="line">	Seq       int</span><br><span class="line">	Envelope  []byte</span><br><span class="line">	TxID      string</span><br><span class="line">	Channel   string</span><br><span class="line">	VSCCName  string</span><br><span class="line">	Policy    []byte // 背书策略</span><br><span class="line">	Namespace string</span><br><span class="line">	Block     *common.Block</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>VSCCValidateTx</code>函数会创建Context，填写policy字段，其中policy是调用<code>GetInfoForValidate</code>获取的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *VsccValidatorImpl)</span> <span class="title">VSCCValidateTx</span><span class="params">(seq <span class="keyword">int</span>, payload *common.Payload, envBytes []<span class="keyword">byte</span>, block *common.Block)</span> <span class="params">(error, peer.TxValidationCode)</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 普通链码</span></span><br><span class="line">  <span class="keyword">if</span> !v.sccprovider.IsSysCC(ccID) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 获取policy、vscc等</span></span><br><span class="line">    <span class="comment">// Get latest chaincode version, vscc and validate policy</span></span><br><span class="line">    txcc, vscc, policy, err := v.GetInfoForValidate(chdr, ns)</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// do VSCC validation</span></span><br><span class="line">    ctx := &amp;Context&#123;</span><br><span class="line">      Seq:       seq,</span><br><span class="line">      Envelope:  envBytes,</span><br><span class="line">      Block:     block,</span><br><span class="line">      TxID:      chdr.TxId,</span><br><span class="line">      Channel:   chdr.ChannelId,</span><br><span class="line">      Namespace: ns,</span><br><span class="line">      Policy:    policy, <span class="comment">// Here</span></span><br><span class="line">      VSCCName:  vscc.ChaincodeName,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err = v.VSCCValidateTxForCC(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">switch</span> err.(<span class="keyword">type</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> *commonerrors.VSCCEndorsementPolicyError:</span><br><span class="line">        <span class="keyword">return</span> err, peer.TxValidationCode_ENDORSEMENT_POLICY_FAILURE</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> err, peer.TxValidationCode_INVALID_OTHER_REASON</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// SCC</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>GetInfoForValidate</code>先是获取了<code>ChaincodeDefinition</code>，它记录了peer对某个链码的proposal背书和验证的必要信息，然后利用<code>ChaincodeDefinition.Validation</code>获取了policy。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetInfoForValidate gets the ChaincodeInstance(with latest version) of tx, vscc and policy from lscc</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *VsccValidatorImpl)</span> <span class="title">GetInfoForValidate</span><span class="params">(chdr *common.ChannelHeader, ccID <span class="keyword">string</span>)</span> <span class="params">(*sysccprovider.ChaincodeInstance, *sysccprovider.ChaincodeInstance, []<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	cc := &amp;sysccprovider.ChaincodeInstance&#123;</span><br><span class="line">		ChainID:          chdr.ChannelId,</span><br><span class="line">		ChaincodeName:    ccID,</span><br><span class="line">		ChaincodeVersion: coreUtil.GetSysCCVersion(),</span><br><span class="line">	&#125;</span><br><span class="line">	vscc := &amp;sysccprovider.ChaincodeInstance&#123;</span><br><span class="line">		ChainID:          chdr.ChannelId,</span><br><span class="line">		ChaincodeName:    <span class="string">"vscc"</span>,                     <span class="comment">// default vscc for system chaincodes</span></span><br><span class="line">		ChaincodeVersion: coreUtil.GetSysCCVersion(), <span class="comment">// Get vscc version</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> policy []<span class="keyword">byte</span></span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	<span class="keyword">if</span> !v.sccprovider.IsSysCC(ccID) &#123;</span><br><span class="line">		<span class="comment">// when we are validating a chaincode that is not a</span></span><br><span class="line">		<span class="comment">// system CC, we need to ask the CC to give us the name</span></span><br><span class="line">		<span class="comment">// of VSCC and of the policy that should be used</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// obtain name of the VSCC and the policy</span></span><br><span class="line">		<span class="comment">// 获取cc 定义</span></span><br><span class="line">		cd, err := v.getCDataForCC(chdr.ChannelId, ccID)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			msg := fmt.Sprintf(<span class="string">"Unable to get chaincode data from ledger for txid %s, due to %s"</span>, chdr.TxId, err)</span><br><span class="line">			logger.Errorf(msg)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		cc.ChaincodeName = cd.CCName()</span><br><span class="line">		cc.ChaincodeVersion = cd.CCVersion()</span><br><span class="line">		<span class="comment">// 拿到policy</span></span><br><span class="line">		vscc.ChaincodeName, policy = cd.Validation()</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// when we are validating a system CC, we use the default</span></span><br><span class="line">		<span class="comment">// VSCC and a default policy that requires one signature</span></span><br><span class="line">		<span class="comment">// from any of the members of the channel</span></span><br><span class="line">		p := cauthdsl.SignedByAnyMember(v.support.GetMSPIDs(chdr.ChannelId))</span><br><span class="line">		policy, err = utils.Marshal(p)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> cc, vscc, policy, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------- ChaincodeDefinition - interface for ChaincodeData ------</span></span><br><span class="line"><span class="comment">// ChaincodeDefinition describes all of the necessary information for a peer to decide whether to endorse</span></span><br><span class="line"><span class="comment">// a proposal and whether to validate a transaction, for a particular chaincode.</span></span><br><span class="line"><span class="keyword">type</span> ChaincodeDefinition <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// CCName returns the name of this chaincode (the name it was put in the ChaincodeRegistry with).</span></span><br><span class="line">	CCName() <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Hash returns the hash of the chaincode.</span></span><br><span class="line">	Hash() []<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// CCVersion returns the version of the chaincode.</span></span><br><span class="line">	CCVersion() <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Validation returns how to validate transactions for this chaincode.</span></span><br><span class="line">	<span class="comment">// The string returned is the name of the validation method (usually 'vscc')</span></span><br><span class="line">	<span class="comment">// and the bytes returned are the argument to the validation (in the case of</span></span><br><span class="line">	<span class="comment">// 'vscc', this is a marshaled pb.VSCCArgs message).</span></span><br><span class="line">	Validation() (<span class="keyword">string</span>, []<span class="keyword">byte</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Endorsement returns how to endorse proposals for this chaincode.</span></span><br><span class="line">	<span class="comment">// The string returns is the name of the endorsement method (usually 'escc').</span></span><br><span class="line">	Endorsement() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ChaincodeData</code>实现了<code>ChaincodeDefinition</code>接口，<code>ChaincodeData</code>是LSCC保存的数据，它其中有1个字段就是Policy。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Validation returns how to validate transactions for this chaincode.</span></span><br><span class="line"><span class="comment">// The string returned is the name of the validation method (usually 'vscc')</span></span><br><span class="line"><span class="comment">// and the bytes returned are the argument to the validation (in the case of</span></span><br><span class="line"><span class="comment">// 'vscc', this is a marshaled pb.VSCCArgs message).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cd *ChaincodeData)</span> <span class="title">Validation</span><span class="params">()</span> <span class="params">(<span class="keyword">string</span>, []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> cd.Vscc, cd.Policy</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------- ChaincodeData is stored on the LSCC -------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ChaincodeData defines the datastructure for chaincodes to be serialized by proto</span></span><br><span class="line"><span class="comment">// Type provides an additional check by directing to use a specific package after instantiation</span></span><br><span class="line"><span class="comment">// Data is Type specifc (see CDSPackage and SignedCDSPackage)</span></span><br><span class="line"><span class="keyword">type</span> ChaincodeData <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Name of the chaincode</span></span><br><span class="line">	Name <span class="keyword">string</span> <span class="string">`protobuf:"bytes,1,opt,name=name"`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Version of the chaincode</span></span><br><span class="line">	Version <span class="keyword">string</span> <span class="string">`protobuf:"bytes,2,opt,name=version"`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Escc for the chaincode instance</span></span><br><span class="line">	Escc <span class="keyword">string</span> <span class="string">`protobuf:"bytes,3,opt,name=escc"`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Vscc for the chaincode instance</span></span><br><span class="line">	Vscc <span class="keyword">string</span> <span class="string">`protobuf:"bytes,4,opt,name=vscc"`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 背书策略</span></span><br><span class="line">	<span class="comment">// Policy endorsement policy for the chaincode instance</span></span><br><span class="line">	Policy []<span class="keyword">byte</span> <span class="string">`protobuf:"bytes,5,opt,name=policy,proto3"`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Data data specific to the package</span></span><br><span class="line">	Data []<span class="keyword">byte</span> <span class="string">`protobuf:"bytes,6,opt,name=data,proto3"`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Id of the chaincode that's the unique fingerprint for the CC This is not</span></span><br><span class="line">	<span class="comment">// currently used anywhere but serves as a good eyecatcher</span></span><br><span class="line">	Id []<span class="keyword">byte</span> <span class="string">`protobuf:"bytes,7,opt,name=id,proto3"`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// InstantiationPolicy for the chaincode</span></span><br><span class="line">	InstantiationPolicy []<span class="keyword">byte</span> <span class="string">`protobuf:"bytes,8,opt,name=instantiation_policy,proto3"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LSCC的Policy哪来的？"><a href="#LSCC的Policy哪来的？" class="headerlink" title="LSCC的Policy哪来的？"></a>LSCC的Policy哪来的？</h2><blockquote>
<p>提醒：链码实例化在代码里使用<strong>Deploy</strong>，而不是Instantiate，这样可以让代码更简洁，所以链码实例化也常称为链码部署。</p>
</blockquote>
<p><code>executeDeploy</code>为部署链码，也就是在部署链码的时候会保存背书策略。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// executeDeploy implements the "instantiate" Invoke transaction</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lscc *LifeCycleSysCC)</span> <span class="title">executeDeploy</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	stub shim.ChaincodeStubInterface,</span></span></span><br><span class="line"><span class="function"><span class="params">	chainname <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	cds *pb.ChaincodeDeploymentSpec,</span></span></span><br><span class="line"><span class="function"><span class="params">	policy []<span class="keyword">byte</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	escc []<span class="keyword">byte</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	vscc []<span class="keyword">byte</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	cdfs *ccprovider.ChaincodeData,</span></span></span><br><span class="line"><span class="function"><span class="params">	ccpackfs ccprovider.CCPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">	collectionConfigBytes []<span class="keyword">byte</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(*ccprovider.ChaincodeData, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">//just test for existence of the chaincode in the LSCC</span></span><br><span class="line">	chaincodeName := cds.ChaincodeSpec.ChaincodeId.Name</span><br><span class="line">	_, err := lscc.getCCInstance(stub, chaincodeName)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, ExistsErr(chaincodeName)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//retain chaincode specific data and fill channel specific ones</span></span><br><span class="line">	cdfs.Escc = <span class="keyword">string</span>(escc)</span><br><span class="line">	cdfs.Vscc = <span class="keyword">string</span>(vscc)</span><br><span class="line">	<span class="comment">// 保存背书策略</span></span><br><span class="line">	cdfs.Policy = policy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>executeDeployOrUpgrade</code>是执行链码实例化和升级时调用，它会传递Policy，在链码部署和升级时都会保存背书策略。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// executeDeployOrUpgrade routes the code path either to executeDeploy or executeUpgrade</span></span><br><span class="line"><span class="comment">// depending on its function argument</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lscc *LifeCycleSysCC)</span> <span class="title">executeDeployOrUpgrade</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	stub shim.ChaincodeStubInterface,</span></span></span><br><span class="line"><span class="function"><span class="params">	chainname <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	cds *pb.ChaincodeDeploymentSpec,</span></span></span><br><span class="line"><span class="function"><span class="params">	policy, escc, vscc, collectionConfigBytes []<span class="keyword">byte</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	function <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(*ccprovider.ChaincodeData, error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	chaincodeName := cds.ChaincodeSpec.ChaincodeId.Name</span><br><span class="line">	chaincodeVersion := cds.ChaincodeSpec.ChaincodeId.Version</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := lscc.isValidChaincodeName(chaincodeName); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := lscc.isValidChaincodeVersion(chaincodeName, chaincodeVersion); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ccpack, err := lscc.Support.GetChaincodeFromLocalStorage(chaincodeName, chaincodeVersion)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		retErrMsg := fmt.Sprintf(<span class="string">"cannot get package for chaincode (%s:%s)"</span>, chaincodeName, chaincodeVersion)</span><br><span class="line">		logger.Errorf(<span class="string">"%s-err:%s"</span>, retErrMsg, err)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"%s"</span>, retErrMsg)</span><br><span class="line">	&#125;</span><br><span class="line">	cd := ccpack.GetChaincodeData()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> function &#123;</span><br><span class="line">	<span class="keyword">case</span> DEPLOY:</span><br><span class="line">		<span class="keyword">return</span> lscc.executeDeploy(stub, chainname, cds, policy, escc, vscc, cd, ccpack, collectionConfigBytes)</span><br><span class="line">	<span class="keyword">case</span> UPGRADE:</span><br><span class="line">		<span class="keyword">return</span> lscc.executeUpgrade(stub, chainname, cds, policy, escc, vscc, cd, ccpack, collectionConfigBytes)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		logger.Panicf(<span class="string">"Programming error, unexpected function '%s'"</span>, function)</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">""</span>) <span class="comment">// unreachable code</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LSCC也实现了ChainCode接口，与普通链码的实现并没有区别，只不过LSCC并不运行在容器中。<code>LifeCycleSysCC.Invoke</code>会根据参数调用不同的函数，而部署和升级时，会调用<code>executeDeployOrUpgrade</code>部署链码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Invoke implements lifecycle functions "deploy", "start", "stop", "upgrade".</span></span><br><span class="line"><span class="comment">// Deploy's arguments -  &#123;[]byte("deploy"), []byte(&lt;chainname&gt;), &lt;unmarshalled pb.ChaincodeDeploymentSpec&gt;&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Invoke also implements some query-like functions</span></span><br><span class="line"><span class="comment">// Get chaincode arguments -  &#123;[]byte("getid"), []byte(&lt;chainname&gt;), []byte(&lt;chaincodename&gt;)&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lscc *LifeCycleSysCC)</span> <span class="title">Invoke</span><span class="params">(stub shim.ChaincodeStubInterface)</span> <span class="title">pb</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">switch</span> function &#123;</span><br><span class="line">    <span class="keyword">case</span> INSTALL:</span><br><span class="line">      ...</span><br><span class="line">    <span class="keyword">case</span> DEPLOY, UPGRADE:</span><br><span class="line">      <span class="comment">// 提取背书策略</span></span><br><span class="line">      <span class="comment">// optional arguments here (they can each be nil and may or may not be present)</span></span><br><span class="line">      <span class="comment">// args[3] is a marshalled SignaturePolicyEnvelope representing the endorsement policy</span></span><br><span class="line">      <span class="comment">// args[4] is the name of escc</span></span><br><span class="line">      <span class="comment">// args[5] is the name of vscc</span></span><br><span class="line">      <span class="comment">// args[6] is a marshalled CollectionConfigPackage struct</span></span><br><span class="line">      <span class="keyword">var</span> EP []<span class="keyword">byte</span></span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">len</span>(args) &gt; <span class="number">3</span> &amp;&amp; <span class="built_in">len</span>(args[<span class="number">3</span>]) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        EP = args[<span class="number">3</span>]</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p := cauthdsl.SignedByAnyMember(peer.GetMSPIDs(channel))</span><br><span class="line">        EP, err = utils.Marshal(p)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> shim.Error(err.Error())</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">      cd, err := lscc.executeDeployOrUpgrade(stub, channel, cds, EP, escc, vscc, collectionsConfig, function)</span><br><span class="line">      ...</span><br><span class="line">    <span class="keyword">case</span> ...:</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们终于知道Policy是哪来的，又是如何被使用的了。管理和查看链码信息，本质是创建一个调用LSCC的Proposal或者交易，链码的信息会保存在LSCC，当VSCC验证链码的交易时，会从LSCC获取信息，包括背书策略、vscc插件等，以验证交易。</p>
<p><img src="http://img.lessisbetter.site/2019-09-endorser-policy.png" alt="endorser policy"></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2019/09/05/etcd-raft-sources-structs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="区块链、Go语言">
      <meta itemprop="image" content="http://img.lessisbetter.site/gzh-qrcode-logo-small.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Go语言充电站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/05/etcd-raft-sources-structs/" class="post-title-link" itemprop="url">Etcd Raft架构设计和源码剖析3：重要结构体定义</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-09-05 21:59:35" itemprop="dateCreated datePublished" datetime="2019-09-05T21:59:35+08:00">2019-09-05</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-09-06 08:17:36" itemprop="dateModified" datetime="2019-09-06T08:17:36+08:00">2019-09-06</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>etcd raft定义了一些重要的结构体，来传递和表示raft使用到的数据。</p>
<p>在介绍各结构体之前，先澄清一下raft、log和state machine的关系，它们三个是独立的，没有隶属关系，尤其是state machine并不属于raft。</p>
<p><img src="http://img.lessisbetter.site/2019-08-raft-%E5%9B%BE1.png" alt="State machine"></p>
<p>Consensus Module指raft算法，它输出一致的Log Entry序列，State machine指应用Entry后得到的状态，状态机是并不是raft的一部分，而是用来存储数据的模块。</p>
<h2 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h2><p>每个Raft集群节点都是一个状态机，每个节点都使用相同的log entry序列修改状态机的数据，Entry就是每一个操作项，<strong>raft的核心能力就是为应用层提供序列相同的entry</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Entry <span class="keyword">struct</span> &#123;</span><br><span class="line">	Term             <span class="keyword">uint64</span>    <span class="string">`protobuf:"varint,2,opt,name=Term" json:"Term"`</span></span><br><span class="line">	Index            <span class="keyword">uint64</span>    <span class="string">`protobuf:"varint,3,opt,name=Index" json:"Index"`</span></span><br><span class="line">	Type             EntryType <span class="string">`protobuf:"varint,1,opt,name=Type,enum=raftpb.EntryType" json:"Type"`</span></span><br><span class="line">	Data             []<span class="keyword">byte</span>    <span class="string">`protobuf:"bytes,4,opt,name=Data" json:"Data,omitempty"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> EntryType <span class="keyword">int32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	EntryNormal       EntryType = <span class="number">0</span></span><br><span class="line">	EntryConfChange   EntryType = <span class="number">1</span></span><br><span class="line">	EntryConfChangeV2 EntryType = <span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>每一个Entry，都可以使用(Term, Index)进行唯一标记，相当于Entry的ID：</p>
<ul>
<li>Term：即raft论文中的Term，表明了当前Entry所属的Term。raft不使用绝对时间，而是使用相对时间，它把时间分割成了大小不等的term，每一轮选举都会开启一个新的term，term值会连续累加。如果当前的节点已经是Term 10缺收到了Term 8的Entry，Term 8的Entry已经过时，会被丢弃。</li>
<li>Index：每一个Entry都有一个的Index，代表当前Entry在log entry序列中的位置，每个index上最终只有1个达成共识的Entry。</li>
</ul>
<p>除了用于达成一致的Term和Index外，Entry还携带了数据：</p>
<ul>
<li>Type：表明当前Entry的类型，<code>EntryNormal</code>代表是Entry携带的是修改状态机的操作数据，<code>EntryConfChange</code>和<code>EntryConfChangeV2</code>代表的是Entry携带的是修改当前raft集群的配置。</li>
<li>Data：是序列化的数据，不同的Type类型，对应不同的Data。</li>
</ul>
<h2 id="Snapshot"><a href="#Snapshot" class="headerlink" title="Snapshot"></a>Snapshot</h2><p>在Entry特别多的场景下，会存在一些问题，比如现在有1亿条已经达成一致Entry，后面还有源源不断的Entry产生，是否有以下问题：</p>
<ol>
<li>这些Entry占用了大量的磁盘空间，但实际上过去的Entry已经对已经拥有这些Entry的节点没有意义了，只对那些没有Entry的节点有意义，leader把Entry发送给没有这些Entry节点，以让这些节点最终能和leader保持一致的状态。</li>
<li>有些follower非常慢，或者刚启动，或者重启过，与leader的当前状态已经严重脱节，让他们从Entry 0开始同步，然后应用到状态机，这种操作时间效率是不是非常慢？然后每一个Entry都会产生一个历史的状态，当产生新的状态之后，历史状态对当前节点也没有意义。</li>
</ol>
<p>解决这种问题的办法就是快照，比如虚拟机的快照，或者docker镜像（镜像本质也是一种快照），有了快照就可以把状态机快速恢复到快照时的状态，<strong>空间和时间上效率都能提高很多</strong>。</p>
<p>Raft可以定期产生一些快照，然后在这些快照上按序应用快照之后的Entry就能得到一致的状态。1亿个Entry + 1亿01个Entry得到的状态，跟第1亿个Entry后所产生的快照+1亿零1个Entry得到的状态是一致的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Snapshot <span class="keyword">struct</span> &#123;</span><br><span class="line">	Data             []<span class="keyword">byte</span>           <span class="string">`protobuf:"bytes,1,opt,name=data" json:"data,omitempty"`</span></span><br><span class="line">	Metadata         SnapshotMetadata <span class="string">`protobuf:"bytes,2,opt,name=metadata" json:"metadata"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SnapshotMetadata <span class="keyword">struct</span> &#123;</span><br><span class="line">	ConfState        ConfState <span class="string">`protobuf:"bytes,1,opt,name=conf_state,json=confState" json:"conf_state"`</span></span><br><span class="line">	Index            <span class="keyword">uint64</span>    <span class="string">`protobuf:"varint,2,opt,name=index" json:"index"`</span></span><br><span class="line">	Term             <span class="keyword">uint64</span>    <span class="string">`protobuf:"varint,3,opt,name=term" json:"term"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Data：是状态机中状态的快照。</li>
<li>Metadata：是快照自身相关的数据。<ul>
<li>ConfState：是快照时，当前raft的配置状态，这些状态数据并不在状态机中，所以需要进行保存。</li>
<li>Index、Term：快照所依据的Entry所在的Index和Term。</li>
</ul>
</li>
</ul>
<h2 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h2><p>Raft集群节点之间的通信只使用了1个结构体<code>Message</code>，Message中有一个<code>Type</code>成员，表明了当前的Message是哪种消息，比如可以是Raft论文中提到的AppendEntries，RequestVotes等，目前实际可以容纳19种类型的消息，每种消息对Raft都有不同的作用，具体见<a href="https://zhuanlan.zhihu.com/p/51065416" target="_blank" rel="noopener">这篇文章</a>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不同的Message类型会用到不同的字段</span></span><br><span class="line"><span class="keyword">type</span> Message <span class="keyword">struct</span> &#123;</span><br><span class="line">	Type             MessageType <span class="string">`protobuf:"varint,1,opt,name=type,enum=raftpb.MessageType" json:"type"`</span></span><br><span class="line">	To               <span class="keyword">uint64</span>      <span class="string">`protobuf:"varint,2,opt,name=to" json:"to"`</span></span><br><span class="line">	From             <span class="keyword">uint64</span>      <span class="string">`protobuf:"varint,3,opt,name=from" json:"from"`</span></span><br><span class="line">	Term             <span class="keyword">uint64</span>      <span class="string">`protobuf:"varint,4,opt,name=term" json:"term"`</span></span><br><span class="line">	LogTerm          <span class="keyword">uint64</span>      <span class="string">`protobuf:"varint,5,opt,name=logTerm" json:"logTerm"`</span></span><br><span class="line">	Index            <span class="keyword">uint64</span>      <span class="string">`protobuf:"varint,6,opt,name=index" json:"index"`</span></span><br><span class="line">	Entries          []Entry     <span class="string">`protobuf:"bytes,7,rep,name=entries" json:"entries"`</span></span><br><span class="line">	Commit           <span class="keyword">uint64</span>      <span class="string">`protobuf:"varint,8,opt,name=commit" json:"commit"`</span></span><br><span class="line">	Snapshot         Snapshot    <span class="string">`protobuf:"bytes,9,opt,name=snapshot" json:"snapshot"`</span></span><br><span class="line">	Reject           <span class="keyword">bool</span>        <span class="string">`protobuf:"varint,10,opt,name=reject" json:"reject"`</span></span><br><span class="line">	RejectHint       <span class="keyword">uint64</span>      <span class="string">`protobuf:"varint,11,opt,name=rejectHint" json:"rejectHint"`</span></span><br><span class="line">	Context          []<span class="keyword">byte</span>      <span class="string">`protobuf:"bytes,12,opt,name=context" json:"context,omitempty"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Message中包含了很多字段，不同的消息类型使用的字段组合不相同，可以从不同消息的处理逻辑中看出来。</p>
<ul>
<li>To, From：是消息的接收节点和发送节点的的Raft ID。</li>
<li>Term：创建Message时，发送节点所在的Term。</li>
<li>LogTerm：创建Message时，发送节点本地所保存的log entry序列中最大的Term，在选举的时候会使用。</li>
<li>Index：不同的消息类型，Index的含义不同。Term和Index与Entry中的Term和Index不一定会相同，因为某个follower可能比较慢，leader向follower发送已经committed的Entry。</li>
<li>Entries：发送给follower，待follower处理的Entry。</li>
<li>Commit：创建Message时，不同消息含义不同，Append时是发送节点本地已committed的Index，Heartbeat时是committed Index或者与follower匹配的Index。</li>
<li>Snapshot：leader传递给follower的snapshot。</li>
<li>Reject：投票和Append的响应消息使用，Reject表示拒绝leader发来的消息。</li>
<li>RejectHint：拒绝Append消息的响应消息使用，用来给leader提示，发送follower已有的最后一个Index。</li>
<li>Context：某些消息的附加信息，即用来存储通用的数据。比如竞选时，存放<code>campaignTransfer</code>。</li>
</ul>
<h2 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h2><p>etcd raft不负责数据存储和网络通信，网络数据都是通过Node接口的函数传入和传出raft。数据存储由创建raft.Node的应用层负责，数据存储包含：</p>
<ul>
<li>应用层使用Entry生成的状态机，即一致的应用数据。</li>
<li>raft算法使用的存储信息，比如保存Entry序列的文件，保存Snapshot的文件。</li>
</ul>
<p>它们都在应用层，raft为了能够<strong>读取</strong>这些数据，定义了一个接口<code>Storage</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Storage is an interface that may be implemented by the application</span></span><br><span class="line"><span class="comment">// to retrieve log entries from storage.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If any Storage method returns an error, the raft instance will</span></span><br><span class="line"><span class="comment">// become inoperable and refuse to participate in elections; the</span></span><br><span class="line"><span class="comment">// application is responsible for cleanup and recovery in this case.</span></span><br><span class="line"><span class="keyword">type</span> Storage <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// TODO(tbg): split this into two interfaces, LogStorage and StateStorage.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// InitialState returns the saved HardState and ConfState information.</span></span><br><span class="line">	InitialState() (pb.HardState, pb.ConfState, error)</span><br><span class="line">	<span class="comment">// Entries returns a slice of log entries in the range [lo,hi).</span></span><br><span class="line">	<span class="comment">// MaxSize limits the total size of the log entries returned, but</span></span><br><span class="line">	<span class="comment">// Entries returns at least one entry if any.</span></span><br><span class="line">	Entries(lo, hi, maxSize <span class="keyword">uint64</span>) ([]pb.Entry, error)</span><br><span class="line">	<span class="comment">// Term returns the term of entry i, which must be in the range</span></span><br><span class="line">	<span class="comment">// [FirstIndex()-1, LastIndex()]. The term of the entry before</span></span><br><span class="line">	<span class="comment">// FirstIndex is retained for matching purposes even though the</span></span><br><span class="line">	<span class="comment">// rest of that entry may not be available.</span></span><br><span class="line">	Term(i <span class="keyword">uint64</span>) (<span class="keyword">uint64</span>, error)</span><br><span class="line">	<span class="comment">// LastIndex returns the index of the last entry in the log.</span></span><br><span class="line">	LastIndex() (<span class="keyword">uint64</span>, error)</span><br><span class="line">	<span class="comment">// FirstIndex returns the index of the first log entry that is</span></span><br><span class="line">	<span class="comment">// possibly available via Entries (older entries have been incorporated</span></span><br><span class="line">	<span class="comment">// into the latest Snapshot; if storage only contains the dummy entry the</span></span><br><span class="line">	<span class="comment">// first log entry is not available).</span></span><br><span class="line">	FirstIndex() (<span class="keyword">uint64</span>, error)</span><br><span class="line">	<span class="comment">// Snapshot returns the most recent snapshot.</span></span><br><span class="line">	<span class="comment">// If snapshot is temporarily unavailable, it should return ErrSnapshotTemporarilyUnavailable,</span></span><br><span class="line">	<span class="comment">// so raft state machine could know that Storage needs some time to prepare</span></span><br><span class="line">	<span class="comment">// snapshot and call Snapshot later.</span></span><br><span class="line">	Snapshot() (pb.Snapshot, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用这个接口，从应用层读取：</p>
<ul>
<li>InitialState：HardState和配置状态Confstate</li>
<li>Entries：根据Index获取连续的Entry</li>
<li>Term：获取某个Entry所在的Term</li>
<li>LastIndex：获取本节点已存储的最新的Entry的Index</li>
<li>FirstIndex：获取本节点已存储的第一个Entry的Index</li>
<li>Snapshot：获取本节点最近生成的Snapshot，Snapshot是由应用层创建的，并暂时保存起来，raft调用此接口读取</li>
</ul>
<h2 id="unstable"><a href="#unstable" class="headerlink" title="unstable"></a>unstable</h2><p>unstable因为Entry的存储是由应用层负责的raft负责的，所以raft需要暂时存储还未存到Storage中的Entry或者Snapshot，在创建Ready时，Entry和Snapshot会被封装到Ready，由应用层写入到storage。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unstable.entries[i] has raft log position i+unstable.offset.</span></span><br><span class="line"><span class="comment">// Note that unstable.offset may be less than the highest log</span></span><br><span class="line"><span class="comment">// position in storage; this means that the next write to storage</span></span><br><span class="line"><span class="comment">// might need to truncate the log before persisting unstable.entries.</span></span><br><span class="line"><span class="keyword">type</span> unstable <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// the incoming unstable snapshot, if any.</span></span><br><span class="line">	snapshot *pb.Snapshot</span><br><span class="line">	<span class="comment">// all entries that have not yet been written to storage.</span></span><br><span class="line">	entries []pb.Entry</span><br><span class="line">	offset  <span class="keyword">uint64</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Snapshot：是follower从leader收到的最新的Snapshot。</li>
<li>entries：对leader而已，是raft刚利用请求创建的Entry，对follower而言是从leader收到的Entry。</li>
<li>offset：Entries[i].Index = i + offset。</li>
</ul>
<h2 id="raftLog"><a href="#raftLog" class="headerlink" title="raftLog"></a>raftLog</h2><p>raft使用raftLog来管理当前Entry序列和Snapshot等信息，它由Storage、unstable、committed和applied组成。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> raftLog <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// storage contains all stable entries since the last snapshot.</span></span><br><span class="line">	storage Storage</span><br><span class="line"></span><br><span class="line">	<span class="comment">// unstable contains all unstable entries and snapshot.</span></span><br><span class="line">	<span class="comment">// they will be saved into storage.</span></span><br><span class="line">	unstable unstable</span><br><span class="line"></span><br><span class="line">	<span class="comment">// committed和applied是storage的2个整数下标</span></span><br><span class="line">	<span class="comment">// committed到applied需要Ready</span></span><br><span class="line">	<span class="comment">// committed is the highest log position that is known to be in</span></span><br><span class="line">	<span class="comment">// stable storage on a quorum of nodes.</span></span><br><span class="line">	committed <span class="keyword">uint64</span></span><br><span class="line">	<span class="comment">// applied is the highest log position that the application has</span></span><br><span class="line">	<span class="comment">// been instructed to apply to its state machine.</span></span><br><span class="line">	<span class="comment">// Invariant: applied &lt;= committed</span></span><br><span class="line">	applied <span class="keyword">uint64</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Storage和unstable前面已经介绍过了，所以介绍下committed和applied。</p>
<p>committed指最后一个在raft集群多数节点之间达成一致的Entry Index。</p>
<p>applied指当前节点被应用层应用到状态机的最后一个Entry Index。applied和committed之间的Entry就是等待被应用层应用到状态机的Entry。</p>
<p>前面提到Storage接口可以获取第一个索引firstIdx，最后一个索引lastIdx，在生成snapshot之后签名的Entry就可以删除了，所以firstidx是storage中snapshot后的第一个Entry的Index，lastIndex是storage中保存的最后一个Entry的Index，这个Entry可能还没有在raft集群多数节点之间达成一致，所以在committed之后，这些Entry是等待commit的Entry，leader发现某个Entry Index已经在多数节点之间达成一致，就会把committed移动到该Entry Index。</p>
<p><img src="http://img.lessisbetter.site/2019-08-raftLog.png" alt="raftLog"></p>
<h2 id="SoftState"><a href="#SoftState" class="headerlink" title="SoftState"></a>SoftState</h2><p>SoftState指易变的状态数据，记录了<strong>当前</strong>的Leader的Node ID，以及当前节点的角色。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SoftState provides state that is useful for logging and debugging.</span></span><br><span class="line"><span class="comment">// The state is volatile and does not need to be persisted to the WAL.</span></span><br><span class="line"><span class="keyword">type</span> SoftState <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// leader的Node ID</span></span><br><span class="line">	Lead <span class="keyword">uint64</span> <span class="comment">// must use atomic operations to access; keep 64-bit aligned.</span></span><br><span class="line">	<span class="comment">// 节点是什么角色：leader、follower...</span></span><br><span class="line">	RaftState StateType</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// StateType represents the role of a node in a cluster.</span></span><br><span class="line"><span class="keyword">type</span> StateType <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stmap = [...]<span class="keyword">string</span>&#123;</span><br><span class="line">	<span class="string">"StateFollower"</span>,</span><br><span class="line">	<span class="string">"StateCandidate"</span>,</span><br><span class="line">	<span class="string">"StateLeader"</span>,</span><br><span class="line">	<span class="string">"StatePreCandidate"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="HardState"><a href="#HardState" class="headerlink" title="HardState"></a>HardState</h2><p>HardState是写入到WAL（存储Entry的文件）的状态，可以在节点重启时恢复raft的状态，它了记录：</p>
<ul>
<li>Term：节点当前所在的Term。</li>
<li>Vote：节点在竞选期间所投的候选节点ID。</li>
<li>Commit：当前已经committed Entry Index。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HardState <span class="keyword">struct</span> &#123;</span><br><span class="line">	Term             <span class="keyword">uint64</span> <span class="string">`protobuf:"varint,1,opt,name=term" json:"term"`</span></span><br><span class="line">	Vote             <span class="keyword">uint64</span> <span class="string">`protobuf:"varint,2,opt,name=vote" json:"vote"`</span></span><br><span class="line">	Commit           <span class="keyword">uint64</span> <span class="string">`protobuf:"varint,3,opt,name=commit" json:"commit"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Ready"><a href="#Ready" class="headerlink" title="Ready"></a>Ready</h2><p>终于到etcd raft最重要的一个结构体了。raft使用Ready结构体对外传递数据，是多种数据的打包。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ready encapsulates the entries and messages that are ready to read,</span></span><br><span class="line"><span class="comment">// be saved to stable storage, committed or sent to other peers.</span></span><br><span class="line"><span class="comment">// All fields in Ready are read-only.</span></span><br><span class="line"><span class="keyword">type</span> Ready <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// The current volatile state of a Node.</span></span><br><span class="line">	<span class="comment">// SoftState will be nil if there is no update.</span></span><br><span class="line">	<span class="comment">// It is not required to consume or store SoftState.</span></span><br><span class="line">	*SoftState</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The current state of a Node to be saved to stable storage BEFORE</span></span><br><span class="line">	<span class="comment">// Messages are sent.</span></span><br><span class="line">	<span class="comment">// HardState will be equal to empty state if there is no update.</span></span><br><span class="line">	pb.HardState</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ReadStates can be used for node to serve linearizable read requests locally</span></span><br><span class="line">	<span class="comment">// when its applied index is greater than the index in ReadState.</span></span><br><span class="line">	<span class="comment">// Note that the readState will be returned when raft receives msgReadIndex.</span></span><br><span class="line">	<span class="comment">// The returned is only valid for the request that requested to read.</span></span><br><span class="line">	ReadStates []ReadState</span><br><span class="line"></span><br><span class="line">	<span class="comment">// unstable的entry，即待写入到storage的entry</span></span><br><span class="line">	<span class="comment">// Entries specifies entries to be saved to stable storage BEFORE</span></span><br><span class="line">	<span class="comment">// Messages are sent.</span></span><br><span class="line">	Entries []pb.Entry</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Snapshot specifies the snapshot to be saved to stable storage.</span></span><br><span class="line">	Snapshot pb.Snapshot</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 待applied的entry</span></span><br><span class="line">	<span class="comment">// CommittedEntries specifies entries to be committed to a</span></span><br><span class="line">	<span class="comment">// store/state-machine. These have previously been committed to stable</span></span><br><span class="line">	<span class="comment">// store.</span></span><br><span class="line">	CommittedEntries []pb.Entry</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Messages specifies outbound messages to be sent AFTER Entries are</span></span><br><span class="line">	<span class="comment">// committed to stable storage.</span></span><br><span class="line">	<span class="comment">// If it contains a MsgSnap message, the application MUST report back to raft</span></span><br><span class="line">	<span class="comment">// when the snapshot has been received or has failed by calling ReportSnapshot.</span></span><br><span class="line">	Messages []pb.Message</span><br><span class="line"></span><br><span class="line">	<span class="comment">// MustSync indicates whether the HardState and Entries must be synchronously</span></span><br><span class="line">	<span class="comment">// written to disk or if an asynchronous write is permissible.</span></span><br><span class="line">	MustSync <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SoftState、HardState、Entry、Snapshot、Message都已经介绍过，不再单独介绍含义。</p>
<p>Entries和CommittedEntries的区别是，Entries保存的是从unstable读取的Entry，它们即将被应用层写入storage，CommittedEntries是已经被Committed，还没有applied，应用层会把他们应用到状态机。</p>
<p>ReadStateraft用来处理读请求，MustSync用来指明应用层是否采用异步的方式写数据。</p>
<p>应用层在接收到Ready后，应当处理Ready中的每一个有效字段，处理完毕后，调用<code>Advance()</code>通知raft Ready已处理完毕。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2019/09/03/fabric-problem-of-peers-using-different-language-chaincode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="区块链、Go语言">
      <meta itemprop="image" content="http://img.lessisbetter.site/gzh-qrcode-logo-small.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Go语言充电站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/03/fabric-problem-of-peers-using-different-language-chaincode/" class="post-title-link" itemprop="url">Fabric不同peer使用不同语言链码的问题</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-09-03 11:50:31" itemprop="dateCreated datePublished" datetime="2019-09-03T11:50:31+08:00">2019-09-03</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-09-11 14:14:19" itemprop="dateModified" datetime="2019-09-11T14:14:19+08:00">2019-09-11</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>社区里在讨论一个问题，是由官方的文档引发的，文档上讲不同的peer可以使用不同语言的链码，前提是2份链码功能、接口等必须一致。</p>
<p><img src="http://img.lessisbetter.site/2019-09-fabric-chaincode-error.png" alt="fabric chaincode error"></p>
<p>大家的问题是：</p>
<blockquote>
<p>一个链码可以采用不同的语言实现，不同peer上使用不同的链码真的可行吗？</p>
</blockquote>
<p>经过实证，这是不可行的。</p>
<p>分2种情况，2种都有问题：</p>
<ol>
<li>不同peer安装不同语言链码，然后同时实例化：实例化后，只能启动发送实例化交易的peer拥有的语言的链码</li>
<li>部分peer先实例化，另外peer再安装不同语言链码：调用链码时报指纹不匹配错误</li>
</ol>
<h2 id="不同peer安装不同语言链码，然后同时实例化"><a href="#不同peer安装不同语言链码，然后同时实例化" class="headerlink" title="不同peer安装不同语言链码，然后同时实例化"></a>不同peer安装不同语言链码，然后同时实例化</h2><p>1、修改BFYN，只在peer0.org1和peer0.org2上安装Go语言链码，不进行后续操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Installing chaincode on peer0.org1...</span><br><span class="line">+ peer chaincode install -n mycc -v 1.0 -l golang -p github.com/chaincode/chaincode_example02/go/</span><br><span class="line">+ res=0</span><br><span class="line">+ set +x</span><br><span class="line">2019-09-03 02:08:43.813 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc</span><br><span class="line">2019-09-03 02:08:43.813 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc</span><br><span class="line">2019-09-03 02:08:44.108 UTC [chaincodeCmd] install -&gt; INFO 003 Installed remotely response:&lt;status:200 payload:&quot;OK&quot; &gt;</span><br><span class="line">===================== Chaincode is installed on peer0.org1 =====================</span><br><span class="line"></span><br><span class="line">Install chaincode on peer0.org2...</span><br><span class="line">+ peer chaincode install -n mycc -v 1.0 -l golang -p github.com/chaincode/chaincode_example02/go/</span><br><span class="line">+ res=0</span><br><span class="line">+ set +x</span><br><span class="line">2019-09-03 02:08:44.260 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc</span><br><span class="line">2019-09-03 02:08:44.260 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc</span><br><span class="line">2019-09-03 02:08:44.529 UTC [chaincodeCmd] install -&gt; INFO 003 Installed remotely response:&lt;status:200 payload:&quot;OK&quot; &gt;</span><br><span class="line">===================== Chaincode is installed on peer0.org2 =====================</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">========= All GOOD, BYFN execution completed ===========</span><br></pre></td></tr></table></figure>
<p>2、在peer1.org1上安装Java语言链码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@6cec20eb7502:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer chaincode install -n mycc -v 1.0 -l java -p /opt/gopath/src/github.com/chaincode/chaincode_example02/java/</span><br><span class="line">2019-09-03 03:19:44.710 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc</span><br><span class="line">2019-09-03 03:19:44.711 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc</span><br><span class="line">2019-09-03 03:19:44.754 UTC [chaincodeCmd] install -&gt; INFO 003 Installed remotely response:&lt;status:200 payload:&quot;OK&quot; &gt;</span><br></pre></td></tr></table></figure>
<p>3、在peer1.org1上发起实例化链码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@6cec20eb7502:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer chaincode instantiate -o orderer.example.com:7050 --tls true --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C mychannel -n mycc -l golang -v 1.0 -c &apos;&#123;&quot;Args&quot;:[&quot;init&quot;,&quot;a&quot;,&quot;100&quot;,&quot;b&quot;,&quot;200&quot;]&#125;&apos; -P &apos;OR (&apos;\&apos;&apos;Org1MSP.peer&apos;\&apos;&apos;,&apos;\&apos;&apos;Org2MSP.peer&apos;\&apos;&apos;)&apos;</span><br><span class="line">2019-09-03 03:22:12.430 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc</span><br><span class="line">2019-09-03 03:22:12.431 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc</span><br></pre></td></tr></table></figure>
<p>4、查看链码容器，只有peer1.org1的链码容器，peer0.org1和peer0.org2的链码容器都没有起来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  fabric-sdk-go-sample git:(master) ✗ docker ps</span><br><span class="line">CONTAINER ID        IMAGE                                                                                                  COMMAND                  CREATED             STATUS              PORTS                      NAMES</span><br><span class="line">f8f6aa8b5da6        dev-peer1.org1.example.com-mycc-1.0-cd123150154e6bf2df7ce682e0b1bcbea40499416f37a6da3aae14c4eb51b08d   &quot;/root/chaincode-jav…&quot;   37 seconds ago      Up 36 seconds                                  dev-peer1.org1.example.com-mycc-1.0</span><br><span class="line">6cec20eb7502        hyperledger/fabric-tools:latest                                                                        &quot;/bin/bash&quot;              About an hour ago   Up About an hour                               cli</span><br><span class="line">7e134fe7e8e9        hyperledger/fabric-peer:latest                                                                         &quot;peer node start&quot;        About an hour ago   Up About an hour    0.0.0.0:8051-&gt;8051/tcp     peer1.org1.example.com</span><br><span class="line">ed6f5511d938        hyperledger/fabric-peer:latest                                                                         &quot;peer node start&quot;        About an hour ago   Up About an hour    0.0.0.0:10051-&gt;10051/tcp   peer1.org2.example.com</span><br><span class="line">025a71178777        hyperledger/fabric-peer:latest                                                                         &quot;peer node start&quot;        About an hour ago   Up About an hour    0.0.0.0:7051-&gt;7051/tcp     peer0.org1.example.com</span><br><span class="line">8687dfd14e7b        hyperledger/fabric-peer:latest                                                                         &quot;peer node start&quot;        About an hour ago   Up About an hour    0.0.0.0:9051-&gt;9051/tcp     peer0.org2.example.com</span><br><span class="line">e9cc8b410d7f        hyperledger/fabric-orderer:latest                                                                      &quot;orderer&quot;                About an hour ago   Up About an hour    0.0.0.0:7050-&gt;7050/tcp     orderer.example.com</span><br></pre></td></tr></table></figure>
<h2 id="部分peer先实例化，另外peer再安装不同语言链码"><a href="#部分peer先实例化，另外peer再安装不同语言链码" class="headerlink" title="部分peer先实例化，另外peer再安装不同语言链码"></a>部分peer先实例化，另外peer再安装不同语言链码</h2><p>不改造BYFN，原生启动。peer0.org1，peer0.org2，peer1.org2都已经实例化了Go语言链码。</p>
<p>然后在peer1.org1上安装Java语言的链码，在执行Invoke或者查询，报指纹不匹配-数据不匹配的错误。</p>
<p>原因分析：操作链码时，会调用LSCC的<code>LifeCycleSysCC.getCCCode</code>获取链码，一份链码是从数据库取的，即当前链码容器的，一份链码是本地存储的，会对2份进行匹配，如果不匹配就会报指纹不匹配错误。</p>
<p>匹配函数为<code>CDSPackage.ValidateCC</code>，匹配项为：</p>
<ol>
<li>名称、版本</li>
<li>CodeHash、元数据Hash</li>
</ol>
<p>调用链码时报的指纹不匹配错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@d0533ffe1864:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer chaincode install -n mycc -v 1.0 -l java -p /opt/gopath/src/github.com/chaincode/chaincode_example02/java/</span><br><span class="line">2019-09-03 01:52:15.714 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc</span><br><span class="line">2019-09-03 01:52:15.714 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc</span><br><span class="line">2019-09-03 01:52:15.755 UTC [chaincodeCmd] install -&gt; INFO 003 Installed remotely response:&lt;status:200 payload:&quot;OK&quot; &gt;</span><br><span class="line">root@d0533ffe1864:/opt/gopath/src/github.com/hyperledger/fabric/peer#</span><br><span class="line">root@d0533ffe1864:/opt/gopath/src/github.com/hyperledger/fabric/peer#</span><br><span class="line">root@d0533ffe1864:/opt/gopath/src/github.com/hyperledger/fabric/peer#</span><br><span class="line">root@d0533ffe1864:/opt/gopath/src/github.com/hyperledger/fabric/peer#</span><br><span class="line">root@d0533ffe1864:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer chaincode query -C mychannel -n mycc -c &apos;&#123;&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]&#125;&apos;</span><br><span class="line">Error: endorsement failure during query. response: status:500 message:&quot;failed to execute transaction b8b740aab0e6dd10cfe62416240ef94bfb90a55358904233c4d60dd5a39e6fe3: [channel mychannel] failed to get chaincode container info for mycc:1.0: could not get chaincode code: chaincode fingerprint mismatch: data mismatch&quot;</span><br><span class="line">root@d0533ffe1864:/opt/gopath/src/github.com/hyperledger/fabric/peer#</span><br><span class="line">root@d0533ffe1864:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer chaincode invoke -o orderer.example.com:7050 --tls true --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C mychannel -n mycc --peerAddresses peer1.org1.example.com:8051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/tls/ca.crt  -c &apos;&#123;&quot;Args&quot;:[&quot;invoke&quot;,&quot;a&quot;,&quot;b&quot;,&quot;50&quot;]&#125;&apos;</span><br><span class="line">Error: endorsement failure during invoke. response: status:500 message:&quot;failed to execute transaction aec5a0ccbcf86032774dc80220b90419d2816cc3f050a104c1cfcde55a2247cb: [channel mychannel] failed to get chaincode container info for mycc:1.0: could not get chaincode code: chaincode fingerprint mismatch: data mismatch&quot;</span><br></pre></td></tr></table></figure>
<h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><p>另外，社区里的hucg编写了一篇源码文章：<a href="https://blog.csdn.net/love_feng_forever/article/details/100532324" target="_blank" rel="noopener">https://blog.csdn.net/love_feng_forever/article/details/100532324</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2019/09/02/hyperledger-projects/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="区块链、Go语言">
      <meta itemprop="image" content="http://img.lessisbetter.site/gzh-qrcode-logo-small.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Go语言充电站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/02/hyperledger-projects/" class="post-title-link" itemprop="url">Hyperledger项目介绍</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-09-02 15:04:06" itemprop="dateCreated datePublished" datetime="2019-09-02T15:04:06+08:00">2019-09-02</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-09-04 10:58:38" itemprop="dateModified" datetime="2019-09-04T10:58:38+08:00">2019-09-04</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Hyperledger下有许多区块链相关的项目，曾以为它们分别是不同的类别，专注不同的功能，梳理一下其实并不是这样，比如光区块链框架就有Fabric、Iroha和Sawtooth。</p>
<p><img src="http://img.lessisbetter.site/2019-09-hyperledger-projects.png" alt="hyperledger projects"></p>
<p>各项目的简要介绍以及TWGC的介绍，一定要看看Baohua Yang大佬的<a href="https://github.com/dWChina/ibm-opentech-ma/blob/master/fabric1.4LTS/02_Hyperledger_Overview.pdf" target="_blank" rel="noopener">PPT</a>，ppt介绍Hyperledger社区的现状，各子项目概览，以及发展方向，以及Hyperledger 中国技术工作组的最新动态。。</p>
<p>做Fabric相关的工作，需要关注Fabric、Cello、Caliper、Explorer等几个项目。</p>
<p><img src="http://img.lessisbetter.site/2019-09-fabric-projects-archs.png" alt="fabric projects arch"></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2019/09/02/fabric-sdk-go-chaincode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="区块链、Go语言">
      <meta itemprop="image" content="http://img.lessisbetter.site/gzh-qrcode-logo-small.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Go语言充电站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/02/fabric-sdk-go-chaincode/" class="post-title-link" itemprop="url">使用fabric-sdk-go操作链码</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-09-02 14:55:16" itemprop="dateCreated datePublished" datetime="2019-09-02T14:55:16+08:00">2019-09-02</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-09-05 11:45:15" itemprop="dateModified" datetime="2019-09-05T11:45:15+08:00">2019-09-05</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文把与fabric网络交互的baas、应用程序、客户端统称成为客户端，它们可以使用sdk和fabric网络进行交互，sdk调用grpc可以与指定的peer和orderer进行通信，本文的目的是在BYFN搭建的fabric网络的基础之上，展示如何使用fabric-sdk-go操作链码。</p>
<p><img src="http://img.lessisbetter.site/2019-09-fabric-sdk.png" alt="fabric sdk"></p>
<h2 id="fabric-sdk-go项目简介"><a href="#fabric-sdk-go项目简介" class="headerlink" title="fabric-sdk-go项目简介"></a>fabric-sdk-go项目简介</h2><p><a href="https://github.com/hyperledger/fabric-sdk-go" target="_blank" rel="noopener">fabric-sdk-go</a>是Fabric官方的Go语言SDK，它的目录结构如下：</p>
<p><img src="http://img.lessisbetter.site/2019-09-fabric-sd-go.png" alt="fabric sdk go"></p>
<p>有2个目录需要注意一下，internal和third_party，它们两个包含了sdk依赖的一些代码，来自于fabric、fabric-ca，当使用到fabric的一些类型时，应当使用以下的方式，而不是直接导入fabric或者fabric-ca：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"github.com/hyperledger/fabric-sdk-go/third_party/github.com/hyperledger/fabric/xxx"</span></span><br></pre></td></tr></table></figure>
<p>pkg目录是sdk的主要实现，<a href="https://godoc.org/github.com/hyperledger/fabric-sdk-go" target="_blank" rel="noopener">doc 文档</a>介绍了不同目录所提供的功能，以及给出了接口调用样例：</p>
<ul>
<li>pkg/fabsdk：主package，主要用来生成fabsdk以及各种其他pkg使用的option context。</li>
<li>pkg/client/channel：主要用来调用、查询链码，或者注册链码事件。</li>
<li>pkg/client/resmgmt：主要用来fabric网络的管理，比如创建、加入通道，安装、实例化和升级链码。</li>
<li>pkg/client/event:配合channel模块来进行链码事件注册和过滤。</li>
<li>pkg/client/ledger：主要用来账本的查询，查询区块、交易、配置等。</li>
<li>pkg/client/msp：主要用来管理fabric的成员关系。</li>
</ul>
<blockquote>
<p>想用好fabric-go-sdk，建议仔细看看<a href="https://godoc.org/github.com/hyperledger/fabric-sdk-go" target="_blank" rel="noopener">doc 文档</a>。</p>
</blockquote>
<h2 id="使用SDK步骤"><a href="#使用SDK步骤" class="headerlink" title="使用SDK步骤"></a>使用SDK步骤</h2><ol>
<li>为client编写配置文件config.yaml</li>
<li>为client创建fabric sdk实例fabsdk</li>
<li>为client创建resource manage client，<strong>简称RC</strong>，RC用来进行管理操作的client，比如通道的创建，链码的安装、实例化和升级等</li>
<li>为client创建channel client，<strong>简称CC</strong>，CC用来链码的调用、查询以及链码事件的注册和取消注册</li>
</ol>
<h2 id="SDK配置文件config-yaml"><a href="#SDK配置文件config-yaml" class="headerlink" title="SDK配置文件config.yaml"></a>SDK配置文件config.yaml</h2><p>client使用sdk与fabric网络交互，需要告诉sdk两类信息：</p>
<ol>
<li>我是谁：即当前client的信息，包含所属组织、密钥和证书文件的路径等，这是每个client专用的信息。</li>
<li>对方是谁：即fabric网络结构的信息，channel、org、orderer和peer等的怎么组合起当前fabric网络的，这些结构信息应当与<code>configytx.yaml</code>中是一致的。这是通用配置，每个客户端都可以拿来使用。另外，这部分信息并不需要是完整fabric网络信息，如果当前client只和部分节点交互，那配置文件中只需要包含所使用到的网络信息。</li>
</ol>
<p><img src="http://img.lessisbetter.site/2019-09-fabric-sdk-config.yaml.png" alt="fabric sdk config"></p>
<p>这里提供一个适合<a href="https://github.com/hyperledger/fabric-samples/tree/release-1.4/first-network" target="_blank" rel="noopener">BFYN</a>的精简配置文件<a href="https://github.com/Shitaibin/fabric-sdk-go-sample/blob/master/config/config.yaml" target="_blank" rel="noopener">fabric-sdk-go-sample/config.yaml</a>。</p>
<h2 id="使用go-mod管理依赖"><a href="#使用go-mod管理依赖" class="headerlink" title="使用go mod管理依赖"></a>使用go mod管理依赖</h2><p>fabric-sdk-go目前本身使用go modules管理依赖，从<a href="https://github.com/hyperledger/fabric-sdk-go/blob/master/go.mod" target="_blank" rel="noopener">go.mod</a>可知，依赖的一些包指定了具体的版本，如果项目依赖的版本和sdk依赖的版本不同，会产生编译问题。</p>
<p>建议项目也使用go moudles管理依赖，然后相同的软件包可以使用相同的版本，可以这样操作：</p>
<ol>
<li>go mod init初始化好项目的go.mod文件。</li>
<li>编写代码，完成后运行go mod run，会自动下载依赖的项目，但版本可能与fabric-sdk-go中的依赖版本不同，编译存在问题。</li>
<li>把<a href="https://github.com/hyperledger/fabric-sdk-go/blob/master/go.mod" target="_blank" rel="noopener">go.mod</a>中的内容复制到项目的go.mod中，然后保存，go mod会自动合并相同的依赖，运行go mod tidy，会自动添加新的依赖或删除不需要的依赖。</li>
</ol>
<p>项目的go mod样例可以参考<a href="https://github.com/securekey/fabric-examples/blob/master/fabric-cli/cmd/fabric-cli/go.mod" target="_blank" rel="noopener">securekey/fabric-examples … /go.mod</a>，<a href="https://github.com/Shitaibin/fabric-sdk-go-sample/blob/master/go.mod" target="_blank" rel="noopener">shitaibin/fabric-sdk-go-sample/go.mod</a>。</p>
<h2 id="创建Client"><a href="#创建Client" class="headerlink" title="创建Client"></a>创建Client</h2><h3 id="利用config-yaml创建fabsdk"><a href="#利用config-yaml创建fabsdk" class="headerlink" title="利用config.yaml创建fabsdk"></a>利用config.yaml创建fabsdk</h3><p>通过<code>config.FromFile</code>解析配置文件，然后通过<code>fabsdk.New</code>创建sdk实例。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"github.com/hyperledger/fabric-sdk-go/pkg/core/config"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"github.com/hyperledger/fabric-sdk-go/pkg/fabsdk"</span></span><br><span class="line"></span><br><span class="line">sdk, err := fabsdk.New(config.FromFile(c.ConfigPath))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  log.Panicf(<span class="string">"failed to create fabric sdk: %s"</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建RC"><a href="#创建RC" class="headerlink" title="创建RC"></a>创建RC</h3><p>管理员账号才能进行fabric网络的管理操作，所以创建rc一定要使用管理员账号。</p>
<p>通过<code>fabsdk.WithOrg(&quot;Org1&quot;)</code>和<code>fabsdk.WithUser(&quot;Admin&quot;)</code>指定Org1的Admin账户，使用<code>sdk.Context</code>创建<strong>clientProvider</strong>，然后通过<code>resmgmt.New</code>创建rc。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> 	<span class="string">"github.com/hyperledger/fabric-sdk-go/pkg/client/resmgmt"</span></span><br><span class="line"></span><br><span class="line">rcp := sdk.Context(fabsdk.WithUser(<span class="string">"Admin"</span>), fabsdk.WithOrg(<span class="string">"Org1"</span>))</span><br><span class="line">rc, err := resmgmt.New(rcp)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  log.Panicf(<span class="string">"failed to create resource client: %s"</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建CC"><a href="#创建CC" class="headerlink" title="创建CC"></a>创建CC</h3><p>创建cc使用用户账号，进行链码的调用和查询，使用<code>sdk.ChannelContext</code>创建<strong>channelProvider</strong>，需要指定channelID和用户User1，然后通过<code>channel.New</code>创建cc，此cc就是调用channelID对应channel上链码的channel client。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> 	<span class="string">"github.com/hyperledger/fabric-sdk-go/pkg/client/channel"</span></span><br><span class="line"></span><br><span class="line">ccp := sdk.ChannelContext(ChannelID, fabsdk.WithUser(<span class="string">"User1"</span>))</span><br><span class="line">cc, err := channel.New(ccp)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  log.Panicf(<span class="string">"failed to create channel client: %s"</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="管理操作"><a href="#管理操作" class="headerlink" title="管理操作"></a>管理操作</h2><h3 id="安装链码"><a href="#安装链码" class="headerlink" title="安装链码"></a>安装链码</h3><p>安装链码使用<code>rc.InstallCC</code>接口，需要指定<code>resmgmt.InstallCCRequest</code>以及在哪些peers上面安装。<code>resmgmt.InstallCCRequest</code>指明了链码ID、链码路径、链码版本以及打包后的链码。</p>
<p>打包链码需要使用到链码路径<code>CCPath</code>和<code>GoPath</code>，<code>GoPath</code>即本机的<code>$GOPATH</code>，<code>CCPath</code>是相对于<code>GoPath</code>的<strong>相对路径</strong>，如果路径设置不对，会造成sdk找不到链码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pack the chaincode</span></span><br><span class="line">ccPkg, err := gopackager.NewCCPackage(<span class="string">"github.com/hyperledger/fabric-samples/chaincode/chaincode_example02/go/"</span>, <span class="string">"/Users/shitaibin/go"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> errors.WithMessage(err, <span class="string">"pack chaincode error"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new request of installing chaincode</span></span><br><span class="line">req := resmgmt.InstallCCRequest&#123;</span><br><span class="line">  Name:    c.CCID,</span><br><span class="line">  Path:    c.CCPath,</span><br><span class="line">  Version: v,</span><br><span class="line">  Package: ccPkg,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reqPeers := resmgmt.WithTargetEndpoints(<span class="string">"peer0.org1.example.com"</span>)</span><br><span class="line">resps, err := rc.InstallCC(req, reqPeers)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> errors.WithMessage(err, <span class="string">"installCC error"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实例化链码"><a href="#实例化链码" class="headerlink" title="实例化链码"></a>实例化链码</h3><p>实例化链码需要使用<code>rc.InstantiateCC</code>接口，需要通过ChannelID、<code>resmgmt.InstantiateCCRequest</code>和peers，指明在哪个channel上实例化链码，请求包含了链码的ID、路径、版本，以及初始化参数和背书策略，背书策略可以通过<code>cauthdsl.FromString</code>生成。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// endorser policy</span></span><br><span class="line">org1OrOrg2 := <span class="string">"OR('Org1MSP.member','Org2MSP.member')"</span></span><br><span class="line">ccPolicy, err := cauthdsl.FromString(org1OrOrg2)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> errors.WithMessage(err, <span class="string">"gen policy from string error"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new request</span></span><br><span class="line">args := packArgs([]<span class="keyword">string</span>&#123;<span class="string">"init"</span>, <span class="string">"a"</span>, <span class="string">"100"</span>, <span class="string">"b"</span>, <span class="string">"200"</span>&#125;)</span><br><span class="line">req := resmgmt.InstantiateCCRequest&#123;</span><br><span class="line">  Name:    c.CCID,</span><br><span class="line">  Path:    c.CCPath,</span><br><span class="line">  Version: v,</span><br><span class="line">  Args:    args,</span><br><span class="line">  Policy:  ccPolicy,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// send request and handle response</span></span><br><span class="line">reqPeers := resmgmt.WithTargetEndpoints(<span class="string">"peer0.org1.example.com"</span>)</span><br><span class="line">resp, err := rc.InstantiateCC(ChannelID, req, reqPeers)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> errors.WithMessage(err, <span class="string">"instantiate chaincode error"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="升级链码"><a href="#升级链码" class="headerlink" title="升级链码"></a>升级链码</h3><p>升级链码和实例化链码是非常相似的，不同点只在请求是<code>resmgmt.UpgradeCCRequest</code>，调用的接口是<code>rc.UpgradeCC</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// endorser policy</span></span><br><span class="line">org1AndOrg2 := <span class="string">"AND('Org1MSP.member','Org2MSP.member')"</span></span><br><span class="line">ccPolicy, err := c.genPolicy(org1AndOrg2)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> errors.WithMessage(err, <span class="string">"gen policy from string error"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new request</span></span><br><span class="line">args := packArgs([]<span class="keyword">string</span>&#123;<span class="string">"init"</span>, <span class="string">"a"</span>, <span class="string">"100"</span>, <span class="string">"b"</span>, <span class="string">"200"</span>&#125;)</span><br><span class="line">req := resmgmt.UpgradeCCRequest&#123;</span><br><span class="line">  Name:    c.CCID,</span><br><span class="line">  Path:    c.CCPath,</span><br><span class="line">  Version: v,</span><br><span class="line">  Args:    args,</span><br><span class="line">  Policy:  ccPolicy,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// send request and handle response</span></span><br><span class="line">reqPeers := resmgmt.WithTargetEndpoints(<span class="string">"peer0.org1.example.com"</span>)</span><br><span class="line">resp, err := rc.UpgradeCC(ChannelID, req, reqPeers)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> errors.WithMessage(err, <span class="string">"instantiate chaincode error"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h2><h3 id="调用链码"><a href="#调用链码" class="headerlink" title="调用链码"></a>调用链码</h3><p>调用链码使用<code>cc.Execute</code>接口，使用入参<code>channel.Request</code>和peers指明要让哪些peer上执行链码，进行背书。<code>channel.Request</code>指明了要调用的链码，以及链码内要Invoke的函数args，args是序列化的结果，序列化是自定义的，只要链码能够按相同的规则进行反序列化即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new channel request for invoke</span></span><br><span class="line">args := packArgs([]<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"10"</span>&#125;)</span><br><span class="line">req := channel.Request&#123;</span><br><span class="line">  ChaincodeID: c.CCID,</span><br><span class="line">  Fcn:         <span class="string">"invoke"</span>,</span><br><span class="line">  Args:        args,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// send request and handle response</span></span><br><span class="line"><span class="comment">// peers is needed</span></span><br><span class="line">reqPeers := channel.WithTargetEndpoints(<span class="string">"peer0.org1.example.com"</span>)</span><br><span class="line">resp, err := cc.Execute(req, reqPeers)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> errors.WithMessage(err, <span class="string">"invoke chaincode error"</span>)</span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">"invoke chaincode tx: %s"</span>, resp.TransactionID)</span><br></pre></td></tr></table></figure>
<h3 id="查询链码"><a href="#查询链码" class="headerlink" title="查询链码"></a>查询链码</h3><p>查询和调用链码是非常相似的，使用相同的<code>channel.Request</code>，指明了Invoke链码中的<code>query</code>函数，然后调用<code>cc.Query</code>进行查询操作，这样节点不会对请求进行背书。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new channel request for query</span></span><br><span class="line">req := channel.Request&#123;</span><br><span class="line">  ChaincodeID: c.CCID,</span><br><span class="line">  Fcn:         <span class="string">"query"</span>,</span><br><span class="line">  Args:        packArgs([]<span class="keyword">string</span>&#123;keys&#125;),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// send request and handle response</span></span><br><span class="line">reqPeers := channel.WithTargetEndpoints(peer)</span><br><span class="line">resp, err := cc.Query(req, reqPeers)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> errors.WithMessage(err, <span class="string">"query chaincode error"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">"query chaincode tx: %s"</span>, resp.TransactionID)</span><br><span class="line">log.Printf(<span class="string">"result: %v"</span>, <span class="keyword">string</span>(resp.Payload))</span><br></pre></td></tr></table></figure>
<h2 id="示例项目"><a href="#示例项目" class="headerlink" title="示例项目"></a>示例项目</h2><p>本文的基础是创建了一个结合fabric byfn的示例项目，在byfn的基础之上对链码进行安装、实例化、升级，调用和查询等操作，项目的使用可见项目<a href="https://github.com/Shitaibin/fabric-sdk-go-sample" target="_blank" rel="noopener">README文档</a>，项目地址：<a href="https://github.com/Shitaibin/fabric-sdk-go-sample" target="_blank" rel="noopener">https://github.com/Shitaibin/fabric-sdk-go-sample</a> ，项目样例执行后，可见新部署和升级成功的链码容器，操作日志可见项目。</p>
<p><img src="http://img.lessisbetter.site/2019-09-byfn-sdk.png" alt="byfn-sdk"></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2019/08/27/protobuf-in-go-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="区块链、Go语言">
      <meta itemprop="image" content="http://img.lessisbetter.site/gzh-qrcode-logo-small.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Go语言充电站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/27/protobuf-in-go-2/" class="post-title-link" itemprop="url">Go是如何实现protobuf的编解码的(2)：源码</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-27 20:27:13" itemprop="dateCreated datePublished" datetime="2019-08-27T20:27:13+08:00">2019-08-27</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-09-07 11:19:50" itemprop="dateModified" datetime="2019-09-07T11:19:50+08:00">2019-09-07</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这是一篇姊妹篇文章，浅析一下Go是如何实现protobuf编解码的：</p>
<ol>
<li><a href="http://lessisbetter.site/2019/08/26/protobuf-in-go/">Go是如何实现protobuf的编解码的(1): 原理</a></li>
<li><a href="http://lessisbetter.site/2019/08/27/protobuf-in-go-2/">Go是如何实现protobuf的编解码的(2): 源码</a></li>
</ol>
<p>本编是第二篇。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇文章<a href="http://lessisbetter.site/2019/08/26/protobuf-in-go/">Go是如何实现protobuf的编解码的（1）：原理</a><br>中已经指出了<strong>Go语言数据和Protobuf数据的编解码是由包<code>github.com/golang/protobuf/proto</code>完成的</strong>，本编就来分析一下proto包是如何实现编解码的。</p>
<p><img src="http://img.lessisbetter.site/2019-09-marshal-unmarshal.png" alt=""></p>
<h2 id="编解码原理"><a href="#编解码原理" class="headerlink" title="编解码原理"></a>编解码原理</h2><p>编解码包都有支持的编解码类型，我们暂且把这些类型称为底层类型，编解码的本质是：</p>
<ol>
<li>为每一个底层类型配备一个或多个编解码函数</li>
<li>把一个结构体的字段，递归的拆解成底层类型，然后选择合适的函数进行编码或解码操作</li>
</ol>
<p><img src="http://img.lessisbetter.site/2019-09-protobuf-marshal.png" alt=""></p>
<p>接下来先看编码，再看解码。</p>
<h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><blockquote>
<p>约定：以下所有的代码片，如果是request.pb.go或main.go中的代码，会在第一行标记文件名，否则都是proto包的源码。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"./types"</span></span><br><span class="line">	<span class="string">"github.com/golang/protobuf/proto"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	req := &amp;types.Request&#123;Data: <span class="string">"Hello Dabin"</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Marshal</span></span><br><span class="line">	encoded, err := proto.Marshal(req)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"Encode to protobuf data error: %v"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编码调用的是<code>proto.Marshal</code>函数，它可以完成的是Go语言数据序列化成protobuf数据，返回序列化结果或错误。</p>
<p>proto编译成的Go结构体都是符合<code>Message</code>接口的，从<code>Marshal</code>可知Go结构体有3种序列化方式：</p>
<ol>
<li><code>pb Message</code>满足<code>newMarshaler</code>接口，则调用<code>XXX_Marshal()</code>进行序列化。</li>
<li><code>pb</code>满足<code>Marshaler</code>接口，则调用<code>Marshal()</code>进行序列化，这种方式适合某类型自定义序列化规则的情况。</li>
<li>否则，使用默认的序列化方式，创建一个Warpper，利用wrapper对<code>pb</code>进行序列化，后面会介绍方式1实际就是使用方式3。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Marshal takes a protocol buffer message</span></span><br><span class="line"><span class="comment">// and encodes it into the wire format, returning the data.</span></span><br><span class="line"><span class="comment">// This is the main entry point.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Marshal</span><span class="params">(pb Message)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> m, ok := pb.(newMarshaler); ok &#123;</span><br><span class="line">		siz := m.XXX_Size()</span><br><span class="line">		b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">0</span>, siz)</span><br><span class="line">		<span class="keyword">return</span> m.XXX_Marshal(b, <span class="literal">false</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> m, ok := pb.(Marshaler); ok &#123;</span><br><span class="line">		<span class="comment">// If the message can marshal itself, let it do it, for compatibility.</span></span><br><span class="line">		<span class="comment">// <span class="doctag">NOTE:</span> This is not efficient.</span></span><br><span class="line">		<span class="keyword">return</span> m.Marshal()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// in case somehow we didn't generate the wrapper</span></span><br><span class="line">	<span class="keyword">if</span> pb == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, ErrNil</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> info InternalMessageInfo</span><br><span class="line">	siz := info.Size(pb)</span><br><span class="line">	b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">0</span>, siz)</span><br><span class="line">	<span class="keyword">return</span> info.Marshal(b, pb, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>newMarshaler</code>和<code>Marshaler</code>如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// newMarshaler is the interface representing objects that can marshal themselves.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This exists to support protoc-gen-go generated messages.</span></span><br><span class="line"><span class="comment">// The proto package will stop type-asserting to this interface in the future.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// DO NOT DEPEND ON THIS.</span></span><br><span class="line"><span class="keyword">type</span> newMarshaler <span class="keyword">interface</span> &#123;</span><br><span class="line">	XXX_Size() <span class="keyword">int</span></span><br><span class="line">	XXX_Marshal(b []<span class="keyword">byte</span>, deterministic <span class="keyword">bool</span>) ([]<span class="keyword">byte</span>, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Marshaler is the interface representing objects that can marshal themselves.</span></span><br><span class="line"><span class="keyword">type</span> Marshaler <span class="keyword">interface</span> &#123;</span><br><span class="line">	Marshal() ([]<span class="keyword">byte</span>, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Request</code>实现了<code>newMarshaler</code>接口，<code>XXX_Marshal</code>实现如下，它实际是调用了<code>xxx_messageInfo_Request.Marshal</code>，<code>xxx_messageInfo_Request</code>是定义在<code>request.pb.go</code>中的一个全局变量，类型就是<code>InternalMessageInfo</code>，实际就是前文提到的wrapper。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// request.pb.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Request)</span> <span class="title">XXX_Marshal</span><span class="params">(b []<span class="keyword">byte</span>, deterministic <span class="keyword">bool</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"Called xxx marshal\n"</span>)</span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">"I want see stack trace"</span>)</span><br><span class="line">	<span class="keyword">return</span> xxx_messageInfo_Request.Marshal(b, m, deterministic)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xxx_messageInfo_Request proto.InternalMessageInfo</span><br></pre></td></tr></table></figure>
<p>本质上，<code>XXX_Marshal</code>也是wrapper，后面才是真正序列化的主体函数在proto包中。</p>
<p><code>InternalMessageInfo</code>主要是用来缓存序列化和反序列化需要用到的信息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InternalMessageInfo is a type used internally by generated .pb.go files.</span></span><br><span class="line"><span class="comment">// This type is not intended to be used by non-generated code.</span></span><br><span class="line"><span class="comment">// This type is not subject to any compatibility guarantee.</span></span><br><span class="line"><span class="keyword">type</span> InternalMessageInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">	marshal   *marshalInfo   <span class="comment">// marshal信息</span></span><br><span class="line">	unmarshal *unmarshalInfo <span class="comment">// unmarshal信息</span></span><br><span class="line">	merge     *mergeInfo</span><br><span class="line">	discard   *discardInfo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>InternalMessageInfo.Marshal</code>首先是获取待序列化类型的序列化信息<code>u marshalInfo</code>，然后利用<code>u.marshal</code>进行序列化。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Marshal is the entry point from generated code,</span></span><br><span class="line"><span class="comment">// and should be ONLY called by generated code.</span></span><br><span class="line"><span class="comment">// It marshals msg to the end of b.</span></span><br><span class="line"><span class="comment">// a is a pointer to a place to store cached marshal info.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *InternalMessageInfo)</span> <span class="title">Marshal</span><span class="params">(b []<span class="keyword">byte</span>, msg Message, deterministic <span class="keyword">bool</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 获取该message类型的MarshalInfo，这些信息都缓存起来了</span></span><br><span class="line">	<span class="comment">// 大量并发时无需重复创建</span></span><br><span class="line">	u := getMessageMarshalInfo(msg, a)</span><br><span class="line">	<span class="comment">// 入参校验</span></span><br><span class="line">	ptr := toPointer(&amp;msg)</span><br><span class="line">	<span class="keyword">if</span> ptr.isNil() &#123;</span><br><span class="line">		<span class="comment">// We get here if msg is a typed nil ((*SomeMessage)(nil)),</span></span><br><span class="line">		<span class="comment">// so it satisfies the interface, and msg == nil wouldn't</span></span><br><span class="line">		<span class="comment">// catch it. We don't want crash in this case.</span></span><br><span class="line">		<span class="keyword">return</span> b, ErrNil</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 根据MarshalInfo对数据进行marshal</span></span><br><span class="line">	<span class="keyword">return</span> u.marshal(b, ptr, deterministic)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于每种类型的序列化信息是一致的，所以<code>getMessageMarshalInfo</code>对序列化信息进行了缓存，缓存在<code>a.marshal</code>中，如果a中不存在marshal信息，则去生成，但不进行初始化，然后保存到a中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMessageMarshalInfo</span><span class="params">(msg <span class="keyword">interface</span>&#123;&#125;, a *InternalMessageInfo)</span> *<span class="title">marshalInfo</span></span> &#123;</span><br><span class="line">	<span class="comment">// u := a.marshal, but atomically.</span></span><br><span class="line">	<span class="comment">// We use an atomic here to ensure memory consistency.</span></span><br><span class="line">	<span class="comment">// 从InternalMessageInfo中读取</span></span><br><span class="line">	u := atomicLoadMarshalInfo(&amp;a.marshal)</span><br><span class="line">	<span class="comment">// 读取不到代表未保存过</span></span><br><span class="line">	<span class="keyword">if</span> u == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Get marshal information from type of message.</span></span><br><span class="line">		t := reflect.ValueOf(msg).Type()</span><br><span class="line">		<span class="keyword">if</span> t.Kind() != reflect.Ptr &#123;</span><br><span class="line">			<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"cannot handle non-pointer message type %v"</span>, t))</span><br><span class="line">		&#125;</span><br><span class="line">		u = getMarshalInfo(t.Elem())</span><br><span class="line">		<span class="comment">// Store it in the cache for later users.</span></span><br><span class="line">		<span class="comment">// a.marshal = u, but atomically.</span></span><br><span class="line">		atomicStoreMarshalInfo(&amp;a.marshal, u)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> u</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>getMarshalInfo</code>只是创建了一个<code>marshalInfo</code>对象，填充了字段<code>typ</code>，剩余的字段未填充。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// getMarshalInfo returns the information to marshal a given type of message.</span><br><span class="line">// The info it returns may not necessarily initialized.</span><br><span class="line">// t is the type of the message (NOT the pointer to it).</span><br><span class="line">// 获取MarshalInfo结构体，如果不存在则使用message类型t创建1个</span><br><span class="line">func getMarshalInfo(t reflect.Type) *marshalInfo &#123;</span><br><span class="line">	marshalInfoLock.Lock()</span><br><span class="line">	u, ok := marshalInfoMap[t]</span><br><span class="line">	if !ok &#123;</span><br><span class="line">		u = &amp;marshalInfo&#123;typ: t&#125;</span><br><span class="line">		marshalInfoMap[t] = u</span><br><span class="line">	&#125;</span><br><span class="line">	marshalInfoLock.Unlock()</span><br><span class="line">	return u</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// marshalInfo is the information used for marshaling a message.</span><br><span class="line">type marshalInfo struct &#123;</span><br><span class="line">	typ          reflect.Type</span><br><span class="line">	fields       []*marshalFieldInfo</span><br><span class="line">	unrecognized field                      // offset of XXX_unrecognized</span><br><span class="line">	extensions   field                      // offset of XXX_InternalExtensions</span><br><span class="line">	v1extensions field                      // offset of XXX_extensions</span><br><span class="line">	sizecache    field                      // offset of XXX_sizecache</span><br><span class="line">	initialized  int32                      // 0 -- only typ is set, 1 -- fully initialized</span><br><span class="line">	messageset   bool                       // uses message set wire format</span><br><span class="line">	hasmarshaler bool                       // has custom marshaler</span><br><span class="line">	sync.RWMutex                            // protect extElems map, also for initialization</span><br><span class="line">	extElems     map[int32]*marshalElemInfo // info of extension elements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>marshalInfo.marshal</code>是Marshal真实主体，会判断u是否已经初始化，如果未初始化调用<code>computeMarshalInfo</code>计算Marshal需要的信息，实际就是填充<code>marshalInfo</code>中的各种字段。</p>
<p><code>u.hasmarshaler</code>代表当前类型是否实现了<code>Marshaler</code>接口，直接调用Marshal函数进行序列化。可以确定Marshal函数的序列化方式2，即实现<code>Marshaler</code>接口的方法，最后肯定也会调用<code>marshalInfo.marshal</code>。</p>
<p>该函数的主体是一个for循环，依次遍历该类型的每一个字段，对required属性进行校验，然后按字段类型，调用<code>f.marshaler</code>对该字段类型进行序列化。这个<code>f.marshaler</code>哪来的呢？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// marshal is the main function to marshal a message. It takes a byte slice and appends</span></span><br><span class="line"><span class="comment">// the encoded data to the end of the slice, returns the slice and error (if any).</span></span><br><span class="line"><span class="comment">// ptr is the pointer to the message.</span></span><br><span class="line"><span class="comment">// If deterministic is true, map is marshaled in deterministic order.</span></span><br><span class="line"><span class="comment">// 该函数是Marshal的主体函数，把消息编码为数据后，追加到b之后，最后返回b。</span></span><br><span class="line"><span class="comment">// deterministic为true代表map会以确定的顺序进行编码。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *marshalInfo)</span> <span class="title">marshal</span><span class="params">(b []<span class="keyword">byte</span>, ptr pointer, deterministic <span class="keyword">bool</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 初始化marshalInfo的基础信息</span></span><br><span class="line">	<span class="comment">// 主要是根据已有信息填充该结构体的一些字段</span></span><br><span class="line">	<span class="keyword">if</span> atomic.LoadInt32(&amp;u.initialized) == <span class="number">0</span> &#123;</span><br><span class="line">		u.computeMarshalInfo()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If the message can marshal itself, let it do it, for compatibility.</span></span><br><span class="line">	<span class="comment">// <span class="doctag">NOTE:</span> This is not efficient.</span></span><br><span class="line">	<span class="comment">// 如果该类型实现了Marshaler接口，即能够对自己Marshal，则自行Marshal</span></span><br><span class="line">	<span class="comment">// 结果追加到b</span></span><br><span class="line">	<span class="keyword">if</span> u.hasmarshaler &#123;</span><br><span class="line">		m := ptr.asPointerTo(u.typ).Interface().(Marshaler)</span><br><span class="line">		b1, err := m.Marshal()</span><br><span class="line">		b = <span class="built_in">append</span>(b, b1...)</span><br><span class="line">		<span class="keyword">return</span> b, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> err, errLater error</span><br><span class="line">	<span class="comment">// The old marshaler encodes extensions at beginning.</span></span><br><span class="line">	<span class="comment">// 检查扩展字段，把message的扩展字段追加到b</span></span><br><span class="line">	<span class="keyword">if</span> u.extensions.IsValid() &#123;</span><br><span class="line">		<span class="comment">// offset函数用来根据指针偏移量获取message的指定字段</span></span><br><span class="line">		e := ptr.offset(u.extensions).toExtensions()</span><br><span class="line">		<span class="keyword">if</span> u.messageset &#123;</span><br><span class="line">			b, err = u.appendMessageSet(b, e, deterministic)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			b, err = u.appendExtensions(b, e, deterministic)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> b, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> u.v1extensions.IsValid() &#123;</span><br><span class="line">		m := *ptr.offset(u.v1extensions).toOldExtensions()</span><br><span class="line">		b, err = u.appendV1Extensions(b, m, deterministic)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> b, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历message的每一个字段，检查并做编码，然后追加到b</span></span><br><span class="line">	<span class="keyword">for</span> _, f := <span class="keyword">range</span> u.fields &#123;</span><br><span class="line">		<span class="keyword">if</span> f.required &#123;</span><br><span class="line">			<span class="comment">// 如果required的字段未设置，则记录错误，所有的marshal工作完成后再处理</span></span><br><span class="line">			<span class="keyword">if</span> ptr.offset(f.field).getPointer().isNil() &#123;</span><br><span class="line">				<span class="comment">// Required field is not set.</span></span><br><span class="line">				<span class="comment">// We record the error but keep going, to give a complete marshaling.</span></span><br><span class="line">				<span class="keyword">if</span> errLater == <span class="literal">nil</span> &#123;</span><br><span class="line">					errLater = &amp;RequiredNotSetError&#123;f.name&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 字段为指针类型，并且为nil，代表未设置，该字段无需编码</span></span><br><span class="line">		<span class="keyword">if</span> f.isPointer &amp;&amp; ptr.offset(f.field).getPointer().isNil() &#123;</span><br><span class="line">			<span class="comment">// nil pointer always marshals to nothing</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 利用这个字段的marshaler进行编码</span></span><br><span class="line">		b, err = f.marshaler(b, ptr.offset(f.field), f.wiretag, deterministic)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err1, ok := err.(*RequiredNotSetError); ok &#123;</span><br><span class="line">				<span class="comment">// required字段但未设置错误</span></span><br><span class="line">				<span class="comment">// Required field in submessage is not set.</span></span><br><span class="line">				<span class="comment">// We record the error but keep going, to give a complete marshaling.</span></span><br><span class="line">				<span class="keyword">if</span> errLater == <span class="literal">nil</span> &#123;</span><br><span class="line">					errLater = &amp;RequiredNotSetError&#123;f.name + <span class="string">"."</span> + err1.field&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// “动态数组”中包含nil元素</span></span><br><span class="line">			<span class="keyword">if</span> err == errRepeatedHasNil &#123;</span><br><span class="line">				err = errors.New(<span class="string">"proto: repeated field "</span> + f.name + <span class="string">" has nil element"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> err == errInvalidUTF8 &#123;</span><br><span class="line">				<span class="keyword">if</span> errLater == <span class="literal">nil</span> &#123;</span><br><span class="line">					fullName := revProtoTypes[reflect.PtrTo(u.typ)] + <span class="string">"."</span> + f.name</span><br><span class="line">					errLater = &amp;invalidUTF8Error&#123;fullName&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> b, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 为识别的类型字段，直接转为bytes，追加到b</span></span><br><span class="line">	<span class="comment">// computeMarshalInfo中已经收集这些字段</span></span><br><span class="line">	<span class="keyword">if</span> u.unrecognized.IsValid() &#123;</span><br><span class="line">		s := *ptr.offset(u.unrecognized).toBytes()</span><br><span class="line">		b = <span class="built_in">append</span>(b, s...)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b, errLater</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>computeMarshalInfo</code>实际上就是对要序列化的类型，进行一次全面检查，设置好序列化要使用的数据，这其中就包含了各字段的序列化函数<code>f.marshaler</code>。我们就重点关注下这部分，struct的每一个字段都会分配一个<code>marshalFieldInfo</code>，代表这个字段序列化需要的信息，会调用<code>computeMarshalFieldInfo</code>会填充这个对象。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// computeMarshalInfo initializes the marshal info.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *marshalInfo)</span> <span class="title">computeMarshalInfo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 加锁，代表了不能同时计算marshal信息</span></span><br><span class="line">	u.Lock()</span><br><span class="line">	<span class="keyword">defer</span> u.Unlock()</span><br><span class="line">	<span class="comment">// 计算1次即可</span></span><br><span class="line">	<span class="keyword">if</span> u.initialized != <span class="number">0</span> &#123; <span class="comment">// non-atomic read is ok as it is protected by the lock</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取要marshal的message类型</span></span><br><span class="line">	t := u.typ</span><br><span class="line">	u.unrecognized = invalidField</span><br><span class="line">	u.extensions = invalidField</span><br><span class="line">	u.v1extensions = invalidField</span><br><span class="line">	u.sizecache = invalidField</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If the message can marshal itself, let it do it, for compatibility.</span></span><br><span class="line">	<span class="comment">// 判断当前类型是否实现了Marshal接口，如果实现标记为类型自有marshaler</span></span><br><span class="line">	<span class="comment">// 没用类型断言是因为t是Type类型，不是保存在某个接口的变量</span></span><br><span class="line">	<span class="comment">// <span class="doctag">NOTE:</span> This is not efficient.</span></span><br><span class="line">	<span class="keyword">if</span> reflect.PtrTo(t).Implements(marshalerType) &#123;</span><br><span class="line">		u.hasmarshaler = <span class="literal">true</span></span><br><span class="line">		atomic.StoreInt32(&amp;u.initialized, <span class="number">1</span>)</span><br><span class="line">		<span class="comment">// 可以直接返回了，后面使用自有的marshaler编码</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// get oneof implementers</span></span><br><span class="line">	<span class="comment">// 看*t实现了以下哪个接口，oneof特性</span></span><br><span class="line">	<span class="keyword">var</span> oneofImplementers []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">switch</span> m := reflect.Zero(reflect.PtrTo(t)).Interface().(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> oneofFuncsIface:</span><br><span class="line">		_, _, _, oneofImplementers = m.XXX_OneofFuncs()</span><br><span class="line">	<span class="keyword">case</span> oneofWrappersIface:</span><br><span class="line">		oneofImplementers = m.XXX_OneofWrappers()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	n := t.NumField()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// deal with XXX fields first</span></span><br><span class="line">	<span class="comment">// 遍历t的每一个XXX字段</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">		f := t.Field(i)</span><br><span class="line">		<span class="comment">// 跳过非XXX开头的字段</span></span><br><span class="line">		<span class="keyword">if</span> !strings.HasPrefix(f.Name, <span class="string">"XXX_"</span>) &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 处理以下几个protobuf自带的字段</span></span><br><span class="line">		<span class="keyword">switch</span> f.Name &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">"XXX_sizecache"</span>:</span><br><span class="line">			u.sizecache = toField(&amp;f)</span><br><span class="line">		<span class="keyword">case</span> <span class="string">"XXX_unrecognized"</span>:</span><br><span class="line">			u.unrecognized = toField(&amp;f)</span><br><span class="line">		<span class="keyword">case</span> <span class="string">"XXX_InternalExtensions"</span>:</span><br><span class="line">			u.extensions = toField(&amp;f)</span><br><span class="line">			u.messageset = f.Tag.Get(<span class="string">"protobuf_messageset"</span>) == <span class="string">"1"</span></span><br><span class="line">		<span class="keyword">case</span> <span class="string">"XXX_extensions"</span>:</span><br><span class="line">			u.v1extensions = toField(&amp;f)</span><br><span class="line">		<span class="keyword">case</span> <span class="string">"XXX_NoUnkeyedLiteral"</span>:</span><br><span class="line">			<span class="comment">// nothing to do</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">"unknown XXX field: "</span> + f.Name)</span><br><span class="line">		&#125;</span><br><span class="line">		n--</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// normal fields</span></span><br><span class="line">	<span class="comment">// 处理message的普通字段</span></span><br><span class="line">	fields := <span class="built_in">make</span>([]marshalFieldInfo, n) <span class="comment">// batch allocation</span></span><br><span class="line">	u.fields = <span class="built_in">make</span>([]*marshalFieldInfo, <span class="number">0</span>, n)</span><br><span class="line">	<span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="number">0</span>; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">		f := t.Field(i)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 跳过XXX字段</span></span><br><span class="line">		<span class="keyword">if</span> strings.HasPrefix(f.Name, <span class="string">"XXX_"</span>) &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 取fields的下一个有效字段，指针类型</span></span><br><span class="line">		<span class="comment">// j代表了fields有效字段数量，n是包含了XXX字段的总字段数量</span></span><br><span class="line">		field := &amp;fields[j]</span><br><span class="line">		j++</span><br><span class="line">		field.name = f.Name</span><br><span class="line">		<span class="comment">// 填充到u.fields</span></span><br><span class="line">		u.fields = <span class="built_in">append</span>(u.fields, field)</span><br><span class="line">		<span class="comment">// 字段的tag里包含“protobuf_oneof”特殊处理</span></span><br><span class="line">		<span class="keyword">if</span> f.Tag.Get(<span class="string">"protobuf_oneof"</span>) != <span class="string">""</span> &#123;</span><br><span class="line">			field.computeOneofFieldInfo(&amp;f, oneofImplementers)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 字段里不包含“protobuf”，代表不是protoc自动生成的字段</span></span><br><span class="line">		<span class="keyword">if</span> f.Tag.Get(<span class="string">"protobuf"</span>) == <span class="string">""</span> &#123;</span><br><span class="line">			<span class="comment">// field has no tag (not in generated message), ignore it</span></span><br><span class="line">			<span class="comment">// 删除刚刚保存的字段信息</span></span><br><span class="line">			u.fields = u.fields[:<span class="built_in">len</span>(u.fields)<span class="number">-1</span>]</span><br><span class="line">			j--</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 填充字段的marshal信息</span></span><br><span class="line">		field.computeMarshalFieldInfo(&amp;f)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// fields are marshaled in tag order on the wire.</span></span><br><span class="line">	<span class="comment">// 字段排序</span></span><br><span class="line">	sort.Sort(byTag(u.fields))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化完成</span></span><br><span class="line">	atomic.StoreInt32(&amp;u.initialized, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回顾一下<code>Request</code>的定义，它包含1个字段Data，后面<code>protobuf:...</code>描述了protobuf要使用的信息，<code>&quot;bytes,...&quot;</code>这段被称为tags，用逗号进行分割后，其中：</p>
<ul>
<li>tags[0]: bytes，代表Data类型的数据要被转换为bytes</li>
<li>tags[1]: 1，代表了字段的ID</li>
<li>tags[2]: opt，代表可行，非必须</li>
<li>tags[3]: name=data，proto文件中的名称</li>
<li>tags[4]: proto3，代表使用的protobuf版本</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// request.pb.go</span></span><br><span class="line"><span class="keyword">type</span> Request <span class="keyword">struct</span>&#123;</span><br><span class="line">	Data                 <span class="keyword">string</span>   <span class="string">`protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>computeMarshalFieldInfo</code>首先要获取字段ID和要转换的类型，填充到<code>marshalFieldInfo</code>，然后调用<code>setMarshaler</code>利用字段f和tags获取该字段类型的序列化函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// computeMarshalFieldInfo fills up the information to marshal a field.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fi *marshalFieldInfo)</span> <span class="title">computeMarshalFieldInfo</span><span class="params">(f *reflect.StructField)</span></span> &#123;</span><br><span class="line">	<span class="comment">// parse protobuf tag of the field.</span></span><br><span class="line">	<span class="comment">// tag has format of "bytes,49,opt,name=foo,def=hello!"</span></span><br><span class="line">	<span class="comment">// 获取"protobuf"的完整tag，然后使用，分割，得到上面的格式</span></span><br><span class="line">	tags := strings.Split(f.Tag.Get(<span class="string">"protobuf"</span>), <span class="string">","</span>)</span><br><span class="line">	<span class="keyword">if</span> tags[<span class="number">0</span>] == <span class="string">""</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// tag的编号，即message中设置的string name = x，则x就是这个字段的tag id</span></span><br><span class="line">	tag, err := strconv.Atoi(tags[<span class="number">1</span>])</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"tag is not an integer"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 要转换成的类型，bytes，varint等等</span></span><br><span class="line">	wt := wiretype(tags[<span class="number">0</span>])</span><br><span class="line">	<span class="comment">// 设置字段是required还是opt</span></span><br><span class="line">	<span class="keyword">if</span> tags[<span class="number">2</span>] == <span class="string">"req"</span> &#123;</span><br><span class="line">		fi.required = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 设置field和tag信息到marshalFieldInfo</span></span><br><span class="line">	fi.setTag(f, tag, wt)</span><br><span class="line">	<span class="comment">// 根据当前的tag信息（类型等），选择marshaler函数</span></span><br><span class="line">	fi.setMarshaler(f, tags)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>setMarshaler</code>的重点是<code>typeMarshaler</code>，<code>typeMarshaler</code>这个函数非常长，其实就是根据类型设置返回对于的序列化函数，比如Bool、Int32、Uint32…，如果是结构体、切片等复合类型，就可以形成递归了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setMarshaler fills up the sizer and marshaler in the info of a field.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fi *marshalFieldInfo)</span> <span class="title">setMarshaler</span><span class="params">(f *reflect.StructField, tags []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// map类型字段特殊处理</span></span><br><span class="line">	<span class="keyword">switch</span> f.Type.Kind() &#123;</span><br><span class="line">	<span class="keyword">case</span> reflect.Map:</span><br><span class="line">		<span class="comment">// map field</span></span><br><span class="line">		fi.isPointer = <span class="literal">true</span></span><br><span class="line">		fi.sizer, fi.marshaler = makeMapMarshaler(f)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	<span class="keyword">case</span> reflect.Ptr, reflect.Slice:</span><br><span class="line">		<span class="comment">// 指针字段和切片字段标记指针类型</span></span><br><span class="line">		fi.isPointer = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据字段类型和tag选择marshaler</span></span><br><span class="line">	fi.sizer, fi.marshaler = typeMarshaler(f.Type, tags, <span class="literal">true</span>, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// typeMarshaler returns the sizer and marshaler of a given field.</span></span><br><span class="line"><span class="comment">// t is the type of the field.</span></span><br><span class="line"><span class="comment">// tags is the generated "protobuf" tag of the field.</span></span><br><span class="line"><span class="comment">// If nozero is true, zero value is not marshaled to the wire.</span></span><br><span class="line"><span class="comment">// If oneof is true, it is a oneof field.</span></span><br><span class="line"><span class="comment">// 函数非常长，省略内容</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">typeMarshaler</span><span class="params">(t reflect.Type, tags []<span class="keyword">string</span>, nozero, oneof <span class="keyword">bool</span>)</span> <span class="params">(sizer, marshaler)</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">switch</span> t.Kind() &#123;</span><br><span class="line">	<span class="keyword">case</span> reflect.Bool:</span><br><span class="line">		<span class="keyword">if</span> pointer &#123;</span><br><span class="line">			<span class="keyword">return</span> sizeBoolPtr, appendBoolPtr</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> slice &#123;</span><br><span class="line">			<span class="keyword">if</span> packed &#123;</span><br><span class="line">				<span class="keyword">return</span> sizeBoolPackedSlice, appendBoolPackedSlice</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> sizeBoolSlice, appendBoolSlice</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> nozero &#123;</span><br><span class="line">			<span class="keyword">return</span> sizeBoolValueNoZero, appendBoolValueNoZero</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sizeBoolValue, appendBoolValue</span><br><span class="line">	<span class="keyword">case</span> reflect.Uint32:</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">case</span> reflect.Int32:</span><br><span class="line">	....</span><br><span class="line">	<span class="keyword">case</span> reflect.Struct:</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下是Bool和String类型的2个序列化函数示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendBoolValue</span><span class="params">(b []<span class="keyword">byte</span>, ptr pointer, wiretag <span class="keyword">uint64</span>, _ <span class="keyword">bool</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	v := *ptr.toBool()</span><br><span class="line">	b = appendVarint(b, wiretag)</span><br><span class="line">	<span class="keyword">if</span> v &#123;</span><br><span class="line">		b = <span class="built_in">append</span>(b, <span class="number">1</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		b = <span class="built_in">append</span>(b, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendStringValue</span><span class="params">(b []<span class="keyword">byte</span>, ptr pointer, wiretag <span class="keyword">uint64</span>, _ <span class="keyword">bool</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	v := *ptr.toString()</span><br><span class="line">	b = appendVarint(b, wiretag)</span><br><span class="line">	b = appendVarint(b, <span class="keyword">uint64</span>(<span class="built_in">len</span>(v)))</span><br><span class="line">	b = <span class="built_in">append</span>(b, v...)</span><br><span class="line">	<span class="keyword">return</span> b, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以序列化后的<code>[]byte</code>，应当是符合这种模式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| wiretag | data | wiretag | data | ... | data |</span><br></pre></td></tr></table></figure>
<p>OK，以上就是编码的主要流程，简单回顾一下：</p>
<ol>
<li><code>proto.Marshal</code>会调用<code>*.pb.go</code>中自动生成的Wrapper函数，Wrapper函数会调用<code>InternalMessageInfo</code>进行序列化，然后才步入序列化的正题</li>
<li>首先获取要序列化类型的marshal信息u，如果u没有初始化，则进行初始化，即设置好结构体每个字段的序列化函数，以及其他信息</li>
<li>遍历结构体的每个字段，使用u中的信息为每个字段进行编码，并把加过追加到<code>[]byte</code>，所以字段编码完成，则返回序列化的结果<code>[]byte</code>或者错误。</li>
</ol>
<h3 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h3><p><strong>解码的流程其实与编码很类似</strong>，会是上面回顾的3大步骤，主要的区别在步骤2：它要获取的是序列化类型的unmarshal信息u，如果u没有初始化，会进行初始化，设置的是结构体每个字段的反序列化函数，以及其他信息。</p>
<p>所以解码的函数解析会简要的过一遍，不再有编码那么详细的解释。</p>
<p>下面是proto包中反序列化的接口和函数定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unmarshaler is the interface representing objects that can</span></span><br><span class="line"><span class="comment">// unmarshal themselves.  The argument points to data that may be</span></span><br><span class="line"><span class="comment">// overwritten, so implementations should not keep references to the</span></span><br><span class="line"><span class="comment">// buffer.</span></span><br><span class="line"><span class="comment">// Unmarshal implementations should not clear the receiver.</span></span><br><span class="line"><span class="comment">// Any unmarshaled data should be merged into the receiver.</span></span><br><span class="line"><span class="comment">// Callers of Unmarshal that do not want to retain existing data</span></span><br><span class="line"><span class="comment">// should Reset the receiver before calling Unmarshal.</span></span><br><span class="line"><span class="keyword">type</span> Unmarshaler <span class="keyword">interface</span> &#123;</span><br><span class="line">	Unmarshal([]<span class="keyword">byte</span>) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// newUnmarshaler is the interface representing objects that can</span></span><br><span class="line"><span class="comment">// unmarshal themselves. The semantics are identical to Unmarshaler.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This exists to support protoc-gen-go generated messages.</span></span><br><span class="line"><span class="comment">// The proto package will stop type-asserting to this interface in the future.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// DO NOT DEPEND ON THIS.</span></span><br><span class="line"><span class="keyword">type</span> newUnmarshaler <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// 实现了XXX_Unmarshal</span></span><br><span class="line">	XXX_Unmarshal([]<span class="keyword">byte</span>) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unmarshal parses the protocol buffer representation in buf and places the</span></span><br><span class="line"><span class="comment">// decoded result in pb.  If the struct underlying pb does not match</span></span><br><span class="line"><span class="comment">// the data in buf, the results can be unpredictable.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Unmarshal resets pb before starting to unmarshal, so any</span></span><br><span class="line"><span class="comment">// existing data in pb is always removed. Use UnmarshalMerge</span></span><br><span class="line"><span class="comment">// to preserve and append to existing data.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unmarshal</span><span class="params">(buf []<span class="keyword">byte</span>, pb Message)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	pb.Reset()</span><br><span class="line">	<span class="comment">// pb自己有unmarshal函数，实现了newUnmarshaler接口</span></span><br><span class="line">	<span class="keyword">if</span> u, ok := pb.(newUnmarshaler); ok &#123;</span><br><span class="line">		<span class="keyword">return</span> u.XXX_Unmarshal(buf)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// pb自己有unmarshal函数，实现了Unmarshaler接口</span></span><br><span class="line">	<span class="keyword">if</span> u, ok := pb.(Unmarshaler); ok &#123;</span><br><span class="line">		<span class="keyword">return</span> u.Unmarshal(buf)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 使用默认的Unmarshal</span></span><br><span class="line">	<span class="keyword">return</span> NewBuffer(buf).Unmarshal(pb)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Request</code>实现了<code>Unmarshaler</code>接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// request.pb.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Request)</span> <span class="title">XXX_Unmarshal</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> xxx_messageInfo_Request.Unmarshal(m, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反序列化也是使用<code>InternalMessageInfo</code>进行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unmarshal is the entry point from the generated .pb.go files.</span></span><br><span class="line"><span class="comment">// This function is not intended to be used by non-generated code.</span></span><br><span class="line"><span class="comment">// This function is not subject to any compatibility guarantee.</span></span><br><span class="line"><span class="comment">// msg contains a pointer to a protocol buffer struct.</span></span><br><span class="line"><span class="comment">// b is the data to be unmarshaled into the protocol buffer.</span></span><br><span class="line"><span class="comment">// a is a pointer to a place to store cached unmarshal information.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *InternalMessageInfo)</span> <span class="title">Unmarshal</span><span class="params">(msg Message, b []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// Load the unmarshal information for this message type.</span></span><br><span class="line">	<span class="comment">// The atomic load ensures memory consistency.</span></span><br><span class="line">	<span class="comment">// 获取保存在a中的unmarshal信息</span></span><br><span class="line">	u := atomicLoadUnmarshalInfo(&amp;a.unmarshal)</span><br><span class="line">	<span class="keyword">if</span> u == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Slow path: find unmarshal info for msg, update a with it.</span></span><br><span class="line">		u = getUnmarshalInfo(reflect.TypeOf(msg).Elem())</span><br><span class="line">		atomicStoreUnmarshalInfo(&amp;a.unmarshal, u)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Then do the unmarshaling.</span></span><br><span class="line">	<span class="comment">// 执行unmarshal</span></span><br><span class="line">	err := u.unmarshal(toPointer(&amp;msg), b)</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下是反序列化的主题函数，u未初始化时会调用<code>computeUnmarshalInfo</code>设置反序列化需要的信息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unmarshal does the main work of unmarshaling a message.</span></span><br><span class="line"><span class="comment">// u provides type information used to unmarshal the message.</span></span><br><span class="line"><span class="comment">// m is a pointer to a protocol buffer message.</span></span><br><span class="line"><span class="comment">// b is a byte stream to unmarshal into m.</span></span><br><span class="line"><span class="comment">// This is top routine used when recursively unmarshaling submessages.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *unmarshalInfo)</span> <span class="title">unmarshal</span><span class="params">(m pointer, b []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> atomic.LoadInt32(&amp;u.initialized) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 为u填充unmarshal信息，以及设置每个字段类型的unmarshaler函数</span></span><br><span class="line">		u.computeUnmarshalInfo()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> u.isMessageSet &#123;</span><br><span class="line">		<span class="keyword">return</span> unmarshalMessageSet(b, m.offset(u.extensions).toExtensions())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> reqMask <span class="keyword">uint64</span> <span class="comment">// bitmask of required fields we've seen.</span></span><br><span class="line">	<span class="keyword">var</span> errLater error</span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(b) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// Read tag and wire type.</span></span><br><span class="line">		<span class="comment">// Special case 1 and 2 byte varints.</span></span><br><span class="line">		<span class="keyword">var</span> x <span class="keyword">uint64</span></span><br><span class="line">		<span class="keyword">if</span> b[<span class="number">0</span>] &lt; <span class="number">128</span> &#123;</span><br><span class="line">			x = <span class="keyword">uint64</span>(b[<span class="number">0</span>])</span><br><span class="line">			b = b[<span class="number">1</span>:]</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(b) &gt;= <span class="number">2</span> &amp;&amp; b[<span class="number">1</span>] &lt; <span class="number">128</span> &#123;</span><br><span class="line">			x = <span class="keyword">uint64</span>(b[<span class="number">0</span>]&amp;<span class="number">0x7f</span>) + <span class="keyword">uint64</span>(b[<span class="number">1</span>])&lt;&lt;<span class="number">7</span></span><br><span class="line">			b = b[<span class="number">2</span>:]</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">var</span> n <span class="keyword">int</span></span><br><span class="line">			x, n = decodeVarint(b)</span><br><span class="line">			<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> io.ErrUnexpectedEOF</span><br><span class="line">			&#125;</span><br><span class="line">			b = b[n:]</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 获取tag和wire标记</span></span><br><span class="line">		tag := x &gt;&gt; <span class="number">3</span></span><br><span class="line">		wire := <span class="keyword">int</span>(x) &amp; <span class="number">7</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// Dispatch on the tag to one of the unmarshal* functions below.</span></span><br><span class="line">		<span class="comment">// 根据tag选择该类型的unmarshalFieldInfo：f</span></span><br><span class="line">		<span class="keyword">var</span> f unmarshalFieldInfo</span><br><span class="line">		<span class="keyword">if</span> tag &lt; <span class="keyword">uint64</span>(<span class="built_in">len</span>(u.dense)) &#123;</span><br><span class="line">			f = u.dense[tag]</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			f = u.sparse[tag]</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果该类型有unmarshaler函数，则执行解码和错误处理</span></span><br><span class="line">		<span class="keyword">if</span> fn := f.unmarshal; fn != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">var</span> err error</span><br><span class="line">			<span class="comment">// 从b解析，然后填充到f的对应字段</span></span><br><span class="line">			b, err = fn(b, m.offset(f.field), wire)</span><br><span class="line">			<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">				reqMask |= f.reqMask</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> r, ok := err.(*RequiredNotSetError); ok &#123;</span><br><span class="line">				<span class="comment">// Remember this error, but keep parsing. We need to produce</span></span><br><span class="line">				<span class="comment">// a full parse even if a required field is missing.</span></span><br><span class="line">				<span class="keyword">if</span> errLater == <span class="literal">nil</span> &#123;</span><br><span class="line">					errLater = r</span><br><span class="line">				&#125;</span><br><span class="line">				reqMask |= f.reqMask</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> err != errInternalBadWireType &#123;</span><br><span class="line">				<span class="keyword">if</span> err == errInvalidUTF8 &#123;</span><br><span class="line">					<span class="keyword">if</span> errLater == <span class="literal">nil</span> &#123;</span><br><span class="line">						fullName := revProtoTypes[reflect.PtrTo(u.typ)] + <span class="string">"."</span> + f.name</span><br><span class="line">						errLater = &amp;invalidUTF8Error&#123;fullName&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Fragments with bad wire type are treated as unknown fields.</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Unknown tag.</span></span><br><span class="line">		<span class="comment">// 跳过未知tag，可能是proto中的message定义升级了，增加了一些字段，使用老版本的，就不识别新的字段</span></span><br><span class="line">		<span class="keyword">if</span> !u.unrecognized.IsValid() &#123;</span><br><span class="line">			<span class="comment">// Don't keep unrecognized data; just skip it.</span></span><br><span class="line">			<span class="keyword">var</span> err error</span><br><span class="line">			b, err = skipField(b, wire)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 检查未识别字段是不是extension</span></span><br><span class="line">		<span class="comment">// Keep unrecognized data around.</span></span><br><span class="line">		<span class="comment">// maybe in extensions, maybe in the unrecognized field.</span></span><br><span class="line">		z := m.offset(u.unrecognized).toBytes()</span><br><span class="line">		<span class="keyword">var</span> emap <span class="keyword">map</span>[<span class="keyword">int32</span>]Extension</span><br><span class="line">		<span class="keyword">var</span> e Extension</span><br><span class="line">		<span class="keyword">for</span> _, r := <span class="keyword">range</span> u.extensionRanges &#123;</span><br><span class="line">			<span class="keyword">if</span> <span class="keyword">uint64</span>(r.Start) &lt;= tag &amp;&amp; tag &lt;= <span class="keyword">uint64</span>(r.End) &#123;</span><br><span class="line">				<span class="keyword">if</span> u.extensions.IsValid() &#123;</span><br><span class="line">					mp := m.offset(u.extensions).toExtensions()</span><br><span class="line">					emap = mp.extensionsWrite()</span><br><span class="line">					e = emap[<span class="keyword">int32</span>(tag)]</span><br><span class="line">					z = &amp;e.enc</span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> u.oldExtensions.IsValid() &#123;</span><br><span class="line">					p := m.offset(u.oldExtensions).toOldExtensions()</span><br><span class="line">					emap = *p</span><br><span class="line">					<span class="keyword">if</span> emap == <span class="literal">nil</span> &#123;</span><br><span class="line">						emap = <span class="keyword">map</span>[<span class="keyword">int32</span>]Extension&#123;&#125;</span><br><span class="line">						*p = emap</span><br><span class="line">					&#125;</span><br><span class="line">					e = emap[<span class="keyword">int32</span>(tag)]</span><br><span class="line">					z = &amp;e.enc</span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="built_in">panic</span>(<span class="string">"no extensions field available"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Use wire type to skip data.</span></span><br><span class="line">		<span class="keyword">var</span> err error</span><br><span class="line">		b0 := b</span><br><span class="line">		b, err = skipField(b, wire)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		*z = encodeVarint(*z, tag&lt;&lt;<span class="number">3</span>|<span class="keyword">uint64</span>(wire))</span><br><span class="line">		*z = <span class="built_in">append</span>(*z, b0[:<span class="built_in">len</span>(b0)-<span class="built_in">len</span>(b)]...)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> emap != <span class="literal">nil</span> &#123;</span><br><span class="line">			emap[<span class="keyword">int32</span>(tag)] = e</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 校验解析到的required字段的数量，如果与u中记录的不匹配，则报错</span></span><br><span class="line">	<span class="keyword">if</span> reqMask != u.reqMask &amp;&amp; errLater == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// A required field of this message is missing.</span></span><br><span class="line">		<span class="keyword">for</span> _, n := <span class="keyword">range</span> u.reqFields &#123;</span><br><span class="line">			<span class="keyword">if</span> reqMask&amp;<span class="number">1</span> == <span class="number">0</span> &#123;</span><br><span class="line">				errLater = &amp;RequiredNotSetError&#123;n&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			reqMask &gt;&gt;= <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> errLater</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置字段反序列化函数的过程不看了，看一下怎么选函数的，<code>typeUnmarshaler</code>是为字段类型，选择反序列化函数，这些函数选择与序列化函数是一一对应的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// typeUnmarshaler returns an unmarshaler for the given field type / field tag pair.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">typeUnmarshaler</span><span class="params">(t reflect.Type, tags <span class="keyword">string</span>)</span> <span class="title">unmarshaler</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Figure out packaging (pointer, slice, or both)</span></span><br><span class="line">	slice := <span class="literal">false</span></span><br><span class="line">	pointer := <span class="literal">false</span></span><br><span class="line">	<span class="keyword">if</span> t.Kind() == reflect.Slice &amp;&amp; t.Elem().Kind() != reflect.Uint8 &#123;</span><br><span class="line">		slice = <span class="literal">true</span></span><br><span class="line">		t = t.Elem()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> t.Kind() == reflect.Ptr &#123;</span><br><span class="line">		pointer = <span class="literal">true</span></span><br><span class="line">		t = t.Elem()</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">switch</span> t.Kind() &#123;</span><br><span class="line">	<span class="keyword">case</span> reflect.Bool:</span><br><span class="line">		<span class="keyword">if</span> pointer &#123;</span><br><span class="line">			<span class="keyword">return</span> unmarshalBoolPtr</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> slice &#123;</span><br><span class="line">			<span class="keyword">return</span> unmarshalBoolSlice</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">return</span> unmarshalBoolValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>unmarshalBoolValue</code>是默认的Bool类型反序列化函数，会把protobuf数据b解码，然后转换为bool类型v，最后赋值给字段f。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unmarshalBoolValue</span><span class="params">(b []<span class="keyword">byte</span>, f pointer, w <span class="keyword">int</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> w != WireVarint &#123;</span><br><span class="line">		<span class="keyword">return</span> b, errInternalBadWireType</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Note: any length varint is allowed, even though any sane</span></span><br><span class="line">	<span class="comment">// encoder will use one byte.</span></span><br><span class="line">	<span class="comment">// See https://github.com/golang/protobuf/issues/76</span></span><br><span class="line">	x, n := decodeVarint(b)</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, io.ErrUnexpectedEOF</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> check if x&gt;1? Tests seem to indicate no.</span></span><br><span class="line">    <span class="comment">// toBool是返回bool类型的指针</span></span><br><span class="line">	<span class="comment">// 完成对字段f的赋值</span></span><br><span class="line">	v := x != <span class="number">0</span></span><br><span class="line">	*f.toBool() = v</span><br><span class="line">	<span class="keyword">return</span> b[n:], <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文分析了Go语言protobuf数据的序列化和反序列过程，可以简要概括为：</p>
<ol>
<li><code>proto.Marshal</code>和<code>proto.Unmarshal</code>会调用<code>*.pb.go</code>中自动生成的Wrapper函数，Wrapper函数会调用<code>InternalMessageInfo</code>进行(反)序列化，然后才步入(反)序列化的正题</li>
<li>首先获取要目标类型的(um)marshal信息u，如果u没有初始化，则进行初始化，即设置好结构体每个字段的(反)序列化函数，以及其他信息</li>
<li>遍历结构体的每个字段，使用u中的信息为每个字段进行编码，生成序列化的结果，或进行解码，给结构体成员进行赋值</li>
</ol>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>以下参考文章都值得阅读：</p>
<ul>
<li><a href="https://tech.meituan.com/2015/02/26/serialization-vs-deserialization.html" target="_blank" rel="noopener">https://tech.meituan.com/2015/02/26/serialization-vs-deserialization.html</a><br>《序列化和反序列化》出自美团技术团队，值得一读。</li>
<li><a href="https://github.com/golang/protobuf" target="_blank" rel="noopener">https://github.com/golang/protobuf</a><br>Go支持protocol buffer的仓库，Readme，值得详读。</li>
<li><a href="https://developers.google.com/protocol-buffers/docs/gotutorial" target="_blank" rel="noopener">https://developers.google.com/protocol-buffers/docs/gotutorial</a><br>Google Protocol Buffers的Go语言tutorial，值得详细阅读和实操。</li>
<li><a href="https://developers.google.com/protocol-buffers/docs/overview" target="_blank" rel="noopener">https://developers.google.com/protocol-buffers/docs/overview</a><br>Google Protocol Buffers的Overview，介绍了什么是Protocol Buffers，它的原理、历史（起源），以及和XML的对比，必读。</li>
<li><a href="https://developers.google.com/protocol-buffers/docs/proto3" target="_blank" rel="noopener">https://developers.google.com/protocol-buffers/docs/proto3</a><br>《Language Guide (proto3)》这篇文章介绍了proto3的定义，也可以理解为<code>.proto</code>文件的语法，就如同Go语言的语法，不懂语法怎么编写<code>.proto</code>文件？读这篇文章会了解很多原理，以及可以少踩坑，必读。</li>
<li><a href="https://developers.google.com/protocol-buffers/docs/reference/go-generated" target="_blank" rel="noopener">https://developers.google.com/protocol-buffers/docs/reference/go-generated</a><br>《Go Generated Code》这篇文章详细介绍了protoc是怎么用<code>.protoc</code>生成<code>.pb.go</code>的，可选。</li>
<li><a href="https://developers.google.com/protocol-buffers/docs/encoding#" target="_blank" rel="noopener">https://developers.google.com/protocol-buffers/docs/encoding#</a><br>《Protocol Buffers Encoding》这篇介绍编码原理，可选。</li>
<li><a href="https://godoc.org/github.com/golang/protobuf/proto" target="_blank" rel="noopener">https://godoc.org/github.com/golang/protobuf/proto</a><br>《package proto文档》可以把proto包当做Go语言操作protobuf数据的SDK，它实现了结构体和protobuf数据的转换，它和<code>.pb.go</code>文件配合使用。</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2019/08/26/protobuf-in-go/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="区块链、Go语言">
      <meta itemprop="image" content="http://img.lessisbetter.site/gzh-qrcode-logo-small.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Go语言充电站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/26/protobuf-in-go/" class="post-title-link" itemprop="url">Go是如何实现protobuf的编解码的(1)：原理</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-26 20:52:58" itemprop="dateCreated datePublished" datetime="2019-08-26T20:52:58+08:00">2019-08-26</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-09-07 11:30:58" itemprop="dateModified" datetime="2019-09-07T11:30:58+08:00">2019-09-07</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这是一篇姊妹篇文章，浅析一下Go是如何实现protobuf编解码的：</p>
<ol>
<li><a href="http://lessisbetter.site/2019/08/26/protobuf-in-go/">Go是如何实现protobuf的编解码的(1): 原理</a></li>
<li><a href="http://lessisbetter.site/2019/08/27/protobuf-in-go-2/">Go是如何实现protobuf的编解码的(2): 源码</a></li>
</ol>
<p>本编是第一篇。</p>
<h2 id="Protocol-Buffers介绍"><a href="#Protocol-Buffers介绍" class="headerlink" title="Protocol Buffers介绍"></a>Protocol Buffers介绍</h2><p>Protocol buffers缩写为protobuf，是由Google创造的一种用于序列化的标记语言，项目Github仓库：<a href="https://github.com/protocolbuffers/protobuf。" target="_blank" rel="noopener">https://github.com/protocolbuffers/protobuf。</a></p>
<p>Protobuf主要用于不同的编程语言的协作RPC场景下，定义需要序列化的数据格式。Protobuf本质上仅仅是<strong>一种用于交互的结构式定义</strong>，从功能上<strong>和XML、JSON</strong>等各种其他的交互形式都<strong>并无本质不同，只负责定义不负责数据编解码</strong>。</p>
<p>其官方介绍如下：</p>
<blockquote>
<p>Protocol buffers are Google’s language-neutral, platform-neutral, extensible <strong>mechanism for serializing structured data</strong> – think XML, but smaller, faster, and simpler. You <strong>define how you want your data to be structured</strong> once, then you can use special generated source code to easily write and read your structured data to and from a variety of data streams and using a variety of languages.</p>
</blockquote>
<h2 id="Protocol-buffers的多语言支持"><a href="#Protocol-buffers的多语言支持" class="headerlink" title="Protocol buffers的多语言支持"></a>Protocol buffers的多语言支持</h2><p>protobuf是支持多种编程语言的，即多种编程语言的类型数据可以转换成protobuf定义的类型数据，各种语言的类型对应可以看此<a href="https://developers.google.com/protocol-buffers/docs/proto3#scalar" target="_blank" rel="noopener">介绍</a>。</p>
<p>我们介绍一下protobuf对多语言的支持原理。protobuf有个程序叫<strong>protoc</strong>，它是一个编译程序，<strong>负责把proto文件编译成对应语言的文件</strong>，它已经支持了C++、C#、Java、Python，而对于Go和Dart需要安装插件才能配合生成对于语言的文件。</p>
<p>对于C++，protoc可以把<code>a.proto</code>，编译成<code>a.pb.h</code>和<code>a.pb.cc</code>。</p>
<p>对于Go，protoc需要使用插件<strong>protoc-gen-go</strong>，把<code>a.proto</code>，编译成<code>a.pb.go</code>，其中包含了定义的数据类型，它的序列化和反序列化函数等。</p>
<p><img src="http://img.lessisbetter.site/2019-09-protoc.png" alt=""></p>
<p>敲黑板，对Go语言，protoc只负责利用protoc-gen-go把proto文件编译成Go语言文件，并不负责序列化和反序列化，生成的Go语言文件中的序列化和反序列化操作都是只是wrapper。</p>
<p>那Go语言对protobuf的序列化和反序列化，是由谁完成的？</p>
<p>由<code>github.com/golang/protobuf/proto</code>完成，它负责把结构体等序列化成proto数据(<code>[]byte</code>)，把proto数据反序列化成Go结构体。</p>
<p><img src="http://img.lessisbetter.site/2019-09-marshal-unmarshal.png" alt=""></p>
<p>OK，原理部分就铺垫这些，看一个简单样例，了解protoc和protoc-gen-go的使用，以及进行序列化和反序列化操作。</p>
<h2 id="一个Hello-World样例"><a href="#一个Hello-World样例" class="headerlink" title="一个Hello World样例"></a>一个Hello World样例</h2><p>根据上面的介绍，Go语言使用protobuf我们要先安装2个工具：protoc和protoc-gen-go。</p>
<h3 id="安装protoc和protoc-gen-go"><a href="#安装protoc和protoc-gen-go" class="headerlink" title="安装protoc和protoc-gen-go"></a>安装protoc和protoc-gen-go</h3><p>首先去<a href="https://github.com/protocolbuffers/protobuf/releases/tag/v3.9.1" target="_blank" rel="noopener">下载页</a>下载符合你系统的protoc，本文示例版本如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">➜  protoc-3.9.0-osx-x86_64 tree .</span><br><span class="line">.</span><br><span class="line">├── bin</span><br><span class="line">│   └── protoc</span><br><span class="line">├── include</span><br><span class="line">│   └── google</span><br><span class="line">│       └── protobuf</span><br><span class="line">│           ├── any.proto</span><br><span class="line">│           ├── api.proto</span><br><span class="line">│           ├── compiler</span><br><span class="line">│           │   └── plugin.proto</span><br><span class="line">│           ├── descriptor.proto</span><br><span class="line">│           ├── duration.proto</span><br><span class="line">│           ├── empty.proto</span><br><span class="line">│           ├── field_mask.proto</span><br><span class="line">│           ├── source_context.proto</span><br><span class="line">│           ├── struct.proto</span><br><span class="line">│           ├── timestamp.proto</span><br><span class="line">│           ├── type.proto</span><br><span class="line">│           └── wrappers.proto</span><br><span class="line">└── readme.txt</span><br><span class="line"></span><br><span class="line">5 directories, 14 files</span><br></pre></td></tr></table></figure>
<p><strong>protoc的安装</strong>步骤在readme.txt中：</p>
<blockquote>
<p>To install, simply place this binary somewhere in your PATH.</p>
</blockquote>
<p>把<code>protoc-3.9.0-osx-x86_64/bin</code>加入到PATH。</p>
<blockquote>
<p>If you intend to use the included well known types then don’t forget to<br>copy the contents of the ‘include’ directory somewhere as well, for example<br>into ‘/usr/local/include/‘.</p>
</blockquote>
<p>如果使用已经定义好的类型，即上面include目录<code>*.proto</code>文件中的类型，把include目录下文件，拷贝到<code>/usr/local/include/</code>。</p>
<p><strong>安装protoc-gen-go：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get –u github.com/golang/protobuf/protoc-gen-go</span><br></pre></td></tr></table></figure>
<p>检查安装，应该能查到这2个程序的位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  fabric git:(release-1.4) which protoc</span><br><span class="line">/usr/local/bin/protoc</span><br><span class="line">➜  fabric git:(release-1.4) which protoc-gen-go</span><br><span class="line">/Users/shitaibin/go/bin/protoc-gen-go</span><br></pre></td></tr></table></figure>
<h3 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h3><p>创建了一个使用protoc的小玩具，项目地址<a href="https://github.com/Shitaibin/golang_step_by_step/tree/master/protobuf/helloworld1" target="_blank" rel="noopener">Github: golang_step_by_step</a>。</p>
<p>它的目录结构如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  protobuf git:(master) tree helloworld1</span><br><span class="line">helloworld1</span><br><span class="line">├── main.go</span><br><span class="line">├── request.proto</span><br><span class="line">└── types</span><br><span class="line">    └── request.pb.go</span><br></pre></td></tr></table></figure>
<h4 id="定义proto文件"><a href="#定义proto文件" class="headerlink" title="定义proto文件"></a>定义proto文件</h4><p>使用proto3，定义一个Request，<code>request.proto</code>内容如下：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// file: request.proto</span><br><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line">package helloworld;</span><br><span class="line">option go_package=&quot;./types&quot;;</span><br><span class="line"></span><br><span class="line">message Request &#123;</span><br><span class="line">    string data = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>syntax：protobuf版本，现在是proto3</li>
<li>package：不完全等价于Go的package，最好另行设定<code>go_package</code>，指定根据protoc文件生成的go语言文件的package名称。</li>
<li>message：会编译成Go的<code>struct</code>。<ul>
<li><code>string data = 1</code>：代表request的成员data是string类型，该成员的id是1，protoc给每个成员都定义一个编号，编解码的时候使用编号代替使用成员名称，压缩数据量。</li>
</ul>
</li>
</ul>
<h4 id="编译proto文件"><a href="#编译proto文件" class="headerlink" title="编译proto文件"></a>编译proto文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ protoc --go_out=. ./request.proto</span><br></pre></td></tr></table></figure>
<p><code>--go_out</code>指明了要把<code>./request.proto</code>编译成Go语言文件，生成的是<code>./types/request.pb.go</code>，注意观察一下为Request结构体生产的2个方法<code>XXX_Unmarshal</code>和<code>XXX_Marshal</code>，文件内容如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: ./types/request.pb.go</span></span><br><span class="line"><span class="comment">// Code generated by protoc-gen-go. DO NOT EDIT.</span></span><br><span class="line"><span class="comment">// source: request.proto</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> types</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	fmt <span class="string">"fmt"</span></span><br><span class="line">	math <span class="string">"math"</span></span><br><span class="line"></span><br><span class="line">	proto <span class="string">"github.com/golang/protobuf/proto"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reference imports to suppress errors if they are not otherwise used.</span></span><br><span class="line"><span class="keyword">var</span> _ = proto.Marshal</span><br><span class="line"><span class="keyword">var</span> _ = fmt.Errorf</span><br><span class="line"><span class="keyword">var</span> _ = math.Inf</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is a compile-time assertion to ensure that this generated file</span></span><br><span class="line"><span class="comment">// is compatible with the proto package it is being compiled against.</span></span><br><span class="line"><span class="comment">// A compilation error at this line likely means your copy of the</span></span><br><span class="line"><span class="comment">// proto package needs to be updated.</span></span><br><span class="line"><span class="keyword">const</span> _ = proto.ProtoPackageIsVersion3 <span class="comment">// please upgrade the proto package</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Request <span class="keyword">struct</span> &#123;</span><br><span class="line">	Data                 <span class="keyword">string</span>   <span class="string">`protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`</span></span><br><span class="line">	<span class="comment">// 以下是protobuf自动填充的字段，protobuf需要使用</span></span><br><span class="line">	XXX_NoUnkeyedLiteral <span class="keyword">struct</span>&#123;&#125; <span class="string">`json:"-"`</span></span><br><span class="line">	XXX_unrecognized     []<span class="keyword">byte</span>   <span class="string">`json:"-"`</span></span><br><span class="line">	XXX_sizecache        <span class="keyword">int32</span>    <span class="string">`json:"-"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Request)</span> <span class="title">Reset</span><span class="params">()</span></span>         &#123; *m = Request&#123;&#125; &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Request)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> proto.CompactTextString(m) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Request)</span> <span class="title">ProtoMessage</span><span class="params">()</span></span>    &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Request)</span> <span class="title">Descriptor</span><span class="params">()</span> <span class="params">([]<span class="keyword">byte</span>, []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fileDescriptor_7f73548e33e655fe, []<span class="keyword">int</span>&#123;<span class="number">0</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Request)</span> <span class="title">XXX_Unmarshal</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> xxx_messageInfo_Request.Unmarshal(m, b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 序列化函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Request)</span> <span class="title">XXX_Marshal</span><span class="params">(b []<span class="keyword">byte</span>, deterministic <span class="keyword">bool</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> xxx_messageInfo_Request.Marshal(b, m, deterministic)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Request)</span> <span class="title">XXX_Merge</span><span class="params">(src proto.Message)</span></span> &#123;</span><br><span class="line">	xxx_messageInfo_Request.Merge(m, src)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Request)</span> <span class="title">XXX_Size</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> xxx_messageInfo_Request.Size(m)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Request)</span> <span class="title">XXX_DiscardUnknown</span><span class="params">()</span></span> &#123;</span><br><span class="line">	xxx_messageInfo_Request.DiscardUnknown(m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xxx_messageInfo_Request proto.InternalMessageInfo</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取字段</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Request)</span> <span class="title">GetData</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> m != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> m.Data</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	proto.RegisterType((*Request)(<span class="literal">nil</span>), <span class="string">"helloworld.Request"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123; proto.RegisterFile(<span class="string">"request.proto"</span>, fileDescriptor_7f73548e33e655fe) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fileDescriptor_7f73548e33e655fe = []<span class="keyword">byte</span>&#123;</span><br><span class="line">	<span class="comment">// 91 bytes of a gzipped FileDescriptorProto</span></span><br><span class="line">	<span class="number">0x1f</span>, <span class="number">0x8b</span>, <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0xff</span>, <span class="number">0xe2</span>, <span class="number">0xe2</span>, <span class="number">0x2d</span>, <span class="number">0x4a</span>, <span class="number">0x2d</span>, <span class="number">0x2c</span>,</span><br><span class="line">	<span class="number">0x4d</span>, <span class="number">0x2d</span>, <span class="number">0x2e</span>, <span class="number">0xd1</span>, <span class="number">0x2b</span>, <span class="number">0x28</span>, <span class="number">0xca</span>, <span class="number">0x2f</span>, <span class="number">0xc9</span>, <span class="number">0x17</span>, <span class="number">0xe2</span>, <span class="number">0xca</span>, <span class="number">0x48</span>, <span class="number">0xcd</span>, <span class="number">0xc9</span>, <span class="number">0xc9</span>,</span><br><span class="line">	<span class="number">0x2f</span>, <span class="number">0xcf</span>, <span class="number">0x2f</span>, <span class="number">0xca</span>, <span class="number">0x49</span>, <span class="number">0x51</span>, <span class="number">0x92</span>, <span class="number">0xe5</span>, <span class="number">0x62</span>, <span class="number">0x0f</span>, <span class="number">0x82</span>, <span class="number">0x48</span>, <span class="number">0x0a</span>, <span class="number">0x09</span>, <span class="number">0x71</span>, <span class="number">0xb1</span>,</span><br><span class="line">	<span class="number">0xa4</span>, <span class="number">0x24</span>, <span class="number">0x96</span>, <span class="number">0x24</span>, <span class="number">0x4a</span>, <span class="number">0x30</span>, <span class="number">0x2a</span>, <span class="number">0x30</span>, <span class="number">0x6a</span>, <span class="number">0x70</span>, <span class="number">0x06</span>, <span class="number">0x81</span>, <span class="number">0xd9</span>, <span class="number">0x4e</span>, <span class="number">0x9c</span>, <span class="number">0x51</span>,</span><br><span class="line">	<span class="number">0xec</span>, <span class="number">0x7a</span>, <span class="number">0xfa</span>, <span class="number">0x25</span>, <span class="number">0x95</span>, <span class="number">0x05</span>, <span class="number">0xa9</span>, <span class="number">0xc5</span>, <span class="number">0x49</span>, <span class="number">0x6c</span>, <span class="number">0x60</span>, <span class="number">0xcd</span>, <span class="number">0xc6</span>, <span class="number">0x80</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">	<span class="number">0x00</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0x2e</span>, <span class="number">0x52</span>, <span class="number">0x69</span>, <span class="number">0xb5</span>, <span class="number">0x4d</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="编写Go语言程序"><a href="#编写Go语言程序" class="headerlink" title="编写Go语言程序"></a>编写Go语言程序</h4><p>下面这段测试程序就是创建了一个请求，序列化又反序列化的过程。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"./types"</span></span><br><span class="line">	<span class="string">"github.com/golang/protobuf/proto"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	req := &amp;types.Request&#123;Data: <span class="string">"Hello LIB"</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Marshal</span></span><br><span class="line">	encoded, err := proto.Marshal(req)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"Encode to protobuf data error: %v"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Unmarshal</span></span><br><span class="line">	<span class="keyword">var</span> unmarshaledReq types.Request</span><br><span class="line">	err = proto.Unmarshal(encoded, &amp;unmarshaledReq)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"Unmarshal to struct error: %v"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"req: %v\n"</span>, req.String())</span><br><span class="line">	fmt.Printf(<span class="string">"unmarshaledReq: %v\n"</span>, unmarshaledReq.String())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  helloworld1 git:(master) go run main.go</span><br><span class="line">req: data:&quot;Hello LIB&quot;</span><br><span class="line">unmarshaledReq: data:&quot;Hello LIB&quot;</span><br></pre></td></tr></table></figure>
<p>以上都是铺垫，下一节的proto包怎么实现编解码才是重点，protobuf用法可以去翻：</p>
<ol>
<li>官方介绍：<a href="https://developers.google.com/protocol-buffers/docs/proto3" target="_blank" rel="noopener">protoc3介绍</a>，<a href="https://developers.google.com/protocol-buffers/docs/encoding" target="_blank" rel="noopener">编码介绍</a>，<a href="https://developers.google.com/protocol-buffers/docs/gotutorial" target="_blank" rel="noopener">Go教程</a></li>
<li>煎鱼<a href="https://eddycjy.gitbook.io/golang/di-4-ke-grpc/install" target="_blank" rel="noopener">grpc系列文章</a></li>
</ol>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://tech.meituan.com/2015/02/26/serialization-vs-deserialization.html" target="_blank" rel="noopener">https://tech.meituan.com/2015/02/26/serialization-vs-deserialization.html</a><br>《序列化和反序列化》出自美团技术团队，值得一读。</li>
<li><a href="https://github.com/golang/protobuf" target="_blank" rel="noopener">https://github.com/golang/protobuf</a><br>Go支持protocol buffer的仓库，Readme，值得详读。</li>
<li><a href="https://developers.google.com/protocol-buffers/docs/gotutorial" target="_blank" rel="noopener">https://developers.google.com/protocol-buffers/docs/gotutorial</a><br>Google Protocol Buffers的Go语言tutorial，值得详细阅读和实操。</li>
<li><a href="https://developers.google.com/protocol-buffers/docs/overview" target="_blank" rel="noopener">https://developers.google.com/protocol-buffers/docs/overview</a><br>Google Protocol Buffers的Overview，介绍了什么是Protocol Buffers，它的原理、历史（起源），以及和XML的对比，必读。</li>
<li><a href="https://developers.google.com/protocol-buffers/docs/proto3" target="_blank" rel="noopener">https://developers.google.com/protocol-buffers/docs/proto3</a><br>《Language Guide (proto3)》这篇文章介绍了proto3的定义，也可以理解为<code>.proto</code>文件的语法，就如同Go语言的语法，不懂语法怎么编写<code>.proto</code>文件？读这篇文章会了解很多原理，以及可以少踩坑，必读。</li>
<li><a href="https://developers.google.com/protocol-buffers/docs/reference/go-generated" target="_blank" rel="noopener">https://developers.google.com/protocol-buffers/docs/reference/go-generated</a><br>《Go Generated Code》这篇文章详细介绍了protoc是怎么用<code>.protoc</code>生成<code>.pb.go</code>的，可选。</li>
<li><a href="https://developers.google.com/protocol-buffers/docs/encoding#" target="_blank" rel="noopener">https://developers.google.com/protocol-buffers/docs/encoding#</a><br>《Protocol Buffers Encoding》这篇介绍编码原理，可选。</li>
<li><a href="https://godoc.org/github.com/golang/protobuf/proto" target="_blank" rel="noopener">https://godoc.org/github.com/golang/protobuf/proto</a><br>《package proto文档》可以把proto包当做Go语言操作protobuf数据的SDK，它实现了结构体和protobuf数据的转换，它和<code>.pb.go</code>文件配合使用。</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2019/08/22/etcd-raft-source-data-flow/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="区块链、Go语言">
      <meta itemprop="image" content="http://img.lessisbetter.site/gzh-qrcode-logo-small.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Go语言充电站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/22/etcd-raft-source-data-flow/" class="post-title-link" itemprop="url">Etcd Raft架构设计和源码剖析2：数据流</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-22 20:24:08" itemprop="dateCreated datePublished" datetime="2019-08-22T20:24:08+08:00">2019-08-22</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-09-06 08:17:47" itemprop="dateModified" datetime="2019-09-06T08:17:47+08:00">2019-09-06</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前看到一幅描述etcd raft的流程图，感觉非常直观，但和自己看源码的又有些不同，所以自己模仿着画了一下，加深自己的理解。</p>
<p>下图从左到右依次分为4个部分：</p>
<ol>
<li>raft：raft主体功能部分</li>
<li>Node：raft提供的接口，raft跟上层的通信接口，会运行一个run函数，持续循环处理通道上的数据</li>
<li>raftNode：上层应用逻辑</li>
<li>其他：Client、Network、State</li>
</ol>
<p><img src="http://img.lessisbetter.site/2019-09-etcd-raft-msg-flow.png" alt="etcd raft workflow"></p>
<p>图中的箭头为数据的流向，这幅图包含了多个流程，接下来会分成4个流程介绍：</p>
<ol>
<li>客户端请求</li>
<li>发送消息给其他节点</li>
<li>接收其他节点消息及处理</li>
<li>应用达成一致的日志</li>
</ol>
<h2 id="客户端请求"><a href="#客户端请求" class="headerlink" title="客户端请求"></a>客户端请求</h2><p>客户端请求的流程，在下图已经使用红色箭头标出，流程如下：</p>
<ol>
<li>客户端将请求发送给应用层raftNode</li>
<li>raftNode使用Propose方法，请求写入到propc通道</li>
<li>raft.Step接收到通道数据，会通过append等函数加入到raftLog</li>
<li>raftLog用来暂时存储和查询日志，请求会先加入到unstable</li>
</ol>
<p><img src="http://img.lessisbetter.site/2019-09-etcd-raft-msg-flow-req.png" alt="etcd raft request flow"></p>
<h2 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h2><p>发送消息的数据流，已经用红色箭头标出，流程如下：</p>
<ol>
<li>raft发现有数据发送给其他节点，数据可以是leader要发送给follower的日志、snapshot，或者其他类型的消息，比如follower给leader的响应消息</li>
<li>利用NewReady创建结构体Ready，并写入到readyc通道</li>
<li>raftNode从通道读到Ready，取出其中的消息，交给Network发送给其他节点</li>
</ol>
<p><img src="http://img.lessisbetter.site/2019-09-etcd-raft-msg-flow-send.png" alt="etcd raft send message flow"></p>
<h2 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h2><p>接收消息的数据流，已经在下图用红色箭头标出，流程如下：</p>
<ol>
<li>从Network收到消息，可以是leader给follower的消息，也可以是follower发给leader的响应消息，Network的handler函数将数据回传给raftNode</li>
<li>raftNode调用Step函数，将数据发给raft，数据被写入recvc通道</li>
<li>raft的Step从recvc收到消息，并修改raftLog中的日志</li>
</ol>
<p><img src="http://img.lessisbetter.site/2019-09-etcd-raft-msg-flow-recv.png" alt="etcd raft receive msg flow"></p>
<h2 id="应用日志"><a href="#应用日志" class="headerlink" title="应用日志"></a>应用日志</h2><p>raft会将达成一致的log通知给raftNode，让它应用到上层的数据库，数据流已经在下图用红色箭头标出，流程如下：</p>
<ol>
<li>raft发现有日志需要交给raftNode，调用NewReady创建Ready，从raftLog读取日志，并存到Ready结构体</li>
<li>Ready结构体写入到readyc通道</li>
<li>raftNode读到Ready结构体，发现Ready结构体中包含日志</li>
<li>raftNode会把日志写入到storage和WAL，把需要应用的日志，提交给状态机或数据库，去修改数据</li>
<li>raftNode处理完Ready后，调用Advance函数，通过advancec发送一个信号给raft，告知raft传出来的Ready已经处理完毕</li>
</ol>
<p>可以发现有2个storage，1个是raftLog.Storage，一个是raftNode.storage，Storage是一个接口，可以用来读取storage中的数据，但不写入，storage的数据写入是由raftNode完成的。</p>
<p><img src="http://img.lessisbetter.site/2019-09-etcd-raft-msg-flow-commit.png" alt="etcd raft apply logs flow"></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2019/08/19/etcd-raft-sources-arch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="区块链、Go语言">
      <meta itemprop="image" content="http://img.lessisbetter.site/gzh-qrcode-logo-small.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Go语言充电站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/19/etcd-raft-sources-arch/" class="post-title-link" itemprop="url">Etcd Raft架构设计和源码剖析1：宏观架构</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-19 09:42:37" itemprop="dateCreated datePublished" datetime="2019-08-19T09:42:37+08:00">2019-08-19</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-09-03 08:36:04" itemprop="dateModified" datetime="2019-09-03T08:36:04+08:00">2019-09-03</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p><a href="https://github.com/etcd-io/etcd" target="_blank" rel="noopener">Etcd</a>提供了一个样例<a href="https://github.com/etcd-io/etcd/tree/master/contrib/raftexample" target="_blank" rel="noopener">contrib/raftexample</a>，用来展示如何使用etcd raft。这篇文章通过raftexample介绍如何使用etcd raft。</p>
<h2 id="raft服务"><a href="#raft服务" class="headerlink" title="raft服务"></a>raft服务</h2><p>raftexample是一个分布式KV数据库，客户端可以向集群的节点发送写数据和读数据，以及修改集群配置的请求，它使用etcd raft保持各集群之间数据的一致性。</p>
<p><img src="http://img.lessisbetter.site/2019-08-cluster.png" alt="cluster"></p>
<h2 id="etcd-raft"><a href="#etcd-raft" class="headerlink" title="etcd raft"></a>etcd raft</h2><p>etcd raft实现了raft论文的核心，所有的IO（磁盘存储、网络通信）它都没有实现，它做了解耦。</p>
<p>它是一个状态机，有数据作为输入，经过当前状态和输入，得到确定性的输出，即每个节点上都是一样的。</p>
<p><img src="http://img.lessisbetter.site/2019-08-etcd-raft.png" alt="etcd-raft"></p>
<h2 id="raft应用架构"><a href="#raft应用架构" class="headerlink" title="raft应用架构"></a>raft应用架构</h2><p>raft集群会由多个节点组成，客户端的请求发送给raft leader，再由raft leader通过网络通信在集群之中对请求达成共识。</p>
<p>集群中的每个节点从架构上都可以分为两层：</p>
<ul>
<li>应用层，负责处理用户请求，数据存储以及集群节点间的网络通信，</li>
<li>共识层，负责相同和输入数据和状态，生成确定性的、一直的输出，</li>
</ul>
<p>共识层由etcd raft负责，应用层要负责业务逻辑，数据存储和网络通信不需要应用层实现，而是由不同的模块负责，应用层负责起<strong>衔接</strong>存储存储和网络通信即可。</p>
<p><img src="http://img.lessisbetter.site/2019-08-app-arch.png" alt="app-arch"></p>
<p>应用层有3个重要组成部分：http API、kv store和raftNode。</p>
<h3 id="http-API"><a href="#http-API" class="headerlink" title="http API"></a>http API</h3><p>每个节点都会启动一个http API用来接受客户端请求，它只是接收请求，不对请求做处理。它会把客户端的写入请求PUT和查询请求GET都交给kv store。</p>
<p>对于修改raft集群配置请求，它会生成<code>ConfChange</code>交给raftNode。</p>
<h3 id="kv-store"><a href="#kv-store" class="headerlink" title="kv store"></a>kv store</h3><p>一个kv数据库服务，它保存有一个kv db，用来存储<strong>用户数据</strong>。</p>
<ul>
<li>对于查询请求，它直接从db中读取数据。</li>
<li>对于写入请求，需要修改用户数据，这就需要集群节点使用raft对请求达成共识，它把请求传递给raftNode。</li>
</ul>
<h3 id="raftNode"><a href="#raftNode" class="headerlink" title="raftNode"></a>raftNode</h3><p>raftNode用来跟etcd raft交互，他需要：</p>
<ul>
<li>把客户端的写请求，修改raft配置的请求交给etcd raft</li>
<li>衔接网络通信跟etcd raft之间的桥梁，把etcd raft的消息发送出去，或接受到的raft消息交给raft</li>
<li>保存raft的WAL和snapshot。</li>
</ul>
<p>对于写请求，它会把请求<strong>数据编码</strong>后发送给etcd raft，etcd raft会把写请求封装成raft的Propose消息<code>MsgProp</code>，编码后的数据成为log Entry。因为raft并不关心具体的请求内容，它只需要保证每个集群节点在相同的log index拥有相同的log Entry，即请求即可。</p>
<p>raftNode还会启动1个http server，用来集群节点之间的通信，传递raft消息，让集群节点达成共识。它与http api是不同的，http api用来接收用户请求。</p>
<h3 id="raftNode与raft交互"><a href="#raftNode与raft交互" class="headerlink" title="raftNode与raft交互"></a>raftNode与raft交互</h3><p>raft模块内部定义了一个<code>Node</code>接口，它代表了raft集群中的一个raft节点，它是应用层跟共识层交互的接口。</p>
<p>其中有几个与数据传递相关函数的是：</p>
<ul>
<li>Propose：应用层通过此函数把客户端写请求传递raft。</li>
<li>ProposeConfChange：应用层通过此函数把客户端<strong>修改raft集群配置的请求</strong>传递raft。</li>
<li>Step：应用层把收到的raft集群之间通信的消息传递给raft。</li>
<li>Ready：raft对外的出口只有1个，就是Ready函数，<strong>Ready函数</strong>返回一个通道，应用层可以从这个通道中读到raft要输出的所有数据，这个数据被称为<strong>Ready结构体</strong>，包括log entry，集群间的通信消息等。</li>
<li>Advance：应用层处理完Ready结构体后，调用Advance通知raft，它已处理完刚读到的Ready结构体，raft可以根据最新状态生成下一个Ready结构体。</li>
</ul>
<p>还有一个ApplyConfChange函数，当Ready结构体中包含修改raft集群配置的log entry时，应用层会调用此函数，把配置应用到raft。</p>
<h2 id="raft架构"><a href="#raft架构" class="headerlink" title="raft架构"></a>raft架构</h2><p>瞄完raft应用架构，可以从宏观角度看一下raft是如何跟应用层对接的。</p>
<p>raft包内部有2个很重要的结构体：node和raft。</p>
<h3 id="node结构体"><a href="#node结构体" class="headerlink" title="node结构体"></a>node结构体</h3><p>node结构体（后续称为raft.node）实现了<code>Node</code>接口，负责跟应用层对接，raft.node有个goroutine持续运行，应用层raftNode也有goroutine持续运行，raftNode调用raft.node的函数，每个函数都有对应的一个channel，用来把raftNode要传递给raft的数据，发送给raft.node。比如Propose函数的通道是proc，Step函数的通道是recvc。</p>
<h3 id="raft结构体"><a href="#raft结构体" class="headerlink" title="raft结构体"></a>raft结构体</h3><p>raft结构体（后续称为raft.raft）是raft算法的主要实现。</p>
<p>raft.node把输入推给raft.raft，raft.raft根据输入和<strong>当前的状态数据</strong>生成输出，输出临时保存在raft内，raft.node会检查raft.raft是否有输出，如果有输出数据，就把输出生成Ready结构体，并传递给应用层。</p>
<p>raft.raft应用层有一个storage，存放的是<strong>当前的状态数据</strong>，包含了保存在内存中的log entry，但这个storage并不是raft.raft的，是应用层的，raft.raft只从中读取数据，log entry的写入由应用层负责。</p>
<p><img src="http://img.lessisbetter.site/2019-08-raft-arch.png" alt="raft-arch"></p>
<h2 id="几个存储相关的概念"><a href="#几个存储相关的概念" class="headerlink" title="几个存储相关的概念"></a>几个存储相关的概念</h2><p><strong>WAL</strong>是Write Ahead Logs的缩写，存储的是log entry记录，即所有写请求的记录。</p>
<p><strong>storage</strong>也是存的log entry，只不过是保存在内存中的。</p>
<p><strong>kv db</strong>是保存了所有数据的最新值，而log entry是修改数据值的操作记录。</p>
<p>log entry在集群节点之间达成共识之后，log entry会写入WAL文件，也会写入storage，然后会被应用到kv store中，改变kv db中的数据。</p>
<p><strong>Snapshot</strong>是kv db是某个log entry被应用后生成的快照，可以根据快照快速回复kv db，而无需从所有的历史log entry依次应用，恢复kv db。</p>
<h2 id="一个写请求的处理过程"><a href="#一个写请求的处理过程" class="headerlink" title="一个写请求的处理过程"></a>一个写请求的处理过程</h2><p>有了上面架构层面的了解，我们从宏观的角度看一下一个写请求被处理的过程。</p>
<ol>
<li>客户端把写请求发给leader节点</li>
<li>leader节点的http api接收请求，并把请求传递给kv store，kv sotre把写请求发送给raftNode，raftNode把写请求传递给raft.node</li>
<li>leader节点的raft.node把写请求转化为log entry，并交给raft.raft，raft.raft生成发送给每一个follower的Append消息</li>
<li>leader节点的raft.node取出raft.raft中的Append消息以及其他数据，封装成Ready传递给raft.Node</li>
<li>leader节点的raft.Node把Ready中的entry保存到storage，然后把Ready中的消息，发送给相应的节点</li>
<li>follower节点的raft.Node收到消息，把消息传递给raft.node，raft.node推给raft.raft</li>
<li>follower的raft.raft处理Append消息，进行匹配和校验后，生成Append Response消息和保存log entry</li>
<li>follower的raft.node从raft.raft获取数据，然后生成Ready传递给raft.Node</li>
<li>follower节点的raft.Node把Ready中的entry保存到storage，然后把Ready中的消息，发送给相应的节点</li>
<li>leader节点的raft.Node收到消息，把消息传递给raft.node，raft.node推给raft.raft</li>
<li>leader节点的raft.raft处理Append Response消息，然后检查已经达成半数以上同意的log entry，更新已经被commit的log entry的index</li>
<li>leader节点的raft.raft在创建Append等消息的时候，填写了已被commited的log index，所以下次在生成消息，并发送给follower后，follower就根据committed log index提交本地的log entry</li>
<li>无论是leader，还是follower在生成Ready的时候，会包含已经被committed的log entry，这些entry是等待应用到kv store的，raftNode拿到Ready后，会把这些entry取出来，传递给kv store，kv store会修改key-value的最新值。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文从宏观角度介绍了：</p>
<ul>
<li>使用etcd raft应用的架构</li>
<li>使用etcd raft应用应当提供哪些功能供raft使用</li>
<li>应用是如何和etcd raft交互的</li>
<li>etcd raft涉及到的存储概念</li>
<li>一个写请求从客户端到在节点之间达成一致，应用到状态机的过程</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="http://img.lessisbetter.site/gzh-qrcode-logo-small.png"
                alt="大彬" />
            
              <p class="site-author-name" itemprop="name">大彬</p>
              <p class="site-description motion-element" itemprop="description">区块链、Go语言</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives">
                
                    <span class="site-state-item-count">102</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">62</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="http://img.lessisbetter.site/gzh-qrcode-logo-small.png" title="公众号 &rarr; http://img.lessisbetter.site/gzh-qrcode-logo-small.png" rel="noopener" target="_blank"><i class="fa fa-fw fa-wechat"></i>公众号</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/shitaibin" title="GitHub &rarr; https://github.com/shitaibin" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://segmentfault.com/u/lessisbetter" title="SegmentFault &rarr; https://segmentfault.com/u/lessisbetter" rel="noopener" target="_blank"><i class="fa fa-fw fa-crosshairs"></i>SegmentFault</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://www.jianshu.com/u/947f3ccdd481" title="简书 &rarr; https://www.jianshu.com/u/947f3ccdd481" rel="noopener" target="_blank"><i class="fa fa-fw fa-heartbeat"></i>简书</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://stackoverflow.com/users/4296218/james-shi" title="StackOverflow &rarr; https://stackoverflow.com/users/4296218/james-shi" rel="noopener" target="_blank"><i class="fa fa-fw fa-stack-overflow"></i>StackOverflow</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:hz_stb@163.com" title="E-Mail &rarr; mailto:hz_stb@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友链
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://xargin.com" title="https://xargin.com" rel="noopener" target="_blank">Xargin曹大博客</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://pingcap.com/blog-cn/" title="https://pingcap.com/blog-cn/" rel="noopener" target="_blank">PingCap技术博客</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://qcrao.github.io/" title="https://qcrao.github.io/" rel="noopener" target="_blank">码农桃花源博客</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://book.eddycjy.com/golang/" title="https://book.eddycjy.com/golang/" rel="noopener" target="_blank">煎鱼的迷之博客</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://dave.cheney.net" title="https://dave.cheney.net" rel="noopener" target="_blank">Dave Cheney的博客</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">[object Object]</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v6.6.0</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv" title="总访客量">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="site-pv" title="总访问量">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









  <div style="display: none;">
    <script src="//s95.cnzz.com/z_stat.php?id=1275814754&web_id=1275814754" language="JavaScript"></script>
  </div>



        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script src="/js/src/utils.js?v=6.6.0"></script>

  <script src="/js/src/motion.js?v=6.6.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.6.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.6.0"></script>



  

  


  <script src="/js/src/bootstrap.js?v=6.6.0"></script>



  



  











  





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  

  
  

  

  

  

  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  <script>
    $('.highlight').each(function (i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap');
      $(e).after($wrap);
      $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function (e) {
        var code = $(this).parent().find('.code').find('.line').map(function (i, e) {
          return $(e).text();
        }).toArray().join('\n');
        var ta = document.createElement('textarea');
        var range = document.createRange(); //For Chrome
        var sel = window.getSelection(); //For Chrome
        var yPosition = window.pageYOffset || document.documentElement.scrollTop;
        ta.style.top = yPosition + 'px'; //Prevent page scroll
        ta.style.position = 'absolute';
        ta.style.opacity = '0';
        ta.value = code;
        ta.textContent = code; //For FireFox
        ta.contentEditable = true;
        ta.readOnly = false;
        document.body.appendChild(ta);
        range.selectNode(ta);
        sel.removeAllRanges();
        sel.addRange(range);
        ta.setSelectionRange(0, code.length);
        var result = document.execCommand('copy');
        
        ta.blur(); //For iOS
        $(this).blur();
      })).on('mouseleave', function (e) {
        var $b = $(this).find('.copy-btn');
        setTimeout(function () {
          $b.text('复制');
        }, 300);
      }).append(e);
    })
  </script>


  

</body>
</html>
