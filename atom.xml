<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Go语言充电站</title>
  
  <subtitle>大彬 less is better</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lessisbetter.site/"/>
  <updated>2020-09-28T09:33:05.509Z</updated>
  <id>http://lessisbetter.site/</id>
  
  <author>
    <name>大彬</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>被误解的iowait</title>
    <link href="http://lessisbetter.site/2020/09/28/misunderstanding-iowait/"/>
    <id>http://lessisbetter.site/2020/09/28/misunderstanding-iowait/</id>
    <published>2020-09-28T08:57:19.000Z</published>
    <updated>2020-09-28T09:33:05.509Z</updated>
    
    <content type="html"><![CDATA[<p>有一个cpu指标叫<code>iowait</code>或者<code>wa</code>，在top、iostat、vmstat命令中都可以看到这一项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[~]$ top</span><br><span class="line">top - 08:58:06 up 26 days, 23:20,  1 user,  load average: 0.07, 0.23, 0.26</span><br><span class="line">Tasks: 164 total,   1 running, 111 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  2.5 us,  1.2 sy,  0.0 ni, 96.2 id,  0.1 wa,  0.0 hi,  0.1 si,  0.0 st</span><br><span class="line">KiB Mem :  8167548 total,   698220 free,   996640 used,  6472688 buff&#x2F;cache</span><br><span class="line">KiB Swap:        0 total,        0 free,        0 used.  7061988 avail Mem</span><br><span class="line"></span><br><span class="line">[~]$ iostat</span><br><span class="line">Linux 4.15.0-112-generic (shitaibin-x) 09&#x2F;28&#x2F;20 _x86_64_(4 CPU)</span><br><span class="line"></span><br><span class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class="line">           1.02    0.00    0.55    0.86    0.00   97.56</span><br><span class="line"></span><br><span class="line">Device             tps    kB_read&#x2F;s    kB_wrtn&#x2F;s    kB_read    kB_wrtn</span><br><span class="line">loop0             0.00         0.00         0.00          5          0</span><br><span class="line">vda              13.32         2.65        84.15    6182326  196098973</span><br><span class="line"></span><br><span class="line">[~]$</span><br><span class="line">[~]$</span><br><span class="line">[~]$ vmstat</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> 0  0      0 685616 177356 6306652    0    0     1    21    5    3  1  1 98  1  0</span><br></pre></td></tr></table></figure><p>这个指标的字面含义是等待IO的时间（百分比），很多人会认为这个指标暗示这IO瓶颈，然而这是有一定无解的，iowait高不一定有IO瓶颈。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iowait &#x3D; CPU空闲时间 &#x2F; CPU总时间 ，前提CPU在等待至少一项IO操作完成</span><br></pre></td></tr></table></figure><p>所以它真正的含义是有未完成的IO操作时，CPU空闲的时间。</p><p>这2个资料都把iowait讲解的很清晰，并且举例iowait和IO瓶颈无关的例子。</p><ul><li><a href="http://linuxperf.com/?p=33" target="_blank" rel="noopener">理解iowait</a></li><li><a href="https://www.inspurpower.com/upload/file/1583309942.pdf" target="_blank" rel="noopener">浪潮：CPU iowait详解</a></li></ul><p>例子：</p><ul><li>低iowait，高IO的例子：IO高同时CPU计算也高，这样CPU的空闲时间少，造成iowait比较低，CPU密集掩盖了IO密集。</li><li>高iowait，低IO的例子：CPU计算很少，CPU基本空闲，但也有1个进程在IO，所以iowait高，但实际IO根本没任何瓶颈。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有一个cpu指标叫&lt;code&gt;iowait&lt;/code&gt;或者&lt;code&gt;wa&lt;/code&gt;，在top、iostat、vmstat命令中都可以看到这一项。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gu
      
    
    </summary>
    
    
    
      <category term="Linux" scheme="http://lessisbetter.site/tags/Linux/"/>
    
      <category term="IO" scheme="http://lessisbetter.site/tags/IO/"/>
    
      <category term="性能优化" scheme="http://lessisbetter.site/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 16.04上部署单机Kubernetes</title>
    <link href="http://lessisbetter.site/2020/09/06/deloy-k8s-on-ubuntu16/"/>
    <id>http://lessisbetter.site/2020/09/06/deloy-k8s-on-ubuntu16/</id>
    <published>2020-09-06T00:33:55.000Z</published>
    <updated>2020-10-09T02:27:08.159Z</updated>
    
    <content type="html"><![CDATA[<p>在公司都是用现成的K8s集群，没自己搭过，想知道搭建集群涉及哪些组件、做了什么，于是自己搭了一下，没想象的顺利，动作做到位了，也就不会有太多问题。</p><p>许多资料都是基于Centos7的，包括《Kubernetes权威指南》，手头只有Ubuntu 16.04，刚好也是支持K8s最低Ubuntu版本，就在Ubuntu上面部署。Ubuntu与Centos部署K8s并没有太大区别，唯一区别是安装kubeadm等软件的不同，由于k8s本身也是运行在容器中，其他的过程二者都相同了，这种设计也极大的方便了k8s集群的搭建。</p><p><strong>没有阿里云，搭建一个K8s集群还是挺费劲的</strong>。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li><code>/etc/hosts</code>中加入：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 k8s-master</span><br></pre></td></tr></table></figure><ol start="2"><li><p>关闭防火墙：<code>ufw status</code></p></li><li><p><a href="https://lessisbetter.site/2020/09/05/docker-proxy-and-registry-mirror/">安装Docker，并设置镜像加速器</a>。</p></li></ol><h2 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h2><p>Ubuntu 16.04上利用阿里云安装kubeadm、kubelet、kubectl</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update &amp;&amp; sudo apt-get install -y apt-transport-https curl</span><br><span class="line">curl -s http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;apt&#x2F;doc&#x2F;apt-key.gpg | sudo apt-key add -</span><br><span class="line">cat &lt;&lt;EOF | sudo tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;kubernetes.list</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;apt&#x2F; kubernetes-xenial main</span><br><span class="line">EOF</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y kubelet kubeadm kubectl</span><br><span class="line">sudo apt-mark hold kubelet kubeadm kubectl</span><br></pre></td></tr></table></figure><p>centos 7上利用阿里云镜像安装kubeadm、kubelet、kubectl</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt; &#x2F;etc&#x2F;yum.repos.d&#x2F;kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name&#x3D;Kubernetes</span><br><span class="line">baseurl&#x3D;http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;yum&#x2F;repos&#x2F;kubernetes-el7-x86_64</span><br><span class="line">enabled&#x3D;1</span><br><span class="line">gpgcheck&#x3D;1</span><br><span class="line">repo_gpgcheck&#x3D;1</span><br><span class="line">gpgkey&#x3D;http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;yum&#x2F;doc&#x2F;yum-key.gpg http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;yum&#x2F;doc&#x2F;rpm-package-key.gpg</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"># 将 SELinux 设置为 permissive 模式（相当于将其禁用）</span><br><span class="line">setenforce 0</span><br><span class="line">sed -i &#39;s&#x2F;^SELINUX&#x3D;enforcing$&#x2F;SELINUX&#x3D;permissive&#x2F;&#39; &#x2F;etc&#x2F;selinux&#x2F;config</span><br><span class="line"></span><br><span class="line">yum install -y kubelet kubeadm kubectl --disableexcludes&#x3D;kubernetes</span><br><span class="line"></span><br><span class="line">systemctl enable --now kubelet</span><br></pre></td></tr></table></figure><p>二进制程序安装位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[~]$ which kubectl kubeadm kubectl</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;kubectl</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;kubeadm</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;kubectl</span><br></pre></td></tr></table></figure><h2 id="部署Master节点"><a href="#部署Master节点" class="headerlink" title="部署Master节点"></a>部署Master节点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init \</span><br><span class="line">  --kubernetes-version&#x3D;v1.19.0 \</span><br><span class="line">  --image-repository registry.cn-hangzhou.aliyuncs.com&#x2F;google_containers \</span><br><span class="line">  --pod-network-cidr&#x3D;10.24.0.0&#x2F;16 \</span><br><span class="line">  --ignore-preflight-errors&#x3D;Swap</span><br></pre></td></tr></table></figure><ul><li><code>--image-repository</code> ： 由于<code>k8s.gcr.io</code>由于网络原因无法访问，使用阿里云提供的k8s镜像仓库，快速下载k8s相关的镜像</li><li><code>--ignore-preflight-errors</code> ： 部署时忽略swap问题</li><li><code>--pod-network-cidr</code> ：设置pod的ip区间</li></ul><p>遇到错误需要重置集群：<code>kubeadm reset</code></p><p>遇到错误参考：<a href="https://www.cnblogs.com/pu20065226/p/10641312.html" target="_blank" rel="noopener">kubernetes安装过程报错及解决方法</a></p><h2 id="拷贝kubectl配置"><a href="#拷贝kubectl配置" class="headerlink" title="拷贝kubectl配置"></a>拷贝kubectl配置</h2><p>切回普通用户，拷贝当前集群的配置给kubectl使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p $HOME&#x2F;.kube</span><br><span class="line">sudo cp -i &#x2F;etc&#x2F;kubernetes&#x2F;admin.conf $HOME&#x2F;.kube&#x2F;config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME&#x2F;.kube&#x2F;config</span><br></pre></td></tr></table></figure><p>查看集群信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dabin@ubuntu:~$ kubectl cluster-info</span><br><span class="line">Kubernetes master is running at https:&#x2F;&#x2F;192.168.0.103:6443</span><br><span class="line">KubeDNS is running at https:&#x2F;&#x2F;192.168.0.103:6443&#x2F;api&#x2F;v1&#x2F;namespaces&#x2F;kube-system&#x2F;services&#x2F;kube-dns:dns&#x2F;proxy</span><br></pre></td></tr></table></figure><h2 id="安装CNI网络插件"><a href="#安装CNI网络插件" class="headerlink" title="安装CNI网络插件"></a>安装CNI网络插件</h2><p>k8s本身不负责容器之间的通信，集群启动后，集群的Pod直接还不能通信，需要安装网络插件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dabin@ubuntu:~$ kubectl get node</span><br><span class="line">NAME         STATUS     ROLES    AGE    VERSION</span><br><span class="line">k8s-master   NotReady   master   5m8s   v1.19.0</span><br></pre></td></tr></table></figure><p>k8s的<a href="https://kubernetes.io/zh/docs/concepts/cluster-administration/addons/" target="_blank" rel="noopener">文档</a>列举了多种选择，这里提供2种：</p><p>weave:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f &quot;https:&#x2F;&#x2F;cloud.weave.works&#x2F;k8s&#x2F;net?k8s-version&#x3D;$(kubectl version | base64 | tr -d &#39;\n&#39;)&quot;</span><br></pre></td></tr></table></figure><p>flannel:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;coreos&#x2F;flannel&#x2F;master&#x2F;Documentation&#x2F;kube-flannel.yml</span><br></pre></td></tr></table></figure><p>本机选择了weave：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dabin@ubuntu:~$ kubectl apply -f &quot;https:&#x2F;&#x2F;cloud.weave.works&#x2F;k8s&#x2F;net?k8s-version&#x3D;$(kubectl version | base64 | tr -d &#39;\n&#39;)&quot;</span><br><span class="line">serviceaccount&#x2F;weave-net created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io&#x2F;weave-net created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io&#x2F;weave-net created</span><br><span class="line">role.rbac.authorization.k8s.io&#x2F;weave-net created</span><br><span class="line">rolebinding.rbac.authorization.k8s.io&#x2F;weave-net created</span><br><span class="line">daemonset.apps&#x2F;weave-net created</span><br></pre></td></tr></table></figure><p>安装之后节点变为Ready：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">dabin@ubuntu:~$ kubectl get node</span><br><span class="line">NAME         STATUS   ROLES    AGE   VERSION</span><br><span class="line">k8s-master   Ready    master   10m   v1.19.0</span><br><span class="line">dabin@ubuntu:~$</span><br><span class="line">dabin@ubuntu:~$ kubectl get -n kube-system pods</span><br><span class="line">NAME                                 READY   STATUS    RESTARTS   AGE</span><br><span class="line">coredns-6d56c8448f-bdgwj             1&#x2F;1     Running   0          10m</span><br><span class="line">coredns-6d56c8448f-w6nnb             1&#x2F;1     Running   0          10m</span><br><span class="line">etcd-k8s-master                      1&#x2F;1     Running   0          10m</span><br><span class="line">kube-apiserver-k8s-master            1&#x2F;1     Running   0          10m</span><br><span class="line">kube-controller-manager-k8s-master   1&#x2F;1     Running   0          10m</span><br><span class="line">kube-proxy-xtgwn                     1&#x2F;1     Running   0          10m</span><br><span class="line">kube-scheduler-k8s-master            1&#x2F;1     Running   0          10m</span><br><span class="line">weave-net-4gtcq                      2&#x2F;2     Running   0          93s</span><br></pre></td></tr></table></figure><h2 id="开启master调度"><a href="#开启master调度" class="headerlink" title="开启master调度"></a>开启master调度</h2><p>master节点默认是不可调度的，不可在master上部署任务，在单节点下，需要开启master可被调度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl taint nodes --all node-role.kubernetes.io&#x2F;master-</span><br></pre></td></tr></table></figure><p>以上集群搭建完毕。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>部署一个Pod进行测试，Pod能Running，代表Docker、K8s的配置基本没问题了：</p><p>声明文件为<code>twocontainers.yaml</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1 #指定当前描述文件遵循v1版本的Kubernetes API</span><br><span class="line">kind: Pod #我们在描述一个pod</span><br><span class="line">metadata:</span><br><span class="line">  name: twocontainers #指定pod的名称</span><br><span class="line">  namespace: default #指定当前描述的pod所在的命名空间</span><br><span class="line">  labels: #指定pod标签</span><br><span class="line">    app: twocontainers</span><br><span class="line">  annotations: #指定pod注释</span><br><span class="line">    version: v0.5.0</span><br><span class="line">    releasedBy: david</span><br><span class="line">    purpose: demo</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">    - name: sise #容器的名称</span><br><span class="line">      image: quay.io&#x2F;openshiftlabs&#x2F;simpleservice:0.5.0 #创建容器所使用的镜像</span><br><span class="line">      ports:</span><br><span class="line">        - containerPort: 9876 #应用监听的端口</span><br><span class="line">    - name: shell #容器的名称</span><br><span class="line">      image: centos:7 #创建容器所使用的镜像</span><br><span class="line">      command: #容器启动命令</span><br><span class="line">        - &quot;bin&#x2F;bash&quot;</span><br><span class="line">        - &quot;-c&quot;</span><br><span class="line">        - &quot;sleep 10000&quot;</span><br></pre></td></tr></table></figure><p>部署Pod：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f twocontainers.yaml</span><br></pre></td></tr></table></figure><p>几分钟后可以看pod状态是否为running。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dabin@k8s-master:~&#x2F;workspace&#x2F;notes&#x2F;kubernetes&#x2F;examples$ kubectl get pods</span><br><span class="line">NAME            READY   STATUS    RESTARTS   AGE</span><br><span class="line">twocontainers   2&#x2F;2     Running   2          83m</span><br></pre></td></tr></table></figure><p>如果不是，查看Pod部署遇到的问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe pod twocontainers</span><br></pre></td></tr></table></figure><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><ol><li>人人必备的神书《Kuerbenetes权威指南》</li><li><a href="https://kubernetes.io/zh/docs/setup/independent/create-cluster-kubeadm/" target="_blank" rel="noopener">K8S中文文档</a></li><li><a href="https://www.cnblogs.com/pu20065226/p/10641312.html" target="_blank" rel="noopener">kubernetes安装过程报错及解决方法</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在公司都是用现成的K8s集群，没自己搭过，想知道搭建集群涉及哪些组件、做了什么，于是自己搭了一下，没想象的顺利，动作做到位了，也就不会有太多问题。&lt;/p&gt;
&lt;p&gt;许多资料都是基于Centos7的，包括《Kubernetes权威指南》，手头只有Ubuntu 16.04，刚好
      
    
    </summary>
    
    
    
      <category term="Kubernetes" scheme="http://lessisbetter.site/tags/Kubernetes/"/>
    
      <category term="Docker" scheme="http://lessisbetter.site/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker网络代理和仓库镜像加速</title>
    <link href="http://lessisbetter.site/2020/09/05/docker-proxy-and-registry-mirror/"/>
    <id>http://lessisbetter.site/2020/09/05/docker-proxy-and-registry-mirror/</id>
    <published>2020-09-05T06:48:04.000Z</published>
    <updated>2020-09-06T00:30:50.325Z</updated>
    
    <content type="html"><![CDATA[<p>对于Docker官方镜像仓库<code>Registry</code>，没有仓库镜像加速，寸步难行。</p><p>对于国外非Docker官方镜像仓库，并且还被墙的仓库<code>Registry</code>，没有网络代理，寸步难行。</p><p>镜像仓库加速器<code>Registry Mirrors</code>，是国内对官方<code>Registry</code>的”镜像(mirror)”，当拉取image时，Docker Daemon先去 <code>Registry Mirrors</code> 拉去镜像，如果没找到镜像，<code>Registry Mirrors</code>找官方<code>Registry</code>拉去镜像，然后再返回给本地。</p><p>网络代理是给Docker设置http和https代理，最原始的方式，适合有代理的情况。主要用于服务器上有<strong>稳定可访问</strong>的代理或者当前主机上有稳定代理的情况。对于代理和docker不在同一台机器上时，稳定可访问就成了一个问题，比如代理在笔记本上，IP随时都可能变化，服务器连接笔记本做代理，就算法上稳定可访问，而docker也在笔记本上运行，通过环回地址就能稳定访问。</p><p><strong>不推荐给Docker设置代理，而应当优先使用<code>Registry Mirrors</code></strong>。代理也是有副作用的，你需要保证非本机能稳定连接到代理，并且能够转发数据，不然端口拒绝访问、TLS握手失败等问题，需要花费更多的时间。</p><p>可访问的Registry有：</p><ul><li><a href="https://quay.io/" target="_blank" rel="noopener">quay.io</a> : 只是访问慢一些而已，可以拉下镜像来</li></ul><h2 id="镜像仓库加速器-推荐"><a href="#镜像仓库加速器-推荐" class="headerlink" title="镜像仓库加速器(推荐)"></a>镜像仓库加速器(推荐)</h2><p>如果指定拉某个镜像仓库的镜像，镜像加速器是用不上的。如果该仓库可以访问，非本机有代理的情况，无需配置网络代理。</p><p>看如何配置<a href="https://yeasy.gitbooks.io/docker_practice/install/mirror.html" target="_blank" rel="noopener">Docker镜像加速器</a>。</p><p>推荐使用阿里云、七牛、DaoCloud的镜像仓库加速器。</p><p><code>/etc/docker/daemon.json</code> 配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;insecure-registries&quot;:[&quot;192.168.9.8:80&quot;],</span><br><span class="line">    &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;a90tkz28.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后冲抵daemon：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h2 id="网络代理-不推荐"><a href="#网络代理-不推荐" class="headerlink" title="网络代理(不推荐)"></a>网络代理(不推荐)</h2><p>我Mac上的http、https、socks5代理，http和https监听的是7890端口，sock5监听的是7891端口。</p><p>拉镜像时，可以看到docker连接了7890端口走http代理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;private&#x2F;tmp]$ lsof -i:7890</span><br><span class="line">COMMAND     PID      USER   FD   TYPE             DEVICE SIZE&#x2F;OFF NODE NAME</span><br><span class="line">....</span><br><span class="line">com.docke 73371 shitaibin   50u  IPv4 0xa8184ba4240fbe99      0t0  TCP localhost:58847-&gt;localhost:7890 (ESTABLISHED)</span><br><span class="line">com.docke 73371 shitaibin   53u  IPv4 0xa8184ba4035deb09      0t0  TCP localhost:58857-&gt;localhost:7890 (ESTABLISHED)</span><br><span class="line">com.docke 73371 shitaibin   58u  IPv4 0xa8184ba42d889861      0t0  TCP localhost:58893-&gt;localhost:7890 (ESTABLISHED)</span><br></pre></td></tr></table></figure><p><a href="https://docs.docker.com/network/proxy/" target="_blank" rel="noopener">官方设置代理教程</a>，2选1:</p><ol><li>给Docker客户端设置代理，拉去镜像、创建新容器时，客户端会把变量发送给Daemon。支持17.07及以上版本，这是官方推荐方式。</li><li>给Daemon设置代理，通过环境变量的方式。支持17.06及以下版本，不推荐。</li></ol><p>给Daemon设置的代理的另外方法：</p><p>创建Daemon的代理配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;docker.service.d</span><br><span class="line">sudo touch &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;docker.service.d&#x2F;http-proxy.conf</span><br></pre></td></tr></table></figure><p>内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">Environment&#x3D;&quot;HTTP_PROXY&#x3D;http:&#x2F;&#x2F;proxy.server.com:913&#x2F;&quot; &quot;HTTPS_PROXY&#x3D;http:&#x2F;&#x2F;proxy.server.com:913&#x2F;&quot; &quot;NO_PROXY&#x3D;localhost,127.0.0.1,10.96.0.0&#x2F;16, 10.244.0.0&#x2F;16&quot;</span><br></pre></td></tr></table></figure><p>然后重启Daemon：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br><span class="line"></span><br><span class="line">systemctl show --property&#x3D;Environment docker</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于Docker官方镜像仓库&lt;code&gt;Registry&lt;/code&gt;，没有仓库镜像加速，寸步难行。&lt;/p&gt;
&lt;p&gt;对于国外非Docker官方镜像仓库，并且还被墙的仓库&lt;code&gt;Registry&lt;/code&gt;，没有网络代理，寸步难行。&lt;/p&gt;
&lt;p&gt;镜像仓库加速器&lt;cod
      
    
    </summary>
    
    
    
      <category term="Docker" scheme="http://lessisbetter.site/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker容器基础3：Cgroup - cpu, cpuacct, cpuset子系统</title>
    <link href="http://lessisbetter.site/2020/09/01/cgroup-3-cpu-md/"/>
    <id>http://lessisbetter.site/2020/09/01/cgroup-3-cpu-md/</id>
    <published>2020-09-01T15:00:24.000Z</published>
    <updated>2020-09-01T15:19:56.419Z</updated>
    
    <content type="html"><![CDATA[<h2 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h2><p>Ubuntu 18.04，内核版本4.15，机器拥有4核。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[~]$ cat &#x2F;proc&#x2F;version</span><br><span class="line">Linux version 4.15.0-112-generic (buildd@lcy01-amd64-027) (gcc version 7.5.0 (Ubuntu 7.5.0-3ubuntu1~18.04)) #113-Ubuntu SMP Thu Jul 9 23:41:39 UTC 2020</span><br><span class="line">[~]$</span><br><span class="line">[~]$ cat &#x2F;etc&#x2F;os-release</span><br><span class="line">NAME&#x3D;&quot;Ubuntu&quot;</span><br><span class="line">VERSION&#x3D;&quot;18.04.3 LTS (Bionic Beaver)&quot;</span><br><span class="line">...</span><br><span class="line">[~]$ cat &#x2F;proc&#x2F;cpuinfo | grep &quot;processor&quot; | wc -l</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="CPU相关子系统简介"><a href="#CPU相关子系统简介" class="headerlink" title="CPU相关子系统简介"></a>CPU相关子系统简介</h2><p>有关CPU的cgroup subsystem有3个：</p><ul><li>cpu : 用来<strong>限制</strong>cgroup的CPU使用率</li><li>cpuacct : 用来<strong>统计</strong>cgroup的CPU的使用率</li><li>cpuset : 用来绑定cgroup到指定CPU的哪个核上和NUMA节点</li></ul><p>每个子系统都有多个配置项和指标文件，主要介绍下图常用的配置项：</p><p><img src="http://img.lessisbetter.site/2020-09-cgroup-cpux.png" alt="cpu、cpuacct、cpuset的指标"></p><h3 id="cpu"><a href="#cpu" class="headerlink" title="cpu"></a>cpu</h3><p>cpu子系统用来限制cgroup如何使用CPU的时间，也就是调度，它提供了3种调度办法，并且这3种调度办法都可以在启动容器时进行配置，分别是：</p><ul><li>share ：相对权重的CPU调度</li><li>cfs ：完全公平调度</li><li>rt ：实时调度</li></ul><p>share调度的配置项和原理如下：</p><p><img src="http://img.lessisbetter.site/2020-09-cgroup-cpu-share.png" alt="cpu share调度"></p><p>cfs 是Completely Fair Scheduler的缩写，代表完全公平调度，它利用 <code>cpu.cfs_quota_us</code> 和 <code>cpu.cfs_period_us</code> 实现公平调度，这两个文件内容组合使用可以限制进程在长度为 <code>cfs_period_us</code> 的时间内，只能被分配到总量为 <code>cfs_quota_us</code> 的 CPU 时间。CFS的指标如下：</p><p><img src="http://img.lessisbetter.site/2020-09-cgroup-cpu-cfs.png" alt="cpu cfs调度"></p><p><strong>注意</strong>： </p><ol><li><code>cfs_period_us</code> 取值范围1000~1000000：1ms ~ 1s，<code>cfs_quota_us</code>的最小值为1000，当设置的值不在取值范围时，会报 <code>write xxx: invalid argument</code> 的错误。</li><li>只有这2个参数都有意义时，才能把任务写入到 tasks 文件。</li></ol><p>rt 是RealTime的缩写，它是实时调度，它与cfs调度的区别是cfs不会保证进程的CPU使用率一定要达到设置的比率，而rt会严格保证，让进程的占用率达到这个比率，适合实时性较强的任务，它包含 <code>cpu.rt_period_us</code> 和 <code>cpu.rt_runtime_us</code> 2个配置项。</p><h3 id="cpuacct"><a href="#cpuacct" class="headerlink" title="cpuacct"></a>cpuacct</h3><p>cpuacct包含非常多的统计指标，常用的有以下4个文件：</p><p><img src="http://img.lessisbetter.site/2020-09-cgroup-cpuacct.png" alt="cpuacct常用指标文件"></p><h3 id="cpuset"><a href="#cpuset" class="headerlink" title="cpuset"></a>cpuset</h3><p>为啥需要cpuset？</p><p>比如：</p><ol><li>多核可以提高并发、并行，但是核太多了，会影响进程执行的局部性，降低效率。</li><li>一个服务器上部署多种应用，不同的应用不同的核。</li></ol><p>cpuset也包含居多的配置项，主要是分为cpu和mem 2类，mem与NUMA有关，其常用的配置项如下图:</p><p><img src="http://img.lessisbetter.site/2020-09-cgroup-cpuset.png" alt="cpuset常用配置项"></p><h2 id="利用Docker演示Cgroup-CPU限制"><a href="#利用Docker演示Cgroup-CPU限制" class="headerlink" title="利用Docker演示Cgroup CPU限制"></a>利用Docker演示Cgroup CPU限制</h2><h3 id="cpu-1"><a href="#cpu-1" class="headerlink" title="cpu"></a>cpu</h3><h4 id="不限制cpu的情况"><a href="#不限制cpu的情况" class="headerlink" title="不限制cpu的情况"></a>不限制cpu的情况</h4><p>stress为基于ubuntu:16.04安装stress做出来的镜像，利用stress来测试cpu限制。</p><p>Dockerfile如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">From</span> ubuntu:<span class="number">16.04</span></span><br><span class="line"><span class="comment"># Using Aliyun mirror</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mv /etc/apt/sources.list /root/sources.list.bak</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> sed -e s/security.ubuntu/mirrors.aliyun/ -e s/archive.ubuntu/mirrors.aliyun/ -e s/archive.canonical/mirrors.aliyun/ -e s/esm.ubuntu/mirrors.aliyun/ /root/sources.list.bak &gt; /etc/apt/sources.list</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get install -y stress</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /root</span></span><br></pre></td></tr></table></figure><p>启动容器不做任何cpu限制，利用 <code>stress -c 2</code> 开启另外2个stress线程，共3个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu]$ docker run --rm -it stress:16.04</span><br><span class="line">root@5fad38726740:&#x2F;# stress -c 2</span><br><span class="line">stress: info: [12] dispatching hogs: 2 cpu, 0 io, 1 vm, 0 hdd</span><br></pre></td></tr></table></figure><p>在<code>cgroup/cpu,cpuacct</code>下，找到该容器对应的目录，查看 <code>cfs_period_us</code> 和 <code>cfs_quota_us</code> 的默认值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu,cpuacct&#x2F;system.slice&#x2F;docker-5fad38726740b90b93c06972fe4a9f11391a38aaeb3e922f10c3269fa32e1873.scope]$ cat cpu.cfs_period_us</span><br><span class="line">100000</span><br><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu,cpuacct&#x2F;system.slice&#x2F;docker-5fad38726740b90b93c06972fe4a9f11391a38aaeb3e922f10c3269fa32e1873.scope]$ cat cpu.cfs_quota_us</span><br><span class="line">-1</span><br></pre></td></tr></table></figure><p>查看主机CPU利用率，为3个stress进程，每1个都100%，它们属于同一个cgroup：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line">5616 root      20   0  109872 102336     36 R 100.0  1.3   0:07.46 stress</span><br><span class="line">5617 root      20   0    7468     88      0 R 100.0  0.0   0:07.45 stress</span><br><span class="line">5615 root      20   0    7468     88      0 R 100.0  0.0   0:07.45 stress</span><br></pre></td></tr></table></figure><h4 id="限制cpu的情况"><a href="#限制cpu的情况" class="headerlink" title="限制cpu的情况"></a>限制cpu的情况</h4><p><code>--cpu-quota</code>设置5000，开stress分配到另外2个核。</p><p>[/sys/fs/cgroup/cpu]$ docker run –rm -it –cpu-quota=5000 stress:16.04<br>root@7e79005d7ca1:/#<br>root@7e79005d7ca1:/# stress  -c 2<br>stress: info: [13] dispatching hogs: 2 cpu, 0 io, 1 vm, 0 hdd</p><p>查看 <code>cfs_period_us</code> 和 <code>cfs_quota_us</code> 的设置，<code>5000/100000 = 5%</code> ， 即限制该容器的CPU使用率不得超过5%。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu,cpuacct&#x2F;system.slice&#x2F;docker-7e79005d7ca1b338d870d3dc79af3f1cd38ace195ebd685a09575f6acee36a07.scope]$ cat cpu.cfs_quota_us</span><br><span class="line">5000</span><br><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu,cpuacct&#x2F;system.slice&#x2F;docker-7e79005d7ca1b338d870d3dc79af3f1cd38ace195ebd685a09575f6acee36a07.scope]$ cat cpu.cfs_period_us</span><br><span class="line">100000</span><br></pre></td></tr></table></figure><p>利用top可以看到3个进程总cpu使用率5.1%。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line">5411 root      20   0    7468     92      0 R   1.7  0.0   0:00.53 stress</span><br><span class="line">5412 root      20   0  109872 102500     36 R   1.7  1.3   0:00.30 stress</span><br><span class="line">5413 root      20   0    7468     92      0 R   1.7  0.0   0:00.35 stress</span><br></pre></td></tr></table></figure><h3 id="cpuacct-1"><a href="#cpuacct-1" class="headerlink" title="cpuacct"></a>cpuacct</h3><p>查看<code>cpuacct.stat, cpuacct.usage, cpuacct.usage_percpu</code>，一定要同时输出这几个文件，不然可能有时间差，利用python可以计算每个核上的时间之和为<code>usage</code>，即该容器占用的cpu总时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu,cpuacct]$ cat cpuacct.*</span><br><span class="line">user 20244450 &#x2F;&#x2F; cpuacct.stat</span><br><span class="line">system 52361  &#x2F;&#x2F; cpuacct.stat</span><br><span class="line">204310768947624  &#x2F;&#x2F; cpuacct.usage</span><br><span class="line">61143521333219 32616883199042 73804985004267 36745379411096 &#x2F;&#x2F; cpuacct.usage_percpu</span><br><span class="line"></span><br><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu,cpuacct]$ python</span><br><span class="line">Python 2.7.5 (default, Apr 11 2018, 07:36:10)</span><br><span class="line">[GCC 4.8.5 20150623 (Red Hat 4.8.5-28)] on linux2</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt; sum &#x3D; 61143521333219+32616883199042+73804985004267+36745379411096</span><br><span class="line">&gt;&gt;&gt; dist &#x3D; sum - 204310768947624</span><br><span class="line">&gt;&gt;&gt; dist</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; sum</span><br><span class="line">204310768947624</span><br><span class="line">&gt;&gt;&gt; sum2 &#x3D; 20244450+52361</span><br><span class="line">&gt;&gt;&gt; sum2</span><br><span class="line">20296811</span><br></pre></td></tr></table></figure><h3 id="cpuset-1"><a href="#cpuset-1" class="headerlink" title="cpuset"></a>cpuset</h3><p>启动容器，然后使用stress占用1个核：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu]$ docker run --rm -it stress:16.04</span><br><span class="line">root@a907df624697:~#</span><br><span class="line">root@a907df624697:~# stress -c 1</span><br><span class="line">stress: info: [12] dispatching hogs: 1 cpu, 0 io, 0 vm, 0 hdd</span><br></pre></td></tr></table></figure><p>top显示占用100%CPU。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line">6633 root      20   0    7480     92      0 R 100.0  0.0   0:12.13 stress</span><br></pre></td></tr></table></figure><p>cpuset 能看到可使用的核为： 0~3。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset&#x2F;docker&#x2F;a907df624697a19631929c1e9e971d2893afddbf6befb0dd44be3cf0024a3e0d]$ cat cpuset.cpus</span><br><span class="line">0-3</span><br></pre></td></tr></table></figure><p>使用cpuacct查看CPU情况使用统计，可以看到用了4个核上的使用时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu&#x2F;docker&#x2F;a907df624697a19631929c1e9e971d2893afddbf6befb0dd44be3cf0024a3e0d]$ cat cpuacct.usage cpuacct.usage_all</span><br><span class="line">153015464879</span><br><span class="line">cpu user system</span><br><span class="line">0 45900415963 0</span><br><span class="line">1 4675002 0</span><br><span class="line">2 63537634967 0</span><br><span class="line">3 43572738947 0</span><br></pre></td></tr></table></figure><p>现在创建一个新容器，限制只能用1，3这2个核：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu]$ docker run --rm -it --cpuset-cpus 1,3 stress:16.04</span><br><span class="line">root@0ce61a38e7c9:~# stress -c 1</span><br><span class="line">stress: info: [10] dispatching hogs: 1 cpu, 0 io, 0 vm, 0 hdd</span><br></pre></td></tr></table></figure><p>查看可以使用的核：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset&#x2F;docker&#x2F;0ce61a38e7c9621334871ab40d5b7d287d89a1e994148833ddf3ca4941a39c89]$ cat cpuset.cpus</span><br><span class="line">1,3</span><br></pre></td></tr></table></figure><p><code>cpuacct.usage_all</code> 显示只有1、3两个核的数据在使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu&#x2F;docker&#x2F;0ce61a38e7c9621334871ab40d5b7d287d89a1e994148833ddf3ca4941a39c89]$ cat cpuacct.usage_all</span><br><span class="line">cpu user system</span><br><span class="line">0 0 0</span><br><span class="line">1 37322884717 0</span><br><span class="line">2 0 0</span><br><span class="line">3 21332956940 0</span><br></pre></td></tr></table></figure><p>现在切换到root账号，把 <code>sched_load_balance</code> 标记设置为0，不进行核间的负载均衡，然后利用 <code>cpuacct.usage_all</code> 查看每个核上的时间，隔几秒前后查询2次，可以发现3号核的cpu使用时间停留在<code>21332956940</code>，而核1的cpu使用时间从<code>185084024837</code> 增加到 <code>221479683602</code>， 说明设置之后stress线程一致在核1上运行，不再进行负载均衡。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset&#x2F;docker&#x2F;0ce61a38e7c9621334871ab40d5b7d287d89a1e994148833ddf3ca4941a39c89]$ echo 0 &gt; cpuset.sched_load_balance</span><br><span class="line"></span><br><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu&#x2F;docker&#x2F;0ce61a38e7c9621334871ab40d5b7d287d89a1e994148833ddf3ca4941a39c89]$ cat cpuacct.usage_all</span><br><span class="line">cpu user system</span><br><span class="line">0 0 0</span><br><span class="line">1 185084024837 0</span><br><span class="line">2 0 0</span><br><span class="line">3 21332956940 0</span><br><span class="line"></span><br><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu&#x2F;docker&#x2F;0ce61a38e7c9621334871ab40d5b7d287d89a1e994148833ddf3ca4941a39c89]$ cat cpuacct.usage_all</span><br><span class="line">cpu user system</span><br><span class="line">0 0 0</span><br><span class="line">1 221479683602 0</span><br><span class="line">2 0 0</span><br><span class="line">3 21332956940 0</span><br></pre></td></tr></table></figure><h2 id="利用Go演示Cgroup-CPU限制"><a href="#利用Go演示Cgroup-CPU限制" class="headerlink" title="利用Go演示Cgroup CPU限制"></a>利用Go演示Cgroup CPU限制</h2><p>测试程序：<a href="https://github.com/Shitaibin/notes/blob/master/docker/codes/02.2.cgroup_cpu.go" target="_blank" rel="noopener">02.2.cgroup_cpu.go</a> 。</p><p>该程序接受1个入参，代表测试类型：</p><ul><li>空或<code>nolimit</code>: 无限制</li><li><code>cpu</code> : 执行cpu限制，利用cfs把cpu使用率控制在5%</li><li><code>cpuset</code> : 限制只使用核1和核3</li></ul><p>测试程序的执行动作如下：</p><ol><li>程序首先在cpu和cpuset中创建2个cgroup，</li><li>按传入的参数设置限制或不设置限制</li><li>利用<code>/proc/self/exe</code>启动进程</li><li>把进程加入到2个cgroup的tasks，即加入cgroup</li><li>进程会创建3个goroutine不断的去消耗cpu，它们会占用3个线程</li></ol><p>当CPU使用率不限制时，3个线程会分配到3个核上执行，所以进程的CPU使用率应当达到300%。</p><p>利用测试程序分3组实验，然后利用 <code>top</code>、<code>cpuacct.usage_all</code>、<code>cpuset.cpu</code> 3个角度查看CPU限制和使用情况。</p><h3 id="不限制CPU"><a href="#不限制CPU" class="headerlink" title="不限制CPU"></a>不限制CPU</h3><ol><li>启动测试程序，进程id为4805，进入Namespace后进程id变为1，可以看到启动了3个worker协程。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;home&#x2F;ubuntu&#x2F;workspace&#x2F;notes&#x2F;docker&#x2F;codes]$ go run 02.2.cgroup_cpu.go</span><br><span class="line">---------- 1 ------------</span><br><span class="line">Test type: No limit</span><br><span class="line">cmdPid: 4805</span><br><span class="line">---------- 2 ------------</span><br><span class="line">Current pid: 1</span><br><span class="line">worker 2 start</span><br><span class="line">worker 0 start</span><br><span class="line">worker 1 start</span><br></pre></td></tr></table></figure><ol start="2"><li>top查看进程的CPU占用率为300%，符合预期。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line">4805 root      20   0    3376   1004    836 R 300.0  0.0   4:41.09 exe</span><br></pre></td></tr></table></figure><ol start="3"><li>利用cpuacct查看每个核上的使用时间：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuacct]$ cat test_cpu_limit&#x2F;cpuacct.usage_all</span><br><span class="line">cpu user system</span><br><span class="line">0 8046597390 0</span><br><span class="line">1 34269979109 0</span><br><span class="line">2 26597651949 0</span><br><span class="line">3 33886705168 0</span><br></pre></td></tr></table></figure><ol start="4"><li>利用cpuset.cpus查看使用的cpu核：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset]$ cat test_cpuset_limit&#x2F;cpuset.cpus</span><br><span class="line">0-3</span><br></pre></td></tr></table></figure><h3 id="使用cpu限制CPU使用率"><a href="#使用cpu限制CPU使用率" class="headerlink" title="使用cpu限制CPU使用率"></a>使用cpu限制CPU使用率</h3><ol><li>启动测试程序：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;home&#x2F;ubuntu&#x2F;workspace&#x2F;notes&#x2F;docker&#x2F;codes]$ go run 02.2.cgroup_cpu.go cpu</span><br><span class="line">---------- 1 ------------</span><br><span class="line">Test type: Cpu limit</span><br><span class="line">cmdPid: 4937</span><br><span class="line">---------- 2 ------------</span><br><span class="line">Current pid: 1</span><br><span class="line">worker 2 start</span><br><span class="line">worker 1 start</span><br><span class="line">worker 0 start</span><br></pre></td></tr></table></figure><ol start="2"><li>top查看进程的CPU占用率为5.0%，符合预期。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line">4937 root      20   0    3376   1004    836 R   5.3  0.0   0:08.40 exe</span><br></pre></td></tr></table></figure><ol start="3"><li>利用cpuacct查看每个核上的使用时间，由于没有限制使用的cpu核，所以每个核上都还有运行时间</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuacct]$ cat test_cpu_limit&#x2F;cpuacct.usage_all</span><br><span class="line">cpu user system</span><br><span class="line">0 2036903414 0</span><br><span class="line">1 44170 0</span><br><span class="line">2 4428266075 0</span><br><span class="line">3 4356927661 0</span><br></pre></td></tr></table></figure><ol start="4"><li>利用cpuset.cpus查看使用的cpu核</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset]$ cat test_cpuset_limit&#x2F;cpuset.cpus</span><br><span class="line">0-3</span><br></pre></td></tr></table></figure><h3 id="使用cpuset限制CPU占用的核"><a href="#使用cpuset限制CPU占用的核" class="headerlink" title="使用cpuset限制CPU占用的核"></a>使用cpuset限制CPU占用的核</h3><ol><li>启动测试程序，这次与前面的不同，看到只起来了2个worker协程在运行，因为机器上的Go版本是go1.10，还不支持抢占，当协程为for循环时，2个协程都持续运行，不让出cpu，只有2个核时，第3个协程无法运行。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;home&#x2F;ubuntu&#x2F;workspace&#x2F;notes&#x2F;docker&#x2F;codes]$ go run 02.2.cgroup_cpu.go cpuset</span><br><span class="line">---------- 1 ------------</span><br><span class="line">Test type: Cpuset limit</span><br><span class="line">cmdPid: 5063</span><br><span class="line">---------- 2 ------------</span><br><span class="line">Current pid: 1</span><br><span class="line">worker 2 start</span><br><span class="line">worker 0 start</span><br></pre></td></tr></table></figure><ol start="2"><li>top查看进程的CPU占用率为200%，符合只使用2个核的预期。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line">5063 root      20   0    3376   1004    836 R 199.7  0.0   4:21.49 exe</span><br></pre></td></tr></table></figure><ol start="3"><li>利用cpuacct查看每个核上的使用时间，只有核1和3上有时间统计，说明只使用了核1和3</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuacct]$ cat test_cpu_limit&#x2F;cpuacct.usage_all</span><br><span class="line">cpu user system</span><br><span class="line">0 0 0</span><br><span class="line">1 24172994458 0</span><br><span class="line">2 0 0</span><br><span class="line">3 24213057511 0</span><br></pre></td></tr></table></figure><ol start="4"><li>利用cpuset.cpus查看使用的cpu核</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset]$ cat test_cpuset_limit&#x2F;cpuset.cpus</span><br><span class="line">1,3</span><br></pre></td></tr></table></figure><h2 id="推荐资料"><a href="#推荐资料" class="headerlink" title="推荐资料"></a>推荐资料</h2><ol><li><a href="https://kernel.googlesource.com/pub/scm/linux/kernel/git/glommer/memcg/+/cpu_stat/Documentation/cgroups/" target="_blank" rel="noopener">Linux Kernel关于cgroup cpu、cpuset的文档</a></li><li><a href="https://union-click.jd.com/jdc?e=&amp;p=AyIGZRtSFwsWB1EcXhUyFQ5WEloVCxMBURxrUV1KWQorAlBHU0VeBUVNR0ZbSkdETlcNVQtHRVNSUVNLXANBRA1XB14DS10cQQVYD21XHgBcGFIUAhsGUx9cJQEbBTJbEmFdcHkRSANGBhBDCnkmEVQeC2UaaxUDEwVWEl8RBhM3ZRtcJUN8B1QaUxMCFAFlGmsVBhoOUx9fFwESB1IfaxICGzeDtdnBl4nT2YZrJTIRN2UrWyUBIkU7HQxBABEGBhILHVdGAgcaXB0DQARWHQ4QVhFVVhkLEVciBVQaXxw%3D" target="_blank" rel="noopener">阿里同学的书《自己动手写Docker》</a></li><li><a href="https://my.oschina.net/xiaominmin/blog/3068364" target="_blank" rel="noopener">解决写 cpu.cfs_quota_us <code>invalid argument</code>问题</a></li><li><a href="https://blog.csdn.net/xftony/article/details/80536562" target="_blank" rel="noopener">解决写 cpuset.tasks <code>No space</code> 问题</a></li><li><a href="https://www.cnblogs.com/raymondshiquan/articles/2727037.html" target="_blank" rel="noopener">cgroup使用踩坑</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;测试环境&quot;&gt;&lt;a href=&quot;#测试环境&quot; class=&quot;headerlink&quot; title=&quot;测试环境&quot;&gt;&lt;/a&gt;测试环境&lt;/h2&gt;&lt;p&gt;Ubuntu 18.04，内核版本4.15，机器拥有4核。&lt;/p&gt;
&lt;figure class=&quot;highlight pla
      
    
    </summary>
    
    
    
      <category term="Kubernetes" scheme="http://lessisbetter.site/tags/Kubernetes/"/>
    
      <category term="Docker" scheme="http://lessisbetter.site/tags/Docker/"/>
    
      <category term="Cgroup" scheme="http://lessisbetter.site/tags/Cgroup/"/>
    
  </entry>
  
  <entry>
    <title>Docker容器基础2：Cgroup - memory子系统</title>
    <link href="http://lessisbetter.site/2020/08/30/cgroup-2-memory/"/>
    <id>http://lessisbetter.site/2020/08/30/cgroup-2-memory/</id>
    <published>2020-08-30T02:45:08.000Z</published>
    <updated>2020-09-01T15:16:28.500Z</updated>
    
    <content type="html"><![CDATA[<h2 id="测试环境版本"><a href="#测试环境版本" class="headerlink" title="测试环境版本"></a>测试环境版本</h2><p>测试机采用的Ubuntu 16.04 与 Linux 4.4.0 内核版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[~]$ cat &#x2F;etc&#x2F;issue</span><br><span class="line">Ubuntu 16.04.4 LTS \n \l</span><br><span class="line">[~]$</span><br><span class="line">[~]$ cat &#x2F;proc&#x2F;version</span><br><span class="line">Linux version 4.4.0-117-generic (buildd@lgw01-amd64-057) (gcc version 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.9) ) #141-Ubuntu SMP Tue Mar 13 12:01:47 UTC 2018</span><br></pre></td></tr></table></figure><p><strong>提醒</strong>：Linux内核版本至少要大于 4.3 这样cgroup的功能才是全的，否则Linux内核版本过低，由于功能不全可能无法运行提供的Demo，目前已知无法运行的内核版本有：<code>Linux version 3.10.0</code>。</p><h2 id="Cgroup-memory子系统介绍"><a href="#Cgroup-memory子系统介绍" class="headerlink" title="Cgroup memory子系统介绍"></a>Cgroup memory子系统介绍</h2><p>cgroup的memory子系统全称为 Memory Resource Controller ，它能够限制cgroup中所有任务的使用的内存和交换内存进行限制，并且采取control措施：当OOM时，是否要kill进程。</p><p>memroy包含了很多设置指标和统计指标：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory&#x2F;system.slice&#x2F;docker-fda7bbf297d9300894c10c5514c32c70a50987ae99cad5731234058d9f6e2b7f.scope]$ ls memory.*</span><br><span class="line">memory.failcnt                  memory.kmem.tcp.limit_in_bytes      memory.memsw.limit_in_bytes      memory.soft_limit_in_bytes</span><br><span class="line">memory.force_empty              memory.kmem.tcp.max_usage_in_bytes  memory.memsw.max_usage_in_bytes  memory.stat</span><br><span class="line">memory.kmem.failcnt             memory.kmem.tcp.usage_in_bytes      memory.memsw.usage_in_bytes      memory.swappiness</span><br><span class="line">memory.kmem.limit_in_bytes      memory.kmem.usage_in_bytes          memory.move_charge_at_immigrate  memory.usage_in_bytes</span><br><span class="line">memory.kmem.max_usage_in_bytes  memory.limit_in_bytes               memory.numa_stat                 memory.use_hierarchy</span><br><span class="line">memory.kmem.slabinfo            memory.max_usage_in_bytes           memory.oom_control</span><br><span class="line">memory.kmem.tcp.failcnt         memory.memsw.failcnt                memory.pressure_level</span><br></pre></td></tr></table></figure><p>下图进行了汇总，虚线所圈出的指标为常用指标，每个指标的含义也如图所标注：</p><p><img src="http://img.lessisbetter.site/2020-08-cgroup-memory.png" alt="cgroup memory subsystem"></p><p>所有指标的含义可以参考<a href="https://kernel.googlesource.com/pub/scm/linux/kernel/git/glommer/memcg/+/cpu_stat/Documentation/cgroups/memory.txt" target="_blank" rel="noopener">Linux Kernel关于cgroup memory</a>的介绍。</p><h2 id="利用Docker演示Cgroup内存限制"><a href="#利用Docker演示Cgroup内存限制" class="headerlink" title="利用Docker演示Cgroup内存限制"></a>利用Docker演示Cgroup内存限制</h2><ol><li>创建一个容器，限制为内存为128MB</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[~]$ docker run --rm -itd -m 128m stress:16.04</span><br><span class="line">fda7bbf297d9300894c10c5514c32c70a50987ae99cad5731234058d9f6e2b7f</span><br></pre></td></tr></table></figure><ol start="2"><li>容器内利用<code>stress</code>使用100MB内存</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[~]$ docker exec -it fda7bbf29 bash</span><br><span class="line">root@fda7bbf297d9:&#x2F;# stress --vm-bytes 100m --vm-keep -m 1</span><br><span class="line">stress: info: [23739] dispatching hogs: 0 cpu, 0 io, 1 vm, 0 hdd</span><br></pre></td></tr></table></figure><ol start="3"><li>在memory子系统目录下，利用容器id找到与当前容器相关的cgroup目录</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory&#x2F;system.slice]$ find . -name &quot;*fda7bbf29*&quot; -print</span><br><span class="line">.&#x2F;var-lib-docker-containers-fda7bbf297d9300894c10c5514c32c70a50987ae99cad5731234058d9f6e2b7f-shm.mount</span><br><span class="line">.&#x2F;docker-fda7bbf297d9300894c10c5514c32c70a50987ae99cad5731234058d9f6e2b7f.scope</span><br></pre></td></tr></table></figure><p><code>./docker-fda7bbf297d9300894c10c5514c32c70a50987ae99cad5731234058d9f6e2b7f.scope</code> 目录为当前容器的内存cgroup节点。</p><ol start="4"><li>查看该容器的内存使用量、限制，以及统计信息</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory&#x2F;system.slice&#x2F;docker-fda7bbf297d9300894c10c5514c32c70a50987ae99cad5731234058d9f6e2b7f.scope]$ cat memory.usage_in_bytes memory.limit_in_bytes memory.stat</span><br><span class="line">106049536 &#x2F;&#x2F; memory.usage_in_bytes</span><br><span class="line">134217728 &#x2F;&#x2F; memory.limit_in_bytes</span><br><span class="line">cache 0   &#x2F;&#x2F; 以下为memory.stat</span><br><span class="line">rss 105943040</span><br><span class="line">swap 0</span><br><span class="line">...</span><br><span class="line">hierarchical_memory_limit 134217728</span><br><span class="line">hierarchical_memsw_limit 268435456</span><br><span class="line">...</span><br><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory&#x2F;system.slice&#x2F;docker-fda7bbf297d9300894c10c5514c32c70a50987ae99cad5731234058d9f6e2b7f.scope]$</span><br></pre></td></tr></table></figure><ul><li>使用量为 ： 106049536 / 1024 / 1024 = 101.14 MB</li><li>限制为 ： 134217728 / 1024 / 1024 = 128MB</li></ul><p>stat文件：</p><ul><li>rss ：105943040 / 1024 / 1024 = 101.03 MB</li><li>hierarchical_memory_limit ： 134217728 / 1024 / 1024 = 128MB</li></ul><p>stat中rss的值与 <code>usage_in_bytes</code> 有稍微的出入，原因是 <code>usage_in_bytes</code> 的值为近视值，而之所以近似，是因为内核采用的是异步统计，造成统计值和当下的值存在误差。</p><p>该cgroup中所有tasks所占用的真实内存可以使用：<code>stat.rss + stat.cache + stat.swap</code> ，在上面的例子中 cache 和 swap 都为0，所以 rss 的值就是真实的内存使用量。</p><p>之所以存在 <code>usage_in_bytes</code> ， 这样做的目的是通过一个值可以快速获取内存的使用量，而无需进行计算。</p><p>利用<code>docker.stats</code> 查看内存占用情况:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory&#x2F;system.slice&#x2F;docker-fda7bbf297d9300894c10c5514c32c70a50987ae99cad5731234058d9f6e2b7f.scope]$ docker stats</span><br><span class="line">CONTAINER           CPU %               MEM USAGE &#x2F; LIMIT     MEM %               NET I&#x2F;O             BLOCK I&#x2F;O           PIDS</span><br><span class="line">fda7bbf297d9        99.50%              101.1 MiB &#x2F; 128 MiB   79.01%              648 B &#x2F; 648 B       0 B &#x2F; 0 B           4</span><br></pre></td></tr></table></figure><p>可以看到usage和limit分别为101.1MB和128MB，usage与cgroup中 <code>usage_in_bytes</code> 是一致的，limit与容器启动时的配置一致。</p><p>top命令查看进程占用内存情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory&#x2F;system.slice&#x2F;docker-fda7bbf297d9300894c10c5514c32c70a50987ae99cad5731234058d9f6e2b7f.scope]$ top</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line">13025 root      20   0  109872 102336     36 R  93.8  1.3   6:39.09 stress</span><br></pre></td></tr></table></figure><p>可以看到<code>RES</code>为 102336 KB，即 99.9 MB，小于cgroup中统计的内存使用量，原因是因为cgroup中除了stress还有其他任务，比如docker中运行的ssh。</p><p>可以查看该group的进程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory&#x2F;system.slice&#x2F;docker-fda7bbf297d9300894c10c5514c32c70a50987ae99cad5731234058d9f6e2b7f.scope]$ cat cgroup.procs</span><br><span class="line">13780</span><br><span class="line">13792</span><br><span class="line">13793</span><br><span class="line">21124</span><br><span class="line">21221</span><br></pre></td></tr></table></figure><p>从 <code>pstree -p</code> 可以查看整个进程树:</p><p><img src="http://img.lessisbetter.site/2020-cgroup-memory-pstree.png" alt=""></p><h2 id="利用Go演示Cgroup内存限制"><a href="#利用Go演示Cgroup内存限制" class="headerlink" title="利用Go演示Cgroup内存限制"></a>利用Go演示Cgroup内存限制</h2><h3 id="测试源码"><a href="#测试源码" class="headerlink" title="测试源码"></a>测试源码</h3><p>cgroup的演示<a href="https://github.com/Shitaibin/notes/blob/master/docker/codes/02.1.cgroup.go" target="_blank" rel="noopener">源码</a> ，关于源码中的<code>/proc/self/exe</code>看<a href="#补充小知识">补充小知识</a>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参考《自动动手写Docker》</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"os/exec"</span></span><br><span class="line"><span class="string">"path"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line"><span class="string">"syscall"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CgroupMemoryHierarchyMount = <span class="string">"/sys/fs/cgroup/memory"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> os.Args[<span class="number">0</span>] == <span class="string">"/proc/self/exe"</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"---------- 2 ------------"</span>)</span><br><span class="line">fmt.Printf(<span class="string">"Current pid: %d\n"</span>, syscall.Getpid())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建stress子进程，施加内存压力</span></span><br><span class="line">allocMemSize := <span class="string">"99m"</span> <span class="comment">// 另外1项测试为99m</span></span><br><span class="line">fmt.Printf(<span class="string">"allocMemSize: %v\n"</span>, allocMemSize)</span><br><span class="line">stressCmd := fmt.Sprintf(<span class="string">"stress --vm-bytes %s --vm-keep -m 1"</span>, allocMemSize)</span><br><span class="line">cmd := exec.Command(<span class="string">"sh"</span>, <span class="string">"-c"</span>, stressCmd)</span><br><span class="line">cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;&#125;</span><br><span class="line">cmd.Stdin = os.Stdin</span><br><span class="line">cmd.Stdout = os.Stdout</span><br><span class="line">cmd.Stderr = os.Stderr</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := cmd.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"stress run error: %v"</span>, err)</span><br><span class="line">os.Exit(<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"---------- 1 ------------"</span>)</span><br><span class="line">cmd := exec.Command(<span class="string">"/proc/self/exe"</span>)</span><br><span class="line">cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;</span><br><span class="line">Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWNS | syscall.CLONE_NEWPID,</span><br><span class="line">&#125;</span><br><span class="line">cmd.Stdin = os.Stdin</span><br><span class="line">cmd.Stdout = os.Stdout</span><br><span class="line">cmd.Stderr = os.Stderr</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动子进程</span></span><br><span class="line"><span class="keyword">if</span> err := cmd.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"/proc/self/exe start error: %v"</span>, err)</span><br><span class="line">os.Exit(<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cmdPid := cmd.Process.Pid</span><br><span class="line">fmt.Printf(<span class="string">"cmdPid: %d\n"</span>, cmdPid)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建子cgroup</span></span><br><span class="line">memoryGroup := path.Join(CgroupMemoryHierarchyMount, <span class="string">"test_memory_limit"</span>)</span><br><span class="line">os.Mkdir(memoryGroup, <span class="number">0755</span>)</span><br><span class="line"><span class="comment">// 设定内存限制</span></span><br><span class="line">ioutil.WriteFile(path.Join(memoryGroup, <span class="string">"memory.limit_in_bytes"</span>),</span><br><span class="line">[]<span class="keyword">byte</span>(<span class="string">"100m"</span>), <span class="number">0644</span>)</span><br><span class="line"><span class="comment">// 将进程加入cgroup</span></span><br><span class="line">ioutil.WriteFile(path.Join(memoryGroup, <span class="string">"tasks"</span>),</span><br><span class="line">[]<span class="keyword">byte</span>(strconv.Itoa(cmdPid)), <span class="number">0644</span>)</span><br><span class="line"></span><br><span class="line">cmd.Process.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码运行解读：</p><ol><li>使用<code>go run</code>运行程序，或build后运行程序时，程序的名字是<code>02.1.cgroup</code>，所以不满足<code>os.Args[0] == &quot;/proc/self/exe&quot;</code>会被跳过。</li><li>然后使用<code>&quot;/proc/self/exe&quot;</code>新建了子进程，子进程此时叫：<code>&quot;/proc/self/exe&quot;</code></li><li>创建cgroup <code>test_memory_limit</code>，然后设置内存限制为100MB</li><li>把子进程加入到cgroup <code>test_memory_limit</code></li><li>等待子进程结束</li><li>子进程干了啥呢？子进程其实还是当前程序，只不过它的名字是<code>&quot;/proc/self/exe&quot;</code>，符合最初的if语句，之后它会创建stress子进程，然后运行stress，可以修改<code>allocMemSize</code>设置stress所要占用的内存</li></ol><h3 id="不超越内存限制情况"><a href="#不超越内存限制情况" class="headerlink" title="不超越内存限制情况"></a>不超越内存限制情况</h3><p>源码默认在启动stress时，stress占用99m内存，cgroup限制最多使用100m内存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[~&#x2F;workspace&#x2F;notes&#x2F;docker&#x2F;codes]$ go run 02.1.cgroup.go</span><br><span class="line">---------- 1 ------------</span><br><span class="line">cmdPid: 2533</span><br><span class="line">---------- 2 ------------</span><br><span class="line">Current pid: 1</span><br><span class="line">allocMemSize: 99m</span><br><span class="line">stress: info: [6] dispatching hogs: 0 cpu, 0 io, 1 vm, 0 hdd</span><br></pre></td></tr></table></figure><p>可以看到，子进程<code>&quot;/proc/self/exe&quot;</code>运行后取得的pid为 <strong>2533</strong> ，在新的Namespace中，子进程<code>&quot;/proc/self/exe&quot;</code>的pid已经变成1，然后利用stress打了99M内存。</p><p>使用top查看资源使用情况，stress进程内存RES大约为99M，pid 为 <strong>2539</strong> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND</span><br><span class="line">2539 root      20   0  103940 101680    284 R 93.8  9.9   0:06.09 stress</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory&#x2F;test_memory_limit]$ cat memory.limit_in_bytes</span><br><span class="line">104857600</span><br><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory&#x2F;test_memory_limit]$ # 104857600 刚好为100MB</span><br><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory&#x2F;test_memory_limit]$ cat memory.usage_in_bytes</span><br><span class="line">2617344</span><br><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory&#x2F;test_memory_limit]$ cat tasks</span><br><span class="line">2533 &lt;--- &#x2F;prof&#x2F;self&#x2F;exe进程</span><br><span class="line">2534</span><br><span class="line">2535</span><br><span class="line">2536</span><br><span class="line">2537</span><br><span class="line">2538</span><br><span class="line">2539 &lt;--- stress进程</span><br></pre></td></tr></table></figure><p>tasks下都是在cgroup <code>test_memory_limit</code> 中的进程，这些是Host中真实的进程号，通过<code>pstree -p</code>查看进程树，看看这些都是哪些进程：</p><p><img src="http://img.lessisbetter.site/2020-08-cgroup.png" alt="Cgroup限制内存的进程树"></p><p>进程树佐证了前面的代码执行流程分析大致是对的，只不过这其中还涉及一些创建子进程的具体手段，比如stress是通过sh命令创建出来的。</p><h3 id="内存超过限制被Kill情况"><a href="#内存超过限制被Kill情况" class="headerlink" title="内存超过限制被Kill情况"></a>内存超过限制被Kill情况</h3><p>内存超过cgroup限制的内存会怎么样？会OOM吗？</p><p>如果将stress内存提高到占用101MB，大于cgroup中内存的限制100M时，整个group中的进程就会被Kill。</p><p>修改代码，将 <code>allocMemSize</code> 设置为 <code>101m</code> ，然后重新运行程序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[~&#x2F;notes&#x2F;docker&#x2F;codes]$ go run 02.1.cgroup.go                                                                        *[master]</span><br><span class="line">---------- 1 ------------</span><br><span class="line">cmdPid: 21492</span><br><span class="line">---------- 2 ------------</span><br><span class="line">Current pid: 1</span><br><span class="line">allocMemSize: 101m</span><br><span class="line">stress: info: [6] dispatching hogs: 0 cpu, 0 io, 1 vm, 0 hdd</span><br><span class="line">stress: FAIL: [6] (415) &lt;-- worker 7 got signal 9</span><br><span class="line">stress: WARN: [6] (417) now reaping child worker processes</span><br><span class="line">stress: FAIL: [6] (421) kill error: No such process</span><br><span class="line">stress: FAIL: [6] (451) failed run completed in 0s</span><br><span class="line">2020&#x2F;08&#x2F;27 17:38:52 exit status 1</span><br></pre></td></tr></table></figure><p><code>stress: FAIL: [6] (415) &lt;-- worker 7 got signal 9</code> 说明收到了信号9，即SIGKILL 。</p><h2 id="补充小知识"><a href="#补充小知识" class="headerlink" title="补充小知识"></a>补充小知识</h2><p>在演示源码中，使用到<code>&quot;/proc/self/exe&quot;</code>，它在Linux是一个特殊的软链接，它指向当前正在运行的程序，比如执行<code>ll</code>查看该文件时，它就执行了<code>/usr/bin/ls</code>，因为当前的程序是<code>ls</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[~]$ ll &#x2F;proc&#x2F;self&#x2F;exe</span><br><span class="line">lrwxrwxrwx 1 centos centos 0 8月  27 12:44 &#x2F;proc&#x2F;self&#x2F;exe -&gt; &#x2F;usr&#x2F;bin&#x2F;ls</span><br></pre></td></tr></table></figure><p>演示代码中的技巧就是通过<code>&quot;/proc/self/exe&quot;</code>重新启动一个子进程，只不过进程名称叫<code>&quot;/proc/self/exe&quot;</code>而已。如果代码中没有那句if判断，又会执行到创建子进程，最终会导致递归溢出。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>memory是cgroup的一个子系统，主要用来控制一组进程的内存资源，对最大使用量进行限制和控制。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://kernel.googlesource.com/pub/scm/linux/kernel/git/glommer/memcg/+/cpu_stat/Documentation/cgroups/memory.txt" target="_blank" rel="noopener">Linux Kernel关于cgroup memory</a></li><li><a href="https://union-click.jd.com/jdc?e=&amp;p=AyIGZRtSFwsWB1EcXhUyFQ5WEloVCxMBURxrUV1KWQorAlBHU0VeBUVNR0ZbSkdETlcNVQtHRVNSUVNLXANBRA1XB14DS10cQQVYD21XHgBcGFIUAhsGUx9cJQEbBTJbEmFdcHkRSANGBhBDCnkmEVQeC2UaaxUDEwVWEl8RBhM3ZRtcJUN8B1QaUxMCFAFlGmsVBhoOUx9fFwESB1IfaxICGzeDtdnBl4nT2YZrJTIRN2UrWyUBIkU7HQxBABEGBhILHVdGAgcaXB0DQARWHQ4QVhFVVhkLEVciBVQaXxw%3D" target="_blank" rel="noopener">阿里同学的书《自己动手写Docker》</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;测试环境版本&quot;&gt;&lt;a href=&quot;#测试环境版本&quot; class=&quot;headerlink&quot; title=&quot;测试环境版本&quot;&gt;&lt;/a&gt;测试环境版本&lt;/h2&gt;&lt;p&gt;测试机采用的Ubuntu 16.04 与 Linux 4.4.0 内核版本：&lt;/p&gt;
&lt;figure cla
      
    
    </summary>
    
    
    
      <category term="Kubernetes" scheme="http://lessisbetter.site/tags/Kubernetes/"/>
    
      <category term="Docker" scheme="http://lessisbetter.site/tags/Docker/"/>
    
      <category term="Cgroup" scheme="http://lessisbetter.site/tags/Cgroup/"/>
    
  </entry>
  
  <entry>
    <title>Docker容器基础1：Cgroup - 资源控制简介</title>
    <link href="http://lessisbetter.site/2020/08/27/cgroup-1/"/>
    <id>http://lessisbetter.site/2020/08/27/cgroup-1/</id>
    <published>2020-08-27T13:43:52.000Z</published>
    <updated>2020-08-31T12:13:27.599Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Cgroup"><a href="#什么是Cgroup" class="headerlink" title="什么是Cgroup"></a>什么是Cgroup</h2><p>Cgroup 是 Control Group 的缩写，提供对一组进程，及未来子进程的资源<strong>限制、控制、统计</strong>能力，包括CPU、内存、磁盘、网络。</p><ul><li>限制：限制的资源最大使用量阈值。比如不能超过128MB内存，CPU使用率不得超过50%，或者只能是否CPU的某哪几个核。</li><li>控制：超过资源使用最大阈值时，进程会被控制，不任由它发展。比如cgroup内所有tasks的内存使用量超过阈值的结果就是被KILL，CPU使用率不得超过设定值。</li><li>统计：统计资源的使用情况等指标。比如cgroup内tasks的内存使用量，占用CPU的时间。</li></ul><p>Cgroup 包含3个组件：</p><ul><li>cgroup ：一组进程，可以加上subsystem</li><li>subsystem ：一组资源控制模块，CPU、内存…</li><li>hierarchy ： 把一组cgroup串成树状结构，这样就能实现cgroup的继承。为什么要继承呢？就如同docker镜像的继承，站在前人的基础之上，免去重复的配置</li></ul><h2 id="为什么需要Cgroup"><a href="#为什么需要Cgroup" class="headerlink" title="为什么需要Cgroup"></a>为什么需要Cgroup</h2><p>为什么需要Cgroup的问题等价于：为什么需要限制一组进程的资源？</p><p>有多种原因，比如：</p><ol><li>Linux是一个可以多用户登录的系统，如何限制不同的用户使用不同量的系统资源呢？</li><li>某个系统有64核，由于局部性原理，如果一组进程在64个核上调度，效率比较低，但把这些进程只允许在某几个核上调度，就有较好的局部性，提高效率。这类似与在分布式系统中，某个有状态的请求，最好能分配到上一次处理该请求的机器上一样的道理。</li></ol><p>cgroup的文档中还提到一个思路：实现资源限制的技术有多种，为什么使用cgroup？</p><p>cgroup是内核实现的，它更轻量、更高效、对内核的热点路径影响最小。</p><h2 id="你的Linux支持哪些Cgroup-subsystem"><a href="#你的Linux支持哪些Cgroup-subsystem" class="headerlink" title="你的Linux支持哪些Cgroup subsystem"></a>你的Linux支持哪些Cgroup subsystem</h2><p>查看当前系统支持的subsystem，共12个子系统。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup]$ cat &#x2F;proc&#x2F;cgroups</span><br><span class="line">#subsys_namehierarchynum_cgroupsenabled</span><br><span class="line">cpuset841</span><br><span class="line">cpu2741</span><br><span class="line">cpuacct2741</span><br><span class="line">memory11741</span><br><span class="line">devices6691</span><br><span class="line">freezer1041</span><br><span class="line">net_cls441</span><br><span class="line">blkio9691</span><br><span class="line">perf_event541</span><br><span class="line">hugetlb741</span><br><span class="line">pids3691</span><br><span class="line">net_prio441</span><br></pre></td></tr></table></figure><p>从左到右字段的含义分别是：</p><ol><li>subsys_name: subsystem的名字</li><li>hierarchy: subsystem所关联到的cgroup树的ID，如果多个subsystem关联到同一颗cgroup树，那么他们的这个字段将一样，比如这里的cpu和cpuacct就一样，表示他们绑定到了同一颗树。如果出现下面的情况，这个字段将为0：<ul><li>当前subsystem没有和任何cgroup树绑定</li><li>当前subsystem已经和cgroup v2的树绑定</li><li>当前subsystem没有被内核开启</li></ul></li><li>num_cgroups: subsystem所关联的cgroup树中进程组的个数，也即树上节点的个数</li><li>enabled: 1表示开启，0表示没有被开启(可以通过设置内核的启动参数“cgroup_disable”来控制subsystem的开启).</li></ol><p><a href="https://www.kernel.org/doc/Documentation/cgroup-v1/" target="_blank" rel="noopener">Cgroup的内核文档</a>对各 cgroup 和 subsystem 有详细的介绍，以下是每个 subsystem 功能简记：</p><ol><li>cpu ：用来<strong>限制</strong>cgroup的CPU使用率</li><li>cpuacct ：用来<strong>统计</strong>cgroup的CPU的使用率</li><li>cpuset ： 用来绑定cgroup到指定CPU哪个核上和NUMA节点</li><li>memory ：限制和统计cgroup的内存的使用率，包括process memory, kernel memory, 和swap</li><li>devices ： 限制cgroup创建(mknod)和访问设备的权限</li><li>freezer ： suspend和restore一个cgroup中的所有进程</li><li>net_cls ： 将一个cgroup中进程创建的所有网络包加上一个classid标记，用于tc和iptables。 只对发出去的网络包生效，对收到的网络包不起作用</li><li>blkio ： 限制cgroup访问块设备的IO速度</li><li>perf_event ： 对cgroup进行性能监控</li><li>net_prio ： 针对每个网络接口设置cgroup的访问优先级</li><li>hugetlb ： 限制cgroup的huge pages的使用量</li><li>pids ：限制一个cgroup及其子孙cgroup中的总进程数</li></ol><p>这些子系统的排列顺序，就是引入Linux内核顺序，最早的是cpu subsystem ，引入自Linux 2.6.24，最晚的是pid subsystem ，引入自 Linux 4.3。</p><h2 id="查看子系统和cgroup的挂载"><a href="#查看子系统和cgroup的挂载" class="headerlink" title="查看子系统和cgroup的挂载"></a>查看子系统和cgroup的挂载</h2><p>cgroup是通过文件系统实现的，每个目录都是一个cgroup节点，目录中的子目录都是子cgroup节点，这样就形成了 cgroup的 hierarchy 特性。</p><p>cgroup会挂载到 <code>/sys/fs/cgroup/</code>目录，该目录下的目录基本都是subsystem，<code>systemd</code>目录除外（它是 systemd 自建在cgroup下的目录，但不是子系统）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup]$ ll</span><br><span class="line">total 0</span><br><span class="line">dr-xr-xr-x 6 root root  0 Aug 30 09:30 blkio</span><br><span class="line">lrwxrwxrwx 1 root root 11 Aug 30 09:30 cpu -&gt; cpu,cpuacct</span><br><span class="line">lrwxrwxrwx 1 root root 11 Aug 30 09:30 cpuacct -&gt; cpu,cpuacct</span><br><span class="line">dr-xr-xr-x 7 root root  0 Aug 30 09:30 cpu,cpuacct</span><br><span class="line">dr-xr-xr-x 3 root root  0 Aug 30 09:30 cpuset</span><br><span class="line">dr-xr-xr-x 6 root root  0 Aug 30 09:30 devices</span><br><span class="line">dr-xr-xr-x 3 root root  0 Aug 30 09:30 freezer</span><br><span class="line">dr-xr-xr-x 3 root root  0 Aug 30 09:30 hugetlb</span><br><span class="line">dr-xr-xr-x 6 root root  0 Aug 30 09:30 memory</span><br><span class="line">lrwxrwxrwx 1 root root 16 Aug 30 09:30 net_cls -&gt; net_cls,net_prio</span><br><span class="line">dr-xr-xr-x 3 root root  0 Aug 30 09:30 net_cls,net_prio</span><br><span class="line">lrwxrwxrwx 1 root root 16 Aug 30 09:30 net_prio -&gt; net_cls,net_prio</span><br><span class="line">dr-xr-xr-x 3 root root  0 Aug 30 09:30 perf_event</span><br><span class="line">dr-xr-xr-x 6 root root  0 Aug 30 09:30 pids</span><br><span class="line">dr-xr-xr-x 6 root root  0 Aug 30 09:30 systemd</span><br></pre></td></tr></table></figure><p>发现cpu、cpuacct都指向了 <code>cpu,cpuacct</code> 目录，把它们合成了1个cgroup节点。另外 net_cls 和 net_prio 也都合到了 <code>net_cls,net_prio</code> 节点，也就形成了下面这幅图的样子，并把资源控制分成了5个类别：CPU、内存、网络、进程控制、设备，另外的<code>perf_event</code>是cgroup对自身的监控，不归于资源控制。</p><p><img src="http://img.lessisbetter.site/2020-08-30-cgroup-subsystem.png" alt=""></p><p>子系统挂载到cgroup的虚拟文件系统是通过mount命令实现的，系统启动时自动挂载subsystem到cgroup，查看已经挂载的Cgroup：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[~]$ mount -t cgroup</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,release_agent&#x3D;&#x2F;lib&#x2F;systemd&#x2F;systemd-cgroups-agent,name&#x3D;systemd)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory type cgroup (rw,nosuid,nodev,noexec,relatime,memory)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;pids type cgroup (rw,nosuid,nodev,noexec,relatime,pids)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu,cpuacct type cgroup (rw,nosuid,nodev,noexec,relatime,cpu,cpuacct)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;freezer type cgroup (rw,nosuid,nodev,noexec,relatime,freezer)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;net_cls,net_prio type cgroup (rw,nosuid,nodev,noexec,relatime,net_cls,net_prio)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;devices type cgroup (rw,nosuid,nodev,noexec,relatime,devices)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,cpuset)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;blkio type cgroup (rw,nosuid,nodev,noexec,relatime,blkio)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;hugetlb type cgroup (rw,nosuid,nodev,noexec,relatime,hugetlb)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;perf_event type cgroup (rw,nosuid,nodev,noexec,relatime,perf_event)</span><br></pre></td></tr></table></figure><p>查看某个进程所属的cgroup：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup]$ # $$代表当前进程</span><br><span class="line">[&#x2F;sys&#x2F;fs&#x2F;cgroup]$ cat &#x2F;proc&#x2F;$$&#x2F;cgroup</span><br><span class="line">11:memory:&#x2F;user.slice&#x2F;user-1000.slice&#x2F;session-269.scope</span><br><span class="line">10:freezer:&#x2F;</span><br><span class="line">9:blkio:&#x2F;user.slice</span><br><span class="line">8:cpuset:&#x2F;</span><br><span class="line">7:hugetlb:&#x2F;</span><br><span class="line">6:devices:&#x2F;user.slice</span><br><span class="line">5:perf_event:&#x2F;</span><br><span class="line">4:net_prio,net_cls:&#x2F;</span><br><span class="line">3:pids:&#x2F;user.slice</span><br><span class="line">2:cpuacct,cpu:&#x2F;user.slice&#x2F;user-1000.slice&#x2F;session-269.scope</span><br><span class="line">1:name&#x3D;systemd:&#x2F;user.slice&#x2F;user-1000.slice&#x2F;session-269.scope</span><br></pre></td></tr></table></figure><p>每一行从左到右，用<code>:</code>分割依次是：</p><ul><li><code>11</code>： cgroup继承树的节点的ID</li><li><code>memory</code>: 当前节点上挂载的子系统</li><li><code>/user.slice/user-1000.slice/session-269.scope</code>: cgroup节点相对于cgroup根目录下子系统的相对路径，转换成绝对路径就是：<code>/sys/fs/cgroup/memory/user.slice/user-1000.slice/session-269.scope</code></li></ul><h2 id="再聊cgroup-hierarchy"><a href="#再聊cgroup-hierarchy" class="headerlink" title="再聊cgroup hierarchy"></a>再聊cgroup hierarchy</h2><p>在 cpu,cpuacct 子系统下创建一个测试cgroup节点：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[/sys/fs/cgroup/cpu,cpuacct]$ sudo mkdir dabin_test_cpu_cgroup</span><br><span class="line">[/sys/fs/cgroup/cpu,cpuacct]$ <span class="built_in">cd</span> dabin_test_cpu_cgroup</span><br><span class="line">[/sys/fs/cgroup/cpu,cpuacct/dabin_test_cpu_cgroup]$ ls</span><br><span class="line">[/sys/fs/cgroup/cpu,cpuacct/dabin_test_cpu_cgroup]$ ls cgroup.*</span><br><span class="line">cgroup.clone_children  cgroup.event_control  cgroup.procs</span><br><span class="line">[/sys/fs/cgroup/cpu,cpuacct/dabin_test_cpu_cgroup]$ cat cgroup.clone_children</span><br><span class="line">0</span><br><span class="line">[/sys/fs/cgroup/cpu,cpuacct/dabin_test_cpu_cgroup]$ cat cgroup.procs</span><br><span class="line">[/sys/fs/cgroup/cpu,cpuacct/dabin_test_cpu_cgroup]$</span><br><span class="line">[/sys/fs/cgroup/cpu,cpuacct/dabin_test_cpu_cgroup]$ ls notify_on_release tasks</span><br><span class="line">notify_on_release  tasks</span><br><span class="line">[/sys/fs/cgroup/cpu,cpuacct/dabin_test_cpu_cgroup]$</span><br><span class="line">[/sys/fs/cgroup/cpu,cpuacct/dabin_test_cpu_cgroup]$ cat tasks</span><br><span class="line">[/sys/fs/cgroup/cpu,cpuacct/dabin_test_cpu_cgroup]$ cat notify_on_release</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>cgroup hierarchy (继承树)结构，每个cgroup节点都包含以下几个文件：</p><ul><li>cgroup.clone_children : 被cpuset控制器使用，值为1时子cgroup初始化时拷贝父cgroup的配置</li><li>cgroup.procs : cgroup中的线程组id</li><li>tasks : 当前cgroup包含的进程列表</li><li>notify_on_release : 值为0或1，1代表当cgroup中的最后1个task退出，并且子cgroup移除时，内核会在继承树根目录运行<code>release_agent</code>文件</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>cgroup对一组进程的资源进行控制，包括但不限于CPU、内存、网络、磁盘等资源，共12种资源，通过12个subsystem去进行限制、控制。</p><p>cgroup由内核使用文件系统实现，文件系统的层级结构实现了cgroup的层级结构，它默认挂载到 <code>/sys/fs/cgroup</code> 目录。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://kernel.googlesource.com/pub/scm/linux/kernel/git/glommer/memcg/+/cpu_stat/Documentation/cgroups" target="_blank" rel="noopener">Linux Kernel Cgroup的文档</a></li><li><a href="https://union-click.jd.com/jdc?e=&amp;p=AyIGZRtSFwsWB1EcXhUyFQ5WEloVCxMBURxrUV1KWQorAlBHU0VeBUVNR0ZbSkdETlcNVQtHRVNSUVNLXANBRA1XB14DS10cQQVYD21XHgBcGFIUAhsGUx9cJQEbBTJbEmFdcHkRSANGBhBDCnkmEVQeC2UaaxUDEwVWEl8RBhM3ZRtcJUN8B1QaUxMCFAFlGmsVBhoOUx9fFwESB1IfaxICGzeDtdnBl4nT2YZrJTIRN2UrWyUBIkU7HQxBABEGBhILHVdGAgcaXB0DQARWHQ4QVhFVVhkLEVciBVQaXxw%3D" target="_blank" rel="noopener">阿里同学的书《自己动手写Docker》</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是Cgroup&quot;&gt;&lt;a href=&quot;#什么是Cgroup&quot; class=&quot;headerlink&quot; title=&quot;什么是Cgroup&quot;&gt;&lt;/a&gt;什么是Cgroup&lt;/h2&gt;&lt;p&gt;Cgroup 是 Control Group 的缩写，提供对一组进程，及未来子进程的
      
    
    </summary>
    
    
    
      <category term="Kubernetes" scheme="http://lessisbetter.site/tags/Kubernetes/"/>
    
      <category term="Docker" scheme="http://lessisbetter.site/tags/Docker/"/>
    
      <category term="Cgroup" scheme="http://lessisbetter.site/tags/Cgroup/"/>
    
  </entry>
  
  <entry>
    <title>玩转minikube</title>
    <link href="http://lessisbetter.site/2020/08/27/play-minikube/"/>
    <id>http://lessisbetter.site/2020/08/27/play-minikube/</id>
    <published>2020-08-27T13:30:41.000Z</published>
    <updated>2020-10-24T14:06:17.602Z</updated>
    
    <content type="html"><![CDATA[<p>minikube很好，但某些原因造成国内用起来比较慢，要各种挂代理、Docker镜像加速。</p><h2 id="minikube原理"><a href="#minikube原理" class="headerlink" title="minikube原理"></a>minikube原理</h2><p><img src="http://img.lessisbetter.site/2020-08-minikube.jpeg" alt=""></p><p>kubectl和kube-apiserver是CS架构，kubectl是操作k8s集群的客户端，kube-apiserver是服务端。</p><p>minikube是创建了一个虚拟机<code>minikube vm</code>，然后在虚拟机里创建了1个单机的k8s集群，并把集群部署信息写到<code>~/.kube/config</code>文件，它是kubectl默认使用的配置文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[~]$ ls ~&#x2F;.kube&#x2F;config</span><br><span class="line">&#x2F;Users&#x2F;shitaibin&#x2F;.kube&#x2F;config</span><br><span class="line">[~]$ cat ~&#x2F;.kube&#x2F;config</span><br><span class="line">apiVersion: v1</span><br><span class="line">clusters:</span><br><span class="line">- cluster:</span><br><span class="line">    certificate-authority: &#x2F;Users&#x2F;shitaibin&#x2F;.minikube&#x2F;ca.crt</span><br><span class="line">    server: https:&#x2F;&#x2F;192.168.99.103:8443</span><br><span class="line">  name: minikube</span><br><span class="line">contexts:</span><br><span class="line">- context:</span><br><span class="line">    cluster: minikube</span><br><span class="line">    user: minikube</span><br><span class="line">  name: minikube</span><br><span class="line">current-context: minikube</span><br><span class="line">kind: Config</span><br><span class="line">preferences: &#123;&#125;</span><br><span class="line">users:</span><br><span class="line">- name: minikube</span><br><span class="line">  user:</span><br><span class="line">    client-certificate: &#x2F;Users&#x2F;shitaibin&#x2F;.minikube&#x2F;profiles&#x2F;minikube&#x2F;client.crt</span><br><span class="line">    client-key: &#x2F;Users&#x2F;shitaibin&#x2F;.minikube&#x2F;profiles&#x2F;minikube&#x2F;client.key</span><br></pre></td></tr></table></figure><p>文件内容也可以使用 <code>kubectl config view</code> 命令查看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[~]$ kubectl config view</span><br><span class="line">apiVersion: v1</span><br><span class="line">clusters:</span><br><span class="line">- cluster:</span><br><span class="line">    certificate-authority: &#x2F;Users&#x2F;shitaibin&#x2F;.minikube&#x2F;ca.crt</span><br><span class="line">    server: https:&#x2F;&#x2F;192.168.99.103:8443</span><br><span class="line">  name: minikube</span><br><span class="line">contexts:</span><br><span class="line">- context:</span><br><span class="line">    cluster: minikube</span><br><span class="line">    user: minikube</span><br><span class="line">  name: minikube</span><br><span class="line">current-context: minikube</span><br><span class="line">kind: Config</span><br><span class="line">preferences: &#123;&#125;</span><br><span class="line">users:</span><br><span class="line">- name: minikube</span><br><span class="line">  user:</span><br><span class="line">    client-certificate: &#x2F;Users&#x2F;shitaibin&#x2F;.minikube&#x2F;profiles&#x2F;minikube&#x2F;client.crt</span><br><span class="line">    client-key: &#x2F;Users&#x2F;shitaibin&#x2F;.minikube&#x2F;profiles&#x2F;minikube&#x2F;client.key</span><br><span class="line">[~]$</span><br></pre></td></tr></table></figure><h2 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h2><ol><li><p>安装minikube，1分钟，如果提供的命令行下载不下来，就浏览器下载下来，放到增加可执行，然后放到bin目录即可：<br><a href="https://yq.aliyun.com/articles/691500" target="_blank" rel="noopener">https://yq.aliyun.com/articles/691500</a></p></li><li><p>centos安装virtualbox，2分钟安装完成:<br><a href="https://wiki.centos.org/zh/HowTos/Virtualization/VirtualBox" target="_blank" rel="noopener">https://wiki.centos.org/zh/HowTos/Virtualization/VirtualBox</a></p></li><li><p>安装kubectl：<br><a href="https://blog.csdn.net/yuanjunlai141/article/details/79469071" target="_blank" rel="noopener">https://blog.csdn.net/yuanjunlai141/article/details/79469071</a></p></li></ol><h2 id="首次启动"><a href="#首次启动" class="headerlink" title="首次启动"></a>首次启动</h2><p>启动命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">minikube start --image-mirror-country cn \</span><br><span class="line">    --iso-url&#x3D;https:&#x2F;&#x2F;kubernetes.oss-cn-hangzhou.aliyuncs.com&#x2F;minikube&#x2F;iso&#x2F;minikube-v1.7.3.iso \</span><br><span class="line">    --registry-mirror&#x3D;&quot;https:&#x2F;&#x2F;a90tkz28.mirror.aliyuncs.com&quot; \</span><br><span class="line">    --image-repository&#x3D;&quot;registry.cn-hangzhou.aliyuncs.com&#x2F;google_containers&quot; \</span><br><span class="line">    --kubernetes-version&#x3D;v1.18.3</span><br></pre></td></tr></table></figure></p><p>使用minikube可以查看帮助flag帮助信息：</p><ul><li><code>--image-mirror-country</code>: 需要使用的镜像镜像的国家/地区代码。留空以使用全球代码。对于中国大陆用户，请将其设置为<br>cn</li><li><code>--registry-mirror</code>: 传递给 Docker 守护进程的注册表镜像。效果最好的镜像加速器：<code>--registry-mirror=&quot;https://a90tkz28.mirror.aliyuncs.com&quot;</code> 。使用加速器的原理是，docker deamon会先去加速器寻找镜像，如果找不到才从docker官方仓库拉镜像。如果指定拉某个镜像仓库的镜像，镜像加速器是用不上的。</li><li><code>--image-repository</code> : 如果不能从gcr.io拉镜像，配置minikube中docker拉镜像的地方</li><li><code>--kubernetes-version</code>： 指定要部署的k8s版本，可以省略</li></ul><p>minikube内拉不到镜像的报错:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl describe pod</span><br><span class="line">  Type     Reason     Age                    From               Message</span><br><span class="line">  ----     ------     ----                   ----               -------</span><br><span class="line">  Warning  Failed     2m59s (x4 over 4m36s)  kubelet, minikube  Failed to pull image &quot;kubeguide&#x2F;redis-master&quot;: rpc error: code &#x3D; Unknown desc &#x3D; Error response from daemon: Get https:&#x2F;&#x2F;registry-1.docker.io&#x2F;v2&#x2F;: proxyconnect tcp: dial tcp 192.168.0.104:1087: connect: connection refused</span><br></pre></td></tr></table></figure><p>启动日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ minikube start --image-mirror-country cn \</span><br><span class="line">    --iso-url&#x3D;https:&#x2F;&#x2F;kubernetes.oss-cn-hangzhou.aliyuncs.com&#x2F;minikube&#x2F;iso&#x2F;minikube-v1.7.3.iso \</span><br><span class="line">    --registry-mirror&#x3D;&quot;https:&#x2F;&#x2F;a90tkz28.mirror.aliyuncs.com&quot; \</span><br><span class="line">    --image-repository&#x3D;&quot;registry.cn-hangzhou.aliyuncs.com&#x2F;google_containers&quot;</span><br><span class="line">😄  Darwin 10.15.3 上的 minikube v1.12.3</span><br><span class="line">✨  根据用户配置使用 virtualbox 驱动程序</span><br><span class="line">✅  正在使用镜像存储库 registry.cn-hangzhou.aliyuncs.com&#x2F;google_containers</span><br><span class="line">👍  Starting control plane node minikube in cluster minikube</span><br><span class="line">🔥  Creating virtualbox VM (CPUs&#x3D;2, Memory&#x3D;4000MB, Disk&#x3D;20000MB) ...</span><br><span class="line">💡  Existing disk is missing new features (lz4). To upgrade, run &#39;minikube delete&#39;</span><br><span class="line">🐳  正在 Docker 19.03.6 中准备 Kubernetes v1.18.3…</span><br><span class="line">🔎  Verifying Kubernetes components...</span><br><span class="line">🌟  Enabled addons: default-storageclass, storage-provisioner</span><br><span class="line">🏄  完成！kubectl 已经配置至 &quot;minikube&quot;</span><br></pre></td></tr></table></figure><p>做哪些事？</p><ol><li>创建虚拟机”minikube”</li><li>生成kubectl使用的配置文件，使用该配置连接集群：~/.kube/config</li><li>在虚拟机里的容器上启动k8s</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">$ minikube ssh</span><br><span class="line">                         _             _</span><br><span class="line">            _         _ ( )           ( )</span><br><span class="line">  ___ ___  (_)  ___  (_)| |&#x2F;&#39;)  _   _ | |_      __</span><br><span class="line">&#x2F;&#39; _ &#96; _ &#96;\| |&#x2F;&#39; _ &#96;\| || , &lt;  ( ) ( )| &#39;_&#96;\  &#x2F;&#39;__&#96;\</span><br><span class="line">| ( ) ( ) || || ( ) || || |\&#96;\ | (_) || |_) )(  ___&#x2F;</span><br><span class="line">(_) (_) (_)(_)(_) (_)(_)(_) (_)&#96;\___&#x2F;&#39;(_,__&#x2F;&#39;&#96;\____)</span><br><span class="line"></span><br><span class="line">$</span><br><span class="line">$ docker info</span><br><span class="line">Client:</span><br><span class="line"> Debug Mode: false</span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line"> Containers: 18</span><br><span class="line">  Running: 15</span><br><span class="line">  Paused: 0</span><br><span class="line">  Stopped: 3</span><br><span class="line"> Images: 11</span><br><span class="line"> Server Version: 19.03.6</span><br><span class="line"> Storage Driver: overlay2</span><br><span class="line">  Backing Filesystem: extfs</span><br><span class="line">  Supports d_type: true</span><br><span class="line">  Native Overlay Diff: true</span><br><span class="line"> Logging Driver: json-file</span><br><span class="line"> Cgroup Driver: cgroupfs</span><br><span class="line"> Plugins:</span><br><span class="line">  Volume: local</span><br><span class="line">  Network: bridge host ipvlan macvlan null overlay</span><br><span class="line">  Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog</span><br><span class="line"> Swarm: inactive</span><br><span class="line"> Runtimes: runc</span><br><span class="line"> Default Runtime: runc</span><br><span class="line"> Init Binary: docker-init</span><br><span class="line"> containerd version: 35bd7a5f69c13e1563af8a93431411cd9ecf5021</span><br><span class="line"> runc version: dc9208a3303feef5b3839f4323d9beb36df0a9dd</span><br><span class="line"> init version: fec3683</span><br><span class="line"> Security Options:</span><br><span class="line">  seccomp</span><br><span class="line">   Profile: default</span><br><span class="line"> Kernel Version: 4.19.94</span><br><span class="line"> Operating System: Buildroot 2019.02.9</span><br><span class="line"> OSType: linux</span><br><span class="line"> Architecture: x86_64</span><br><span class="line"> CPUs: 2</span><br><span class="line"> Total Memory: 3.754GiB</span><br><span class="line"> Name: minikube</span><br><span class="line"> ID: 6GOT:L6SH:NPBW:ZM44:PVKY:LSEZ:MXW7:LWOB:GB4N:CNXU:S6NJ:KASG</span><br><span class="line"> Docker Root Dir: &#x2F;var&#x2F;lib&#x2F;docker</span><br><span class="line"> Debug Mode: false</span><br><span class="line"> Registry: https:&#x2F;&#x2F;index.docker.io&#x2F;v1&#x2F;</span><br><span class="line"> Labels:</span><br><span class="line">  provider&#x3D;virtualbox</span><br><span class="line"> Experimental: false</span><br><span class="line"> Insecure Registries:</span><br><span class="line">  10.96.0.0&#x2F;12</span><br><span class="line">  127.0.0.0&#x2F;8</span><br><span class="line"> Registry Mirrors:</span><br><span class="line">  https:&#x2F;&#x2F;a90tkz28.mirror.aliyuncs.com&#x2F;</span><br><span class="line"> Live Restore Enabled: false</span><br><span class="line"> Product License: Community Engine</span><br><span class="line"></span><br><span class="line">$ exit</span><br><span class="line">logout</span><br></pre></td></tr></table></figure><p>Registry Mirrors对应的是阿里云镜像加速，HTTP proxy也配置上了，如果启动后，发现没有改变，需要删除过去创建的minikube，全部清理一遍。</p><h2 id="minikube常用命令"><a href="#minikube常用命令" class="headerlink" title="minikube常用命令"></a>minikube常用命令</h2><ul><li>集群状态： minikube status</li><li>暂停和恢复集群，不用的时候把它暂停掉，节约主机的CPU和内存： minikube pause， minikube unpause</li><li>停止集群： minikube stop</li><li>删除集群，遇到问题时，清理一波数据： minikube delete</li><li>查看集群IP，kubectl就是连这个IP： minikube ip</li><li>进入minikube虚拟机，整个k8s集群跑在这里面： minikube ssh</li></ul><h2 id="kubectl自动补全"><a href="#kubectl自动补全" class="headerlink" title="kubectl自动补全"></a>kubectl自动补全</h2><p>zsh在配置文件 <code>~/.zshrc</code> 中增加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source &lt;(kubectl completion zsh)  # 在 zsh 中设置当前 shell 的自动补全</span><br><span class="line">echo &quot;if [ $commands[kubectl] ]; then source &lt;(kubectl completion zsh); fi&quot; &gt;&gt; ~&#x2F;.zshrc # 在您的 zsh shell 中永久的添加自动补全</span><br></pre></td></tr></table></figure><p>bash 在 <code>~/.bashrc</code> 中增加:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source &lt;(kubectl completion bash) # 在 bash 中设置当前 shell 的自动补全，要先安装 bash-completion 包。</span><br><span class="line">echo &quot;source &lt;(kubectl completion bash)&quot; &gt;&gt; ~&#x2F;.bashrc # 在您的 bash shell 中永久的添加自动补全</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;minikube很好，但某些原因造成国内用起来比较慢，要各种挂代理、Docker镜像加速。&lt;/p&gt;
&lt;h2 id=&quot;minikube原理&quot;&gt;&lt;a href=&quot;#minikube原理&quot; class=&quot;headerlink&quot; title=&quot;minikube原理&quot;&gt;&lt;/a&gt;min
      
    
    </summary>
    
    
    
      <category term="Kubernetes" scheme="http://lessisbetter.site/tags/Kubernetes/"/>
    
      <category term="Docker" scheme="http://lessisbetter.site/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>VSCode利用SFTP上传代码到服务器</title>
    <link href="http://lessisbetter.site/2020/08/27/sync-code-to-server-with-sftp-in-vscode/"/>
    <id>http://lessisbetter.site/2020/08/27/sync-code-to-server-with-sftp-in-vscode/</id>
    <published>2020-08-27T12:24:00.000Z</published>
    <updated>2020-08-27T12:37:00.984Z</updated>
    
    <content type="html"><![CDATA[<p>VSCode已经支持远程开发，可以把代码自动从本地和服务器进行同步。</p><p>为了某些实验搞了一条Ubuntu 14.04的服务器，结果VSCode说远程服务器不支持，就只能另谋它路了，利用SFTP实现本地和服务器端的代码同步。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>VSCode应用市场安装SFTP插件</li><li>在项目目录下建立SFTP的配置文件：<code>.vscode/sftp.json</code>，内容如下</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"root"</span>,</span><br><span class="line">    <span class="attr">"host"</span>: <span class="string">"192.168.9.xxx"</span>,</span><br><span class="line">    <span class="attr">"protocol"</span>: <span class="string">"sftp"</span>,</span><br><span class="line">    <span class="attr">"port"</span>: <span class="number">22</span>,</span><br><span class="line">    <span class="attr">"username"</span>: <span class="string">"centos"</span>,</span><br><span class="line">    <span class="attr">"privateKeyPath"</span>: <span class="string">"/Users/shitaibin/.ssh/id_xxx"</span>,</span><br><span class="line">    <span class="attr">"remotePath"</span>: <span class="string">"/home/centos/workspace/docker/notes"</span>,</span><br><span class="line">    <span class="attr">"uploadOnSave"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"ignore"</span>: [<span class="string">".vscode"</span>, <span class="string">".git"</span>, <span class="string">".DS_Store"</span>, <span class="string">"node_modules"</span>, <span class="string">"vendor"</span>],</span><br><span class="line">    <span class="attr">"localPath"</span>:<span class="string">"."</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>登录服务器可以使用密码或者私钥，上面文件的示例使用私钥，如果使用密码，增加一项<code>password</code>即可。</p><p><code>uploadOnSave</code>配置项设置为true，能够确保文件保存时，自动上传到服务器，无需手动上传。</p><ol start="3"><li><p>初次上传到服务器</p><p> a. Ctrl + Shift + P，输入<code>SFTP</code>，选择<code>Sync Local -&gt; Remote</code>即可<br> b. VSCode底部状态栏，会显示SFTP，如果在动态变化，说明在上传文件</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;VSCode已经支持远程开发，可以把代码自动从本地和服务器进行同步。&lt;/p&gt;
&lt;p&gt;为了某些实验搞了一条Ubuntu 14.04的服务器，结果VSCode说远程服务器不支持，就只能另谋它路了，利用SFTP实现本地和服务器端的代码同步。&lt;/p&gt;
&lt;h2 id=&quot;步骤&quot;&gt;&lt;a 
      
    
    </summary>
    
    
    
      <category term="VSCode" scheme="http://lessisbetter.site/tags/VSCode/"/>
    
      <category term="SFTP" scheme="http://lessisbetter.site/tags/SFTP/"/>
    
  </entry>
  
  <entry>
    <title>Go语言日期和时间戳转换</title>
    <link href="http://lessisbetter.site/2020/07/29/go-time-date-timestamp/"/>
    <id>http://lessisbetter.site/2020/07/29/go-time-date-timestamp/</id>
    <published>2020-07-29T11:48:59.000Z</published>
    <updated>2020-07-29T11:49:32.733Z</updated>
    
    <content type="html"><![CDATA[<p>字符串格式日期、time.Time类型、整形时间戳三者之间的转换如下图：</p><p><img src="http://img.lessisbetter.site/2020-07-go-time-date-transform.png" alt=""></p><p>有2点要注意：</p><ol><li>字符串日期和时间戳之间不能直接转换，需要通过time.Time完成。</li><li>涉及字符串日期的时候，字符串日期格式一定要以Go诞生的时间为基准，而不是随意的时间，否则会导致时间转换不正确。所以，以下Demo中的日期格式是通用的。</li><li>字符串日期格式要与真实的日期格式完全匹配，否则会解析时间不正确。比如设置的格式为<code>2006-01-02</code>，实际日期格式为<code>2006-1-2</code>时会解析错误。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Date2Time</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"&gt;&gt; Date2Time"</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"&lt;&lt; Date2Time"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一定要以Go诞生的时间为基准</span></span><br><span class="line"><span class="comment">// 2006年1月2号，MST时区，下午3:04分为基准</span></span><br><span class="line"><span class="keyword">const</span> dateFormat = <span class="string">"Jan 2, 2006 at 3:04pm (MST)"</span></span><br><span class="line">t, _ := time.Parse(dateFormat, <span class="string">"May 20, 2020 at 0:00am (UTC)"</span>)</span><br><span class="line">fmt.Println(t)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> shortForm = <span class="string">"2006-Jan-02"</span></span><br><span class="line">t, _ = time.Parse(shortForm, <span class="string">"2020-May-20"</span>)</span><br><span class="line">fmt.Println(t)</span><br><span class="line"></span><br><span class="line">t, _ = time.Parse(<span class="string">"01/02/2006"</span>, <span class="string">"05/20/2020"</span>)</span><br><span class="line">fmt.Println(t)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Time2Date</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"&gt;&gt; Time2Date"</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"&lt;&lt; Time2Date"</span>)</span><br><span class="line"></span><br><span class="line">tm := time.Now()</span><br><span class="line">fmt.Println(tm.Format(<span class="string">"2006-01-02 03:04:05 PM"</span>))</span><br><span class="line">fmt.Println(tm.Format(<span class="string">"2006-1-2 03:04:05 PM"</span>))</span><br><span class="line">fmt.Println(tm.Format(<span class="string">"2006-Jan-02 03:04:05 PM"</span>))</span><br><span class="line">fmt.Println(tm.Format(<span class="string">"02/01/2006 03:04:05 PM"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Timestamp2Time</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"&gt;&gt; Timestamp2Time"</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"&lt;&lt; Timestamp2Time"</span>)</span><br><span class="line"></span><br><span class="line">ts := <span class="keyword">int64</span>(<span class="number">1595900001</span>)</span><br><span class="line">tm := time.Unix(ts, <span class="number">0</span>)</span><br><span class="line">fmt.Println(tm)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Time2Timestamp</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"&gt;&gt; Time2Timestamp"</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"&lt;&lt; Time2Timestamp"</span>)</span><br><span class="line"></span><br><span class="line">tm := time.Now()</span><br><span class="line">ts := tm.Unix()</span><br><span class="line">fmt.Println(ts)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">Date2Time()</span><br><span class="line">Time2Date()</span><br><span class="line">Timestamp2Time()</span><br><span class="line">Time2Timestamp()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; Date2Time</span><br><span class="line">2020-05-20 00:00:00 +0000 UTC</span><br><span class="line">2020-05-20 00:00:00 +0000 UTC</span><br><span class="line">2020-05-20 00:00:00 +0000 UTC</span><br><span class="line">&lt;&lt; Date2Time</span><br><span class="line">&gt;&gt; Time2Date</span><br><span class="line">2020-07-28 09:35:46 AM</span><br><span class="line">2020-7-28 09:35:46 AM</span><br><span class="line">2020-Jul-28 09:35:46 AM</span><br><span class="line">28&#x2F;07&#x2F;2020 09:35:46 AM</span><br><span class="line">&lt;&lt; Time2Date</span><br><span class="line">&gt;&gt; Timestamp2Time</span><br><span class="line">2020-07-28 09:33:21 +0800 CST</span><br><span class="line">&lt;&lt; Timestamp2Time</span><br><span class="line">&gt;&gt; Time2Timestamp</span><br><span class="line">1595900146</span><br><span class="line">&lt;&lt; Time2Timestamp</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;字符串格式日期、time.Time类型、整形时间戳三者之间的转换如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.lessisbetter.site/2020-07-go-time-date-transform.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;有2点
      
    
    </summary>
    
    
    
      <category term="Go" scheme="http://lessisbetter.site/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>SSH常用命令和配置</title>
    <link href="http://lessisbetter.site/2020/07/28/about-ssh/"/>
    <id>http://lessisbetter.site/2020/07/28/about-ssh/</id>
    <published>2020-07-28T13:11:15.000Z</published>
    <updated>2020-07-28T13:12:11.547Z</updated>
    
    <content type="html"><![CDATA[<h2 id="生成SSH密钥"><a href="#生成SSH密钥" class="headerlink" title="生成SSH密钥"></a>生成SSH密钥</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -f ~/.ssh/id_rsa -C <span class="string">"temp user"</span> -N <span class="string">""</span></span><br></pre></td></tr></table></figure><p>-t：指定加密算法<br>-f：指定路径<br>-C：注释，可以填写用户名或邮箱<br>-N：密码</p><p>指定以上<code>f、C、N</code>这3个参数，可以避免交互式问答，快速生成密钥，在脚本中使用很方便。</p><h2 id="SSH客户端配置文件"><a href="#SSH客户端配置文件" class="headerlink" title="SSH客户端配置文件"></a>SSH客户端配置文件</h2><p><code>~/.ssh/config</code>文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Read more about SSH config files: https:&#x2F;&#x2F;linux.die.net&#x2F;man&#x2F;5&#x2F;ssh_config</span><br><span class="line">Host 个人VM</span><br><span class="line">    HostName 192.168.9.137</span><br><span class="line">    User centos</span><br><span class="line"></span><br><span class="line">Host 阿里云</span><br><span class="line">    HostName 139.224.105.10</span><br><span class="line">    User root</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">Host 腾讯云</span><br><span class="line">    HostName 140.143.6.185</span><br><span class="line">    User root</span><br><span class="line">    Port 22</span><br><span class="line">    IdentityFile ~&#x2F;.ssh&#x2F;id_rsa_tencent</span><br></pre></td></tr></table></figure><ul><li>Host：自定义命名</li><li>HostName：机器IP或者域名</li><li>User：登录机器的用户名</li><li>Port：登录机器的端口，默认为22，可省略</li><li>IdentityFile：登录机器时使用的私钥，默认为<code>~/.ssh/id_rsa</code>，可省略；当某台机器使用单独密钥时，很有用</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;生成SSH密钥&quot;&gt;&lt;a href=&quot;#生成SSH密钥&quot; class=&quot;headerlink&quot; title=&quot;生成SSH密钥&quot;&gt;&lt;/a&gt;生成SSH密钥&lt;/h2&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gu
      
    
    </summary>
    
    
    
      <category term="Linux" scheme="http://lessisbetter.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>如何选择开源协议</title>
    <link href="http://lessisbetter.site/2020/05/05/open-source-license/"/>
    <id>http://lessisbetter.site/2020/05/05/open-source-license/</id>
    <published>2020-05-05T06:37:26.000Z</published>
    <updated>2020-05-05T06:58:26.497Z</updated>
    
    <content type="html"><![CDATA[<p>当基于开源项目发布新的开源项目时，我们需要说明项目所使用的License，同样也需要考虑你基于开源项目所做的事情，是否满足该项目的License。</p><p>下面这2幅图摘自 <a href="https://www.zhihu.com/question/28292322" target="_blank" rel="noopener">开源许可证都有什么区别,一般开源项目用什么许可证? - 知乎</a>，足以帮助我们判断：</p><ol><li>要做的事情，是否满足开源项目的License。</li><li>开源一个项目，该如何选择License。</li></ol><p><img src="http://img.lessisbetter.site/2020-05-license-choose.jpg" alt=""><br>来源：<a href="https://www.zhihu.com/question/28292322/answer/656121132" target="_blank" rel="noopener">https://www.zhihu.com/question/28292322/answer/656121132</a></p><p><img src="http://img.lessisbetter.site/2020-05-license-2.jpg" alt=""><br>来源：<a href="https://www.zhihu.com/question/28292322/answer/840556759" target="_blank" rel="noopener">https://www.zhihu.com/question/28292322/answer/840556759</a><br>从左到右，是从宽松到严格。</p><p>举例：</p><ol><li>以太坊采License用的是LGPLv3，修改源码后如果提供给外部使用必须开源，不要求新增代码采用相同的License，也不要求对新增代码进行文档说明，后来我们项目同样采用了LGPLv3。</li><li>Fabric采用Apache 2.0，基于Fabric项目原有代码都必须放置Fabric原有版权声明，但可以选择不开源。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当基于开源项目发布新的开源项目时，我们需要说明项目所使用的License，同样也需要考虑你基于开源项目所做的事情，是否满足该项目的License。&lt;/p&gt;
&lt;p&gt;下面这2幅图摘自 &lt;a href=&quot;https://www.zhihu.com/question/2829232
      
    
    </summary>
    
    
    
      <category term="开源" scheme="http://lessisbetter.site/tags/%E5%BC%80%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>Fabric 1.4源码解读 10：可扩展密码服务提供者BCCSP，以及可扩展国密</title>
    <link href="http://lessisbetter.site/2020/04/12/fabric-bccsp/"/>
    <id>http://lessisbetter.site/2020/04/12/fabric-bccsp/</id>
    <published>2020-04-12T06:32:33.000Z</published>
    <updated>2020-04-12T08:14:56.193Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>密码学是当代数字信息化时代的基础技术，没有密码学，网络上的传输信息的可靠性就无法保证，比如你输入的密码会被窃取，你存在网络上的照片、文档如果没有加密，就有可能泄露。</p><p>密码学也是区块链的一项基础技术，使用密码学实现区块链中的：身份验证、数据可信、权限管理、零知识证明、可信计算等等。</p><p>Fabric提供了模块化的、可插拔的密码服务，该服务由<code>bccsp</code>模块提供，本文就谈一下BCCSP插件化设计，另外Fabric国密化也是最近2年必做的事情，所以同时介绍实现可扩展国密的思路，最后介绍一下Hyperledger社区对Fabric支持国密的开发。</p><h2 id="BCCSP介绍"><a href="#BCCSP介绍" class="headerlink" title="BCCSP介绍"></a>BCCSP介绍</h2><p>BCCSP是Block Chain Crypto Service Provider的缩写。</p><p><code>bccsp</code>模块它为Fabric的上层模块提供密码学服务，它包含的具体功能有：对称加密和非对称加密的密钥生成、导如、导出，数字签名和验证，对称加密和解密、摘要计算。</p><p><code>bccsp</code>模块为了密码服务的扩展性，定义了<code>BCCSP</code>接口，上层模块调用<code>BCCSP</code>接口中定义的方法，而不直接调用具体的实现函数，实现和具体密码学实现的解耦，当<code>bccsp</code>使用不同密码学实现时，上层模块无需修改，这种解耦是通过<strong>依赖反转</strong>实现的。</p><p>bccsp模块中当前有2种密码实现，它们都是bccsp中的密码学插件：SW和PKCS11，SW代表的是国际标准加密的软实现，SW是software的缩写，PKCS11代指硬实现。</p><p><img src="http://img.lessisbetter.site/2020-04-fabric-bccsp.png" alt=""></p><blockquote><p>扩展阅读：PKCS11是PKCS系列标准中的第11个，它定义了应用层和底层加密设备的交互标准，比如过去在电脑上，插入USBKey用网银转账时，就需要走USBKey中的硬件进行数字签名，这个过程就需要使用PCKS11。</p></blockquote><p>密码学通常有软实现和硬实现，软实现就是常用的各种加密库，比如Go中<code>crypto</code>包，硬实现是使用加密机提供的一套加密服务。软实现和硬实现的重要区别是，密码算法的安全性强依赖随机数，软实现利用的是OS的伪随机数，而硬实现利用的是加密机生成的随机数，所以硬实现的安全强度要高于软实现。</p><p>让Fabric支持国密时，就需要在bccsp中新增一个国密插件<code>GM</code>，只在bccsp中增加GM并不是完成的Fabric国密改造，下文再详细介绍。</p><h2 id="SW介绍"><a href="#SW介绍" class="headerlink" title="SW介绍"></a>SW介绍</h2><p>SW是国际标准加密的软实现插件，它包含了ECDSA算法、RSA算法、AES算法，以及SHA系列的摘要算法。</p><p><code>BCCSP</code>接口定义了以下方法，其实对密码学中的函数进行了一个功能分类：</p><ul><li><code>KeyGen</code>：密钥生成，包含对称和非对称加密</li><li><code>KeyDeriv</code>：密钥派生</li><li><code>KeyImport</code>：密钥导入，从文件、内存、数字证书中导入</li><li><code>GetKey</code>：获取密钥</li><li><code>Hash</code>：计算摘要</li><li><code>GetHash</code>：获取摘要计算实例</li><li><code>Sign</code>：数字签名</li><li><code>Verify</code>：签名验证</li><li><code>Encrypt</code>：数据加密，包含对称和非对称加密</li><li><code>Decrypt</code>：数据解密，包含对称和非对称加密</li></ul><p>SW要做的是，把ECDSA、RSA、AES、SHA中的各种函数，对应到以上各种分类中，主要的分类如下图所示。</p><p><img src="http://img.lessisbetter.site/2020-04-12-bccsp-sw.png" alt=""></p><p>从上图可以看出，密钥生成、派生、导入都包含了ECDSA、RSA、AES，签名和延签包含了ECDSA和RSA，摘要计算包含了SHA系列，加密解密包含了AES，但没有包含RSA，是因为非对称加密耗时，并不常用。</p><h2 id="可插拔国密"><a href="#可插拔国密" class="headerlink" title="可插拔国密"></a>可插拔国密</h2><p>Fabric支持国密并非仅仅在bccsp中增加1个国密实现这么简单，还需要让数字证书支持国密，让数字证书的操作符合X.509。各语言的标准库<code>x509</code>都是适配标准加密的，并不能直接用来操作国密证书。</p><p>在数字证书支持国密后，还可能需要进一步考虑，是否需要TLS证书使用国密数字证书，让通信过程使用国密算法。</p><p>另外，国密的实现有很多版本，如果需要适配不同的国密实现，就需要保证国密的可插拔和可扩展。</p><p>综上情况，你需要一个中间件，中间件中包含定义好国密接口、国密数字证书接口等，用这些接口去适配Fabric，然后当采用不同国密实现时，只需要对具体实现进行封装，去适配中间件中定义好的接口。</p><p><img src="http://img.lessisbetter.site/2020-04-fabric-gm.png" alt=""></p><h2 id="社区对Fabric支持国密的态度"><a href="#社区对Fabric支持国密的态度" class="headerlink" title="社区对Fabric支持国密的态度"></a>社区对Fabric支持国密的态度</h2><p>国密有很多基于Fabric的项目，金融业是区块链场景最多的行业，金融行业又必须使用国密，所以国内对Fabric国密的改造是必须的，在《金融分布式账本安全规范》发布之后，社区也计划让Fabric支持国密，但方式是不提供具体国密实现，而是定义好接口，项目方使用哪种国密实现，去适配定义好的接口即可，这样保留了好的扩展性，与<a href="#可插拔国密">可插拔国密</a>的目的是一致的，选择权交给企业。</p><p>社区支持Fabric国密的版本，预计在2.x版本发布。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>密码学在区块链中的地位是相当高的，从区块链使用最基础的密码学，到现在还在不断融入同态加密、零知识证明等前言的加密技术，未来可以在区块链上保护数据隐私的情况，提供更好的服务，区块链也可以有更多的应用场景。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h2&gt;&lt;p&gt;密码学是当代数字信息化时代的基础技术，没有密码学，网络上的传输信息的可靠性就无法保证，比如你输入的密码会被窃取，你存在网络上的照片、文档如果
      
    
    </summary>
    
    
    
      <category term="区块链" scheme="http://lessisbetter.site/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Fabric" scheme="http://lessisbetter.site/tags/Fabric/"/>
    
      <category term="密码学" scheme="http://lessisbetter.site/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>提高画时序图的效率</title>
    <link href="http://lessisbetter.site/2020/03/23/markdown-mermaid/"/>
    <id>http://lessisbetter.site/2020/03/23/markdown-mermaid/</id>
    <published>2020-03-23T07:28:40.000Z</published>
    <updated>2020-03-23T07:30:04.354Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mermaid-js.github.io/mermaid/#/README" target="_blank" rel="noopener">mermaid</a>是一个开源项目，可以在Markdown中，使用类似编写代码的方式，制作流程图、时序图、甘特图、饼图等。使用下来，感觉可以明显提升时序图的效率。</p><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    %% 注释</span><br><span class="line">    Client -&gt;&gt; Gateway: 发送JSON RPC请求</span><br><span class="line">    Gateway -&gt;&gt; Gateway: JSON RPC请求转换为gRPC请求</span><br><span class="line">    Gateway -&gt;&gt; Server: 发送gRPC请求</span><br><span class="line">    Server -&gt;&gt; Server: 处理gRPC请求</span><br><span class="line">    Server -&gt;&gt; Gateway: 发送gRPC响应</span><br><span class="line">    Gateway -&gt;&gt; Gateway: gRPC响应转换为JSON RPC响应</span><br><span class="line">    Gateway -&gt;&gt; Client: 把JSON RPC响应发送给客户端</span><br></pre></td></tr></table></figure><pre class="mermaid">sequenceDiagram    %% 注释    Client ->> Gateway: 发送JSON RPC请求    Gateway ->> Gateway: JSON RPC请求转换为gRPC请求    Gateway ->> Server: 发送gRPC请求    Server ->> Server: 处理gRPC请求    Server ->> Gateway: 发送gRPC响应    Gateway ->> Gateway: gRPC响应转换为JSON RPC响应    Gateway ->> Client: 把JSON RPC响应发送给客户端</pre><h4 id="昵称"><a href="#昵称" class="headerlink" title="昵称"></a>昵称</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant C as Client</span><br><span class="line">    participant G as Gateway</span><br><span class="line">    participant S as Server</span><br><span class="line"></span><br><span class="line">    C -&gt;&gt; G: 发送JSON RPC请求</span><br><span class="line">    G -&gt;&gt; G: JSON RPC请求转换为gRPC请求</span><br><span class="line">    G -&gt;&gt; S: 发送gRPC请求</span><br><span class="line">    S -&gt;&gt; S: 处理gRPC请求</span><br><span class="line">    S -&gt;&gt; G: 发送gRPC响应</span><br><span class="line">    G -&gt;&gt; G: gRPC响应转换为JSON RPC响应</span><br><span class="line">    G -&gt;&gt; C: 把JSON RPC响应发送给客户端</span><br></pre></td></tr></table></figure><pre class="mermaid">sequenceDiagram    participant C as Client    participant G as Gateway    participant S as Server    C ->> G: 发送JSON RPC请求    G ->> G: JSON RPC请求转换为gRPC请求    G ->> S: 发送gRPC请求    S ->> S: 处理gRPC请求    S ->> G: 发送gRPC响应    G ->> G: gRPC响应转换为JSON RPC响应    G ->> C: 把JSON RPC响应发送给客户端</pre><h4 id="线条和箭头"><a href="#线条和箭头" class="headerlink" title="线条和箭头"></a>线条和箭头</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    Client -&gt; Gateway: 实线</span><br><span class="line">    Client --&gt; Gateway: 虚线 --</span><br><span class="line">    Client -&gt;&gt; Gateway: 带箭头 &gt;&gt;</span><br><span class="line">    Client -x Gateway: 带叉，不使用&gt;</span><br></pre></td></tr></table></figure><pre class="mermaid">sequenceDiagram    Client -> Gateway: 实线    Client --> Gateway: 虚线 --    Client ->> Gateway: 带箭头 >>    Client -x Gateway: 带叉，不使用></pre><h4 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    Note left of Client: 创建请求</span><br><span class="line">    Note right of Gateway: 接收请求</span><br></pre></td></tr></table></figure><pre class="mermaid">sequenceDiagram    Note left of Client: 创建请求    Note right of Gateway: 接收请求</pre><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    loop Every Second</span><br><span class="line">        Client -&gt;&gt; Server: 发送请求</span><br><span class="line">        Server -&gt;&gt; Server: 处理请求</span><br><span class="line">        Server -&gt;&gt; Client: 发送响应</span><br><span class="line">    end</span><br></pre></td></tr></table></figure><pre class="mermaid">sequenceDiagram    loop Every Second        Client ->> Server: 发送请求        Server ->> Server: 处理请求        Server ->> Client: 发送响应    end</pre><h4 id="If语句"><a href="#If语句" class="headerlink" title="If语句"></a>If语句</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    Client -&gt;&gt; Server: 查询用户</span><br><span class="line">    alt User not found</span><br><span class="line">        Server -&gt;&gt; Server: 创建错误响应：用户不存在</span><br><span class="line">    else </span><br><span class="line">        Server -&gt;&gt; Server: 使用用户信息创建响应</span><br><span class="line">    end</span><br><span class="line">    Server -&gt;&gt; Client: 发送响应</span><br></pre></td></tr></table></figure><pre class="mermaid">sequenceDiagram    Client ->> Server: 查询用户    alt User not found        Server ->> Server: 创建错误响应：用户不存在    else         Server ->> Server: 使用用户信息创建响应    end    Server ->> Client: 发送响应</pre><h4 id="背景颜色"><a href="#背景颜色" class="headerlink" title="背景颜色"></a>背景颜色</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    Client -&gt;&gt; Server: 发送请求</span><br><span class="line">    rect rgb(191,223,255)</span><br><span class="line">    Server -&gt;&gt; Server: 处理请求</span><br><span class="line">    Server -&gt;&gt; Client: 发送响应</span><br><span class="line">    end</span><br></pre></td></tr></table></figure><pre class="mermaid">sequenceDiagram    Client ->> Server: 发送请求    rect rgb(191,223,255)    Server ->> Server: 处理请求    Server ->> Client: 发送响应    end</pre><h4 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    Client -&gt;&gt; Server: 发送请求</span><br><span class="line">    activate Server</span><br><span class="line">    Server -&gt;&gt; Server: 处理请求</span><br><span class="line">    Server -&gt;&gt; Client: 发送响应</span><br><span class="line">    deactivate Server</span><br></pre></td></tr></table></figure><pre class="mermaid">sequenceDiagram    Client ->> Server: 发送请求    activate Server    Server ->> Server: 处理请求    Server ->> Client: 发送响应    deactivate Server</pre><h3 id="饼图"><a href="#饼图" class="headerlink" title="饼图"></a>饼图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pie</span><br><span class="line">    title 硬币正反面的概率</span><br><span class="line">    &quot;正面&quot;: 0.5</span><br><span class="line">    &quot;反面&quot;: 0.5</span><br></pre></td></tr></table></figure><pre class="mermaid">pie    title 硬币正反面的概率    "正面": 0.5    "反面": 0.5</pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://mermaid-js.github.io/mermaid/#/README&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;mermaid&lt;/a&gt;是一个开源项目，可以在Markdown中，使用类似编写代码的方式，制作流程图、
      
    
    </summary>
    
    
    
      <category term="写作" scheme="http://lessisbetter.site/tags/%E5%86%99%E4%BD%9C/"/>
    
      <category term="工具" scheme="http://lessisbetter.site/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Markdown" scheme="http://lessisbetter.site/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>为什么PBFT需要View Changes</title>
    <link href="http://lessisbetter.site/2020/03/22/why-pbft-needs-viewchange/"/>
    <id>http://lessisbetter.site/2020/03/22/why-pbft-needs-viewchange/</id>
    <published>2020-03-22T06:10:53.000Z</published>
    <updated>2020-04-11T09:33:20.052Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在当前的PBFT资料中，尤其是中文资料，多数都在介绍PBFT的3阶段消息过程，很少提及View Changes（视图切换），View Changes对PBFT的重要性，如同Leader Election对Raft的重要性，它是一个一致性算法中，不可或缺的部分。</p><p>作者为大家介绍下，为什么View Changes如此重要，即为什么PBFT需要View Changes，以及View Changes的原理。</p><h2 id="为什么PBFT需要View-Changes"><a href="#为什么PBFT需要View-Changes" class="headerlink" title="为什么PBFT需要View Changes"></a>为什么PBFT需要View Changes</h2><p>一致性算法都要提供：</p><ul><li>safety ：原意指不会出现错误情况，一致性中指操作是正确的，得到相同的结果。</li><li>liveness ：操作过程能在有限时间内完成。</li></ul><p><img src="http://img.lessisbetter.site/2020-03-consistency-property.png" alt="一致性协议需要满足的特性"></p><p><strong>safety通常称为一致性，liveness通常称为可用性</strong>，没有liveness的一致性算法无法长期提供一致性服务，没有safety的一致性算法称不上一致性算法，所以，所有的一致性算法都在做二者之间的折中。</p><p>所以对一致性和可用性不同的要求，就出现了你常听见的ACID原理、CAP理论、BASE理论。</p><p>PBFT作为一个一致性算法，它也需要提供一致性和可用性。在<a href="https://lessisbetter.site/2020/03/15/why-pbft-needs-3-phase-message/">为什么PBFT需要3个阶段消息</a>中，介绍了PBFT算法的如何达成一致性，并且请求可以在有限时间内达成一致，客户端得到响应，也满足可用性。</p><p>但没有介绍，当遇到以下情况时，是否还能保住一致性和可用性呢？</p><ol><li>主节点是拜占庭节点（宕机、拒绝响应…）</li><li>主节点不是拜占庭节点，但非拜占庭副本节点参与度不足，不足以完成3阶段消息</li><li>网络不畅，丢包严重，造成不足以完成3阶段消息</li><li>…</li></ol><p>在以上场景中，<strong>新的请求无法在有限时间内达成一致，老的数据可以保持一致性，所以一致性是可以满足的，但可用性无法满足</strong>。必须寻找一个方案，恢复集群的可用性。</p><p><strong>PBFT算法使用View Changes，让集群重新具有可用性</strong>。通过View Changes，可以选举出新的、让请求在有限时间内达成一致的主节点，向客户端响应，从而满足可用性的要求。</p><p>让集群重新恢复可用，需要做到什么呢？<strong>让至少f+1个非拜占庭节点迁移到，新的一致的状态</strong>。然后这些节点，运行3阶段消息协议，处理新的客户端请求，并达成一致。</p><h2 id="不同版本的View-Changes协议有什么不同？"><a href="#不同版本的View-Changes协议有什么不同？" class="headerlink" title="不同版本的View Changes协议有什么不同？"></a>不同版本的View Changes协议有什么不同？</h2><p>PBFT算法有1999年和2001年2个版本：</p><ul><li>99年：<a href="http://pmg.csail.mit.edu/papers/osdi99.pdf" target="_blank" rel="noopener">Practical Byzantine Fault Tolerance</a>，PBFT初次发表。</li><li>01年：<a href="http://www.pmg.csail.mit.edu/papers/bft-tocs.pdf" target="_blank" rel="noopener">Practical Byzantine Fault Tolerance and Proactive Recovery</a>，又称PBFT-PR，让PBFT受攻击时，具有主动恢复能力。</li></ul><p>PBFT-PR并非只是在PBFT上增加了PR，同时也对PBFT算法做了详细的介绍和改进，View Changes的改进就是其中一项。</p><p>PBFT中View Changes介绍比较简单，没有说明以下场景下，View Changes协议如何处理：</p><ul><li>如果下一个View的主节点宕机了怎么办</li><li>如果下一个View的主节点是恶意节点，作恶怎么办</li><li>如果非拜占庭恶意发起View Changes，造成主节点切换怎么办？</li><li>如果参与View Changes的节点数量不足怎么办</li></ul><p>如果，以上场景下，节点处在View Changes阶段，持续的等待下去，就无法恢复集群的可用性。</p><p>PBFT-PR中的View Changes协议进行了细化，可以解决以上问题。</p><h2 id="2001年版本View-Changes协议原理"><a href="#2001年版本View-Changes协议原理" class="headerlink" title="2001年版本View Changes协议原理"></a>2001年版本View Changes协议原理</h2><p>每个主节点都拥有一个View，就如同Raft中每个leader都拥有1个term。不同点是term所属的leader是选举出来的，而View所属的主节点是计算出的： <code>primary = v % R</code>，R是运行PBFT协议的节点数量。</p><p>View Changes的战略是：当副本节点怀疑主节点无法让请求达成一致时，发起视图切换，新的主节点收集当前视图中已经Prepared，但未Committed的请求，传递到下一个视图中，所有非拜占庭节点基于以上请求，会达到一个新的、一致的状态。然后，正常运行3阶段消息协议。</p><p>为什么要包含已经Prepared，但未Committed的请求？如果一个请求，在副本节点i上，已经是Prepared状态，证明至少f+1的非拜占庭节点，已经拥有此请求并赞成请求req在视图v中使用序号n。如果没有问题，不发生视图切换，这些请求可以在有限的时间内达成一致，新的主节点把已经Prepared的请求，带到新的view，并证明给其他节点，请求已经Prepared，那只需1轮Commit就可以达成一致。</p><h3 id="View-Changes主要流程简介"><a href="#View-Changes主要流程简介" class="headerlink" title="View Changes主要流程简介"></a>View Changes主要流程简介</h3><p>对View Changes的流程可以分为2部分：</p><ul><li>View Changes的开端，即每一次View的开始</li><li>View Changes的中间过程，以及View Changes的结束，切换到正常流程</li></ul><p>这2部分分别占据了下图的左右两部分。实线代表流程线，虚线代表网络消息。蓝色代表正常操作流程（三阶段消息：Preprepare、Prepare、Commit），青色代表View Changes流程，蓝青相接就是正常流程和View Changes流程切换的地方。</p><p><img src="http://img.lessisbetter.site/2020-04-09-blueprint-view-changes.png" alt=""></p><p>View Changes的开端流程是通用的，主节点和副本节点都遵守这一流程：<code>新视图：v=v+1</code>，代表一个新的View开始，指向它的每一个箭头，都是视图切换的一种原因。某个副本节点，新视图的开始，还伴随着广播<code>view-change</code>消息，告诉其他节点，本节点开启了一个新的视图。</p><p>主节点是通过公式算出来的，其余为副本节点，在View Changes流程中，副本节点会和主节点交互，共同完成View Changes过程。副本节点会对收到的<code>view-change</code>消息进行检查，然后把一条对应的<code>view-change-ack</code>消息发送给主节点，主节点会依赖收到的<code>view-change</code>消息和<code>view-change-ack</code>消息数量和内容，产生能让所有节点移动到统一状态的<code>new-view</code>消息，并且对<code>new-view</code>消息进行3阶段共识，即对<code>new-view</code>消息达成一致，从而让至少<code>f+1</code>个非拜占庭节点达成一致。</p><h3 id="View-Changes的开端"><a href="#View-Changes的开端" class="headerlink" title="View Changes的开端"></a>View Changes的开端</h3><p>View Change的核心因素只有一个：怀疑当前的主节点在有限的时间内，无法达成一致。</p><p>具体有4个路径：</p><ol><li>正常阶段定时器超时，代表一定时间内无法完成Pre-prepare -&gt; Prepare -&gt; Commit</li><li>View Changes阶段定时器超时，代表一定时间内无法完成正在进行的View Change</li><li>定时器未超时，但有效的view-change消息数量达到f+1个，代表当前已经有f+1个非拜占庭节点发起了新的视图切换，本节点为了不落后，不等待超时而进入视图切换</li><li>new-view消息不合法，代表当前View Changes阶段的主节点为拜占庭节点</li></ol><p>图中【正常阶段定时器超时】被标记为蓝色，是因为它是正常阶段进入视图切换阶段的开端，【有效的view-change消息数量达到f+1个】即有可能是正常阶段的定时器，也有可能是视图切换过程中的定时器，所以颜色没做调整。</p><h3 id="主副节点主要交互流程"><a href="#主副节点主要交互流程" class="headerlink" title="主副节点主要交互流程"></a>主副节点主要交互流程</h3><p>视图切换过程中有3个消息：view-change消息、view-change-ack消息和new-view消息，下文围绕这3个消息，对主副节点的交互流程做详细介绍。</p><h3 id="view-change消息阶段"><a href="#view-change消息阶段" class="headerlink" title="view-change消息阶段"></a>view-change消息阶段</h3><p>在view v时，副本节点怀疑主节点fault时，会发送view-change消息，该消息包含：</p><ol><li>h：副本i最新的稳定检查点序号</li><li>C：副本i保存的h之后的（非稳定）检查点</li><li>P和Q</li><li>i：副本i</li><li>α：副本i对本消息的数字签名</li></ol><p>P和Q是2个集合。</p><p>P是已经Prepared消息的信息集合：消息既然已经Prepared，说明<strong>至少2f+1的节点拥有了消息，并且认可<code>&lt;view, n, d&gt;</code></strong>，即为消息分配的view和序号，只是还差一步commit阶段就可以完成一致性确认。P中包含的就是已经达到Prepared的消息的摘要d，无需包含完整的请求消息。新的view中，这些请求会使用老的序号n，而无需分配新的序号。</p><p>Q是已经Pre-prepared消息的信息集合，主节点已经发送Pre-prepare或副本节点i为请求已经发送Prepare消息，证明<strong>该节点认可<code>&lt;n, d, v&gt;</code></strong>。</p><p>P、Q中的请求都是高低水位之间的，无View Changes时，P、Q都是空的，也就是说不包含已经committed的请求。new-view消息中的数据（View Changes的决策结果），都是基于P、Q集合计算出的。</p><p>在发送view-change消息前，副本节点会利用日志中的三阶段消息计算P、Q集合，发送view-change消息后，就删除日志中的三阶段消息。</p><h3 id="view-change-ack消息阶段"><a href="#view-change-ack消息阶段" class="headerlink" title="view-change-ack消息阶段"></a>view-change-ack消息阶段</h3><p>视图<code>v+1</code>的主节点在收到其他节点发送的view-change消息后，并不确认view-change消息是是否拜占庭节点发出的，即不确定消息是否是正确无误的，如果基于错误的消息做决策，就会得到错误的结果，违反一致性：一切操作都是正确的。</p><p>设置view-change-ack消息的目的是，让所有副本节点对所有它收到的view-change消息进行检查和确认，只不过确认的结果都发送给新的主节点。主节点统计ack消息，可以辨别哪些view-change是正确的，哪些是拜占庭节点发出的。</p><p>副本节点会对view-change消息中的P、Q集合进行检查，要求集合中的请求消息小于等于视图<code>v</code>，满足则发送view-change-ack消息：</p><ol><li>v：v+1</li><li>i：发送ack消息的副本序号</li><li>j：副本i要确认的view-change消息的发送方</li><li>d：副本i要确认的view-change消息的摘要</li><li>μip：i向主节点p发送消息的通信密钥计算出的MAC，这里需要保证i和p之间通信的私密性，所以不使用数字签名</li></ol><h3 id="new-view消息阶段"><a href="#new-view消息阶段" class="headerlink" title="new-view消息阶段"></a>new-view消息阶段</h3><p>新视图主节点p负责基于view-change消息做决策，决策放到new-view消息中。</p><p>主节点p维护了一个集合S，用来存放正确的view-change消息。只有view-change消息，以及为该消息背书的view-change-ack消息达到<code>2f-1</code>个时，view-change消息才能加入到集合S，但view-change-ack消息不加入集合S。</p><p>当集合S的大小达到<code>2f+1</code>时，证明有足够多的非拜占庭节点认为需要进行视图变更，并提供了变更的依据：2f+1个view-change消息，主节点p使用S做决策。以下便是<strong>决策逻辑</strong>。</p><p>主节点p先确定h：所有view-change消息中最大的稳定检查点。h和h+L其实就是高低水位。</p><p>然后依次检查h到h+L中的每一个序号n，对序号n对于的请求进行的处理为：请求m已经Prepared并且Pre-prepared，则收集序号n对应的请求。否则，说明没有请求在序号n能达到committed，为序号n分配一个空请求，并收集起来。它们最后会被放到new-view消息的X集合中。</p><p>主节点会创建new-view消息：</p><ul><li>view：当前新视图的编号</li><li>V：是一个集合，每个元素是一对<code>(i, d)</code>，代表i发送的view-change消息摘要是d，每一对都与集合S中消息对应，可以使用V证明主节点是在满足条件下，创建new-view消息的，即V是新视图的证明。因为其它多数副本节点已经接收view-change消息，所以此处发送消息的摘要做对比即可。</li><li>X：是一个集合，包含检查点以及选定的请求</li><li>α：主节点p对new-view消息的数字签名</li></ul><p>之后，主节点会把new-view消息广播给每一个副本节点。</p><h3 id="处理new-view消息"><a href="#处理new-view消息" class="headerlink" title="处理new-view消息"></a>处理new-view消息</h3><h4 id="主节点处理new-view消息"><a href="#主节点处理new-view消息" class="headerlink" title="主节点处理new-view消息"></a>主节点处理new-view消息</h4><p>在发生View Changes时，主节点的状态可能也不是最全的，如果它没有X结合中的请求或者检查点，它可以从其他节点哪拉去。</p><p>主节点需要使用new-view消息，达到视图切换的最后一步状态：在新视图v+1中，让集合X中的请求，全部是Pre-prepared状态。为何是Pre-prepared状态呢？因为new-view消息，可以看做一次特殊的Pre-prepare消息。</p><p>为什么不直接标记为Committed呢？因为主节点也可能是拜占庭节点，副本节点需要检查new-view消息，向所有节点广播自己检查的结果，满足条件后才能达成一致性。</p><h4 id="副本节点处理new-view消息"><a href="#副本节点处理new-view消息" class="headerlink" title="副本节点处理new-view消息"></a>副本节点处理new-view消息</h4><p>副本节点在视图v+1，会持续接收view-change消息和new-view消息，它会把new-view消息V集合中的view-change消息，跟它收到的消息做对比，如果它本地不存在某条view-change消息，它可以要求主节点向他提供view-change消息和view-change-ack消息集合，证明至少f+1个非拜占庭副本节点收到过此view-change消息。</p><p>副本节点拥有所有的view-change消息之后，副本节点会和主节点运行相同的决策逻辑，以校验new-view消息的正确性。</p><p>如果new-view消息是正确的，副本节点会和主节点一样移动到相同的状态，然后广播一条Prepare消息给所有节点，这样就恢复到了正常情况下的：<code>Pre-prepare -&gt; Prepare -&gt; Commit</code> 一致性逻辑。这样就完成了从View Changes到正常处理流程的迁移。</p><p>如果new-view消息是错误的，说明主节点p是拜占庭节点，副本节点会直接进入v+2，发送view-change消息，进行新的一轮视图切换。</p><h3 id="View-Changes如何提供liveness"><a href="#View-Changes如何提供liveness" class="headerlink" title="View Changes如何提供liveness"></a>View Changes如何提供liveness</h3><p>在一轮视图切换无法完成的时候，会开启新的一轮视图切换，由于拜占庭节点的数量最多为f个，最终会在某一轮视图切换中，能够完成视图切换，所有非拜占庭节点达成一致的状态，保证liveness和safety。</p><p>本文前面列出了几种异常情况，下面就看一下View Changes是如何应对这些异常情况的，以及如何提供活性。</p><p>Q1：如果下一个View的主节点宕机了怎么办？</p><p>A1：副本节点在收集到2f+1个view-change消息后，会启动定时器，超时时间为T，新view的主节点宕机，必然会导致定时器超时时，未能完成View Changes流程，会进入新一轮视图切换。</p><p>Q2：如果下一个View的主节点是恶意节点，作恶怎么办？</p><p>A2：新view的主节点是恶意节点，如果它做恶了，生成的new-view消息不合法，副本节点可以检测出来。或者new-view消息是合法的，但它只发送给了少数副本节点，副本节点在对new-view消息进行正常的3阶段流程，参与的节点太少，在定时器超时前，不足以完成3阶段流程，副本节点会进入下一轮视图切换。</p><p>Q3：如果非拜占庭恶意发起View Changes，造成主节点切换怎么办？</p><p>A3：定时器未超时情况下，只有有效的f+1个view-change消息，才会引发其他副本节点进行主节点切换，否则无法造成主节点切换。但PBFT的前提条件是恶意节点不足f个，所以只有恶意节点发起view-change消息时，无法造成主节点切换。</p><p>Q4：如果参与View Changes的节点数量不足怎么办？</p><p>A4：这个问题可以分几种情况。</p><ul><li>发起view-change的节点数量不足f+1个，这种情况不会发生整个集群的视图切换。</li><li>视图切换过程中，不满足各节点的数量要求，无法完成本轮视图切换，会进入下一轮视图切换。</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>View Changes是PBFT中一个重要的环节，它能保证整个协议的liveness，是PBFT不可或缺的一部分。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在当前的PBFT资料中，尤其是中文资料，多数都在介绍PBFT的3阶段消息过程，很少提及View Changes（视图切换），View Cha
      
    
    </summary>
    
    
    
      <category term="一致性" scheme="http://lessisbetter.site/tags/%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    
      <category term="区块链" scheme="http://lessisbetter.site/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="PBFT" scheme="http://lessisbetter.site/tags/PBFT/"/>
    
      <category term="共识算法" scheme="http://lessisbetter.site/tags/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Go官方进程诊断工具gops详解</title>
    <link href="http://lessisbetter.site/2020/03/15/gops-introduction/"/>
    <id>http://lessisbetter.site/2020/03/15/gops-introduction/</id>
    <published>2020-03-15T12:20:47.000Z</published>
    <updated>2020-03-17T09:50:48.528Z</updated>
    
    <content type="html"><![CDATA[<h2 id="gops简介"><a href="#gops简介" class="headerlink" title="gops简介"></a>gops简介</h2><p><a href="https://github.com/google/gops" target="_blank" rel="noopener">gops</a> 是Go团队提供的命令行工具，它可以用来获取go进程运行时信息。</p><p>可以查看：</p><ul><li>当前有哪些go语言进程，哪些使用gops的go进程</li><li>进程的概要信息</li><li>进程的调用栈</li><li>进程的内存使用情况</li><li>构建程序的Go版本</li><li>运行时统计信息</li></ul><p>可以获取：</p><ul><li>trace</li><li>cpu profile和memory profile</li></ul><p>还可以：</p><ul><li>让进程进行1次GC</li><li>设置GC百分比</li></ul><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>使用<code>Options</code>配置agent。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"runtime"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/google/gops/agent"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := agent.Listen(agent.Options&#123;</span><br><span class="line">Addr:            <span class="string">"0.0.0.0:8848"</span>,</span><br><span class="line"><span class="comment">// ConfigDir:       "/home/centos/gopsconfig", // 最好使用默认</span></span><br><span class="line">ShutdownCleanup: <span class="literal">true</span>&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试代码</span></span><br><span class="line">_ = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">1000</span>, <span class="number">1000</span>)</span><br><span class="line">runtime.GC()</span><br><span class="line"></span><br><span class="line">_ = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">1000</span>, <span class="number">2000</span>)</span><br><span class="line">runtime.GC()</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Hour)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="agent-Option选项"><a href="#agent-Option选项" class="headerlink" title="agent Option选项"></a>agent Option选项</h2><p>agent有3个配置：</p><ul><li><code>Addr</code>：agent要监听的ip和端口，默认ip为环回地址，端口随机分配。</li><li><code>ConfigDir</code>：该目录存放的不是agent的配置，而是每一个使用了agent的go进程信息，文件以pid命名，内容是该pid进程所监听的端口号，所以其中文件的目的是形成pid到端口的映射。默认值为<code>~/.config/gops</code></li><li><code>ShutdownCleanup</code>：进程退出时，是否清理ConfigDir中的文件，默认值为false，不清理</li></ul><p>通常可以把<code>Addr</code>设置为要监听的IP，把<code>ShutdownCleanup</code>设置为<code>ture</code>，进程退出后，残留在ConfigDir目录的文件不再有用，最好清除掉。</p><p><code>ConfigDir</code>示例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// gopsconfig为设置的ConfigDir目录，2051为pid，8848为端口号。</span><br><span class="line">➜  ~ cat gopsconfig/2051</span><br><span class="line">8848%</span><br><span class="line">➜  ~ netstat -nap | grep `pgrep gopsexample`</span><br><span class="line">tcp6       0      0 :::8848                 :::*                    LISTEN      2051/./gopsexample</span><br></pre></td></tr></table></figure><h2 id="gops原理"><a href="#gops原理" class="headerlink" title="gops原理"></a>gops原理</h2><p>gops的原理是，代码中导入<code>gops/agent</code>，建立agent服务，gops命令连接<code>agent</code>读取进程信息。</p><p><img src="http://img.lessisbetter.site/2020-03-gops.png" alt="gops"></p><p><code>agent</code>的实现原理可以查看<code>agent/handle</code><a href="https://github.com/google/gops/blob/master/agent/agent.go#L182" target="_blank" rel="noopener">函数</a>。</p><p>使用go标准库中原生接口实现相关功能，如同你要在自己的程序中开启pprof类似，只不过这部分功能由<code>gops/agent</code>实现了：</p><ul><li>使用<code>runtime.MemStats</code>获取内存情况</li><li>使用<code>runtime/pprof</code>获取调用栈、cpu profile和memory profile</li><li>使用<code>runtime/trace</code>获取trace</li><li>使用<code>runtime</code>获取stats信息</li><li>使用<code>runtime/debug</code>、<code>GC</code>设置和启动GC</li></ul><p>再谈<code>ConfigDir</code>。从源码上看，<code>ConfigDir</code>对agent并没有用途，对gops有用。当gops和ConfigDir在一台机器上时，即gops查看本机的go进程信息，gops可以通过其中的文件，快速找到agent服务的端口。能够实现：<code>gops &lt;sub-cmd&gt; pid</code>到<code>gops &lt;sub-cmd&gt; 127.0.0.1:port</code>的转换。</p><p>如果代码中通过<code>ConfigDir</code>指定了其他目录，使用<code>gops</code>时，需要添加环境变量<code>GOPS_CONFIG_DIR</code>指向<code>ConfigDir</code>使用的目录。</p><h2 id="子命令介绍"><a href="#子命令介绍" class="headerlink" title="子命令介绍"></a>子命令介绍</h2><p>gops后面可以跟子命令，然后是pid或者远端地址。</p><p>也可以直接跟pid，查看本机进程信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ gops help memstats</span><br><span class="line">gops is a tool to list and diagnose Go processes.</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  gops &lt;cmd&gt; &lt;pid|addr&gt; ...</span><br><span class="line">  gops &lt;pid&gt; # displays process info</span><br><span class="line">  gops help  # displays this help message</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  stack      Prints the stack trace.</span><br><span class="line">  gc         Runs the garbage collector and blocks until successful.</span><br><span class="line">  setgc     Sets the garbage collection target percentage.</span><br><span class="line">  memstats   Prints the allocation and garbage collection stats.</span><br><span class="line">  version    Prints the Go version used to build the program.</span><br><span class="line">  stats      Prints runtime stats.</span><br><span class="line">  trace      Runs the runtime tracer for 5 secs and launches &quot;go tool trace&quot;.</span><br><span class="line">  pprof-heap Reads the heap profile and launches &quot;go tool pprof&quot;.</span><br><span class="line">  pprof-cpu  Reads the CPU profile and launches &quot;go tool pprof&quot;.</span><br><span class="line"></span><br><span class="line">All commands require the agent running on the Go process.</span><br><span class="line">&quot;*&quot; indicates the process is running the agent.</span><br></pre></td></tr></table></figure><h3 id="查看当前机器上go程序进程信息"><a href="#查看当前机器上go程序进程信息" class="headerlink" title="查看当前机器上go程序进程信息"></a>查看当前机器上go程序进程信息</h3><p>查看当前机器上的go进程，可以列出pid、ppid、进程名、可执行程序所使用的go版本，以及可执行程序的路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ gops</span><br><span class="line">67292 66333 gops                         * go1.13    &#x2F;Users&#x2F;shitaibin&#x2F;Workspace&#x2F;golang_step_by_step&#x2F;gops&#x2F;gops</span><br><span class="line">67434 65931 gops                           go1.13    &#x2F;Users&#x2F;shitaibin&#x2F;go&#x2F;bin&#x2F;gops</span><br><span class="line">66551 1     gocode                         go1.11.2  &#x2F;Users&#x2F;shitaibin&#x2F;go&#x2F;bin&#x2F;gocode</span><br><span class="line">137   1     com.docker.vmnetd              go1.12.7  &#x2F;Library&#x2F;PrivilegedHelperTools&#x2F;com.docker.vmnetd</span><br><span class="line">811   807   com.docker.backend             go1.12.13 &#x2F;Applications&#x2F;Docker.app&#x2F;Contents&#x2F;MacOS&#x2F;com.docker.backend</span><br><span class="line">807   746   com.docker.supervisor          go1.12.13 &#x2F;Applications&#x2F;Docker.app&#x2F;Contents&#x2F;MacOS&#x2F;com.docker.supervisor</span><br><span class="line">810   807   com.docker.driver.amd64-linux  go1.12.13 &#x2F;Applications&#x2F;Docker.app&#x2F;Contents&#x2F;MacOS&#x2F;com.docker.driver.amd64-linux</span><br></pre></td></tr></table></figure><p>带<code>*</code>的是程序中使用了gops/agent，不带<code>*</code>的是普通的go程序。</p><h3 id="go程序进程树"><a href="#go程序进程树" class="headerlink" title="go程序进程树"></a>go程序进程树</h3><p>查看进程树：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ gops tree</span><br><span class="line">...</span><br><span class="line">├── 66333</span><br><span class="line">│   └── [*]  67292 (gops) &#123;go1.13&#125;</span><br><span class="line">├── 1</span><br><span class="line">│   ├── 66551 (gocode) &#123;go1.11.2&#125;</span><br><span class="line">│   └── 137 (com.docker.vmnetd) &#123;go1.12.7&#125;</span><br><span class="line">├── 65931</span><br><span class="line">│   └── 67476 (gops) &#123;go1.13&#125;</span><br><span class="line">└── 746</span><br><span class="line">    └── 807 (com.docker.supervisor) &#123;go1.12.13&#125;</span><br><span class="line">        ├── 811 (com.docker.backend) &#123;go1.12.13&#125;</span><br><span class="line">        └── 810 (com.docker.driver.amd64-linux) &#123;go1.12.13&#125;</span><br></pre></td></tr></table></figure><h3 id="pid：进程概要信息"><a href="#pid：进程概要信息" class="headerlink" title="pid：进程概要信息"></a>pid：进程概要信息</h3><p>查看进程的概要信息，非gops进程也可以：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ gops 67292</span><br><span class="line">parent PID:66333</span><br><span class="line">threads:7</span><br><span class="line">memory usage:0.018%</span><br><span class="line">cpu usage:0.000%</span><br><span class="line">username:shitaibin</span><br><span class="line">cmd+args:.&#x2F;gops</span><br><span class="line">elapsed time:11:28</span><br><span class="line">local&#x2F;remote:127.0.0.1:54753 &lt;-&gt; :0 (LISTEN)</span><br><span class="line">➜  ~</span><br><span class="line">➜  ~ gops 807</span><br><span class="line">parent PID:746</span><br><span class="line">threads:28</span><br><span class="line">memory usage:0.057%</span><br><span class="line">cpu usage:0.003%</span><br><span class="line">username:shitaibin</span><br><span class="line">cmd+args:&#x2F;Applications&#x2F;Docker.app&#x2F;Contents&#x2F;MacOS&#x2F;com.docker.supervisor -watchdog fd:0</span><br><span class="line">elapsed time:27-23:36:35</span><br><span class="line">local&#x2F;remote:127.0.0.1:54832 &lt;-&gt; :0 ()</span><br><span class="line">local&#x2F;remote:*:53849 &lt;-&gt; :0 ()</span><br><span class="line">local&#x2F;remote:127.0.0.1:49473 &lt;-&gt; :0 (LISTEN)</span><br></pre></td></tr></table></figure><h3 id="stack：当前调用栈"><a href="#stack：当前调用栈" class="headerlink" title="stack：当前调用栈"></a>stack：当前调用栈</h3><p>查看使用gops的进程的调用栈：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ gops stack 67292</span><br><span class="line">goroutine 19 [running]:</span><br><span class="line">runtime&#x2F;pprof.writeGoroutineStacks(0x1197160, 0xc00009c028, 0x0, 0x0)</span><br><span class="line">&#x2F;Users&#x2F;shitaibin&#x2F;goroot&#x2F;src&#x2F;runtime&#x2F;pprof&#x2F;pprof.go:679 +0x9d</span><br><span class="line">runtime&#x2F;pprof.writeGoroutine(0x1197160, 0xc00009c028, 0x2, 0x0, 0x0)</span><br><span class="line">&#x2F;Users&#x2F;shitaibin&#x2F;goroot&#x2F;src&#x2F;runtime&#x2F;pprof&#x2F;pprof.go:668 +0x44</span><br><span class="line">runtime&#x2F;pprof.(*Profile).WriteTo(0x1275c60, 0x1197160, 0xc00009c028, 0x2, 0xc00009c028, 0x0)</span><br><span class="line">&#x2F;Users&#x2F;shitaibin&#x2F;goroot&#x2F;src&#x2F;runtime&#x2F;pprof&#x2F;pprof.go:329 +0x3da</span><br><span class="line">github.com&#x2F;google&#x2F;gops&#x2F;agent.handle(0x1665008, 0xc00009c028, 0xc000014068, 0x1, 0x1, 0x0, 0x0)</span><br><span class="line">&#x2F;Users&#x2F;shitaibin&#x2F;go&#x2F;src&#x2F;github.com&#x2F;google&#x2F;gops&#x2F;agent&#x2F;agent.go:185 +0x1ab</span><br><span class="line">github.com&#x2F;google&#x2F;gops&#x2F;agent.listen()</span><br><span class="line">&#x2F;Users&#x2F;shitaibin&#x2F;go&#x2F;src&#x2F;github.com&#x2F;google&#x2F;gops&#x2F;agent&#x2F;agent.go:133 +0x2bf</span><br><span class="line">created by github.com&#x2F;google&#x2F;gops&#x2F;agent.Listen</span><br><span class="line">&#x2F;Users&#x2F;shitaibin&#x2F;go&#x2F;src&#x2F;github.com&#x2F;google&#x2F;gops&#x2F;agent&#x2F;agent.go:111 +0x364</span><br><span class="line"></span><br><span class="line">goroutine 1 [sleep]:</span><br><span class="line">runtime.goparkunlock(...)</span><br><span class="line">&#x2F;Users&#x2F;shitaibin&#x2F;goroot&#x2F;src&#x2F;runtime&#x2F;proc.go:310</span><br><span class="line">time.Sleep(0x34630b8a000)</span><br><span class="line">&#x2F;Users&#x2F;shitaibin&#x2F;goroot&#x2F;src&#x2F;runtime&#x2F;time.go:105 +0x157</span><br><span class="line">main.main()</span><br><span class="line">&#x2F;Users&#x2F;shitaibin&#x2F;Workspace&#x2F;golang_step_by_step&#x2F;gops&#x2F;example.go:15 +0xa3</span><br><span class="line"></span><br><span class="line">goroutine 18 [syscall]:</span><br><span class="line">os&#x2F;signal.signal_recv(0x0)</span><br><span class="line">&#x2F;Users&#x2F;shitaibin&#x2F;goroot&#x2F;src&#x2F;runtime&#x2F;sigqueue.go:144 +0x96</span><br><span class="line">os&#x2F;signal.loop()</span><br><span class="line">&#x2F;Users&#x2F;shitaibin&#x2F;goroot&#x2F;src&#x2F;os&#x2F;signal&#x2F;signal_unix.go:23 +0x22</span><br><span class="line">created by os&#x2F;signal.init.0</span><br><span class="line">&#x2F;Users&#x2F;shitaibin&#x2F;goroot&#x2F;src&#x2F;os&#x2F;signal&#x2F;signal_unix.go:29 +0x41</span><br></pre></td></tr></table></figure><h3 id="memstats-内存使用情况"><a href="#memstats-内存使用情况" class="headerlink" title="memstats: 内存使用情况"></a>memstats: 内存使用情况</h3><p>查看gops进程内存使用情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ gops memstats 67944</span><br><span class="line">alloc: 136.80KB (140088 bytes) &#x2F;&#x2F; 当前分配出去未收回的内存总量</span><br><span class="line">total-alloc: 152.08KB (155728 bytes) &#x2F;&#x2F; 已分配出去的内存总量</span><br><span class="line">sys: 67.25MB (70518784 bytes) &#x2F;&#x2F; 当前进程从OS获取的内存总量</span><br><span class="line">lookups: 0</span><br><span class="line">mallocs: 418 &#x2F;&#x2F; 分配的对象数量</span><br><span class="line">frees: 82 &#x2F;&#x2F; 释放的对象数量</span><br><span class="line">heap-alloc: 136.80KB (140088 bytes) &#x2F;&#x2F; 当前分配出去未收回的堆内存总量</span><br><span class="line">heap-sys: 63.56MB (66650112 bytes) &#x2F;&#x2F; 当前堆从OS获取的内存</span><br><span class="line">heap-idle: 62.98MB (66035712 bytes) &#x2F;&#x2F; 当前堆中空闲的内存量</span><br><span class="line">heap-in-use: 600.00KB (614400 bytes) &#x2F;&#x2F; 当前堆使用中的内存量</span><br><span class="line">heap-released: 62.89MB (65945600 bytes)</span><br><span class="line">heap-objects: 336 &#x2F;&#x2F; 堆中对象数量</span><br><span class="line">stack-in-use: 448.00KB (458752 bytes) &#x2F;&#x2F; 栈使用中的内存量 </span><br><span class="line">stack-sys: 448.00KB (458752 bytes) &#x2F;&#x2F; 栈从OS获取的内存总量 </span><br><span class="line">stack-mspan-inuse: 10.89KB (11152 bytes)</span><br><span class="line">stack-mspan-sys: 16.00KB (16384 bytes)</span><br><span class="line">stack-mcache-inuse: 13.56KB (13888 bytes)</span><br><span class="line">stack-mcache-sys: 16.00KB (16384 bytes)</span><br><span class="line">other-sys: 1.01MB (1062682 bytes)</span><br><span class="line">gc-sys: 2.21MB (2312192 bytes)</span><br><span class="line">next-gc: when heap-alloc &gt;&#x3D; 4.00MB (4194304 bytes) &#x2F;&#x2F; 下次GC的条件</span><br><span class="line">last-gc: 2020-03-16 10:06:26.743193 +0800 CST &#x2F;&#x2F; 上次GC的世界</span><br><span class="line">gc-pause-total: 83.84µs &#x2F;&#x2F; GC总暂停时间</span><br><span class="line">gc-pause: 44891 &#x2F;&#x2F; 上次GC暂停时间，单位纳秒</span><br><span class="line">num-gc: 2 &#x2F;&#x2F; 已进行的GC次数</span><br><span class="line">enable-gc: true &#x2F;&#x2F; 是否开始GC</span><br><span class="line">debug-gc: false</span><br></pre></td></tr></table></figure><h3 id="stats-运行时信息"><a href="#stats-运行时信息" class="headerlink" title="stats: 运行时信息"></a>stats: 运行时信息</h3><p>查看运行时统计信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ gops stats 68125</span><br><span class="line">goroutines: 3</span><br><span class="line">OS threads: 12</span><br><span class="line">GOMAXPROCS: 8</span><br><span class="line">num CPU: 8</span><br></pre></td></tr></table></figure><h3 id="trace"><a href="#trace" class="headerlink" title="trace"></a>trace</h3><p>获取当前运行5s的trace信息，会打开网页：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ gops trace 68125</span><br><span class="line">Tracing now, will take 5 secs...</span><br><span class="line">Trace dump saved to: &#x2F;var&#x2F;folders&#x2F;5g&#x2F;rz16gqtx3nsdfs7k8sb80jth0000gn&#x2F;T&#x2F;trace116447431</span><br><span class="line">2020&#x2F;03&#x2F;16 10:23:37 Parsing trace...</span><br><span class="line">2020&#x2F;03&#x2F;16 10:23:37 Splitting trace...</span><br><span class="line">2020&#x2F;03&#x2F;16 10:23:37 Opening browser. Trace viewer is listening on http:&#x2F;&#x2F;127.0.0.1:55480</span><br></pre></td></tr></table></figure><h3 id="cpu-profile"><a href="#cpu-profile" class="headerlink" title="cpu profile"></a>cpu profile</h3><p>获取cpu profile，并进入交互模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ gops pprof-cpu 68125</span><br><span class="line">Profiling CPU now, will take 30 secs...</span><br><span class="line"></span><br><span class="line">Profile dump saved to: &#x2F;var&#x2F;folders&#x2F;5g&#x2F;rz16gqtx3nsdfs7k8sb80jth0000gn&#x2F;T&#x2F;profile431166544</span><br><span class="line">Binary file saved to: &#x2F;var&#x2F;folders&#x2F;5g&#x2F;rz16gqtx3nsdfs7k8sb80jth0000gn&#x2F;T&#x2F;binary765361519</span><br><span class="line">File: binary765361519</span><br><span class="line">Type: cpu</span><br><span class="line">Time: Mar 16, 2020 at 10:25am (CST)</span><br><span class="line">Duration: 30s, Total samples &#x3D; 0</span><br><span class="line">No samples were found with the default sample value type.</span><br><span class="line">Try &quot;sample_index&quot; command to analyze different sample values.</span><br><span class="line">Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)</span><br><span class="line">(pprof)</span><br><span class="line">(pprof) top</span><br><span class="line">Showing nodes accounting for 0, 0% of 0 total</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br></pre></td></tr></table></figure><h3 id="memory-profile"><a href="#memory-profile" class="headerlink" title="memory profile"></a>memory profile</h3><p>获取memory profile，并进入交互模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ gops pprof-heap 68125</span><br><span class="line">Profile dump saved to: &#x2F;var&#x2F;folders&#x2F;5g&#x2F;rz16gqtx3nsdfs7k8sb80jth0000gn&#x2F;T&#x2F;profile292136242</span><br><span class="line">Binary file saved to: &#x2F;var&#x2F;folders&#x2F;5g&#x2F;rz16gqtx3nsdfs7k8sb80jth0000gn&#x2F;T&#x2F;binary693335273</span><br><span class="line">File: binary693335273</span><br><span class="line">Type: inuse_space</span><br><span class="line">Time: Mar 16, 2020 at 10:27am (CST)</span><br><span class="line">No samples were found with the default sample value type.</span><br><span class="line">Try &quot;sample_index&quot; command to analyze different sample values.</span><br><span class="line">Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)</span><br><span class="line">(pprof)</span><br><span class="line">(pprof) traces</span><br><span class="line">File: binary693335273</span><br><span class="line">Type: inuse_space</span><br><span class="line">Time: Mar 16, 2020 at 10:27am (CST)</span><br><span class="line">-----------+-------------------------------------------------------</span><br><span class="line">     bytes:  256kB</span><br><span class="line">         0   compress&#x2F;flate.(*compressor).init</span><br><span class="line">             compress&#x2F;flate.NewWriter</span><br><span class="line">             compress&#x2F;gzip.(*Writer).Write</span><br><span class="line">             runtime&#x2F;pprof.(*profileBuilder).build</span><br><span class="line">             runtime&#x2F;pprof.profileWriter</span><br><span class="line">-----------+-------------------------------------------------------</span><br><span class="line">     bytes:  64kB</span><br><span class="line">         0   compress&#x2F;flate.newDeflateFast</span><br><span class="line">             compress&#x2F;flate.(*compressor).init</span><br><span class="line">             compress&#x2F;flate.NewWriter</span><br><span class="line">             compress&#x2F;gzip.(*Writer).Write</span><br><span class="line">             runtime&#x2F;pprof.(*profileBuilder).build</span><br><span class="line">             runtime&#x2F;pprof.profileWriter</span><br><span class="line">-----------+-------------------------------------------------------</span><br></pre></td></tr></table></figure><h2 id="使用远程连接"><a href="#使用远程连接" class="headerlink" title="使用远程连接"></a>使用远程连接</h2><p>agent的默认配置<code>Option{}</code>，监听的是环回地址。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ sudo netstat -nap | grep 414</span><br><span class="line">➜  ~ netstat -nap | grep `pgrep gopsexample`</span><br><span class="line">(Not all processes could be identified, non-owned process info</span><br><span class="line"> will not be shown, you would have to be root to see it all.)</span><br><span class="line">tcp        0      0 127.0.0.1:36812         0.0.0.0:*               LISTEN      414/./gopsexample</span><br></pre></td></tr></table></figure><p>修改程序，在<code>Option</code>中设置监听的地址和端口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">agent.Listen(agent.Options&#123;Addr:<span class="string">"0.0.0.0:8848"</span>&#125;)</span><br></pre></td></tr></table></figure><p>在远程主机上重新编译、重启进程，确认进程监听的端口：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ netstat -nap | grep `pgrep gopsexample`</span><br><span class="line">(Not all processes could be identified, non-owned process info</span><br><span class="line"> will not be shown, you would have to be root to see it all.)</span><br><span class="line">tcp6       0      0 :::8848                 :::*                    LISTEN      887/./gopsexample</span><br></pre></td></tr></table></figure><p>在本地主机上使用gops连接远端go进程，并查看数据：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ gops stats 192.168.9.137:8848</span><br><span class="line">goroutines: 3</span><br><span class="line">OS threads: 9</span><br><span class="line">GOMAXPROCS: 4</span><br><span class="line">num CPU: 4</span><br></pre></td></tr></table></figure><p><code>gops</code>后面只能跟pid查看进程简要信息，不能跟ip和port查看远端go进程简要信息，这些简要信息可以通过子命令汇集起来。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ gops 192.168.9.137:8848</span><br><span class="line">gops: unknown subcommand</span><br><span class="line">➜  ~ </span><br><span class="line">➜  ~ gops version 192.168.9.137:8848</span><br><span class="line">go1.13</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;gops简介&quot;&gt;&lt;a href=&quot;#gops简介&quot; class=&quot;headerlink&quot; title=&quot;gops简介&quot;&gt;&lt;/a&gt;gops简介&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/google/gops&quot; target=&quot;_blan
      
    
    </summary>
    
    
    
      <category term="Go" scheme="http://lessisbetter.site/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>为什么PBFT需要3个阶段消息？</title>
    <link href="http://lessisbetter.site/2020/03/15/why-pbft-needs-3-phase-message/"/>
    <id>http://lessisbetter.site/2020/03/15/why-pbft-needs-3-phase-message/</id>
    <published>2020-03-15T01:25:41.000Z</published>
    <updated>2020-03-25T00:49:54.116Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在面试的时候，很多同学的简历熟悉PBFT共识算法，在现场面试的时候，却只能说个主要逻辑，离完整的算法，还差十万八千里，相似从网络上看了一些文章，就算是熟悉了。当我问“为什么PBFT需要3个阶段消息？2个阶段行不行”时，还没有人能回答出来。</p><p>回答这个问题，还要从PBFT要解决的本质问题说起，所以我打算以这样一个思路，为大家回答问题：</p><ul><li>PBFT与拜占庭问题</li><li>拜占庭节点在网络中的行为</li><li>什么是3阶段消息</li><li>3阶段消息解决什么问题</li><li>为什么不能只有前2个阶段</li><li>论文使用的2个不变性</li><li>为什么3个阶段可以达成一致性</li></ul><h2 id="PBFT与拜占庭问题"><a href="#PBFT与拜占庭问题" class="headerlink" title="PBFT与拜占庭问题"></a>PBFT与拜占庭问题</h2><blockquote><p>莱斯利·兰波特在其论文[1]中描述了如下拜占庭问题：</p><p>一组拜占庭帝国的将军分别各率领一支军队共同围困一座城市。为了简化问题，将各支军队的行动策略限定为进攻或撤离两种。因为部分军队进攻，或部分军队撤离可能会造成灾难性后果，因此各位将军必须通过投票来达成一致策略，即所有军队一起进攻或所有军队一起撤离。因为各位将军分处城市不同方向，他们只能通过信使互相联系。在投票过程中，每位将军都将自己投票进攻还是撤退的信息，通过信使分别通知其他所有将军，这样一来每位将军根据自己的投票，和其他所有将军送来的信息，就可以知道共同的投票结果，而决定行动策略。</p><p>问题在于，将军中可能出现叛徒(坏将军)，他们不仅可能向较为糟糕的策略投票，还可能选择性地发送投票信息。阻止好将军达成一致的形成策略。</p><p>摘自：<a href="https://zh.wikipedia.org/wiki/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">维基百科：拜占庭将军问题</a>，有删改。</p></blockquote><p><em>很多人喜欢玩狼人杀，我也喜欢，但我玩的很菜</em>，我用狼人杀跟拜占庭将军问题做个类比。</p><p>在狼人杀开局的时候，你是好人，并且不知道自己的队友是谁，也不知道狼人是谁，但所有的好人都有一个共同的目的：干死狼人，好人获胜。所以游戏中需要使用技巧和策略，达成目的。</p><p>拜占庭将军问题是类似的，好的将军不知道其他将军是好的，还是坏的，但所有好的将军的目的是：行动一致，共同进退。所以，它们也需要策略达成一致。</p><p>BFT是一类解决拜占庭将军问题的策略/算法：让非拜占庭节点达成一致的算法。在这类论文中，拜占庭节点指“坏”的将军，非拜占庭节点指“好”的将军。</p><p>PBFT是实用拜占庭算法（<a href="http://pmg.csail.mit.edu/papers/osdi99.pdf" target="_blank" rel="noopener">Practical Byzantine Fault Tolerance</a>）的缩写，该论文与1999年发表，另外2001年又发表了一篇<a href="http://www.pmg.csail.mit.edu/papers/bft-tocs.pdf" target="_blank" rel="noopener">Practical Byzantine Fault Tolerance and Proactive Recovery</a>，让PBFT拥有恢复能力。</p><p>PBFT作为解决拜占庭问题的策略：<strong>非拜占庭节点不知道哪些是拜占庭节点，哪些是非拜占庭节点，PBFT要让非拜占庭节点达成一致</strong>。</p><h2 id="拜占庭节点在网络中的行为"><a href="#拜占庭节点在网络中的行为" class="headerlink" title="拜占庭节点在网络中的行为"></a>拜占庭节点在网络中的行为</h2><p>拜占庭问题是在分布式对等网络，对通信容错所提出来的。在真实世界中，拜占庭问题是什么样的？</p><p>通常使用拜占庭行为，描述拜占庭节点可能的行为，拜占庭行为有：</p><ul><li>任何不遵守协议的动作</li><li>恶意代码、节点</li><li>代码bug</li><li>网络故障、数据包损坏</li><li>磁盘崩掉、重复丢失</li><li>无权限时加入</li><li>…</li></ul><h2 id="什么是3阶段消息"><a href="#什么是3阶段消息" class="headerlink" title="什么是3阶段消息"></a>什么是3阶段消息</h2><p><img src="http://img.lessisbetter.site/2020-03-pbft-3-phase-message.png" alt="3阶段消息"></p><p>3阶段消息是：Pre-prepare、Prepare和Commit。每个消息都会包含数字签名，证明消息的发送者，以及消息类型，下文中会省略。</p><p>Pre-prepare消息由主节点发出，包含：</p><ul><li>当前view：v</li><li>主节点分配给请求的序号n</li><li>请求的摘要d</li><li>请求本身m</li></ul><p><strong>务必记牢，m、v、n、d，后面会使用缩写</strong>。</p><p>Prepare是副本节点收到Pre-prepare消息后，做出的响应，发送给所有副本节点，包含：</p><ul><li>v</li><li>n</li><li>d</li></ul><p>Prepared状态：副本i有Pre-prepare消息，且收到2f个有效的Prepare消息。</p><p>副本i达到Prepared状态，可以发送Commit消息，Commit消息的内容和Prepare消息内容相同，但消息类型和数字签名是不同的，所以可以区分。</p><p>m可以使用d代替，所以Prepare和Commit消息使用d代替m，来节省通信量。</p><h2 id="3阶段消息解决什么问题"><a href="#3阶段消息解决什么问题" class="headerlink" title="3阶段消息解决什么问题"></a>3阶段消息解决什么问题</h2><p>前面提到，PBFT解决的是拜占庭问题的一致性，即让非拜占庭节点达成一致。更具体的说：<strong>让请求m，在view内使用序号n，并且完成执行m，向客户端发送响应</strong>。</p><h2 id="为什么不能只有前2个阶段消息"><a href="#为什么不能只有前2个阶段消息" class="headerlink" title="为什么不能只有前2个阶段消息"></a>为什么不能只有前2个阶段消息</h2><p>这个问题的等价问题是：为什么Pre-prepare和Prepare消息，不能让非拜占庭节点达成一致？</p><p>Pre-prepare消息的目的是，主节点为请求m，分配了视图v和序号n，让至少f+1个非拜占庭节点对这个分配组合<code>&lt;m, v, n&gt;</code>达成一致，并且不存在<code>&lt;m&#39;, v, n&gt;</code>，即不存在有2个消息使用同一个v和n的情况。</p><p><strong>Prepared状态可以证明非拜占庭节点在只有请求m使用<code>&lt;v, n&gt;</code>上达成一致</strong>。主节点本身是认可<code>&lt;m, v, n&gt;</code>的，所以副本只需要收集2f个Prepare消息，而不是2f+1个Prepare消息，就可以计算出至少f个副本节点是非拜占庭节点，它们认可m使用<code>&lt;v, n&gt;</code>，并且没有另外1个消息可以使用<code>&lt;v, n&gt;</code>。</p><p>既然1个<code>&lt;v, n&gt;</code>只能对应1个请求m了，达到Prepared状态后，副本i执行请求m，不就达成一致了么？</p><p>并不能。<strong>Prepared是一个局部视角，不是全局一致</strong>，即副本i看到了非拜占庭节点认可了<code>&lt;m, v, n&gt;</code>，但整个系统包含3f+1个节点，异步的系统中，存在丢包、延时、拜占庭节点故意向部分节点发送Prepare等拜占庭行文，<strong>副本i无法确定，其他副本也达到Prepared状态。如果少于f个副本成为Prepared状态，然后执行了请求m，系统就出现了不一致。</strong></p><p>所以，前2个阶段的消息，并不能让非拜占庭节点达成一致。</p><p>如果你了解2PC或者Paxos，我相信可以更容易理解上面的描述。2PC或Paxos，第一步只是用来锁定资源，第2步才是真正去Do Action。把Pre-prepare和Prepare理解为第一步，资源是<code>&lt;v, n&gt;</code>，只有第一步是达不成一致性的。</p><h2 id="2个不变性"><a href="#2个不变性" class="headerlink" title="2个不变性"></a>2个不变性</h2><p>PBFT的论文提到了2个不变性，这2个不变性，<strong>用来证明PBFT如何让非拜占庭节点达成一致性</strong>。</p><p><strong>第1个不变性</strong>，它是由Pre-prepare和Prepare消息所共同确保的不变性：非拜占庭节点在同一个view内对请求的序号达成共识。关于这个不变性，已经在<a href="#为什么不能只有前2个阶段消息">为什么不能只有前2个阶段消息</a>中论述过。</p><p>介绍第2个不变性之前，需要介绍2个定义。</p><ul><li>committed-local：副本i已经是Prepared状态，并且收到了2f+1个Commit消息。</li><li>committed：至少f+1个非拜占庭节点已经是Prepared状态。</li></ul><p><img src="http://img.lessisbetter.site/2020-03-pbft-committed.png" alt=""></p><p><strong>第2个不变性</strong>，如果副本i是committed-local，那么一定存在committed。</p><p>2f+1个Commit消息，去掉最多f个拜占庭节点伪造的消息，得出至少f+1个非拜占庭节点发送了Commit消息，即至少f+1个非拜占庭节点是Prepared状态。所以第2个不变性成立。</p><h2 id="为什么3个阶段消息可以达成一致性"><a href="#为什么3个阶段消息可以达成一致性" class="headerlink" title="为什么3个阶段消息可以达成一致性"></a>为什么3个阶段消息可以达成一致性</h2><p>committed意味着有f+1个非拜占庭节点可以执行请求，而committed-local意味着，副本i看到了有f+1个非拜占庭节点可以执行请求，f+1个非拜占庭节点执行请求，也就达成了，让非拜占庭节点一致。</p><p>虽然我前面使用了2PC和Paxos做类比，但不意味着PBFT的Commit阶段就相当于，2PC和Paxos的第2步。因为2PC和Paxos处理的CFT场景，不存在拜占庭节点，它们的主节点充当了统计功能，统计有多少节点完成了第一步。PBFT中节点是存在拜占庭节点的，主节点并不是可靠(信)的，不能依赖主节点统计是否有f+1个非拜占庭节点达成了Prepared，而是每个节点各自统计，committed-local让节点看到了，系统一定可以达成一致，才去执行请求。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了2个阶段消息是无法达成一致的原因，而为什么3阶段消息可以。最核心的还是要理解好，PBFT解决了什么问题，以及它是如何解决的。</p><p><strong>PBFT解决的是在拜占庭环境下，如何提供一致性，以及如何持续的提供一致性的问题</strong>。本文只介绍了如何提供一致性，没有提如何持续提供一致性，即PBFT的可用性。现在，不妨思考一下，View Change是如何保证切换时一致性的，是否也需要2个不变性的支持呢？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在面试的时候，很多同学的简历熟悉PBFT共识算法，在现场面试的时候，却只能说个主要逻辑，离完整的算法，还差十万八千里，相似从网络上看了一些文
      
    
    </summary>
    
    
    
      <category term="一致性" scheme="http://lessisbetter.site/tags/%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    
      <category term="区块链" scheme="http://lessisbetter.site/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="PBFT" scheme="http://lessisbetter.site/tags/PBFT/"/>
    
      <category term="共识算法" scheme="http://lessisbetter.site/tags/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>一张思维导图看懂PBFT</title>
    <link href="http://lessisbetter.site/2020/03/11/pbft-xmind/"/>
    <id>http://lessisbetter.site/2020/03/11/pbft-xmind/</id>
    <published>2020-03-11T13:08:05.000Z</published>
    <updated>2020-09-25T05:52:37.074Z</updated>
    
    <content type="html"><![CDATA[<p>最近央行发布的《金融分布式账本安全规范》中提到了区块链系统要提供BFT共识，把之前整理的PBFT的思维导图分享给大家。</p><p><strong>新标签页中打开，查看高清大图</strong>。</p><h2 id="1999年版本"><a href="#1999年版本" class="headerlink" title="1999年版本"></a>1999年版本</h2><p><img src="http://img.lessisbetter.site/PBFT.svg" alt=""></p><h2 id="2001年版本"><a href="#2001年版本" class="headerlink" title="2001年版本"></a>2001年版本</h2><p><img src="http://img.lessisbetter.site/PBFT-PR.svg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近央行发布的《金融分布式账本安全规范》中提到了区块链系统要提供BFT共识，把之前整理的PBFT的思维导图分享给大家。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;新标签页中打开，查看高清大图&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;1999年版本&quot;&gt;&lt;a href=&quot;#1999年版
      
    
    </summary>
    
    
    
      <category term="一致性" scheme="http://lessisbetter.site/tags/%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    
      <category term="区块链" scheme="http://lessisbetter.site/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="PBFT" scheme="http://lessisbetter.site/tags/PBFT/"/>
    
  </entry>
  
  <entry>
    <title>向Fabric贡献代码</title>
    <link href="http://lessisbetter.site/2020/03/03/contribute-to-fabric/"/>
    <id>http://lessisbetter.site/2020/03/03/contribute-to-fabric/</id>
    <published>2020-03-03T12:33:19.000Z</published>
    <updated>2020-03-16T14:51:33.540Z</updated>
    
    <content type="html"><![CDATA[<p>PDF如下：</p><div class="pdf" target="http://img.lessisbetter.site/contribute-to-fabric.pdf" height=""></div><blockquote><p>PDF不显示时，hexo安装插件：<code>npm install --save hexo-pdf</code>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;PDF如下：&lt;/p&gt;
&lt;div class=&quot;pdf&quot; target=&quot;http://img.lessisbetter.site/contribute-to-fabric.pdf&quot; height=&quot;&quot;&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;PDF不显示时，hexo安
      
    
    </summary>
    
    
    
      <category term="Fabric" scheme="http://lessisbetter.site/tags/Fabric/"/>
    
  </entry>
  
  <entry>
    <title>从因果关系谈个人能力建设和面试</title>
    <link href="http://lessisbetter.site/2020/03/01/causal-relationship-and-personal-ability/"/>
    <id>http://lessisbetter.site/2020/03/01/causal-relationship-and-personal-ability/</id>
    <published>2020-03-01T03:13:38.000Z</published>
    <updated>2020-05-05T06:36:52.104Z</updated>
    
    <content type="html"><![CDATA[<p>昨天睡前了看了一本收藏已久的书，是关于投资的，叫<a href="https://book.douban.com/subject/30450383/" target="_blank" rel="noopener">《伟大的时代-深度解读价值投资》</a>，这是一本采访了国内价值投资者的书籍，从这些投资者的话语里，看到了一些共性的东西，寻找垄断企业持续发展的根因，也就获得了投资收益，这个果。</p><p>今天起床后，就想到了因果关系、面试、个人能力，在这些角度进行了一些思考，在此记录下思考的成果，这篇文章会介绍：</p><ul><li>因果关系应该关注因，还是关注果？</li><li>如何从因果关系角度，建设个人能力？</li><li>如何从因果关系角度，发现优秀的面试者？</li></ul><h3 id="价值投资中的因果关系"><a href="#价值投资中的因果关系" class="headerlink" title="价值投资中的因果关系"></a>价值投资中的因果关系</h3><p>这些投资者的共性是，都提到了要寻找垄断，并且能够持续垄断的企业，并投资这些企业。</p><p><strong>垄断是“果”，持续垄断也是过，它们需要“因”</strong>。</p><p>怎么才能有垄断，并且持续垄断呢？</p><p>需要找到企业的文化、价值观、制度，这些软性的东西、虚的东西，是企业<strong>不断发展和进化</strong>的根基，这些是企业保持垄断，或成长为垄断的基石，垄断创造收益，收益是实。应了阿里一句话：把虚做实，把实做虚。</p><p>所以，企业文化、价值观和制度是“因”，垄断是“果”。</p><p>如果垄断是“因”，企业收益就是“果”。</p><p><img src="http://img.lessisbetter.site/2020-03-cr-monopoly.png" alt=""></p><p>收益的因不只有垄断，但垄断可以带来巨大收益。</p><h3 id="关注因，还是关注果？"><a href="#关注因，还是关注果？" class="headerlink" title="关注因，还是关注果？"></a>关注因，还是关注果？</h3><p>从企业文化、垄断和收益，这3者看，因果关系可以形成链条，组成一条因果链，一个元素即可以是因，又可以是果。</p><p>比如，垄断是企业文化的果，是收益的因。</p><p>说关注因是对的，关注果也是对的，关注因果链中，<strong>关注最根本的“因”，才是最对的</strong>。</p><p>说一个开发者最容易体会的例子：解决bug，需要定位问题的“根因”，只解决中间原因，并不能真正解决bug。</p><p><img src="http://img.lessisbetter.site/2020-03-cr-root-cause.png" alt=""></p><h3 id="如何从因果关系角度，建设个人能力？"><a href="#如何从因果关系角度，建设个人能力？" class="headerlink" title="如何从因果关系角度，建设个人能力？"></a>如何从因果关系角度，建设个人能力？</h3><p>我把<strong>中级</strong>技术开发者的能力，分成5个维度：技术深度、技术广度、商业思维能力、管理能力和演讲能力。</p><p>不同岗位、层次看到的能力维度是不一样的，比如CTO在找技术总监时的岗位时，需要有体系建设的能力。所以上面强调的是中级开发者。</p><p><img src="http://img.lessisbetter.site/2020-03-cr-personal-ability.png" alt=""></p><p>这5个维度的能力是因，项目、职位、收入这些是果。</p><p>果是我们的目标，是我们要达到的地方。而因才是我们要关注的地方。</p><p>建设能力，能力就转变成了“果”，那对应的因是什么呢？</p><p>建设能力的“因”是<strong>持续学习</strong>。</p><p><img src="http://img.lessisbetter.site/2020-03-cr-continuelearn.png" alt=""></p><p>这几年的付费学习，可把持续学习给玩坏了，总是弥漫着一种贩卖焦虑的气息，但不可否认的是，持续学习的人，总有机会。</p><p>持续学习，有很多种通俗的说法:</p><ol><li>活到老，学到老。</li><li>永不止步。</li><li>不给自己设限。</li><li>Stay foolish, Stay hungry。——乔布斯</li><li>…</li></ol><p>关于技术上的持续学习，曹大（Xargin）最近这篇文章值得一看<a href="https://xargin.com/how-to-learn/" target="_blank" rel="noopener">《工程师应该怎么学习》</a>。</p><h3 id="如何从因果关系角度，发现优秀的面试者？"><a href="#如何从因果关系角度，发现优秀的面试者？" class="headerlink" title="如何从因果关系角度，发现优秀的面试者？"></a>如何从因果关系角度，发现优秀的面试者？</h3><p>我考察候选人的经历不是特别多，1年下来，简历筛选过几百份，候选人也面过几十个了，有一些体会，今天就借着因果关系，浅谈一下。</p><p><strong>面试的本质，是挖掘面试者当前的能力和持续学习的能力</strong>。</p><p>上面这句代表2个观点：</p><ol><li>简历是“果”，能力是“因”。</li><li>招进来能持续创建价值是未来的“果”，持续学习是“因”。</li></ol><p>阿里有句土话，用来招聘很适合：没有过程的结果是垃圾，没有结果的过程是放屁。</p><p>上半句用来筛选简历，如果简历只写自己参与、做过了什么，而没有成果，这份简历就是垃圾，而写不出好简历的面试者，能力大概率也不优秀。</p><p>下半句用来面试，面试者是怎么取得这些成果的，TA具有哪些能力才取得了这些成果？</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>因果关系，还让我深刻的想到一句话：<strong>抓住事物的主要矛盾</strong>。</p><p>咱们国家的发展，不一直就是党和政府在抓主要矛盾，解决主要矛盾的过程吗。</p><h3 id="远见"><a href="#远见" class="headerlink" title="远见"></a>远见</h3><p>在世界读书日那天，美团技术团队推荐了许多书，其中有一本关于职业生涯的书籍：《<strong>远见：如何规划职业生涯3大阶段</strong>》，书很薄，也很容易理解，读完之后对职业生涯的认知提升了几个Level，值得深度阅读并实践，推荐给不断让自己更优秀的你。</p><p>下面是<strong>美团点评酒旅事业群前端团队负责人郭凯</strong>的推荐语：</p><blockquote><p>我们不仅要找到热爱的工作，而且要建立热爱的生活。职业生涯就像是一场至少长达45年的马拉松，这本书介绍了远见思维和三大职业生涯阶段，并介绍了如何应对职场和生活的冲突。我辈应该多行动、少忧虑，并且提前做好中长期的职业思考和职业规划。如果用“远见”的思维看待眼前的影响和困难，就根本不值得一提。用“远见”的思维，长期有耐心，每天前进30公里。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;昨天睡前了看了一本收藏已久的书，是关于投资的，叫&lt;a href=&quot;https://book.douban.com/subject/30450383/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《伟大的时代-深度解读价值投资》&lt;/a&gt;，这是一本采访了国内
      
    
    </summary>
    
    
    
      <category term="职业发展" scheme="http://lessisbetter.site/tags/%E8%81%8C%E4%B8%9A%E5%8F%91%E5%B1%95/"/>
    
  </entry>
  
  <entry>
    <title>Fabric 1.4源码解读 9：从账本角度看Peer</title>
    <link href="http://lessisbetter.site/2020/01/03/fabric-peer-ledger/"/>
    <id>http://lessisbetter.site/2020/01/03/fabric-peer-ledger/</id>
    <published>2020-01-03T12:58:03.000Z</published>
    <updated>2020-02-14T07:02:17.527Z</updated>
    
    <content type="html"><![CDATA[<p>区块链最核心的是<strong>可信数据</strong>，所有的功能与设计根源都是数据。本次从数据存储的角度，看一看Peer。</p><h2 id="账本"><a href="#账本" class="headerlink" title="账本"></a>账本</h2><p>区块链的数据存储在账本中，账本包含：</p><ul><li>区块存储<ul><li>区块文件</li><li>区块索引数据库</li></ul></li><li>世界状态数据库</li><li>历史数据库</li><li>私有数据数据库</li></ul><p>关于账本以上各数据库的工具，<a href="https://hyperledger-fabric-cn.readthedocs.io/zh/latest/ledger/ledger.html" target="_blank" rel="noopener">官方文档</a>中对区块存储和世界状态数据库介绍的比较详细了，但我们介绍下它没有提到的。</p><h3 id="区块文件和区块索引数据库"><a href="#区块文件和区块索引数据库" class="headerlink" title="区块文件和区块索引数据库"></a>区块文件和区块索引数据库</h3><p>区块是保存在文件中的，<strong>为了快速查找区块、交易</strong>，Fabric建立了索引，指明某通道某区块高度的第x个交易，是存在哪个文件，偏移量是多少。当然，索引还包含了区块高度、区块hash等，方便根据高度、hash查询区块。</p><p><img src="http://img.lessisbetter.site/2020-01-blockfile-index.png" alt=""></p><p>上图展示了一个区块文件存储区块的情况，每个区块包含：</p><ul><li>区块长度</li><li>区块头</li><li>每条交易长度、交易数据</li></ul><p>每个区块的开始位置、交易的开始位置，在写区块的时候记录下来，然后写到索引数据库（Index DB）。</p><p><strong>整个Fabric网络只有1个区块索引数据库，也就是多通道共用一个</strong>。</p><h3 id="历史数据库"><a href="#历史数据库" class="headerlink" title="历史数据库"></a>历史数据库</h3><p><strong>用来记录交易中每个状态数据的历史信息，直白点可以理解为链码中某个key的历史数值</strong>。它的key实际是<code>{通道id+链码id, key, 区块高度, 交易在区块中的序号}</code>组成的<strong>复合key</strong>，值为空，并且只包含有效的交易。</p><p>有这样一个问题：值为空，到底怎么查询到历史状态呢？</p><p>答：通过历史数据库合成复合key，但复合key中没有交易在区块中的序号，创建一个迭代器，迭代器可以获取包含key的复合key，然后从复合key中提取到交易在区块的序号，然后去区块文件中提取交易，再提取到写集的Value，就可以合成某个key的所有历史值。</p><p>因此<strong>查询历史状态，需要结合历史数据库和区块文件</strong>。</p><h2 id="各数据库实现"><a href="#各数据库实现" class="headerlink" title="各数据库实现"></a>各数据库实现</h2><p><strong>区块文件使用文件直接存储区块，没有使用数据库的原因</strong>是：区块是一种自然的追加操作，写入后不再修改，即不会覆盖历史区块，使用文件系统直接存储区块，可以达到区块最快落盘的目的，因为向文件写区块是顺序写，而写数据库是随机写，磁盘（包含HD、SSD）的顺序写性能要高于随机写。</p><p>世界状态数据库可以使用leveldb或者CouchDB，CouchDB支持富查询功能，当链码数据按JSON建模时，CouchDB可以提供更好的数据查询，更多CouchDB的信息见文档<a href="https://stone-fabric.readthedocs.io/zh/latest/couchdb_tutorial.html" target="_blank" rel="noopener">使用 CouchDB</a>。</p><p>其他数据库都使用leveldb作为底层存储。</p><p><img src="http://img.lessisbetter.site/2020-01-peer-ledger-storage.png" alt=""></p><p><strong>提醒</strong>：Fabric支持多通道，逻辑上每个通道拥有一个账本。实现上区块文件是按通道名隔离开了，使用leveldb的各数据库，被各通道共用。</p><h2 id="从数据看Peer功能"><a href="#从数据看Peer功能" class="headerlink" title="从数据看Peer功能"></a>从数据看Peer功能</h2><p>和账本相关的概念还有<strong>区块、交易和状态</strong>，从账本的角度看，账本向上支撑了2类功能：</p><ol><li>数据同步：广播与同步区块</li><li>交易背书：模拟执行交易</li></ol><p>在下图中，数据同步和交易背书分别使用蓝色和橙色的线圈出，底部剩下的2层为账本。</p><p><img src="http://img.lessisbetter.site/2020-01-03-usage-of-peer-ledger.png" alt=""></p><h3 id="账本-1"><a href="#账本-1" class="headerlink" title="账本"></a>账本</h3><p><code>core/ledger</code>实现了Peer的账本功能，包含了账本中的各项数据库，它依赖<code>common/ledger</code>实现区块文件存储，区块文件存储包含3类：</p><ul><li><code>File</code>：把区块保存在文件中，生产环境使用，orderer和peer皆可使用</li><li><code>Json</code>：把文件保证JSON格式的文件中，使用在非生产环境，仅供orderer使用</li><li><code>Ram</code> ：把区块保存在内存中，使用在非生产环境，仅供orderer使用</li></ul><p><code>core/ledger</code>中的：</p><ul><li><code>PeerLedger</code>接口，代表<strong>Peer账本</strong>，主要用来向账本写区块和私有数据，查询区块、交易和私有数据</li><li><code>Txsimulator</code>接口，代表<strong>交易模拟器</strong>，用来模拟执行1条交易</li><li><code>QueryExecutor</code>接口用来查询<strong>最新的</strong>数据</li><li><code>HistoryQueryExecutor</code>接口用来查询<strong>历史</strong>状态</li></ul><h3 id="同步数据"><a href="#同步数据" class="headerlink" title="同步数据"></a>同步数据</h3><p>同步数据有2种方式：</p><ul><li>Deliver服务，Peer使用事件从Orderer获取区块</li><li>Peer向其他节点请求获取某个区间的区块</li></ul><p>虽然Peer获取区块的方式有2种，但收到区块，处理区块的方式只有1种，所以下面分3小节介绍。</p><h4 id="使用Deliver同步区块"><a href="#使用Deliver同步区块" class="headerlink" title="使用Deliver同步区块"></a>使用Deliver同步区块</h4><p>Deliver用来以事件的方式获取区块，场景有2点：</p><ul><li>Peer从Oderer获取区块</li><li>客户端/SDK从Peer获取区块</li></ul><p>在<a href="http://lessisbetter.site/2019/12/17/fabric-blocks-from-orderer-to-peer/">Fabric 1.4源码解读 8：Orderer和Peer的交互</a>中已经介绍了Peer从Orderer获取区块，这里再做一点补充。</p><p>Deliver服务是Orderer和Peer都使用的功能，但Orderer并没有<code>core/ledger</code>，所以从设计和实现上，<code>common/deliver</code>是从<code>common/ledger</code>中直接读区块，而不是<code>core/ledger</code>读区块。</p><h4 id="Peer请求区块"><a href="#Peer请求区块" class="headerlink" title="Peer请求区块"></a>Peer请求区块</h4><p>每个Peer可以通过Gossip得知同通道的、所连接的Peer信息，其中一项就是对方Peer账本的高度。账本高度低的Peer可以向高度高的Peer发送<strong>StateRequest</strong>，请求获取某个连续区间的区块。</p><p>Peer上负责StateRequest的是<code>gossip/state</code>模块，它负责：</p><ul><li>创建StateRequest请求</li><li>处理StateRequest请求，生成StateRequest响应</li><li>处理StateRequest响应</li></ul><p>创建请求：假设Peer1比Peer2少50个区块，并且配置了Peer每次最多取10个区块，Peer1会创建5个StateRequest请求，顺序的向Peer2进行请求，Peer1收到前一个请求的响应后，才发出下一个请求。</p><p>处理请求：实际是从账本读取所请求区块的过程，这个过程主要是读取区块文件，如果区块涉及私密数据，也涉及读取私密数据库，这部分功能主要由<code>gossip/privdata</code>完成，<code>gossip/state</code>把读到的区块和私密数据生成请求响应。</p><h4 id="Peer处理收到的区块"><a href="#Peer处理收到的区块" class="headerlink" title="Peer处理收到的区块"></a>Peer处理收到的区块</h4><p>Peer从Orderer和其他Peer哪获取的区块，最终都会进入到<code>gossip/state</code>，区块会被放入到一个区块缓冲区：<strong>PayloadsBuffer</strong>，默认大小为存储200个区块。</p><p>每个通道账本都有一个goroutine，从各自的PayloadsBuffer拿下一个高度的区块，交给<code>gossip/privdata</code>进行区块的验证和写入。</p><h5 id="验证区块"><a href="#验证区块" class="headerlink" title="验证区块"></a>验证区块</h5><p>这部分功能由<code>core/handler/validation</code>完成。在Fabric 1.4中，StateImpl会调用QueryExecutor查询状态，但实际StateImpl没有被调用。</p><p>验证区块主要是并发验证区块中的交易：</p><ul><li>验证交易中的字段</li><li>验证是否满足背书策略</li><li>验证交易是否调用最新版本的链码</li><li>验证交易是否重复</li></ul><p>交易验证的结果，即交易是否有效，并不会保存在交易中，这样区块中记录所有交易的DataHash就变化了。区块中所有交易的有效性存储在区块的元数据中，区块元数据中有一个有效性数组，依次存放了每个交易的有效性，使用数组的下标，与交易在数组中的顺序，一一对应。</p><p>交易验证后，会修改区块的元数据，把无效的交易设置为响应的无效序号。</p><p>如果缺失区块的私有数据，<code>gossip/privdata</code>会创建获取私有数据的请求，并获取私有数据，当区块和私有数据都准备齐全后，开始<strong>commit</strong>区块和私有数据。</p><h5 id="区块写入账本"><a href="#区块写入账本" class="headerlink" title="区块写入账本"></a>区块写入账本</h5><p>包含2大块：</p><ul><li>交易MVCC验证<ul><li>Fabric要求世界状态数据库支持MVCC，即多版本并发控制，以便交易能够并发执行（背书），在真正修改状态的时候，才判断读写的数据是否冲突，冲突的交易会被标记为无效。关于MVCC我们在下文的背书部分再详细介绍。</li></ul></li><li>把区块写入数据库，以及修改各数据库：<ul><li>把区块写入到区块文件</li><li>把区块、交易的索引写入到索引数据库</li><li>把<strong>有效交易</strong>的写集更新到世界状态</li><li>提交历史数据库</li><li>提交私密数据库</li></ul></li></ul><h5 id="写区块完成后"><a href="#写区块完成后" class="headerlink" title="写区块完成后"></a>写区块完成后</h5><p>写区块完成后，还需要做一些<strong>修剪</strong>操作：私密数据是有有效期的，比如存活100个区块时间，假如在1000高度写入了某私有数据，第1100写入账本后，私密数据就要从私密数据库被抹除。</p><h3 id="背书"><a href="#背书" class="headerlink" title="背书"></a>背书</h3><p>Peer除了记账的另外一个角色就是背书，背书很重要的一个环节就是模拟执行交易。</p><h4 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h4><p>Fabric为了提供更高的系统性能，支持并发的执行交易，交易在执行过程中会读写世界状态数据库，也就存在并发访问数据库的场景，为了安全的访问数据库数据，就需要对数据库的并发进行限制。</p><p>Draveness在<a href="https://draveness.me/database-concurrency-control" target="_blank" rel="noopener">浅谈数据库并发控制 - 锁和 MVCC</a>种介绍了并发控制3种手段：悲观锁、乐观锁和MVCC。</p><p>Fabric选择了MVCC，它要求世界状态数据库支持MVCC，本质上讲任何支持MVCC的数据库，都可以用来实现状态数据库。</p><p>MVCC是多版本并发控制的缩写，它是一种思想，而不是一种具体的算法，所以不同的数据库实现的MVCC不同。</p><p>在MVCC的数据存储中，数据有版本的概念，写一个数据的值，实际上是创建了一个新的版本来保存数据。</p><p>MVCC可以实现并发读写的能力，当读数据时，先确定待读数据的版本，然后从该版本读取数据，写数据时，创建新的版本保存数据。读数据必然是已经存在的版本，而写数据是新的版本，因此读写可以并行。</p><p><img src="http://img.lessisbetter.site/2020-01-mvcc-read-write.png" alt=""></p><h4 id="Fabric对MVCC的使用"><a href="#Fabric对MVCC的使用" class="headerlink" title="Fabric对MVCC的使用"></a>Fabric对MVCC的使用</h4><p>背书节点在模拟执行交易的过程中，会生成读写集，<strong>读集和写集分别是所有待写key读出来时的版本和待写入的新值</strong>。</p><p>交易并发执行到写入区块的过程中存在2种<strong>读写冲突</strong>的情况：</p><ol><li>同一个区块中的前后两笔交易，后面的交易读集包含某个key，但key在前面交易的写集：也就说后面交易读的是老版本的数据，是一种脏读的情况</li><li>区块中交易的读集的某个key，某之前区块的交易写集修改：背书跟写区块是并发执行的，背书时产生的写集，直到写区块才会更新到世界状态数据库，这里存在一段时间，即key已经有了新版本的数据，只是还没有提交到数据库。如果这期间有新的交易模拟执行，就会读到老版本数据，也是一种脏读的情况</li></ol><p>有效交易的写集会被应用到世界状态数据库，被修改数据都会有一个新的版本，这个版本是逻辑版本，成为Hight，由<code>{区块高度,交易在区块内的顺序}</code>组成。</p><blockquote><p>注：验证函数为 <code>validateTx</code>，读写集冲突错误为 <code>TxValidationCode_MVCC_READ_CONFLICT</code> ，另一个读写冲突错误为 <code>TxValidationCode_PHANTOM_READ_CONFLICT</code>， 因为执行过程中有RangeQuery，查询某个区间的Key，也需要验证这些Key是否冲突，底层本质还是读写集的验证。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文从账本的视角，介绍了Peer的账本，以及和账本打交道的功能。</p><p>真正企业级的区块链、大用户规模的区块链，必然能够支撑大量的并发交易，这对账本以及底层存储，都会提出更高的性能要求、磁盘利用率要求，所以理解和掌握账本和存储机制是非常有必要的。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://draveness.me/database-concurrency-control" target="_blank" rel="noopener">浅谈数据库并发控制 - 锁和 MVCC</a></li><li><a href="https://en.wikipedia.org/wiki/Multiversion_concurrency_control" target="_blank" rel="noopener">WIKI: MVCC</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;区块链最核心的是&lt;strong&gt;可信数据&lt;/strong&gt;，所有的功能与设计根源都是数据。本次从数据存储的角度，看一看Peer。&lt;/p&gt;
&lt;h2 id=&quot;账本&quot;&gt;&lt;a href=&quot;#账本&quot; class=&quot;headerlink&quot; title=&quot;账本&quot;&gt;&lt;/a&gt;账本&lt;/h2&gt;&lt;
      
    
    </summary>
    
    
    
      <category term="区块链" scheme="http://lessisbetter.site/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Fabric" scheme="http://lessisbetter.site/tags/Fabric/"/>
    
  </entry>
  
</feed>
