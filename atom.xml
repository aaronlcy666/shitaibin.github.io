<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Go语言充电站</title>
  
  <subtitle>大彬 less is better</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lessisbetter.site/"/>
  <updated>2020-07-29T11:49:32.733Z</updated>
  <id>http://lessisbetter.site/</id>
  
  <author>
    <name>大彬</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go语言日期和时间戳转换</title>
    <link href="http://lessisbetter.site/2020/07/29/go-time-date-timestamp/"/>
    <id>http://lessisbetter.site/2020/07/29/go-time-date-timestamp/</id>
    <published>2020-07-29T11:48:59.000Z</published>
    <updated>2020-07-29T11:49:32.733Z</updated>
    
    <content type="html"><![CDATA[<p>字符串格式日期、time.Time类型、整形时间戳三者之间的转换如下图：</p><p><img src="http://img.lessisbetter.site/2020-07-go-time-date-transform.png" alt=""></p><p>有2点要注意：</p><ol><li>字符串日期和时间戳之间不能直接转换，需要通过time.Time完成。</li><li>涉及字符串日期的时候，字符串日期格式一定要以Go诞生的时间为基准，而不是随意的时间，否则会导致时间转换不正确。所以，以下Demo中的日期格式是通用的。</li><li>字符串日期格式要与真实的日期格式完全匹配，否则会解析时间不正确。比如设置的格式为<code>2006-01-02</code>，实际日期格式为<code>2006-1-2</code>时会解析错误。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Date2Time</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"&gt;&gt; Date2Time"</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"&lt;&lt; Date2Time"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一定要以Go诞生的时间为基准</span></span><br><span class="line"><span class="comment">// 2006年1月2号，MST时区，下午3:04分为基准</span></span><br><span class="line"><span class="keyword">const</span> dateFormat = <span class="string">"Jan 2, 2006 at 3:04pm (MST)"</span></span><br><span class="line">t, _ := time.Parse(dateFormat, <span class="string">"May 20, 2020 at 0:00am (UTC)"</span>)</span><br><span class="line">fmt.Println(t)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> shortForm = <span class="string">"2006-Jan-02"</span></span><br><span class="line">t, _ = time.Parse(shortForm, <span class="string">"2020-May-20"</span>)</span><br><span class="line">fmt.Println(t)</span><br><span class="line"></span><br><span class="line">t, _ = time.Parse(<span class="string">"01/02/2006"</span>, <span class="string">"05/20/2020"</span>)</span><br><span class="line">fmt.Println(t)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Time2Date</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"&gt;&gt; Time2Date"</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"&lt;&lt; Time2Date"</span>)</span><br><span class="line"></span><br><span class="line">tm := time.Now()</span><br><span class="line">fmt.Println(tm.Format(<span class="string">"2006-01-02 03:04:05 PM"</span>))</span><br><span class="line">fmt.Println(tm.Format(<span class="string">"2006-1-2 03:04:05 PM"</span>))</span><br><span class="line">fmt.Println(tm.Format(<span class="string">"2006-Jan-02 03:04:05 PM"</span>))</span><br><span class="line">fmt.Println(tm.Format(<span class="string">"02/01/2006 03:04:05 PM"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Timestamp2Time</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"&gt;&gt; Timestamp2Time"</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"&lt;&lt; Timestamp2Time"</span>)</span><br><span class="line"></span><br><span class="line">ts := <span class="keyword">int64</span>(<span class="number">1595900001</span>)</span><br><span class="line">tm := time.Unix(ts, <span class="number">0</span>)</span><br><span class="line">fmt.Println(tm)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Time2Timestamp</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"&gt;&gt; Time2Timestamp"</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"&lt;&lt; Time2Timestamp"</span>)</span><br><span class="line"></span><br><span class="line">tm := time.Now()</span><br><span class="line">ts := tm.Unix()</span><br><span class="line">fmt.Println(ts)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">Date2Time()</span><br><span class="line">Time2Date()</span><br><span class="line">Timestamp2Time()</span><br><span class="line">Time2Timestamp()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; Date2Time</span><br><span class="line">2020-05-20 00:00:00 +0000 UTC</span><br><span class="line">2020-05-20 00:00:00 +0000 UTC</span><br><span class="line">2020-05-20 00:00:00 +0000 UTC</span><br><span class="line">&lt;&lt; Date2Time</span><br><span class="line">&gt;&gt; Time2Date</span><br><span class="line">2020-07-28 09:35:46 AM</span><br><span class="line">2020-7-28 09:35:46 AM</span><br><span class="line">2020-Jul-28 09:35:46 AM</span><br><span class="line">28&#x2F;07&#x2F;2020 09:35:46 AM</span><br><span class="line">&lt;&lt; Time2Date</span><br><span class="line">&gt;&gt; Timestamp2Time</span><br><span class="line">2020-07-28 09:33:21 +0800 CST</span><br><span class="line">&lt;&lt; Timestamp2Time</span><br><span class="line">&gt;&gt; Time2Timestamp</span><br><span class="line">1595900146</span><br><span class="line">&lt;&lt; Time2Timestamp</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;字符串格式日期、time.Time类型、整形时间戳三者之间的转换如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.lessisbetter.site/2020-07-go-time-date-transform.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;有2点
      
    
    </summary>
    
    
    
      <category term="Go" scheme="http://lessisbetter.site/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>SSH常用命令和配置</title>
    <link href="http://lessisbetter.site/2020/07/28/about-ssh/"/>
    <id>http://lessisbetter.site/2020/07/28/about-ssh/</id>
    <published>2020-07-28T13:11:15.000Z</published>
    <updated>2020-07-28T13:12:11.547Z</updated>
    
    <content type="html"><![CDATA[<h2 id="生成SSH密钥"><a href="#生成SSH密钥" class="headerlink" title="生成SSH密钥"></a>生成SSH密钥</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -f ~/.ssh/id_rsa -C <span class="string">"temp user"</span> -N <span class="string">""</span></span><br></pre></td></tr></table></figure><p>-t：指定加密算法<br>-f：指定路径<br>-C：注释，可以填写用户名或邮箱<br>-N：密码</p><p>指定以上<code>f、C、N</code>这3个参数，可以避免交互式问答，快速生成密钥，在脚本中使用很方便。</p><h2 id="SSH客户端配置文件"><a href="#SSH客户端配置文件" class="headerlink" title="SSH客户端配置文件"></a>SSH客户端配置文件</h2><p><code>~/.ssh/config</code>文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Read more about SSH config files: https:&#x2F;&#x2F;linux.die.net&#x2F;man&#x2F;5&#x2F;ssh_config</span><br><span class="line">Host 个人VM</span><br><span class="line">    HostName 192.168.9.137</span><br><span class="line">    User centos</span><br><span class="line"></span><br><span class="line">Host 阿里云</span><br><span class="line">    HostName 139.224.105.10</span><br><span class="line">    User root</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">Host 腾讯云</span><br><span class="line">    HostName 140.143.6.185</span><br><span class="line">    User root</span><br><span class="line">    Port 22</span><br><span class="line">    IdentityFile ~&#x2F;.ssh&#x2F;id_rsa_tencent</span><br></pre></td></tr></table></figure><ul><li>Host：自定义命名</li><li>HostName：机器IP或者域名</li><li>User：登录机器的用户名</li><li>Port：登录机器的端口，默认为22，可省略</li><li>IdentityFile：登录机器时使用的私钥，默认为<code>~/.ssh/id_rsa</code>，可省略；当某台机器使用单独密钥时，很有用</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;生成SSH密钥&quot;&gt;&lt;a href=&quot;#生成SSH密钥&quot; class=&quot;headerlink&quot; title=&quot;生成SSH密钥&quot;&gt;&lt;/a&gt;生成SSH密钥&lt;/h2&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gu
      
    
    </summary>
    
    
    
      <category term="Linux" scheme="http://lessisbetter.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>如何选择开源协议</title>
    <link href="http://lessisbetter.site/2020/05/05/open-source-license/"/>
    <id>http://lessisbetter.site/2020/05/05/open-source-license/</id>
    <published>2020-05-05T06:37:26.000Z</published>
    <updated>2020-05-05T06:58:26.497Z</updated>
    
    <content type="html"><![CDATA[<p>当基于开源项目发布新的开源项目时，我们需要说明项目所使用的License，同样也需要考虑你基于开源项目所做的事情，是否满足该项目的License。</p><p>下面这2幅图摘自 <a href="https://www.zhihu.com/question/28292322" target="_blank" rel="noopener">开源许可证都有什么区别,一般开源项目用什么许可证? - 知乎</a>，足以帮助我们判断：</p><ol><li>要做的事情，是否满足开源项目的License。</li><li>开源一个项目，该如何选择License。</li></ol><p><img src="http://img.lessisbetter.site/2020-05-license-choose.jpg" alt=""><br>来源：<a href="https://www.zhihu.com/question/28292322/answer/656121132" target="_blank" rel="noopener">https://www.zhihu.com/question/28292322/answer/656121132</a></p><p><img src="http://img.lessisbetter.site/2020-05-license-2.jpg" alt=""><br>来源：<a href="https://www.zhihu.com/question/28292322/answer/840556759" target="_blank" rel="noopener">https://www.zhihu.com/question/28292322/answer/840556759</a><br>从左到右，是从宽松到严格。</p><p>举例：</p><ol><li>以太坊采License用的是LGPLv3，修改源码后如果提供给外部使用必须开源，不要求新增代码采用相同的License，也不要求对新增代码进行文档说明，后来我们项目同样采用了LGPLv3。</li><li>Fabric采用Apache 2.0，基于Fabric项目原有代码都必须放置Fabric原有版权声明，但可以选择不开源。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当基于开源项目发布新的开源项目时，我们需要说明项目所使用的License，同样也需要考虑你基于开源项目所做的事情，是否满足该项目的License。&lt;/p&gt;
&lt;p&gt;下面这2幅图摘自 &lt;a href=&quot;https://www.zhihu.com/question/2829232
      
    
    </summary>
    
    
    
      <category term="开源" scheme="http://lessisbetter.site/tags/%E5%BC%80%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>Fabric 1.4源码解读 10：可扩展密码服务提供者BCCSP，以及可扩展国密</title>
    <link href="http://lessisbetter.site/2020/04/12/fabric-bccsp/"/>
    <id>http://lessisbetter.site/2020/04/12/fabric-bccsp/</id>
    <published>2020-04-12T06:32:33.000Z</published>
    <updated>2020-04-12T08:14:56.193Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>密码学是当代数字信息化时代的基础技术，没有密码学，网络上的传输信息的可靠性就无法保证，比如你输入的密码会被窃取，你存在网络上的照片、文档如果没有加密，就有可能泄露。</p><p>密码学也是区块链的一项基础技术，使用密码学实现区块链中的：身份验证、数据可信、权限管理、零知识证明、可信计算等等。</p><p>Fabric提供了模块化的、可插拔的密码服务，该服务由<code>bccsp</code>模块提供，本文就谈一下BCCSP插件化设计，另外Fabric国密化也是最近2年必做的事情，所以同时介绍实现可扩展国密的思路，最后介绍一下Hyperledger社区对Fabric支持国密的开发。</p><h2 id="BCCSP介绍"><a href="#BCCSP介绍" class="headerlink" title="BCCSP介绍"></a>BCCSP介绍</h2><p>BCCSP是Block Chain Crypto Service Provider的缩写。</p><p><code>bccsp</code>模块它为Fabric的上层模块提供密码学服务，它包含的具体功能有：对称加密和非对称加密的密钥生成、导如、导出，数字签名和验证，对称加密和解密、摘要计算。</p><p><code>bccsp</code>模块为了密码服务的扩展性，定义了<code>BCCSP</code>接口，上层模块调用<code>BCCSP</code>接口中定义的方法，而不直接调用具体的实现函数，实现和具体密码学实现的解耦，当<code>bccsp</code>使用不同密码学实现时，上层模块无需修改，这种解耦是通过<strong>依赖反转</strong>实现的。</p><p>bccsp模块中当前有2种密码实现，它们都是bccsp中的密码学插件：SW和PKCS11，SW代表的是国际标准加密的软实现，SW是software的缩写，PKCS11代指硬实现。</p><p><img src="http://img.lessisbetter.site/2020-04-fabric-bccsp.png" alt=""></p><blockquote><p>扩展阅读：PKCS11是PKCS系列标准中的第11个，它定义了应用层和底层加密设备的交互标准，比如过去在电脑上，插入USBKey用网银转账时，就需要走USBKey中的硬件进行数字签名，这个过程就需要使用PCKS11。</p></blockquote><p>密码学通常有软实现和硬实现，软实现就是常用的各种加密库，比如Go中<code>crypto</code>包，硬实现是使用加密机提供的一套加密服务。软实现和硬实现的重要区别是，密码算法的安全性强依赖随机数，软实现利用的是OS的伪随机数，而硬实现利用的是加密机生成的随机数，所以硬实现的安全强度要高于软实现。</p><p>让Fabric支持国密时，就需要在bccsp中新增一个国密插件<code>GM</code>，只在bccsp中增加GM并不是完成的Fabric国密改造，下文再详细介绍。</p><h2 id="SW介绍"><a href="#SW介绍" class="headerlink" title="SW介绍"></a>SW介绍</h2><p>SW是国际标准加密的软实现插件，它包含了ECDSA算法、RSA算法、AES算法，以及SHA系列的摘要算法。</p><p><code>BCCSP</code>接口定义了以下方法，其实对密码学中的函数进行了一个功能分类：</p><ul><li><code>KeyGen</code>：密钥生成，包含对称和非对称加密</li><li><code>KeyDeriv</code>：密钥派生</li><li><code>KeyImport</code>：密钥导入，从文件、内存、数字证书中导入</li><li><code>GetKey</code>：获取密钥</li><li><code>Hash</code>：计算摘要</li><li><code>GetHash</code>：获取摘要计算实例</li><li><code>Sign</code>：数字签名</li><li><code>Verify</code>：签名验证</li><li><code>Encrypt</code>：数据加密，包含对称和非对称加密</li><li><code>Decrypt</code>：数据解密，包含对称和非对称加密</li></ul><p>SW要做的是，把ECDSA、RSA、AES、SHA中的各种函数，对应到以上各种分类中，主要的分类如下图所示。</p><p><img src="http://img.lessisbetter.site/2020-04-12-bccsp-sw.png" alt=""></p><p>从上图可以看出，密钥生成、派生、导入都包含了ECDSA、RSA、AES，签名和延签包含了ECDSA和RSA，摘要计算包含了SHA系列，加密解密包含了AES，但没有包含RSA，是因为非对称加密耗时，并不常用。</p><h2 id="可插拔国密"><a href="#可插拔国密" class="headerlink" title="可插拔国密"></a>可插拔国密</h2><p>Fabric支持国密并非仅仅在bccsp中增加1个国密实现这么简单，还需要让数字证书支持国密，让数字证书的操作符合X.509。各语言的标准库<code>x509</code>都是适配标准加密的，并不能直接用来操作国密证书。</p><p>在数字证书支持国密后，还可能需要进一步考虑，是否需要TLS证书使用国密数字证书，让通信过程使用国密算法。</p><p>另外，国密的实现有很多版本，如果需要适配不同的国密实现，就需要保证国密的可插拔和可扩展。</p><p>综上情况，你需要一个中间件，中间件中包含定义好国密接口、国密数字证书接口等，用这些接口去适配Fabric，然后当采用不同国密实现时，只需要对具体实现进行封装，去适配中间件中定义好的接口。</p><p><img src="http://img.lessisbetter.site/2020-04-fabric-gm.png" alt=""></p><h2 id="社区对Fabric支持国密的态度"><a href="#社区对Fabric支持国密的态度" class="headerlink" title="社区对Fabric支持国密的态度"></a>社区对Fabric支持国密的态度</h2><p>国密有很多基于Fabric的项目，金融业是区块链场景最多的行业，金融行业又必须使用国密，所以国内对Fabric国密的改造是必须的，在《金融分布式账本安全规范》发布之后，社区也计划让Fabric支持国密，但方式是不提供具体国密实现，而是定义好接口，项目方使用哪种国密实现，去适配定义好的接口即可，这样保留了好的扩展性，与<a href="#可插拔国密">可插拔国密</a>的目的是一致的，选择权交给企业。</p><p>社区支持Fabric国密的版本，预计在2.x版本发布。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>密码学在区块链中的地位是相当高的，从区块链使用最基础的密码学，到现在还在不断融入同态加密、零知识证明等前言的加密技术，未来可以在区块链上保护数据隐私的情况，提供更好的服务，区块链也可以有更多的应用场景。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h2&gt;&lt;p&gt;密码学是当代数字信息化时代的基础技术，没有密码学，网络上的传输信息的可靠性就无法保证，比如你输入的密码会被窃取，你存在网络上的照片、文档如果
      
    
    </summary>
    
    
    
      <category term="区块链" scheme="http://lessisbetter.site/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Fabric" scheme="http://lessisbetter.site/tags/Fabric/"/>
    
      <category term="密码学" scheme="http://lessisbetter.site/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>提高画时序图的效率</title>
    <link href="http://lessisbetter.site/2020/03/23/markdown-mermaid/"/>
    <id>http://lessisbetter.site/2020/03/23/markdown-mermaid/</id>
    <published>2020-03-23T07:28:40.000Z</published>
    <updated>2020-03-23T07:30:04.354Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mermaid-js.github.io/mermaid/#/README" target="_blank" rel="noopener">mermaid</a>是一个开源项目，可以在Markdown中，使用类似编写代码的方式，制作流程图、时序图、甘特图、饼图等。使用下来，感觉可以明显提升时序图的效率。</p><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    %% 注释</span><br><span class="line">    Client -&gt;&gt; Gateway: 发送JSON RPC请求</span><br><span class="line">    Gateway -&gt;&gt; Gateway: JSON RPC请求转换为gRPC请求</span><br><span class="line">    Gateway -&gt;&gt; Server: 发送gRPC请求</span><br><span class="line">    Server -&gt;&gt; Server: 处理gRPC请求</span><br><span class="line">    Server -&gt;&gt; Gateway: 发送gRPC响应</span><br><span class="line">    Gateway -&gt;&gt; Gateway: gRPC响应转换为JSON RPC响应</span><br><span class="line">    Gateway -&gt;&gt; Client: 把JSON RPC响应发送给客户端</span><br></pre></td></tr></table></figure><pre class="mermaid">sequenceDiagram    %% 注释    Client ->> Gateway: 发送JSON RPC请求    Gateway ->> Gateway: JSON RPC请求转换为gRPC请求    Gateway ->> Server: 发送gRPC请求    Server ->> Server: 处理gRPC请求    Server ->> Gateway: 发送gRPC响应    Gateway ->> Gateway: gRPC响应转换为JSON RPC响应    Gateway ->> Client: 把JSON RPC响应发送给客户端</pre><h4 id="昵称"><a href="#昵称" class="headerlink" title="昵称"></a>昵称</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant C as Client</span><br><span class="line">    participant G as Gateway</span><br><span class="line">    participant S as Server</span><br><span class="line"></span><br><span class="line">    C -&gt;&gt; G: 发送JSON RPC请求</span><br><span class="line">    G -&gt;&gt; G: JSON RPC请求转换为gRPC请求</span><br><span class="line">    G -&gt;&gt; S: 发送gRPC请求</span><br><span class="line">    S -&gt;&gt; S: 处理gRPC请求</span><br><span class="line">    S -&gt;&gt; G: 发送gRPC响应</span><br><span class="line">    G -&gt;&gt; G: gRPC响应转换为JSON RPC响应</span><br><span class="line">    G -&gt;&gt; C: 把JSON RPC响应发送给客户端</span><br></pre></td></tr></table></figure><pre class="mermaid">sequenceDiagram    participant C as Client    participant G as Gateway    participant S as Server    C ->> G: 发送JSON RPC请求    G ->> G: JSON RPC请求转换为gRPC请求    G ->> S: 发送gRPC请求    S ->> S: 处理gRPC请求    S ->> G: 发送gRPC响应    G ->> G: gRPC响应转换为JSON RPC响应    G ->> C: 把JSON RPC响应发送给客户端</pre><h4 id="线条和箭头"><a href="#线条和箭头" class="headerlink" title="线条和箭头"></a>线条和箭头</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    Client -&gt; Gateway: 实线</span><br><span class="line">    Client --&gt; Gateway: 虚线 --</span><br><span class="line">    Client -&gt;&gt; Gateway: 带箭头 &gt;&gt;</span><br><span class="line">    Client -x Gateway: 带叉，不使用&gt;</span><br></pre></td></tr></table></figure><pre class="mermaid">sequenceDiagram    Client -> Gateway: 实线    Client --> Gateway: 虚线 --    Client ->> Gateway: 带箭头 >>    Client -x Gateway: 带叉，不使用></pre><h4 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    Note left of Client: 创建请求</span><br><span class="line">    Note right of Gateway: 接收请求</span><br></pre></td></tr></table></figure><pre class="mermaid">sequenceDiagram    Note left of Client: 创建请求    Note right of Gateway: 接收请求</pre><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    loop Every Second</span><br><span class="line">        Client -&gt;&gt; Server: 发送请求</span><br><span class="line">        Server -&gt;&gt; Server: 处理请求</span><br><span class="line">        Server -&gt;&gt; Client: 发送响应</span><br><span class="line">    end</span><br></pre></td></tr></table></figure><pre class="mermaid">sequenceDiagram    loop Every Second        Client ->> Server: 发送请求        Server ->> Server: 处理请求        Server ->> Client: 发送响应    end</pre><h4 id="If语句"><a href="#If语句" class="headerlink" title="If语句"></a>If语句</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    Client -&gt;&gt; Server: 查询用户</span><br><span class="line">    alt User not found</span><br><span class="line">        Server -&gt;&gt; Server: 创建错误响应：用户不存在</span><br><span class="line">    else </span><br><span class="line">        Server -&gt;&gt; Server: 使用用户信息创建响应</span><br><span class="line">    end</span><br><span class="line">    Server -&gt;&gt; Client: 发送响应</span><br></pre></td></tr></table></figure><pre class="mermaid">sequenceDiagram    Client ->> Server: 查询用户    alt User not found        Server ->> Server: 创建错误响应：用户不存在    else         Server ->> Server: 使用用户信息创建响应    end    Server ->> Client: 发送响应</pre><h4 id="背景颜色"><a href="#背景颜色" class="headerlink" title="背景颜色"></a>背景颜色</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    Client -&gt;&gt; Server: 发送请求</span><br><span class="line">    rect rgb(191,223,255)</span><br><span class="line">    Server -&gt;&gt; Server: 处理请求</span><br><span class="line">    Server -&gt;&gt; Client: 发送响应</span><br><span class="line">    end</span><br></pre></td></tr></table></figure><pre class="mermaid">sequenceDiagram    Client ->> Server: 发送请求    rect rgb(191,223,255)    Server ->> Server: 处理请求    Server ->> Client: 发送响应    end</pre><h4 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    Client -&gt;&gt; Server: 发送请求</span><br><span class="line">    activate Server</span><br><span class="line">    Server -&gt;&gt; Server: 处理请求</span><br><span class="line">    Server -&gt;&gt; Client: 发送响应</span><br><span class="line">    deactivate Server</span><br></pre></td></tr></table></figure><pre class="mermaid">sequenceDiagram    Client ->> Server: 发送请求    activate Server    Server ->> Server: 处理请求    Server ->> Client: 发送响应    deactivate Server</pre><h3 id="饼图"><a href="#饼图" class="headerlink" title="饼图"></a>饼图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pie</span><br><span class="line">    title 硬币正反面的概率</span><br><span class="line">    &quot;正面&quot;: 0.5</span><br><span class="line">    &quot;反面&quot;: 0.5</span><br></pre></td></tr></table></figure><pre class="mermaid">pie    title 硬币正反面的概率    "正面": 0.5    "反面": 0.5</pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://mermaid-js.github.io/mermaid/#/README&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;mermaid&lt;/a&gt;是一个开源项目，可以在Markdown中，使用类似编写代码的方式，制作流程图、
      
    
    </summary>
    
    
    
      <category term="写作" scheme="http://lessisbetter.site/tags/%E5%86%99%E4%BD%9C/"/>
    
      <category term="工具" scheme="http://lessisbetter.site/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Markdown" scheme="http://lessisbetter.site/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>为什么PBFT需要View Changes</title>
    <link href="http://lessisbetter.site/2020/03/22/why-pbft-needs-viewchange/"/>
    <id>http://lessisbetter.site/2020/03/22/why-pbft-needs-viewchange/</id>
    <published>2020-03-22T06:10:53.000Z</published>
    <updated>2020-04-11T09:33:20.052Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在当前的PBFT资料中，尤其是中文资料，多数都在介绍PBFT的3阶段消息过程，很少提及View Changes（视图切换），View Changes对PBFT的重要性，如同Leader Election对Raft的重要性，它是一个一致性算法中，不可或缺的部分。</p><p>作者为大家介绍下，为什么View Changes如此重要，即为什么PBFT需要View Changes，以及View Changes的原理。</p><h2 id="为什么PBFT需要View-Changes"><a href="#为什么PBFT需要View-Changes" class="headerlink" title="为什么PBFT需要View Changes"></a>为什么PBFT需要View Changes</h2><p>一致性算法都要提供：</p><ul><li>safety ：原意指不会出现错误情况，一致性中指操作是正确的，得到相同的结果。</li><li>liveness ：操作过程能在有限时间内完成。</li></ul><p><img src="http://img.lessisbetter.site/2020-03-consistency-property.png" alt="一致性协议需要满足的特性"></p><p><strong>safety通常称为一致性，liveness通常称为可用性</strong>，没有liveness的一致性算法无法长期提供一致性服务，没有safety的一致性算法称不上一致性算法，所以，所有的一致性算法都在做二者之间的折中。</p><p>所以对一致性和可用性不同的要求，就出现了你常听见的ACID原理、CAP理论、BASE理论。</p><p>PBFT作为一个一致性算法，它也需要提供一致性和可用性。在<a href="https://lessisbetter.site/2020/03/15/why-pbft-needs-3-phase-message/">为什么PBFT需要3个阶段消息</a>中，介绍了PBFT算法的如何达成一致性，并且请求可以在有限时间内达成一致，客户端得到响应，也满足可用性。</p><p>但没有介绍，当遇到以下情况时，是否还能保住一致性和可用性呢？</p><ol><li>主节点是拜占庭节点（宕机、拒绝响应…）</li><li>主节点不是拜占庭节点，但非拜占庭副本节点参与度不足，不足以完成3阶段消息</li><li>网络不畅，丢包严重，造成不足以完成3阶段消息</li><li>…</li></ol><p>在以上场景中，<strong>新的请求无法在有限时间内达成一致，老的数据可以保持一致性，所以一致性是可以满足的，但可用性无法满足</strong>。必须寻找一个方案，恢复集群的可用性。</p><p><strong>PBFT算法使用View Changes，让集群重新具有可用性</strong>。通过View Changes，可以选举出新的、让请求在有限时间内达成一致的主节点，向客户端响应，从而满足可用性的要求。</p><p>让集群重新恢复可用，需要做到什么呢？<strong>让至少f+1个非拜占庭节点迁移到，新的一致的状态</strong>。然后这些节点，运行3阶段消息协议，处理新的客户端请求，并达成一致。</p><h2 id="不同版本的View-Changes协议有什么不同？"><a href="#不同版本的View-Changes协议有什么不同？" class="headerlink" title="不同版本的View Changes协议有什么不同？"></a>不同版本的View Changes协议有什么不同？</h2><p>PBFT算法有1999年和2001年2个版本：</p><ul><li>99年：<a href="http://pmg.csail.mit.edu/papers/osdi99.pdf" target="_blank" rel="noopener">Practical Byzantine Fault Tolerance</a>，PBFT初次发表。</li><li>01年：<a href="http://www.pmg.csail.mit.edu/papers/bft-tocs.pdf" target="_blank" rel="noopener">Practical Byzantine Fault Tolerance and Proactive Recovery</a>，又称PBFT-PR，让PBFT受攻击时，具有主动恢复能力。</li></ul><p>PBFT-PR并非只是在PBFT上增加了PR，同时也对PBFT算法做了详细的介绍和改进，View Changes的改进就是其中一项。</p><p>PBFT中View Changes介绍比较简单，没有说明以下场景下，View Changes协议如何处理：</p><ul><li>如果下一个View的主节点宕机了怎么办</li><li>如果下一个View的主节点是恶意节点，作恶怎么办</li><li>如果非拜占庭恶意发起View Changes，造成主节点切换怎么办？</li><li>如果参与View Changes的节点数量不足怎么办</li></ul><p>如果，以上场景下，节点处在View Changes阶段，持续的等待下去，就无法恢复集群的可用性。</p><p>PBFT-PR中的View Changes协议进行了细化，可以解决以上问题。</p><h2 id="2001年版本View-Changes协议原理"><a href="#2001年版本View-Changes协议原理" class="headerlink" title="2001年版本View Changes协议原理"></a>2001年版本View Changes协议原理</h2><p>每个主节点都拥有一个View，就如同Raft中每个leader都拥有1个term。不同点是term所属的leader是选举出来的，而View所属的主节点是计算出的： <code>primary = v % R</code>，R是运行PBFT协议的节点数量。</p><p>View Changes的战略是：当副本节点怀疑主节点无法让请求达成一致时，发起视图切换，新的主节点收集当前视图中已经Prepared，但未Committed的请求，传递到下一个视图中，所有非拜占庭节点基于以上请求，会达到一个新的、一致的状态。然后，正常运行3阶段消息协议。</p><p>为什么要包含已经Prepared，但未Committed的请求？如果一个请求，在副本节点i上，已经是Prepared状态，证明至少f+1的非拜占庭节点，已经拥有此请求并赞成请求req在视图v中使用序号n。如果没有问题，不发生视图切换，这些请求可以在有限的时间内达成一致，新的主节点把已经Prepared的请求，带到新的view，并证明给其他节点，请求已经Prepared，那只需1轮Commit就可以达成一致。</p><h3 id="View-Changes主要流程简介"><a href="#View-Changes主要流程简介" class="headerlink" title="View Changes主要流程简介"></a>View Changes主要流程简介</h3><p>对View Changes的流程可以分为2部分：</p><ul><li>View Changes的开端，即每一次View的开始</li><li>View Changes的中间过程，以及View Changes的结束，切换到正常流程</li></ul><p>这2部分分别占据了下图的左右两部分。实线代表流程线，虚线代表网络消息。蓝色代表正常操作流程（三阶段消息：Preprepare、Prepare、Commit），青色代表View Changes流程，蓝青相接就是正常流程和View Changes流程切换的地方。</p><p><img src="http://img.lessisbetter.site/2020-04-09-blueprint-view-changes.png" alt=""></p><p>View Changes的开端流程是通用的，主节点和副本节点都遵守这一流程：<code>新视图：v=v+1</code>，代表一个新的View开始，指向它的每一个箭头，都是视图切换的一种原因。某个副本节点，新视图的开始，还伴随着广播<code>view-change</code>消息，告诉其他节点，本节点开启了一个新的视图。</p><p>主节点是通过公式算出来的，其余为副本节点，在View Changes流程中，副本节点会和主节点交互，共同完成View Changes过程。副本节点会对收到的<code>view-change</code>消息进行检查，然后把一条对应的<code>view-change-ack</code>消息发送给主节点，主节点会依赖收到的<code>view-change</code>消息和<code>view-change-ack</code>消息数量和内容，产生能让所有节点移动到统一状态的<code>new-view</code>消息，并且对<code>new-view</code>消息进行3阶段共识，即对<code>new-view</code>消息达成一致，从而让至少<code>f+1</code>个非拜占庭节点达成一致。</p><h3 id="View-Changes的开端"><a href="#View-Changes的开端" class="headerlink" title="View Changes的开端"></a>View Changes的开端</h3><p>View Change的核心因素只有一个：怀疑当前的主节点在有限的时间内，无法达成一致。</p><p>具体有4个路径：</p><ol><li>正常阶段定时器超时，代表一定时间内无法完成Pre-prepare -&gt; Prepare -&gt; Commit</li><li>View Changes阶段定时器超时，代表一定时间内无法完成正在进行的View Change</li><li>定时器未超时，但有效的view-change消息数量达到f+1个，代表当前已经有f+1个非拜占庭节点发起了新的视图切换，本节点为了不落后，不等待超时而进入视图切换</li><li>new-view消息不合法，代表当前View Changes阶段的主节点为拜占庭节点</li></ol><p>图中【正常阶段定时器超时】被标记为蓝色，是因为它是正常阶段进入视图切换阶段的开端，【有效的view-change消息数量达到f+1个】即有可能是正常阶段的定时器，也有可能是视图切换过程中的定时器，所以颜色没做调整。</p><h3 id="主副节点主要交互流程"><a href="#主副节点主要交互流程" class="headerlink" title="主副节点主要交互流程"></a>主副节点主要交互流程</h3><p>视图切换过程中有3个消息：view-change消息、view-change-ack消息和new-view消息，下文围绕这3个消息，对主副节点的交互流程做详细介绍。</p><h3 id="view-change消息阶段"><a href="#view-change消息阶段" class="headerlink" title="view-change消息阶段"></a>view-change消息阶段</h3><p>在view v时，副本节点怀疑主节点fault时，会发送view-change消息，该消息包含：</p><ol><li>h：副本i最新的稳定检查点序号</li><li>C：副本i保存的h之后的（非稳定）检查点</li><li>P和Q</li><li>i：副本i</li><li>α：副本i对本消息的数字签名</li></ol><p>P和Q是2个集合。</p><p>P是已经Prepared消息的信息集合：消息既然已经Prepared，说明<strong>至少2f+1的节点拥有了消息，并且认可<code>&lt;view, n, d&gt;</code></strong>，即为消息分配的view和序号，只是还差一步commit阶段就可以完成一致性确认。P中包含的就是已经达到Prepared的消息的摘要d，无需包含完整的请求消息。新的view中，这些请求会使用老的序号n，而无需分配新的序号。</p><p>Q是已经Pre-prepared消息的信息集合，主节点已经发送Pre-prepare或副本节点i为请求已经发送Prepare消息，证明<strong>该节点认可<code>&lt;n, d, v&gt;</code></strong>。</p><p>P、Q中的请求都是高低水位之间的，无View Changes时，P、Q都是空的，也就是说不包含已经committed的请求。new-view消息中的数据（View Changes的决策结果），都是基于P、Q集合计算出的。</p><p>在发送view-change消息前，副本节点会利用日志中的三阶段消息计算P、Q集合，发送view-change消息后，就删除日志中的三阶段消息。</p><h3 id="view-change-ack消息阶段"><a href="#view-change-ack消息阶段" class="headerlink" title="view-change-ack消息阶段"></a>view-change-ack消息阶段</h3><p>视图<code>v+1</code>的主节点在收到其他节点发送的view-change消息后，并不确认view-change消息是是否拜占庭节点发出的，即不确定消息是否是正确无误的，如果基于错误的消息做决策，就会得到错误的结果，违反一致性：一切操作都是正确的。</p><p>设置view-change-ack消息的目的是，让所有副本节点对所有它收到的view-change消息进行检查和确认，只不过确认的结果都发送给新的主节点。主节点统计ack消息，可以辨别哪些view-change是正确的，哪些是拜占庭节点发出的。</p><p>副本节点会对view-change消息中的P、Q集合进行检查，要求集合中的请求消息小于等于视图<code>v</code>，满足则发送view-change-ack消息：</p><ol><li>v：v+1</li><li>i：发送ack消息的副本序号</li><li>j：副本i要确认的view-change消息的发送方</li><li>d：副本i要确认的view-change消息的摘要</li><li>μip：i向主节点p发送消息的通信密钥计算出的MAC，这里需要保证i和p之间通信的私密性，所以不使用数字签名</li></ol><h3 id="new-view消息阶段"><a href="#new-view消息阶段" class="headerlink" title="new-view消息阶段"></a>new-view消息阶段</h3><p>新视图主节点p负责基于view-change消息做决策，决策放到new-view消息中。</p><p>主节点p维护了一个集合S，用来存放正确的view-change消息。只有view-change消息，以及为该消息背书的view-change-ack消息达到<code>2f-1</code>个时，view-change消息才能加入到集合S，但view-change-ack消息不加入集合S。</p><p>当集合S的大小达到<code>2f+1</code>时，证明有足够多的非拜占庭节点认为需要进行视图变更，并提供了变更的依据：2f+1个view-change消息，主节点p使用S做决策。以下便是<strong>决策逻辑</strong>。</p><p>主节点p先确定h：所有view-change消息中最大的稳定检查点。h和h+L其实就是高低水位。</p><p>然后依次检查h到h+L中的每一个序号n，对序号n对于的请求进行的处理为：请求m已经Prepared并且Pre-prepared，则收集序号n对应的请求。否则，说明没有请求在序号n能达到committed，为序号n分配一个空请求，并收集起来。它们最后会被放到new-view消息的X集合中。</p><p>主节点会创建new-view消息：</p><ul><li>view：当前新视图的编号</li><li>V：是一个集合，每个元素是一对<code>(i, d)</code>，代表i发送的view-change消息摘要是d，每一对都与集合S中消息对应，可以使用V证明主节点是在满足条件下，创建new-view消息的，即V是新视图的证明。因为其它多数副本节点已经接收view-change消息，所以此处发送消息的摘要做对比即可。</li><li>X：是一个集合，包含检查点以及选定的请求</li><li>α：主节点p对new-view消息的数字签名</li></ul><p>之后，主节点会把new-view消息广播给每一个副本节点。</p><h3 id="处理new-view消息"><a href="#处理new-view消息" class="headerlink" title="处理new-view消息"></a>处理new-view消息</h3><h4 id="主节点处理new-view消息"><a href="#主节点处理new-view消息" class="headerlink" title="主节点处理new-view消息"></a>主节点处理new-view消息</h4><p>在发生View Changes时，主节点的状态可能也不是最全的，如果它没有X结合中的请求或者检查点，它可以从其他节点哪拉去。</p><p>主节点需要使用new-view消息，达到视图切换的最后一步状态：在新视图v+1中，让集合X中的请求，全部是Pre-prepared状态。为何是Pre-prepared状态呢？因为new-view消息，可以看做一次特殊的Pre-prepare消息。</p><p>为什么不直接标记为Committed呢？因为主节点也可能是拜占庭节点，副本节点需要检查new-view消息，向所有节点广播自己检查的结果，满足条件后才能达成一致性。</p><h4 id="副本节点处理new-view消息"><a href="#副本节点处理new-view消息" class="headerlink" title="副本节点处理new-view消息"></a>副本节点处理new-view消息</h4><p>副本节点在视图v+1，会持续接收view-change消息和new-view消息，它会把new-view消息V集合中的view-change消息，跟它收到的消息做对比，如果它本地不存在某条view-change消息，它可以要求主节点向他提供view-change消息和view-change-ack消息集合，证明至少f+1个非拜占庭副本节点收到过此view-change消息。</p><p>副本节点拥有所有的view-change消息之后，副本节点会和主节点运行相同的决策逻辑，以校验new-view消息的正确性。</p><p>如果new-view消息是正确的，副本节点会和主节点一样移动到相同的状态，然后广播一条Prepare消息给所有节点，这样就恢复到了正常情况下的：<code>Pre-prepare -&gt; Prepare -&gt; Commit</code> 一致性逻辑。这样就完成了从View Changes到正常处理流程的迁移。</p><p>如果new-view消息是错误的，说明主节点p是拜占庭节点，副本节点会直接进入v+2，发送view-change消息，进行新的一轮视图切换。</p><h3 id="View-Changes如何提供liveness"><a href="#View-Changes如何提供liveness" class="headerlink" title="View Changes如何提供liveness"></a>View Changes如何提供liveness</h3><p>在一轮视图切换无法完成的时候，会开启新的一轮视图切换，由于拜占庭节点的数量最多为f个，最终会在某一轮视图切换中，能够完成视图切换，所有非拜占庭节点达成一致的状态，保证liveness和safety。</p><p>本文前面列出了几种异常情况，下面就看一下View Changes是如何应对这些异常情况的，以及如何提供活性。</p><p>Q1：如果下一个View的主节点宕机了怎么办？</p><p>A1：副本节点在收集到2f+1个view-change消息后，会启动定时器，超时时间为T，新view的主节点宕机，必然会导致定时器超时时，未能完成View Changes流程，会进入新一轮视图切换。</p><p>Q2：如果下一个View的主节点是恶意节点，作恶怎么办？</p><p>A2：新view的主节点是恶意节点，如果它做恶了，生成的new-view消息不合法，副本节点可以检测出来。或者new-view消息是合法的，但它只发送给了少数副本节点，副本节点在对new-view消息进行正常的3阶段流程，参与的节点太少，在定时器超时前，不足以完成3阶段流程，副本节点会进入下一轮视图切换。</p><p>Q3：如果非拜占庭恶意发起View Changes，造成主节点切换怎么办？</p><p>A3：定时器未超时情况下，只有有效的f+1个view-change消息，才会引发其他副本节点进行主节点切换，否则无法造成主节点切换。但PBFT的前提条件是恶意节点不足f个，所以只有恶意节点发起view-change消息时，无法造成主节点切换。</p><p>Q4：如果参与View Changes的节点数量不足怎么办？</p><p>A4：这个问题可以分几种情况。</p><ul><li>发起view-change的节点数量不足f+1个，这种情况不会发生整个集群的视图切换。</li><li>视图切换过程中，不满足各节点的数量要求，无法完成本轮视图切换，会进入下一轮视图切换。</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>View Changes是PBFT中一个重要的环节，它能保证整个协议的liveness，是PBFT不可或缺的一部分。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在当前的PBFT资料中，尤其是中文资料，多数都在介绍PBFT的3阶段消息过程，很少提及View Changes（视图切换），View Cha
      
    
    </summary>
    
    
    
      <category term="一致性" scheme="http://lessisbetter.site/tags/%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    
      <category term="区块链" scheme="http://lessisbetter.site/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="PBFT" scheme="http://lessisbetter.site/tags/PBFT/"/>
    
      <category term="共识算法" scheme="http://lessisbetter.site/tags/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Go官方进程诊断工具gops详解</title>
    <link href="http://lessisbetter.site/2020/03/15/gops-introduction/"/>
    <id>http://lessisbetter.site/2020/03/15/gops-introduction/</id>
    <published>2020-03-15T12:20:47.000Z</published>
    <updated>2020-03-17T09:50:48.528Z</updated>
    
    <content type="html"><![CDATA[<h2 id="gops简介"><a href="#gops简介" class="headerlink" title="gops简介"></a>gops简介</h2><p><a href="https://github.com/google/gops" target="_blank" rel="noopener">gops</a> 是Go团队提供的命令行工具，它可以用来获取go进程运行时信息。</p><p>可以查看：</p><ul><li>当前有哪些go语言进程，哪些使用gops的go进程</li><li>进程的概要信息</li><li>进程的调用栈</li><li>进程的内存使用情况</li><li>构建程序的Go版本</li><li>运行时统计信息</li></ul><p>可以获取：</p><ul><li>trace</li><li>cpu profile和memory profile</li></ul><p>还可以：</p><ul><li>让进程进行1次GC</li><li>设置GC百分比</li></ul><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>使用<code>Options</code>配置agent。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"runtime"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/google/gops/agent"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := agent.Listen(agent.Options&#123;</span><br><span class="line">Addr:            <span class="string">"0.0.0.0:8848"</span>,</span><br><span class="line"><span class="comment">// ConfigDir:       "/home/centos/gopsconfig", // 最好使用默认</span></span><br><span class="line">ShutdownCleanup: <span class="literal">true</span>&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试代码</span></span><br><span class="line">_ = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">1000</span>, <span class="number">1000</span>)</span><br><span class="line">runtime.GC()</span><br><span class="line"></span><br><span class="line">_ = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">1000</span>, <span class="number">2000</span>)</span><br><span class="line">runtime.GC()</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Hour)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="agent-Option选项"><a href="#agent-Option选项" class="headerlink" title="agent Option选项"></a>agent Option选项</h2><p>agent有3个配置：</p><ul><li><code>Addr</code>：agent要监听的ip和端口，默认ip为环回地址，端口随机分配。</li><li><code>ConfigDir</code>：该目录存放的不是agent的配置，而是每一个使用了agent的go进程信息，文件以pid命名，内容是该pid进程所监听的端口号，所以其中文件的目的是形成pid到端口的映射。默认值为<code>~/.config/gops</code></li><li><code>ShutdownCleanup</code>：进程退出时，是否清理ConfigDir中的文件，默认值为false，不清理</li></ul><p>通常可以把<code>Addr</code>设置为要监听的IP，把<code>ShutdownCleanup</code>设置为<code>ture</code>，进程退出后，残留在ConfigDir目录的文件不再有用，最好清除掉。</p><p><code>ConfigDir</code>示例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// gopsconfig为设置的ConfigDir目录，2051为pid，8848为端口号。</span><br><span class="line">➜  ~ cat gopsconfig/2051</span><br><span class="line">8848%</span><br><span class="line">➜  ~ netstat -nap | grep `pgrep gopsexample`</span><br><span class="line">tcp6       0      0 :::8848                 :::*                    LISTEN      2051/./gopsexample</span><br></pre></td></tr></table></figure><h2 id="gops原理"><a href="#gops原理" class="headerlink" title="gops原理"></a>gops原理</h2><p>gops的原理是，代码中导入<code>gops/agent</code>，建立agent服务，gops命令连接<code>agent</code>读取进程信息。</p><p><img src="http://img.lessisbetter.site/2020-03-gops.png" alt="gops"></p><p><code>agent</code>的实现原理可以查看<code>agent/handle</code><a href="https://github.com/google/gops/blob/master/agent/agent.go#L182" target="_blank" rel="noopener">函数</a>。</p><p>使用go标准库中原生接口实现相关功能，如同你要在自己的程序中开启pprof类似，只不过这部分功能由<code>gops/agent</code>实现了：</p><ul><li>使用<code>runtime.MemStats</code>获取内存情况</li><li>使用<code>runtime/pprof</code>获取调用栈、cpu profile和memory profile</li><li>使用<code>runtime/trace</code>获取trace</li><li>使用<code>runtime</code>获取stats信息</li><li>使用<code>runtime/debug</code>、<code>GC</code>设置和启动GC</li></ul><p>再谈<code>ConfigDir</code>。从源码上看，<code>ConfigDir</code>对agent并没有用途，对gops有用。当gops和ConfigDir在一台机器上时，即gops查看本机的go进程信息，gops可以通过其中的文件，快速找到agent服务的端口。能够实现：<code>gops &lt;sub-cmd&gt; pid</code>到<code>gops &lt;sub-cmd&gt; 127.0.0.1:port</code>的转换。</p><p>如果代码中通过<code>ConfigDir</code>指定了其他目录，使用<code>gops</code>时，需要添加环境变量<code>GOPS_CONFIG_DIR</code>指向<code>ConfigDir</code>使用的目录。</p><h2 id="子命令介绍"><a href="#子命令介绍" class="headerlink" title="子命令介绍"></a>子命令介绍</h2><p>gops后面可以跟子命令，然后是pid或者远端地址。</p><p>也可以直接跟pid，查看本机进程信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ gops help memstats</span><br><span class="line">gops is a tool to list and diagnose Go processes.</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  gops &lt;cmd&gt; &lt;pid|addr&gt; ...</span><br><span class="line">  gops &lt;pid&gt; # displays process info</span><br><span class="line">  gops help  # displays this help message</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  stack      Prints the stack trace.</span><br><span class="line">  gc         Runs the garbage collector and blocks until successful.</span><br><span class="line">  setgc     Sets the garbage collection target percentage.</span><br><span class="line">  memstats   Prints the allocation and garbage collection stats.</span><br><span class="line">  version    Prints the Go version used to build the program.</span><br><span class="line">  stats      Prints runtime stats.</span><br><span class="line">  trace      Runs the runtime tracer for 5 secs and launches &quot;go tool trace&quot;.</span><br><span class="line">  pprof-heap Reads the heap profile and launches &quot;go tool pprof&quot;.</span><br><span class="line">  pprof-cpu  Reads the CPU profile and launches &quot;go tool pprof&quot;.</span><br><span class="line"></span><br><span class="line">All commands require the agent running on the Go process.</span><br><span class="line">&quot;*&quot; indicates the process is running the agent.</span><br></pre></td></tr></table></figure><h3 id="查看当前机器上go程序进程信息"><a href="#查看当前机器上go程序进程信息" class="headerlink" title="查看当前机器上go程序进程信息"></a>查看当前机器上go程序进程信息</h3><p>查看当前机器上的go进程，可以列出pid、ppid、进程名、可执行程序所使用的go版本，以及可执行程序的路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ gops</span><br><span class="line">67292 66333 gops                         * go1.13    &#x2F;Users&#x2F;shitaibin&#x2F;Workspace&#x2F;golang_step_by_step&#x2F;gops&#x2F;gops</span><br><span class="line">67434 65931 gops                           go1.13    &#x2F;Users&#x2F;shitaibin&#x2F;go&#x2F;bin&#x2F;gops</span><br><span class="line">66551 1     gocode                         go1.11.2  &#x2F;Users&#x2F;shitaibin&#x2F;go&#x2F;bin&#x2F;gocode</span><br><span class="line">137   1     com.docker.vmnetd              go1.12.7  &#x2F;Library&#x2F;PrivilegedHelperTools&#x2F;com.docker.vmnetd</span><br><span class="line">811   807   com.docker.backend             go1.12.13 &#x2F;Applications&#x2F;Docker.app&#x2F;Contents&#x2F;MacOS&#x2F;com.docker.backend</span><br><span class="line">807   746   com.docker.supervisor          go1.12.13 &#x2F;Applications&#x2F;Docker.app&#x2F;Contents&#x2F;MacOS&#x2F;com.docker.supervisor</span><br><span class="line">810   807   com.docker.driver.amd64-linux  go1.12.13 &#x2F;Applications&#x2F;Docker.app&#x2F;Contents&#x2F;MacOS&#x2F;com.docker.driver.amd64-linux</span><br></pre></td></tr></table></figure><p>带<code>*</code>的是程序中使用了gops/agent，不带<code>*</code>的是普通的go程序。</p><h3 id="go程序进程树"><a href="#go程序进程树" class="headerlink" title="go程序进程树"></a>go程序进程树</h3><p>查看进程树：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ gops tree</span><br><span class="line">...</span><br><span class="line">├── 66333</span><br><span class="line">│   └── [*]  67292 (gops) &#123;go1.13&#125;</span><br><span class="line">├── 1</span><br><span class="line">│   ├── 66551 (gocode) &#123;go1.11.2&#125;</span><br><span class="line">│   └── 137 (com.docker.vmnetd) &#123;go1.12.7&#125;</span><br><span class="line">├── 65931</span><br><span class="line">│   └── 67476 (gops) &#123;go1.13&#125;</span><br><span class="line">└── 746</span><br><span class="line">    └── 807 (com.docker.supervisor) &#123;go1.12.13&#125;</span><br><span class="line">        ├── 811 (com.docker.backend) &#123;go1.12.13&#125;</span><br><span class="line">        └── 810 (com.docker.driver.amd64-linux) &#123;go1.12.13&#125;</span><br></pre></td></tr></table></figure><h3 id="pid：进程概要信息"><a href="#pid：进程概要信息" class="headerlink" title="pid：进程概要信息"></a>pid：进程概要信息</h3><p>查看进程的概要信息，非gops进程也可以：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ gops 67292</span><br><span class="line">parent PID:66333</span><br><span class="line">threads:7</span><br><span class="line">memory usage:0.018%</span><br><span class="line">cpu usage:0.000%</span><br><span class="line">username:shitaibin</span><br><span class="line">cmd+args:.&#x2F;gops</span><br><span class="line">elapsed time:11:28</span><br><span class="line">local&#x2F;remote:127.0.0.1:54753 &lt;-&gt; :0 (LISTEN)</span><br><span class="line">➜  ~</span><br><span class="line">➜  ~ gops 807</span><br><span class="line">parent PID:746</span><br><span class="line">threads:28</span><br><span class="line">memory usage:0.057%</span><br><span class="line">cpu usage:0.003%</span><br><span class="line">username:shitaibin</span><br><span class="line">cmd+args:&#x2F;Applications&#x2F;Docker.app&#x2F;Contents&#x2F;MacOS&#x2F;com.docker.supervisor -watchdog fd:0</span><br><span class="line">elapsed time:27-23:36:35</span><br><span class="line">local&#x2F;remote:127.0.0.1:54832 &lt;-&gt; :0 ()</span><br><span class="line">local&#x2F;remote:*:53849 &lt;-&gt; :0 ()</span><br><span class="line">local&#x2F;remote:127.0.0.1:49473 &lt;-&gt; :0 (LISTEN)</span><br></pre></td></tr></table></figure><h3 id="stack：当前调用栈"><a href="#stack：当前调用栈" class="headerlink" title="stack：当前调用栈"></a>stack：当前调用栈</h3><p>查看使用gops的进程的调用栈：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ gops stack 67292</span><br><span class="line">goroutine 19 [running]:</span><br><span class="line">runtime&#x2F;pprof.writeGoroutineStacks(0x1197160, 0xc00009c028, 0x0, 0x0)</span><br><span class="line">&#x2F;Users&#x2F;shitaibin&#x2F;goroot&#x2F;src&#x2F;runtime&#x2F;pprof&#x2F;pprof.go:679 +0x9d</span><br><span class="line">runtime&#x2F;pprof.writeGoroutine(0x1197160, 0xc00009c028, 0x2, 0x0, 0x0)</span><br><span class="line">&#x2F;Users&#x2F;shitaibin&#x2F;goroot&#x2F;src&#x2F;runtime&#x2F;pprof&#x2F;pprof.go:668 +0x44</span><br><span class="line">runtime&#x2F;pprof.(*Profile).WriteTo(0x1275c60, 0x1197160, 0xc00009c028, 0x2, 0xc00009c028, 0x0)</span><br><span class="line">&#x2F;Users&#x2F;shitaibin&#x2F;goroot&#x2F;src&#x2F;runtime&#x2F;pprof&#x2F;pprof.go:329 +0x3da</span><br><span class="line">github.com&#x2F;google&#x2F;gops&#x2F;agent.handle(0x1665008, 0xc00009c028, 0xc000014068, 0x1, 0x1, 0x0, 0x0)</span><br><span class="line">&#x2F;Users&#x2F;shitaibin&#x2F;go&#x2F;src&#x2F;github.com&#x2F;google&#x2F;gops&#x2F;agent&#x2F;agent.go:185 +0x1ab</span><br><span class="line">github.com&#x2F;google&#x2F;gops&#x2F;agent.listen()</span><br><span class="line">&#x2F;Users&#x2F;shitaibin&#x2F;go&#x2F;src&#x2F;github.com&#x2F;google&#x2F;gops&#x2F;agent&#x2F;agent.go:133 +0x2bf</span><br><span class="line">created by github.com&#x2F;google&#x2F;gops&#x2F;agent.Listen</span><br><span class="line">&#x2F;Users&#x2F;shitaibin&#x2F;go&#x2F;src&#x2F;github.com&#x2F;google&#x2F;gops&#x2F;agent&#x2F;agent.go:111 +0x364</span><br><span class="line"></span><br><span class="line">goroutine 1 [sleep]:</span><br><span class="line">runtime.goparkunlock(...)</span><br><span class="line">&#x2F;Users&#x2F;shitaibin&#x2F;goroot&#x2F;src&#x2F;runtime&#x2F;proc.go:310</span><br><span class="line">time.Sleep(0x34630b8a000)</span><br><span class="line">&#x2F;Users&#x2F;shitaibin&#x2F;goroot&#x2F;src&#x2F;runtime&#x2F;time.go:105 +0x157</span><br><span class="line">main.main()</span><br><span class="line">&#x2F;Users&#x2F;shitaibin&#x2F;Workspace&#x2F;golang_step_by_step&#x2F;gops&#x2F;example.go:15 +0xa3</span><br><span class="line"></span><br><span class="line">goroutine 18 [syscall]:</span><br><span class="line">os&#x2F;signal.signal_recv(0x0)</span><br><span class="line">&#x2F;Users&#x2F;shitaibin&#x2F;goroot&#x2F;src&#x2F;runtime&#x2F;sigqueue.go:144 +0x96</span><br><span class="line">os&#x2F;signal.loop()</span><br><span class="line">&#x2F;Users&#x2F;shitaibin&#x2F;goroot&#x2F;src&#x2F;os&#x2F;signal&#x2F;signal_unix.go:23 +0x22</span><br><span class="line">created by os&#x2F;signal.init.0</span><br><span class="line">&#x2F;Users&#x2F;shitaibin&#x2F;goroot&#x2F;src&#x2F;os&#x2F;signal&#x2F;signal_unix.go:29 +0x41</span><br></pre></td></tr></table></figure><h3 id="memstats-内存使用情况"><a href="#memstats-内存使用情况" class="headerlink" title="memstats: 内存使用情况"></a>memstats: 内存使用情况</h3><p>查看gops进程内存使用情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ gops memstats 67944</span><br><span class="line">alloc: 136.80KB (140088 bytes) &#x2F;&#x2F; 当前分配出去未收回的内存总量</span><br><span class="line">total-alloc: 152.08KB (155728 bytes) &#x2F;&#x2F; 已分配出去的内存总量</span><br><span class="line">sys: 67.25MB (70518784 bytes) &#x2F;&#x2F; 当前进程从OS获取的内存总量</span><br><span class="line">lookups: 0</span><br><span class="line">mallocs: 418 &#x2F;&#x2F; 分配的对象数量</span><br><span class="line">frees: 82 &#x2F;&#x2F; 释放的对象数量</span><br><span class="line">heap-alloc: 136.80KB (140088 bytes) &#x2F;&#x2F; 当前分配出去未收回的堆内存总量</span><br><span class="line">heap-sys: 63.56MB (66650112 bytes) &#x2F;&#x2F; 当前堆从OS获取的内存</span><br><span class="line">heap-idle: 62.98MB (66035712 bytes) &#x2F;&#x2F; 当前堆中空闲的内存量</span><br><span class="line">heap-in-use: 600.00KB (614400 bytes) &#x2F;&#x2F; 当前堆使用中的内存量</span><br><span class="line">heap-released: 62.89MB (65945600 bytes)</span><br><span class="line">heap-objects: 336 &#x2F;&#x2F; 堆中对象数量</span><br><span class="line">stack-in-use: 448.00KB (458752 bytes) &#x2F;&#x2F; 栈使用中的内存量 </span><br><span class="line">stack-sys: 448.00KB (458752 bytes) &#x2F;&#x2F; 栈从OS获取的内存总量 </span><br><span class="line">stack-mspan-inuse: 10.89KB (11152 bytes)</span><br><span class="line">stack-mspan-sys: 16.00KB (16384 bytes)</span><br><span class="line">stack-mcache-inuse: 13.56KB (13888 bytes)</span><br><span class="line">stack-mcache-sys: 16.00KB (16384 bytes)</span><br><span class="line">other-sys: 1.01MB (1062682 bytes)</span><br><span class="line">gc-sys: 2.21MB (2312192 bytes)</span><br><span class="line">next-gc: when heap-alloc &gt;&#x3D; 4.00MB (4194304 bytes) &#x2F;&#x2F; 下次GC的条件</span><br><span class="line">last-gc: 2020-03-16 10:06:26.743193 +0800 CST &#x2F;&#x2F; 上次GC的世界</span><br><span class="line">gc-pause-total: 83.84µs &#x2F;&#x2F; GC总暂停时间</span><br><span class="line">gc-pause: 44891 &#x2F;&#x2F; 上次GC暂停时间，单位纳秒</span><br><span class="line">num-gc: 2 &#x2F;&#x2F; 已进行的GC次数</span><br><span class="line">enable-gc: true &#x2F;&#x2F; 是否开始GC</span><br><span class="line">debug-gc: false</span><br></pre></td></tr></table></figure><h3 id="stats-运行时信息"><a href="#stats-运行时信息" class="headerlink" title="stats: 运行时信息"></a>stats: 运行时信息</h3><p>查看运行时统计信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ gops stats 68125</span><br><span class="line">goroutines: 3</span><br><span class="line">OS threads: 12</span><br><span class="line">GOMAXPROCS: 8</span><br><span class="line">num CPU: 8</span><br></pre></td></tr></table></figure><h3 id="trace"><a href="#trace" class="headerlink" title="trace"></a>trace</h3><p>获取当前运行5s的trace信息，会打开网页：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ gops trace 68125</span><br><span class="line">Tracing now, will take 5 secs...</span><br><span class="line">Trace dump saved to: &#x2F;var&#x2F;folders&#x2F;5g&#x2F;rz16gqtx3nsdfs7k8sb80jth0000gn&#x2F;T&#x2F;trace116447431</span><br><span class="line">2020&#x2F;03&#x2F;16 10:23:37 Parsing trace...</span><br><span class="line">2020&#x2F;03&#x2F;16 10:23:37 Splitting trace...</span><br><span class="line">2020&#x2F;03&#x2F;16 10:23:37 Opening browser. Trace viewer is listening on http:&#x2F;&#x2F;127.0.0.1:55480</span><br></pre></td></tr></table></figure><h3 id="cpu-profile"><a href="#cpu-profile" class="headerlink" title="cpu profile"></a>cpu profile</h3><p>获取cpu profile，并进入交互模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ gops pprof-cpu 68125</span><br><span class="line">Profiling CPU now, will take 30 secs...</span><br><span class="line"></span><br><span class="line">Profile dump saved to: &#x2F;var&#x2F;folders&#x2F;5g&#x2F;rz16gqtx3nsdfs7k8sb80jth0000gn&#x2F;T&#x2F;profile431166544</span><br><span class="line">Binary file saved to: &#x2F;var&#x2F;folders&#x2F;5g&#x2F;rz16gqtx3nsdfs7k8sb80jth0000gn&#x2F;T&#x2F;binary765361519</span><br><span class="line">File: binary765361519</span><br><span class="line">Type: cpu</span><br><span class="line">Time: Mar 16, 2020 at 10:25am (CST)</span><br><span class="line">Duration: 30s, Total samples &#x3D; 0</span><br><span class="line">No samples were found with the default sample value type.</span><br><span class="line">Try &quot;sample_index&quot; command to analyze different sample values.</span><br><span class="line">Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)</span><br><span class="line">(pprof)</span><br><span class="line">(pprof) top</span><br><span class="line">Showing nodes accounting for 0, 0% of 0 total</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br></pre></td></tr></table></figure><h3 id="memory-profile"><a href="#memory-profile" class="headerlink" title="memory profile"></a>memory profile</h3><p>获取memory profile，并进入交互模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ gops pprof-heap 68125</span><br><span class="line">Profile dump saved to: &#x2F;var&#x2F;folders&#x2F;5g&#x2F;rz16gqtx3nsdfs7k8sb80jth0000gn&#x2F;T&#x2F;profile292136242</span><br><span class="line">Binary file saved to: &#x2F;var&#x2F;folders&#x2F;5g&#x2F;rz16gqtx3nsdfs7k8sb80jth0000gn&#x2F;T&#x2F;binary693335273</span><br><span class="line">File: binary693335273</span><br><span class="line">Type: inuse_space</span><br><span class="line">Time: Mar 16, 2020 at 10:27am (CST)</span><br><span class="line">No samples were found with the default sample value type.</span><br><span class="line">Try &quot;sample_index&quot; command to analyze different sample values.</span><br><span class="line">Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)</span><br><span class="line">(pprof)</span><br><span class="line">(pprof) traces</span><br><span class="line">File: binary693335273</span><br><span class="line">Type: inuse_space</span><br><span class="line">Time: Mar 16, 2020 at 10:27am (CST)</span><br><span class="line">-----------+-------------------------------------------------------</span><br><span class="line">     bytes:  256kB</span><br><span class="line">         0   compress&#x2F;flate.(*compressor).init</span><br><span class="line">             compress&#x2F;flate.NewWriter</span><br><span class="line">             compress&#x2F;gzip.(*Writer).Write</span><br><span class="line">             runtime&#x2F;pprof.(*profileBuilder).build</span><br><span class="line">             runtime&#x2F;pprof.profileWriter</span><br><span class="line">-----------+-------------------------------------------------------</span><br><span class="line">     bytes:  64kB</span><br><span class="line">         0   compress&#x2F;flate.newDeflateFast</span><br><span class="line">             compress&#x2F;flate.(*compressor).init</span><br><span class="line">             compress&#x2F;flate.NewWriter</span><br><span class="line">             compress&#x2F;gzip.(*Writer).Write</span><br><span class="line">             runtime&#x2F;pprof.(*profileBuilder).build</span><br><span class="line">             runtime&#x2F;pprof.profileWriter</span><br><span class="line">-----------+-------------------------------------------------------</span><br></pre></td></tr></table></figure><h2 id="使用远程连接"><a href="#使用远程连接" class="headerlink" title="使用远程连接"></a>使用远程连接</h2><p>agent的默认配置<code>Option{}</code>，监听的是环回地址。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ sudo netstat -nap | grep 414</span><br><span class="line">➜  ~ netstat -nap | grep `pgrep gopsexample`</span><br><span class="line">(Not all processes could be identified, non-owned process info</span><br><span class="line"> will not be shown, you would have to be root to see it all.)</span><br><span class="line">tcp        0      0 127.0.0.1:36812         0.0.0.0:*               LISTEN      414/./gopsexample</span><br></pre></td></tr></table></figure><p>修改程序，在<code>Option</code>中设置监听的地址和端口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">agent.Listen(agent.Options&#123;Addr:<span class="string">"0.0.0.0:8848"</span>&#125;)</span><br></pre></td></tr></table></figure><p>在远程主机上重新编译、重启进程，确认进程监听的端口：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ netstat -nap | grep `pgrep gopsexample`</span><br><span class="line">(Not all processes could be identified, non-owned process info</span><br><span class="line"> will not be shown, you would have to be root to see it all.)</span><br><span class="line">tcp6       0      0 :::8848                 :::*                    LISTEN      887/./gopsexample</span><br></pre></td></tr></table></figure><p>在本地主机上使用gops连接远端go进程，并查看数据：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ gops stats 192.168.9.137:8848</span><br><span class="line">goroutines: 3</span><br><span class="line">OS threads: 9</span><br><span class="line">GOMAXPROCS: 4</span><br><span class="line">num CPU: 4</span><br></pre></td></tr></table></figure><p><code>gops</code>后面只能跟pid查看进程简要信息，不能跟ip和port查看远端go进程简要信息，这些简要信息可以通过子命令汇集起来。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ gops 192.168.9.137:8848</span><br><span class="line">gops: unknown subcommand</span><br><span class="line">➜  ~ </span><br><span class="line">➜  ~ gops version 192.168.9.137:8848</span><br><span class="line">go1.13</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;gops简介&quot;&gt;&lt;a href=&quot;#gops简介&quot; class=&quot;headerlink&quot; title=&quot;gops简介&quot;&gt;&lt;/a&gt;gops简介&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/google/gops&quot; target=&quot;_blan
      
    
    </summary>
    
    
    
      <category term="Go" scheme="http://lessisbetter.site/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>为什么PBFT需要3个阶段消息？</title>
    <link href="http://lessisbetter.site/2020/03/15/why-pbft-needs-3-phase-message/"/>
    <id>http://lessisbetter.site/2020/03/15/why-pbft-needs-3-phase-message/</id>
    <published>2020-03-15T01:25:41.000Z</published>
    <updated>2020-03-25T00:49:54.116Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在面试的时候，很多同学的简历熟悉PBFT共识算法，在现场面试的时候，却只能说个主要逻辑，离完整的算法，还差十万八千里，相似从网络上看了一些文章，就算是熟悉了。当我问“为什么PBFT需要3个阶段消息？2个阶段行不行”时，还没有人能回答出来。</p><p>回答这个问题，还要从PBFT要解决的本质问题说起，所以我打算以这样一个思路，为大家回答问题：</p><ul><li>PBFT与拜占庭问题</li><li>拜占庭节点在网络中的行为</li><li>什么是3阶段消息</li><li>3阶段消息解决什么问题</li><li>为什么不能只有前2个阶段</li><li>论文使用的2个不变性</li><li>为什么3个阶段可以达成一致性</li></ul><h2 id="PBFT与拜占庭问题"><a href="#PBFT与拜占庭问题" class="headerlink" title="PBFT与拜占庭问题"></a>PBFT与拜占庭问题</h2><blockquote><p>莱斯利·兰波特在其论文[1]中描述了如下拜占庭问题：</p><p>一组拜占庭帝国的将军分别各率领一支军队共同围困一座城市。为了简化问题，将各支军队的行动策略限定为进攻或撤离两种。因为部分军队进攻，或部分军队撤离可能会造成灾难性后果，因此各位将军必须通过投票来达成一致策略，即所有军队一起进攻或所有军队一起撤离。因为各位将军分处城市不同方向，他们只能通过信使互相联系。在投票过程中，每位将军都将自己投票进攻还是撤退的信息，通过信使分别通知其他所有将军，这样一来每位将军根据自己的投票，和其他所有将军送来的信息，就可以知道共同的投票结果，而决定行动策略。</p><p>问题在于，将军中可能出现叛徒(坏将军)，他们不仅可能向较为糟糕的策略投票，还可能选择性地发送投票信息。阻止好将军达成一致的形成策略。</p><p>摘自：<a href="https://zh.wikipedia.org/wiki/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">维基百科：拜占庭将军问题</a>，有删改。</p></blockquote><p><em>很多人喜欢玩狼人杀，我也喜欢，但我玩的很菜</em>，我用狼人杀跟拜占庭将军问题做个类比。</p><p>在狼人杀开局的时候，你是好人，并且不知道自己的队友是谁，也不知道狼人是谁，但所有的好人都有一个共同的目的：干死狼人，好人获胜。所以游戏中需要使用技巧和策略，达成目的。</p><p>拜占庭将军问题是类似的，好的将军不知道其他将军是好的，还是坏的，但所有好的将军的目的是：行动一致，共同进退。所以，它们也需要策略达成一致。</p><p>BFT是一类解决拜占庭将军问题的策略/算法：让非拜占庭节点达成一致的算法。在这类论文中，拜占庭节点指“坏”的将军，非拜占庭节点指“好”的将军。</p><p>PBFT是实用拜占庭算法（<a href="http://pmg.csail.mit.edu/papers/osdi99.pdf" target="_blank" rel="noopener">Practical Byzantine Fault Tolerance</a>）的缩写，该论文与1999年发表，另外2001年又发表了一篇<a href="http://www.pmg.csail.mit.edu/papers/bft-tocs.pdf" target="_blank" rel="noopener">Practical Byzantine Fault Tolerance and Proactive Recovery</a>，让PBFT拥有恢复能力。</p><p>PBFT作为解决拜占庭问题的策略：<strong>非拜占庭节点不知道哪些是拜占庭节点，哪些是非拜占庭节点，PBFT要让非拜占庭节点达成一致</strong>。</p><h2 id="拜占庭节点在网络中的行为"><a href="#拜占庭节点在网络中的行为" class="headerlink" title="拜占庭节点在网络中的行为"></a>拜占庭节点在网络中的行为</h2><p>拜占庭问题是在分布式对等网络，对通信容错所提出来的。在真实世界中，拜占庭问题是什么样的？</p><p>通常使用拜占庭行为，描述拜占庭节点可能的行为，拜占庭行为有：</p><ul><li>任何不遵守协议的动作</li><li>恶意代码、节点</li><li>代码bug</li><li>网络故障、数据包损坏</li><li>磁盘崩掉、重复丢失</li><li>无权限时加入</li><li>…</li></ul><h2 id="什么是3阶段消息"><a href="#什么是3阶段消息" class="headerlink" title="什么是3阶段消息"></a>什么是3阶段消息</h2><p><img src="http://img.lessisbetter.site/2020-03-pbft-3-phase-message.png" alt="3阶段消息"></p><p>3阶段消息是：Pre-prepare、Prepare和Commit。每个消息都会包含数字签名，证明消息的发送者，以及消息类型，下文中会省略。</p><p>Pre-prepare消息由主节点发出，包含：</p><ul><li>当前view：v</li><li>主节点分配给请求的序号n</li><li>请求的摘要d</li><li>请求本身m</li></ul><p><strong>务必记牢，m、v、n、d，后面会使用缩写</strong>。</p><p>Prepare是副本节点收到Pre-prepare消息后，做出的响应，发送给所有副本节点，包含：</p><ul><li>v</li><li>n</li><li>d</li></ul><p>Prepared状态：副本i有Pre-prepare消息，且收到2f个有效的Prepare消息。</p><p>副本i达到Prepared状态，可以发送Commit消息，Commit消息的内容和Prepare消息内容相同，但消息类型和数字签名是不同的，所以可以区分。</p><p>m可以使用d代替，所以Prepare和Commit消息使用d代替m，来节省通信量。</p><h2 id="3阶段消息解决什么问题"><a href="#3阶段消息解决什么问题" class="headerlink" title="3阶段消息解决什么问题"></a>3阶段消息解决什么问题</h2><p>前面提到，PBFT解决的是拜占庭问题的一致性，即让非拜占庭节点达成一致。更具体的说：<strong>让请求m，在view内使用序号n，并且完成执行m，向客户端发送响应</strong>。</p><h2 id="为什么不能只有前2个阶段消息"><a href="#为什么不能只有前2个阶段消息" class="headerlink" title="为什么不能只有前2个阶段消息"></a>为什么不能只有前2个阶段消息</h2><p>这个问题的等价问题是：为什么Pre-prepare和Prepare消息，不能让非拜占庭节点达成一致？</p><p>Pre-prepare消息的目的是，主节点为请求m，分配了视图v和序号n，让至少f+1个非拜占庭节点对这个分配组合<code>&lt;m, v, n&gt;</code>达成一致，并且不存在<code>&lt;m&#39;, v, n&gt;</code>，即不存在有2个消息使用同一个v和n的情况。</p><p><strong>Prepared状态可以证明非拜占庭节点在只有请求m使用<code>&lt;v, n&gt;</code>上达成一致</strong>。主节点本身是认可<code>&lt;m, v, n&gt;</code>的，所以副本只需要收集2f个Prepare消息，而不是2f+1个Prepare消息，就可以计算出至少f个副本节点是非拜占庭节点，它们认可m使用<code>&lt;v, n&gt;</code>，并且没有另外1个消息可以使用<code>&lt;v, n&gt;</code>。</p><p>既然1个<code>&lt;v, n&gt;</code>只能对应1个请求m了，达到Prepared状态后，副本i执行请求m，不就达成一致了么？</p><p>并不能。<strong>Prepared是一个局部视角，不是全局一致</strong>，即副本i看到了非拜占庭节点认可了<code>&lt;m, v, n&gt;</code>，但整个系统包含3f+1个节点，异步的系统中，存在丢包、延时、拜占庭节点故意向部分节点发送Prepare等拜占庭行文，<strong>副本i无法确定，其他副本也达到Prepared状态。如果少于f个副本成为Prepared状态，然后执行了请求m，系统就出现了不一致。</strong></p><p>所以，前2个阶段的消息，并不能让非拜占庭节点达成一致。</p><p>如果你了解2PC或者Paxos，我相信可以更容易理解上面的描述。2PC或Paxos，第一步只是用来锁定资源，第2步才是真正去Do Action。把Pre-prepare和Prepare理解为第一步，资源是<code>&lt;v, n&gt;</code>，只有第一步是达不成一致性的。</p><h2 id="2个不变性"><a href="#2个不变性" class="headerlink" title="2个不变性"></a>2个不变性</h2><p>PBFT的论文提到了2个不变性，这2个不变性，<strong>用来证明PBFT如何让非拜占庭节点达成一致性</strong>。</p><p><strong>第1个不变性</strong>，它是由Pre-prepare和Prepare消息所共同确保的不变性：非拜占庭节点在同一个view内对请求的序号达成共识。关于这个不变性，已经在<a href="#为什么不能只有前2个阶段消息">为什么不能只有前2个阶段消息</a>中论述过。</p><p>介绍第2个不变性之前，需要介绍2个定义。</p><ul><li>committed-local：副本i已经是Prepared状态，并且收到了2f+1个Commit消息。</li><li>committed：至少f+1个非拜占庭节点已经是Prepared状态。</li></ul><p><img src="http://img.lessisbetter.site/2020-03-pbft-committed.png" alt=""></p><p><strong>第2个不变性</strong>，如果副本i是committed-local，那么一定存在committed。</p><p>2f+1个Commit消息，去掉最多f个拜占庭节点伪造的消息，得出至少f+1个非拜占庭节点发送了Commit消息，即至少f+1个非拜占庭节点是Prepared状态。所以第2个不变性成立。</p><h2 id="为什么3个阶段消息可以达成一致性"><a href="#为什么3个阶段消息可以达成一致性" class="headerlink" title="为什么3个阶段消息可以达成一致性"></a>为什么3个阶段消息可以达成一致性</h2><p>committed意味着有f+1个非拜占庭节点可以执行请求，而committed-local意味着，副本i看到了有f+1个非拜占庭节点可以执行请求，f+1个非拜占庭节点执行请求，也就达成了，让非拜占庭节点一致。</p><p>虽然我前面使用了2PC和Paxos做类比，但不意味着PBFT的Commit阶段就相当于，2PC和Paxos的第2步。因为2PC和Paxos处理的CFT场景，不存在拜占庭节点，它们的主节点充当了统计功能，统计有多少节点完成了第一步。PBFT中节点是存在拜占庭节点的，主节点并不是可靠(信)的，不能依赖主节点统计是否有f+1个非拜占庭节点达成了Prepared，而是每个节点各自统计，committed-local让节点看到了，系统一定可以达成一致，才去执行请求。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了2个阶段消息是无法达成一致的原因，而为什么3阶段消息可以。最核心的还是要理解好，PBFT解决了什么问题，以及它是如何解决的。</p><p><strong>PBFT解决的是在拜占庭环境下，如何提供一致性，以及如何持续的提供一致性的问题</strong>。本文只介绍了如何提供一致性，没有提如何持续提供一致性，即PBFT的可用性。现在，不妨思考一下，View Change是如何保证切换时一致性的，是否也需要2个不变性的支持呢？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在面试的时候，很多同学的简历熟悉PBFT共识算法，在现场面试的时候，却只能说个主要逻辑，离完整的算法，还差十万八千里，相似从网络上看了一些文
      
    
    </summary>
    
    
    
      <category term="一致性" scheme="http://lessisbetter.site/tags/%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    
      <category term="区块链" scheme="http://lessisbetter.site/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="PBFT" scheme="http://lessisbetter.site/tags/PBFT/"/>
    
      <category term="共识算法" scheme="http://lessisbetter.site/tags/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>一张思维导图看懂PBFT</title>
    <link href="http://lessisbetter.site/2020/03/11/pbft-xmind/"/>
    <id>http://lessisbetter.site/2020/03/11/pbft-xmind/</id>
    <published>2020-03-11T13:08:05.000Z</published>
    <updated>2020-04-11T09:48:59.646Z</updated>
    
    <content type="html"><![CDATA[<p>最近央行发布的《金融分布式账本安全规范》中提到了区块链系统要提供BFT共识，把之前整理的PBFT的思维导图分享给大家。</p><p><strong>新标签页中打开，查看高清大图</strong>。</p><h2 id="1999年版本"><a href="#1999年版本" class="headerlink" title="1999年版本"></a>1999年版本</h2><p><img src="http://img.lessisbetter.site/PBFT.svg" alt=""></p><h2 id="2001年版本"><a href="#2001年版本" class="headerlink" title="2001年版本"></a>2001年版本</h2><p><img src="http://img.lessisbetter.site/PBFT-PR.svg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近央行发布的《金融分布式账本安全规范》中提到了区块链系统要提供BFT共识，把之前整理的PBFT的思维导图分享给大家。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;新标签页中打开，查看高清大图&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;1999年版本&quot;&gt;&lt;a href=&quot;#1999年版
      
    
    </summary>
    
    
    
      <category term="区块链" scheme="http://lessisbetter.site/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="PBFT" scheme="http://lessisbetter.site/tags/PBFT/"/>
    
  </entry>
  
  <entry>
    <title>向Fabric贡献代码</title>
    <link href="http://lessisbetter.site/2020/03/03/contribute-to-fabric/"/>
    <id>http://lessisbetter.site/2020/03/03/contribute-to-fabric/</id>
    <published>2020-03-03T12:33:19.000Z</published>
    <updated>2020-03-16T14:51:33.540Z</updated>
    
    <content type="html"><![CDATA[<p>PDF如下：</p><div class="pdf" target="http://img.lessisbetter.site/contribute-to-fabric.pdf" height=""></div><blockquote><p>PDF不显示时，hexo安装插件：<code>npm install --save hexo-pdf</code>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;PDF如下：&lt;/p&gt;
&lt;div class=&quot;pdf&quot; target=&quot;http://img.lessisbetter.site/contribute-to-fabric.pdf&quot; height=&quot;&quot;&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;PDF不显示时，hexo安
      
    
    </summary>
    
    
    
      <category term="Fabric" scheme="http://lessisbetter.site/tags/Fabric/"/>
    
  </entry>
  
  <entry>
    <title>从因果关系谈个人能力建设和面试</title>
    <link href="http://lessisbetter.site/2020/03/01/causal-relationship-and-personal-ability/"/>
    <id>http://lessisbetter.site/2020/03/01/causal-relationship-and-personal-ability/</id>
    <published>2020-03-01T03:13:38.000Z</published>
    <updated>2020-05-05T06:36:52.104Z</updated>
    
    <content type="html"><![CDATA[<p>昨天睡前了看了一本收藏已久的书，是关于投资的，叫<a href="https://book.douban.com/subject/30450383/" target="_blank" rel="noopener">《伟大的时代-深度解读价值投资》</a>，这是一本采访了国内价值投资者的书籍，从这些投资者的话语里，看到了一些共性的东西，寻找垄断企业持续发展的根因，也就获得了投资收益，这个果。</p><p>今天起床后，就想到了因果关系、面试、个人能力，在这些角度进行了一些思考，在此记录下思考的成果，这篇文章会介绍：</p><ul><li>因果关系应该关注因，还是关注果？</li><li>如何从因果关系角度，建设个人能力？</li><li>如何从因果关系角度，发现优秀的面试者？</li></ul><h3 id="价值投资中的因果关系"><a href="#价值投资中的因果关系" class="headerlink" title="价值投资中的因果关系"></a>价值投资中的因果关系</h3><p>这些投资者的共性是，都提到了要寻找垄断，并且能够持续垄断的企业，并投资这些企业。</p><p><strong>垄断是“果”，持续垄断也是过，它们需要“因”</strong>。</p><p>怎么才能有垄断，并且持续垄断呢？</p><p>需要找到企业的文化、价值观、制度，这些软性的东西、虚的东西，是企业<strong>不断发展和进化</strong>的根基，这些是企业保持垄断，或成长为垄断的基石，垄断创造收益，收益是实。应了阿里一句话：把虚做实，把实做虚。</p><p>所以，企业文化、价值观和制度是“因”，垄断是“果”。</p><p>如果垄断是“因”，企业收益就是“果”。</p><p><img src="http://img.lessisbetter.site/2020-03-cr-monopoly.png" alt=""></p><p>收益的因不只有垄断，但垄断可以带来巨大收益。</p><h3 id="关注因，还是关注果？"><a href="#关注因，还是关注果？" class="headerlink" title="关注因，还是关注果？"></a>关注因，还是关注果？</h3><p>从企业文化、垄断和收益，这3者看，因果关系可以形成链条，组成一条因果链，一个元素即可以是因，又可以是果。</p><p>比如，垄断是企业文化的果，是收益的因。</p><p>说关注因是对的，关注果也是对的，关注因果链中，<strong>关注最根本的“因”，才是最对的</strong>。</p><p>说一个开发者最容易体会的例子：解决bug，需要定位问题的“根因”，只解决中间原因，并不能真正解决bug。</p><p><img src="http://img.lessisbetter.site/2020-03-cr-root-cause.png" alt=""></p><h3 id="如何从因果关系角度，建设个人能力？"><a href="#如何从因果关系角度，建设个人能力？" class="headerlink" title="如何从因果关系角度，建设个人能力？"></a>如何从因果关系角度，建设个人能力？</h3><p>我把<strong>中级</strong>技术开发者的能力，分成5个维度：技术深度、技术广度、商业思维能力、管理能力和演讲能力。</p><p>不同岗位、层次看到的能力维度是不一样的，比如CTO在找技术总监时的岗位时，需要有体系建设的能力。所以上面强调的是中级开发者。</p><p><img src="http://img.lessisbetter.site/2020-03-cr-personal-ability.png" alt=""></p><p>这5个维度的能力是因，项目、职位、收入这些是果。</p><p>果是我们的目标，是我们要达到的地方。而因才是我们要关注的地方。</p><p>建设能力，能力就转变成了“果”，那对应的因是什么呢？</p><p>建设能力的“因”是<strong>持续学习</strong>。</p><p><img src="http://img.lessisbetter.site/2020-03-cr-continuelearn.png" alt=""></p><p>这几年的付费学习，可把持续学习给玩坏了，总是弥漫着一种贩卖焦虑的气息，但不可否认的是，持续学习的人，总有机会。</p><p>持续学习，有很多种通俗的说法:</p><ol><li>活到老，学到老。</li><li>永不止步。</li><li>不给自己设限。</li><li>Stay foolish, Stay hungry。——乔布斯</li><li>…</li></ol><p>关于技术上的持续学习，曹大（Xargin）最近这篇文章值得一看<a href="https://xargin.com/how-to-learn/" target="_blank" rel="noopener">《工程师应该怎么学习》</a>。</p><h3 id="如何从因果关系角度，发现优秀的面试者？"><a href="#如何从因果关系角度，发现优秀的面试者？" class="headerlink" title="如何从因果关系角度，发现优秀的面试者？"></a>如何从因果关系角度，发现优秀的面试者？</h3><p>我考察候选人的经历不是特别多，1年下来，简历筛选过几百份，候选人也面过几十个了，有一些体会，今天就借着因果关系，浅谈一下。</p><p><strong>面试的本质，是挖掘面试者当前的能力和持续学习的能力</strong>。</p><p>上面这句代表2个观点：</p><ol><li>简历是“果”，能力是“因”。</li><li>招进来能持续创建价值是未来的“果”，持续学习是“因”。</li></ol><p>阿里有句土话，用来招聘很适合：没有过程的结果是垃圾，没有结果的过程是放屁。</p><p>上半句用来筛选简历，如果简历只写自己参与、做过了什么，而没有成果，这份简历就是垃圾，而写不出好简历的面试者，能力大概率也不优秀。</p><p>下半句用来面试，面试者是怎么取得这些成果的，TA具有哪些能力才取得了这些成果？</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>因果关系，还让我深刻的想到一句话：<strong>抓住事物的主要矛盾</strong>。</p><p>咱们国家的发展，不一直就是党和政府在抓主要矛盾，解决主要矛盾的过程吗。</p><h3 id="远见"><a href="#远见" class="headerlink" title="远见"></a>远见</h3><p>在世界读书日那天，美团技术团队推荐了许多书，其中有一本关于职业生涯的书籍：《<strong>远见：如何规划职业生涯3大阶段</strong>》，书很薄，也很容易理解，读完之后对职业生涯的认知提升了几个Level，值得深度阅读并实践，推荐给不断让自己更优秀的你。</p><p>下面是<strong>美团点评酒旅事业群前端团队负责人郭凯</strong>的推荐语：</p><blockquote><p>我们不仅要找到热爱的工作，而且要建立热爱的生活。职业生涯就像是一场至少长达45年的马拉松，这本书介绍了远见思维和三大职业生涯阶段，并介绍了如何应对职场和生活的冲突。我辈应该多行动、少忧虑，并且提前做好中长期的职业思考和职业规划。如果用“远见”的思维看待眼前的影响和困难，就根本不值得一提。用“远见”的思维，长期有耐心，每天前进30公里。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;昨天睡前了看了一本收藏已久的书，是关于投资的，叫&lt;a href=&quot;https://book.douban.com/subject/30450383/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《伟大的时代-深度解读价值投资》&lt;/a&gt;，这是一本采访了国内
      
    
    </summary>
    
    
    
      <category term="职业发展" scheme="http://lessisbetter.site/tags/%E8%81%8C%E4%B8%9A%E5%8F%91%E5%B1%95/"/>
    
  </entry>
  
  <entry>
    <title>Fabric 1.4源码解读 9：从账本角度看Peer</title>
    <link href="http://lessisbetter.site/2020/01/03/fabric-peer-ledger/"/>
    <id>http://lessisbetter.site/2020/01/03/fabric-peer-ledger/</id>
    <published>2020-01-03T12:58:03.000Z</published>
    <updated>2020-02-14T07:02:17.527Z</updated>
    
    <content type="html"><![CDATA[<p>区块链最核心的是<strong>可信数据</strong>，所有的功能与设计根源都是数据。本次从数据存储的角度，看一看Peer。</p><h2 id="账本"><a href="#账本" class="headerlink" title="账本"></a>账本</h2><p>区块链的数据存储在账本中，账本包含：</p><ul><li>区块存储<ul><li>区块文件</li><li>区块索引数据库</li></ul></li><li>世界状态数据库</li><li>历史数据库</li><li>私有数据数据库</li></ul><p>关于账本以上各数据库的工具，<a href="https://hyperledger-fabric-cn.readthedocs.io/zh/latest/ledger/ledger.html" target="_blank" rel="noopener">官方文档</a>中对区块存储和世界状态数据库介绍的比较详细了，但我们介绍下它没有提到的。</p><h3 id="区块文件和区块索引数据库"><a href="#区块文件和区块索引数据库" class="headerlink" title="区块文件和区块索引数据库"></a>区块文件和区块索引数据库</h3><p>区块是保存在文件中的，<strong>为了快速查找区块、交易</strong>，Fabric建立了索引，指明某通道某区块高度的第x个交易，是存在哪个文件，偏移量是多少。当然，索引还包含了区块高度、区块hash等，方便根据高度、hash查询区块。</p><p><img src="http://img.lessisbetter.site/2020-01-blockfile-index.png" alt=""></p><p>上图展示了一个区块文件存储区块的情况，每个区块包含：</p><ul><li>区块长度</li><li>区块头</li><li>每条交易长度、交易数据</li></ul><p>每个区块的开始位置、交易的开始位置，在写区块的时候记录下来，然后写到索引数据库（Index DB）。</p><p><strong>整个Fabric网络只有1个区块索引数据库，也就是多通道共用一个</strong>。</p><h3 id="历史数据库"><a href="#历史数据库" class="headerlink" title="历史数据库"></a>历史数据库</h3><p><strong>用来记录交易中每个状态数据的历史信息，直白点可以理解为链码中某个key的历史数值</strong>。它的key实际是<code>{通道id+链码id, key, 区块高度, 交易在区块中的序号}</code>组成的<strong>复合key</strong>，值为空，并且只包含有效的交易。</p><p>有这样一个问题：值为空，到底怎么查询到历史状态呢？</p><p>答：通过历史数据库合成复合key，但复合key中没有交易在区块中的序号，创建一个迭代器，迭代器可以获取包含key的复合key，然后从复合key中提取到交易在区块的序号，然后去区块文件中提取交易，再提取到写集的Value，就可以合成某个key的所有历史值。</p><p>因此<strong>查询历史状态，需要结合历史数据库和区块文件</strong>。</p><h2 id="各数据库实现"><a href="#各数据库实现" class="headerlink" title="各数据库实现"></a>各数据库实现</h2><p><strong>区块文件使用文件直接存储区块，没有使用数据库的原因</strong>是：区块是一种自然的追加操作，写入后不再修改，即不会覆盖历史区块，使用文件系统直接存储区块，可以达到区块最快落盘的目的，因为向文件写区块是顺序写，而写数据库是随机写，磁盘（包含HD、SSD）的顺序写性能要高于随机写。</p><p>世界状态数据库可以使用leveldb或者CouchDB，CouchDB支持富查询功能，当链码数据按JSON建模时，CouchDB可以提供更好的数据查询，更多CouchDB的信息见文档<a href="https://stone-fabric.readthedocs.io/zh/latest/couchdb_tutorial.html" target="_blank" rel="noopener">使用 CouchDB</a>。</p><p>其他数据库都使用leveldb作为底层存储。</p><p><img src="http://img.lessisbetter.site/2020-01-peer-ledger-storage.png" alt=""></p><p><strong>提醒</strong>：Fabric支持多通道，逻辑上每个通道拥有一个账本。实现上区块文件是按通道名隔离开了，使用leveldb的各数据库，被各通道共用。</p><h2 id="从数据看Peer功能"><a href="#从数据看Peer功能" class="headerlink" title="从数据看Peer功能"></a>从数据看Peer功能</h2><p>和账本相关的概念还有<strong>区块、交易和状态</strong>，从账本的角度看，账本向上支撑了2类功能：</p><ol><li>数据同步：广播与同步区块</li><li>交易背书：模拟执行交易</li></ol><p>在下图中，数据同步和交易背书分别使用蓝色和橙色的线圈出，底部剩下的2层为账本。</p><p><img src="http://img.lessisbetter.site/2020-01-03-usage-of-peer-ledger.png" alt=""></p><h3 id="账本-1"><a href="#账本-1" class="headerlink" title="账本"></a>账本</h3><p><code>core/ledger</code>实现了Peer的账本功能，包含了账本中的各项数据库，它依赖<code>common/ledger</code>实现区块文件存储，区块文件存储包含3类：</p><ul><li><code>File</code>：把区块保存在文件中，生产环境使用，orderer和peer皆可使用</li><li><code>Json</code>：把文件保证JSON格式的文件中，使用在非生产环境，仅供orderer使用</li><li><code>Ram</code> ：把区块保存在内存中，使用在非生产环境，仅供orderer使用</li></ul><p><code>core/ledger</code>中的：</p><ul><li><code>PeerLedger</code>接口，代表<strong>Peer账本</strong>，主要用来向账本写区块和私有数据，查询区块、交易和私有数据</li><li><code>Txsimulator</code>接口，代表<strong>交易模拟器</strong>，用来模拟执行1条交易</li><li><code>QueryExecutor</code>接口用来查询<strong>最新的</strong>数据</li><li><code>HistoryQueryExecutor</code>接口用来查询<strong>历史</strong>状态</li></ul><h3 id="同步数据"><a href="#同步数据" class="headerlink" title="同步数据"></a>同步数据</h3><p>同步数据有2种方式：</p><ul><li>Deliver服务，Peer使用事件从Orderer获取区块</li><li>Peer向其他节点请求获取某个区间的区块</li></ul><p>虽然Peer获取区块的方式有2种，但收到区块，处理区块的方式只有1种，所以下面分3小节介绍。</p><h4 id="使用Deliver同步区块"><a href="#使用Deliver同步区块" class="headerlink" title="使用Deliver同步区块"></a>使用Deliver同步区块</h4><p>Deliver用来以事件的方式获取区块，场景有2点：</p><ul><li>Peer从Oderer获取区块</li><li>客户端/SDK从Peer获取区块</li></ul><p>在<a href="http://lessisbetter.site/2019/12/17/fabric-blocks-from-orderer-to-peer/">Fabric 1.4源码解读 8：Orderer和Peer的交互</a>中已经介绍了Peer从Orderer获取区块，这里再做一点补充。</p><p>Deliver服务是Orderer和Peer都使用的功能，但Orderer并没有<code>core/ledger</code>，所以从设计和实现上，<code>common/deliver</code>是从<code>common/ledger</code>中直接读区块，而不是<code>core/ledger</code>读区块。</p><h4 id="Peer请求区块"><a href="#Peer请求区块" class="headerlink" title="Peer请求区块"></a>Peer请求区块</h4><p>每个Peer可以通过Gossip得知同通道的、所连接的Peer信息，其中一项就是对方Peer账本的高度。账本高度低的Peer可以向高度高的Peer发送<strong>StateRequest</strong>，请求获取某个连续区间的区块。</p><p>Peer上负责StateRequest的是<code>gossip/state</code>模块，它负责：</p><ul><li>创建StateRequest请求</li><li>处理StateRequest请求，生成StateRequest响应</li><li>处理StateRequest响应</li></ul><p>创建请求：假设Peer1比Peer2少50个区块，并且配置了Peer每次最多取10个区块，Peer1会创建5个StateRequest请求，顺序的向Peer2进行请求，Peer1收到前一个请求的响应后，才发出下一个请求。</p><p>处理请求：实际是从账本读取所请求区块的过程，这个过程主要是读取区块文件，如果区块涉及私密数据，也涉及读取私密数据库，这部分功能主要由<code>gossip/privdata</code>完成，<code>gossip/state</code>把读到的区块和私密数据生成请求响应。</p><h4 id="Peer处理收到的区块"><a href="#Peer处理收到的区块" class="headerlink" title="Peer处理收到的区块"></a>Peer处理收到的区块</h4><p>Peer从Orderer和其他Peer哪获取的区块，最终都会进入到<code>gossip/state</code>，区块会被放入到一个区块缓冲区：<strong>PayloadsBuffer</strong>，默认大小为存储200个区块。</p><p>每个通道账本都有一个goroutine，从各自的PayloadsBuffer拿下一个高度的区块，交给<code>gossip/privdata</code>进行区块的验证和写入。</p><h5 id="验证区块"><a href="#验证区块" class="headerlink" title="验证区块"></a>验证区块</h5><p>这部分功能由<code>core/handler/validation</code>完成。在Fabric 1.4中，StateImpl会调用QueryExecutor查询状态，但实际StateImpl没有被调用。</p><p>验证区块主要是并发验证区块中的交易：</p><ul><li>验证交易中的字段</li><li>验证是否满足背书策略</li><li>验证交易是否调用最新版本的链码</li><li>验证交易是否重复</li></ul><p>交易验证的结果，即交易是否有效，并不会保存在交易中，这样区块中记录所有交易的DataHash就变化了。区块中所有交易的有效性存储在区块的元数据中，区块元数据中有一个有效性数组，依次存放了每个交易的有效性，使用数组的下标，与交易在数组中的顺序，一一对应。</p><p>交易验证后，会修改区块的元数据，把无效的交易设置为响应的无效序号。</p><p>如果缺失区块的私有数据，<code>gossip/privdata</code>会创建获取私有数据的请求，并获取私有数据，当区块和私有数据都准备齐全后，开始<strong>commit</strong>区块和私有数据。</p><h5 id="区块写入账本"><a href="#区块写入账本" class="headerlink" title="区块写入账本"></a>区块写入账本</h5><p>包含2大块：</p><ul><li>交易MVCC验证<ul><li>Fabric要求世界状态数据库支持MVCC，即多版本并发控制，以便交易能够并发执行（背书），在真正修改状态的时候，才判断读写的数据是否冲突，冲突的交易会被标记为无效。关于MVCC我们在下文的背书部分再详细介绍。</li></ul></li><li>把区块写入数据库，以及修改各数据库：<ul><li>把区块写入到区块文件</li><li>把区块、交易的索引写入到索引数据库</li><li>把<strong>有效交易</strong>的写集更新到世界状态</li><li>提交历史数据库</li><li>提交私密数据库</li></ul></li></ul><h5 id="写区块完成后"><a href="#写区块完成后" class="headerlink" title="写区块完成后"></a>写区块完成后</h5><p>写区块完成后，还需要做一些<strong>修剪</strong>操作：私密数据是有有效期的，比如存活100个区块时间，假如在1000高度写入了某私有数据，第1100写入账本后，私密数据就要从私密数据库被抹除。</p><h3 id="背书"><a href="#背书" class="headerlink" title="背书"></a>背书</h3><p>Peer除了记账的另外一个角色就是背书，背书很重要的一个环节就是模拟执行交易。</p><h4 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h4><p>Fabric为了提供更高的系统性能，支持并发的执行交易，交易在执行过程中会读写世界状态数据库，也就存在并发访问数据库的场景，为了安全的访问数据库数据，就需要对数据库的并发进行限制。</p><p>Draveness在<a href="https://draveness.me/database-concurrency-control" target="_blank" rel="noopener">浅谈数据库并发控制 - 锁和 MVCC</a>种介绍了并发控制3种手段：悲观锁、乐观锁和MVCC。</p><p>Fabric选择了MVCC，它要求世界状态数据库支持MVCC，本质上讲任何支持MVCC的数据库，都可以用来实现状态数据库。</p><p>MVCC是多版本并发控制的缩写，它是一种思想，而不是一种具体的算法，所以不同的数据库实现的MVCC不同。</p><p>在MVCC的数据存储中，数据有版本的概念，写一个数据的值，实际上是创建了一个新的版本来保存数据。</p><p>MVCC可以实现并发读写的能力，当读数据时，先确定待读数据的版本，然后从该版本读取数据，写数据时，创建新的版本保存数据。读数据必然是已经存在的版本，而写数据是新的版本，因此读写可以并行。</p><p><img src="http://img.lessisbetter.site/2020-01-mvcc-read-write.png" alt=""></p><h4 id="Fabric对MVCC的使用"><a href="#Fabric对MVCC的使用" class="headerlink" title="Fabric对MVCC的使用"></a>Fabric对MVCC的使用</h4><p>背书节点在模拟执行交易的过程中，会生成读写集，<strong>读集和写集分别是所有待写key读出来时的版本和待写入的新值</strong>。</p><p>交易并发执行到写入区块的过程中存在2种<strong>读写冲突</strong>的情况：</p><ol><li>同一个区块中的前后两笔交易，后面的交易读集包含某个key，但key在前面交易的写集：也就说后面交易读的是老版本的数据，是一种脏读的情况</li><li>区块中交易的读集的某个key，某之前区块的交易写集修改：背书跟写区块是并发执行的，背书时产生的写集，直到写区块才会更新到世界状态数据库，这里存在一段时间，即key已经有了新版本的数据，只是还没有提交到数据库。如果这期间有新的交易模拟执行，就会读到老版本数据，也是一种脏读的情况</li></ol><p>有效交易的写集会被应用到世界状态数据库，被修改数据都会有一个新的版本，这个版本是逻辑版本，成为Hight，由<code>{区块高度,交易在区块内的顺序}</code>组成。</p><blockquote><p>注：验证函数为 <code>validateTx</code>，读写集冲突错误为 <code>TxValidationCode_MVCC_READ_CONFLICT</code> ，另一个读写冲突错误为 <code>TxValidationCode_PHANTOM_READ_CONFLICT</code>， 因为执行过程中有RangeQuery，查询某个区间的Key，也需要验证这些Key是否冲突，底层本质还是读写集的验证。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文从账本的视角，介绍了Peer的账本，以及和账本打交道的功能。</p><p>真正企业级的区块链、大用户规模的区块链，必然能够支撑大量的并发交易，这对账本以及底层存储，都会提出更高的性能要求、磁盘利用率要求，所以理解和掌握账本和存储机制是非常有必要的。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://draveness.me/database-concurrency-control" target="_blank" rel="noopener">浅谈数据库并发控制 - 锁和 MVCC</a></li><li><a href="https://en.wikipedia.org/wiki/Multiversion_concurrency_control" target="_blank" rel="noopener">WIKI: MVCC</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;区块链最核心的是&lt;strong&gt;可信数据&lt;/strong&gt;，所有的功能与设计根源都是数据。本次从数据存储的角度，看一看Peer。&lt;/p&gt;
&lt;h2 id=&quot;账本&quot;&gt;&lt;a href=&quot;#账本&quot; class=&quot;headerlink&quot; title=&quot;账本&quot;&gt;&lt;/a&gt;账本&lt;/h2&gt;&lt;
      
    
    </summary>
    
    
    
      <category term="区块链" scheme="http://lessisbetter.site/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Fabric" scheme="http://lessisbetter.site/tags/Fabric/"/>
    
  </entry>
  
  <entry>
    <title>WAL(预写式日志)简介</title>
    <link href="http://lessisbetter.site/2020/01/02/wal-introduction/"/>
    <id>http://lessisbetter.site/2020/01/02/wal-introduction/</id>
    <published>2020-01-02T12:56:32.000Z</published>
    <updated>2020-01-02T02:57:24.717Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Write Ahead Logging，简称WAL，也被翻译成<strong>预写式日志</strong>，是数据库技术中实现事务日志(Transaction Journal)的一种标准方法，可以实现<strong>单机</strong>事务的原子性，同时可以提高数据库的写入效率。</p><p>思考如下场景，如何确保原子性：写操作修改数据库中a和b的值，二者是一个事务，需要把a和b的最新值持久化到磁盘，假如保存完a的值，系统宕机了，重新启动后，a的值已经写入，但b待写入的值已经丢失，如何发现事务没有完成呢？如何保证事务的原子性呢？</p><p>可以为事务加锁，也为事务增加标志位，修改完磁盘数据后，标志位设置事务为完成，事务状态保存在磁盘中，假使保存事务状态的过程中宕机了，就把事务回滚掉。实现REDO和UNDO，就能实现原子性。</p><p>数据库中针对<strong>Crash</strong>和<strong>Recovery</strong>的解决方案是WAL。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>WAL的核心思想是<strong>先写日志再写数据文件</strong>，修改数据文件必须发生在修改操作记录在日志文件之后。</p><blockquote><p>本文的日志指事务的操作日志，本文提到的日志都是指事务日志，不再特殊声明。</p></blockquote><p><img src="http://img.lessisbetter.site/2019-12-wal.png" alt="WAL"></p><p>我们看WAL怎么<strong>解决宕机和恢复的问题</strong>：</p><ul><li>写WAL前宕机了，重启后，数据处于事务未执行的状态。</li><li>写WAL时宕机了，重启后，可以检查到WAL数据不正确，回滚当事务前的状态。</li><li>写WAL后宕机了，重启后，把WAL中记录的操作，应用到数据库文件中，得到事务执行后的状态。</li></ul><p>如此，保证了数据的恢复和事务的原子性。</p><p>上面提到的都是写操作，看一下使用WAL时的<strong>读操作</strong>。WAL中可能包含了未写入到数据库文件中的最新值，如果读最新值就需要从WAL中读取，如果WAL中未读到，从数据库读到的就是最新的数据。</p><p><strong>检查点</strong>：写入到WAL文件中的操作记录并不一定会立刻应用到数据库文件上，这个过程是异步的，设计检查点来记录已经被应用到数据库文件上的操作序号，检查点后面的操作记录等待被应用到数据库文件上。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>WAL的作用是解决宕机和恢复的问题，同时也有其他优点：</p><ol><li><strong>提高写数据的性能</strong><ol><li>WAL是顺序写，数据库文件是随机写，顺序写性能高于随机写</li><li>减少写磁盘次数<ol><li>不直接修改数据库真实数据</li><li>合并若干小的事务，一次性commit到数据库</li></ol></li></ol></li><li>保证事务<strong>原子性</strong></li><li>保证事务<strong>一致性</strong></li><li><strong>并发读写</strong>，比如SQLite中，读写、读读都是可以并行的，比如读时需要找到WAL某个值最后写入的位置，就可以从该位置读数据，而写操作是在WAL文件后Append，二者并行。但写写不能并行，因为2次写操作都要向WAL文件Append数据，无法同时进行。</li><li>WAL文件中记录了数据的历史版本，因此可以读取历史版本的值，甚至把状态回滚到某个历史版本。</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>SQLite提到了WAL的几项缺点：</p><ol><li>WAL需要VFS的支持。</li><li>所有使用数据库的进程必须在同一个机器上，以为WAL是单机的。</li><li>多读少写的场景WAL比rollback-journal类型要慢1%~2%。</li></ol><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>WAL几乎是<strong>数据存储</strong>(数据库只是数据存储的一个类别，只不过这个类别很大)的标配：</p><ul><li>Raft可以使用WAL保存log Entry以及状态</li><li>数据库<ul><li>PgSQL使用WAL实现事务日志实现事务原子性、一致性，提升性能</li><li>SQLite使用WAL实现原子事务和回滚</li><li>MySQL使用WAL保证数据不丢失的情况下提升性能</li><li>leveldb也使用WAL提升性能，保证操作原子性</li></ul></li></ul><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><ul><li><a href="https://juejin.im/post/5b04a93151882542672666e8" target="_blank" rel="noopener">菜鸟学数据库——WAL模式及其原理</a></li><li><a href="http://mysql.taobao.org/monthly/2017/03/02/" target="_blank" rel="noopener">PgSQL · 特性分析 · Write-Ahead Logging机制浅析</a></li><li><a href="https://www.postgresql.org/docs/9.1/wal-intro.html" target="_blank" rel="noopener">PostgreSQL 9.1.24 Documentation: Chapter 29. Reliability and the Write-Ahead Log</a></li><li><a href="https://www.sqlite.org/wal.html" target="_blank" rel="noopener">SQLite: Write-Ahead Logging</a></li><li><a href="https://mysqlserverteam.com/mysql-8-0-new-lock-free-scalable-wal-design/" target="_blank" rel="noopener">MySQL 8.0: New Lock free, scalable WAL design</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;Write Ahead Logging，简称WAL，也被翻译成&lt;strong&gt;预写式日志&lt;/strong&gt;，是数据库技术中实现事务日志(Tr
      
    
    </summary>
    
    
    
      <category term="分布式" scheme="http://lessisbetter.site/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="存储" scheme="http://lessisbetter.site/tags/%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>Fabric 1.4源码解读 8：Orderer和Peer的交互</title>
    <link href="http://lessisbetter.site/2019/12/17/fabric-blocks-from-orderer-to-peer/"/>
    <id>http://lessisbetter.site/2019/12/17/fabric-blocks-from-orderer-to-peer/</id>
    <published>2019-12-17T12:14:34.000Z</published>
    <updated>2019-12-17T06:19:58.910Z</updated>
    
    <content type="html"><![CDATA[<p>Peer与Orderer的交互主要是组织的Peer主节点从Orderer获取区块，本文就来介绍，Peer是如何从Orderer获取区块的，顺带介绍为何Peer从Orderer获取的区块“好慢”。</p><h2 id="网络拓扑"><a href="#网络拓扑" class="headerlink" title="网络拓扑"></a>网络拓扑</h2><p>假设存在如下的Fabric网络拓扑情况，本文使用此拓扑进行介绍Orderer到Peer的区块传播情况：</p><p>网络中存在两家组织：Org1和Org2，它们分别拥有Peer1作为主节点，连向了排序服务的Orderer1节点。</p><p>网络中存在2个应用channel：channel1和channel2，它们的账本分别是channel1 ledger和channel2 ledger，Org1和Org2都加入了这2个channel。</p><p><strong>channel间是隔离的，所以Peer和Orderer对不同的channel都会分别处理</strong>。</p><h2 id="宏观视角"><a href="#宏观视角" class="headerlink" title="宏观视角"></a>宏观视角</h2><p>下图展示了Orderer向Peer传递区块的宏观视角，能够展示<strong>多个通道在Orderer和Peer间传递区块的情况</strong>：</p><ol><li>Orderer上有2个通道的账本，每个Peer分别有2个Deliver Server对应2个通道的账本，从账本读取区块，发送给Peer。</li><li>每个Peer有2个Deliver Client，也对应2个通道，接收Orderer发来的区块，加入到缓冲区Payloads Buffer，然后再从Payloads Buffer中提取区块，验证后写入对应的通道账本。</li></ol><p><img src="http://img.lessisbetter.site/2019-12-spread-of-blocks-new.png" alt=""></p><p>后面，介绍区块同步某个通道区块的情况。</p><h2 id="单通道区块同步"><a href="#单通道区块同步" class="headerlink" title="单通道区块同步"></a>单通道区块同步</h2><p><strong>Peer利用Deliver从Orderer获取区块</strong>，就像SDK利用Deliver从Peer获取区块一样，Deliver服务端的处理是一样的，Deliver客户端的处理就由SDK、Peer自行处理了。</p><p>Deliver本质是一个事件订阅接口，Leading Peer启动后，会为每个通道，分别向Orderer节点注册<strong>区块事件</strong>，并且指定结束的区块高度为<code>uint</code>类型的最大值，这是为了不停的从orderer获取区块。</p><p>通过建立的gRPC连接，Orderer源源不断的向Peer发送区块，具体流程，如下图所示：</p><ol><li>Orderer调用<code>deliverBlock</code>函数，该函数是循环函数，获取区块直到指定高度。</li><li>每当有新区块产生，<code>deliverBlock</code>能利用<code>NextBlock</code>从通道账本中读到最新的区块，如果没有最新区块，<code>NextBlock</code>会阻塞。</li><li><code>deliverBlock</code>把获取的区块封装成区块事件，发送给Peer（写入到gRPC缓冲区）。</li><li>Peer从gRPC读到区块事件，把区块提取出来后，加入到<strong>Payloads Buffer</strong>，Payloads Buffer默认大小为200（通过源码和日志发现，Payloads Buffer实际存储202个区块），如果Orderer想向Peer发送更多的区块，必须等Payloads Buffer被消费，有空闲的位置才可以。</li><li><code>deliverPayloads</code>为循环函数，不断<strong>消费</strong>Payloads Buffer中的区块，执行区块验证，添加区块剩余元数据，最后写入通道账本。</li><li>写通道账本包含区块写入区块账本，修改世界状态数据库，历史索引等。</li></ol><p><img src="http://img.lessisbetter.site/2019-12-orderer-to-peer.png" alt=""></p><h2 id="为何Peer从Orderer获取区块慢？"><a href="#为何Peer从Orderer获取区块慢？" class="headerlink" title="为何Peer从Orderer获取区块慢？"></a>为何Peer从Orderer获取区块慢？</h2><p>在性能测试过程中，我们发现Orderer排序完成后，Peer还在不断的从Orderer获取区块，而不是所有排序后的区块都先发送给Peer，Peer缓存起来，慢慢去验证？</p><p>上面提到Orderer向Peer发送的区块，Peer收到后先存到Payloads Buffer中，Buffer有空闲位置的时候，Orderer发送的区块才能写入Buffer，deliverBlock 1次循环才能完成，才可以发送下一个区块。</p><p>但Payloads Buffer大小是有限的，当Buffer满后，Orderer发送区块的操作也会收到阻塞。</p><p>我们可以把Orderer和Peer间发送区块可以抽象一下，它们就是<strong>生产者-消费者模型</strong>，它们中间是缓冲区，Orderer是生产者，向缓冲区写数据，Peer是消费者，从缓冲区读数据，缓冲区满了会阻塞生产者写数据。</p><p>所以<strong>Orderer向Peer发送数据的快慢，取决消费者的速度，即取决于deliverPayloads处理一个区块的快慢</strong>。</p><p>deliverPayloads慢在把区块写入区块账本，也就是写账本，成了整个网络的瓶颈。</p><h2 id="为何不让Peer缓存所有未处理的区块？"><a href="#为何不让Peer缓存所有未处理的区块？" class="headerlink" title="为何不让Peer缓存所有未处理的区块？"></a>为何不让Peer缓存所有未处理的区块？</h2><p>从我们测试的情况看，Orderer排序的速度远快于Peer，Peer和Orderer的高度差可以达到10万+，如果让Peer来缓存这些区块，然后再做处理是需要耗费大量的空间。</p><p>在生产者-消费者模型中，只需要要消费者时刻都有数据处理即可。虽然Orderer和Peer之间是网络传输，测试网络比较可靠，传输速度远比Peer处理区块要快。</p><p>Payloads Buffer可以让网络传输区块和Peer处理区块并行，这样缩短了一个区块从Orderer中发出，到Peer写入区块到账本的总时间，提升Fabric网络整体性能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Peer与Orderer的交互主要是组织的Peer主节点从Orderer获取区块，本文就来介绍，Peer是如何从Orderer获取区块的，顺带介绍为何Peer从Orderer获取的区块“好慢”。&lt;/p&gt;
&lt;h2 id=&quot;网络拓扑&quot;&gt;&lt;a href=&quot;#网络拓扑&quot; class
      
    
    </summary>
    
    
    
      <category term="区块链" scheme="http://lessisbetter.site/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Fabric" scheme="http://lessisbetter.site/tags/Fabric/"/>
    
  </entry>
  
  <entry>
    <title>Fabric 2.0 特性一览</title>
    <link href="http://lessisbetter.site/2019/12/16/fabric-2-0/"/>
    <id>http://lessisbetter.site/2019/12/16/fabric-2-0/</id>
    <published>2019-12-16T12:30:11.000Z</published>
    <updated>2019-12-16T09:35:14.045Z</updated>
    
    <content type="html"><![CDATA[<p>Fabric 2.0 Beta版前几日已经发布了，浏览了官方文档和Release Notes，对特性进行了记录，</p><ul><li><a href="https://hyperledger-fabric.readthedocs.io/en/master/whatsnew.html" target="_blank" rel="noopener">官方文档</a></li><li><a href="https://github.com/hyperledger/fabric/releases/tag/v2.0.0-beta" target="_blank" rel="noopener">Relase Notes</a></li></ul><p><img src="http://img.lessisbetter.site/2019-12-fabric-2.0.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Fabric 2.0 Beta版前几日已经发布了，浏览了官方文档和Release Notes，对特性进行了记录，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://hyperledger-fabric.readthedocs.io/en/master/whatsn
      
    
    </summary>
    
    
    
      <category term="区块链" scheme="http://lessisbetter.site/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Fabric" scheme="http://lessisbetter.site/tags/Fabric/"/>
    
  </entry>
  
  <entry>
    <title>Fabric 1.4源码解读 7：Orderer架构解读</title>
    <link href="http://lessisbetter.site/2019/11/21/fabric-orderer-architecture/"/>
    <id>http://lessisbetter.site/2019/11/21/fabric-orderer-architecture/</id>
    <published>2019-11-21T12:07:54.000Z</published>
    <updated>2020-01-10T09:30:42.951Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Orderer介绍"><a href="#Orderer介绍" class="headerlink" title="Orderer介绍"></a>Orderer介绍</h2><p>排序服务由一组<strong>排序节点</strong>组成，它接收客户端提交的交易，把交易打包成区块，确保排序节点间达成一致的区块内容和顺序，提供区块链的<strong>一致性</strong>服务。</p><p><img src="http://img.lessisbetter.site/2019-11-fabric-orderer-network.png" alt=""></p><blockquote><p>图片源自《区块链原理、设计与应用》，当时Fabric还不支持raft</p></blockquote><p>排序服务所提供的一致性，依赖<strong>确定性的共识算法</strong>，而非比特币、以太坊等公有链，所采用的概率性共识算法。确定性的共识算法是区块上链，即不可修改。Fabric所采用的共识算法有Solo、Kafka、EtcdRaft。</p><p>客户端<strong>通过Broadcast接口向Orderer提交背书过的交易</strong>，客户端（此处广义指用户客户端和<strong>Peer节点</strong>）<strong>通过Deliver接口订阅区块事件，从Orderer获取区块</strong>。</p><p>更多的排序服务介绍请参考这篇官方文档<a href="https://hyperledger-fabric-cn.readthedocs.io/zh/latest/orderer/ordering_service.html" target="_blank" rel="noopener">排序服务</a>。</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><img src="http://img.lessisbetter.site/2019-11-arch-of-orderer.png" alt="Architecture of Orderer"></p><blockquote><p>本图依赖 Fabric 1.4 源码分析而得</p></blockquote><p>Orderer由：多通道、共识插件、消息处理器、本地配置、区块元数据、gRPC服务端、账本等组成，其中gRPC中的Deliver、Ledger是通用的（Peer也有），其余都是Orderer独有的。</p><h3 id="多通道"><a href="#多通道" class="headerlink" title="多通道"></a>多通道</h3><p>Fabric 支持多通道特性，而Orderer是多通道的核心组成部分。多通道由Registrar、ChainSupport、BlockWriter等一些重要部件组成。</p><p>Registrar是所有通道资源的汇总，访问每一条通道，都要经由Registrar，更多信息请看<a href="http://lessisbetter.site/2019/11/18/fabric-orderer-structs/#Registrar">Registrar</a>。</p><p>ChainSupport代表了每一条通道，它融合了一条通道所有的资源，更多信息请看<a href="http://lessisbetter.site/2019/11/18/fabric-orderer-structs/#ChainSupport">ChainSupport</a>。</p><p>BlockWriter 是区块达成共识后，Orderer写入区块到账本需要使用的接口。</p><h3 id="共识插件"><a href="#共识插件" class="headerlink" title="共识插件"></a>共识插件</h3><p>Fabric的共识是插件化的，抽象出了Orderer所使用的共识接口，任何一种共识插件，只要满足给定的接口，就可以配合Fabric Orderer使用。</p><p>当前共识有3种插件：Solo、Kafka、EtcdRaft。Solo用于实验环境，Kafka和EtcdRaft用于生产环境，Kafka和EtcdRaft都是CFT算法，但EtcdRaft比Kafka更易配置。</p><p>EtcdRaft实在Fabric 1.4开始引入的，如果之前的生产环境使用Kafka作为共识，可以遵循Fabric给的指导，把Kafka共识，迁移到Raft共识。</p><h3 id="gRPC通信"><a href="#gRPC通信" class="headerlink" title="gRPC通信"></a>gRPC通信</h3><p>Orderer只有2个gRPC接口：</p><ul><li>Broadcast：用来接收客户端提交的待排序交易</li><li>Deliver：客户端（包括Peer节点）用来从Orderer节点获取已经达成一致的区块</li></ul><p>其中，Broadcast是Orderer独有的，而Devliver是通用的，因为客户端也可以利用Deliver接口从Peer节点获取区块、交易等。</p><p>关于Broadcast和Orderer更多介绍可以参考杨保华的2篇笔记：</p><ul><li><a href="https://github.com/yeasy/hyperledger_code_fabric/blob/master/process/orderer_broadcast.md" target="_blank" rel="noopener">Orderer 节点 Broadcast 请求的处理</a></li><li><a href="https://github.com/yeasy/hyperledger_code_fabric/blob/master/process/orderer_deliver.md" target="_blank" rel="noopener">Orderer 节点 Deliver 请求的处理</a>。<h3 id="Local-Config"><a href="#Local-Config" class="headerlink" title="Local Config"></a>Local Config</h3></li></ul><p>用来解析orderer节点的配置文件: <code>orderer.yaml</code>，并保存入内存。</p><p>该配置文件中的配置，是节点本地的配置，不需要Orderer节点间统一的配置，因此不需要上链，相关配置有：</p><ul><li>网络相关配置</li><li>账本类型、位置</li><li>raft文件位置</li><li>…</li></ul><p>而上链的配置，被称为通道配置，需要使用配置交易进行更新，这部分配置，写在<code>configtx.yaml</code>中，和Orderer相关的有：</p><ul><li>共识类型</li><li>区块大小</li><li>切区块的时间</li><li>区块内交易数</li><li>各种共识的相关配置</li><li>…</li></ul><h3 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h3><p>区块中有4个元数据：</p><ul><li>区块签名，存放orderer对区块的SignatureHeader</li><li>最新配置区块的高度，方便获取当前通道最新配置</li><li>交易过滤，为数组，存放区块内所有交易的有效性，使用数字代表无效的原因，由验证交易的记账节点填写</li><li>orderer相关元数据，不同的共识类型，该元数据不同</li></ul><p>区块Header中记录了Data.Hash()，Data是所有交易后序列化的结果，但不包含区块元数据，所以区块元数据是可以在产生区块后修改的。即，即使元数据上链了，但这数据是可以修改的，只不过修改也没有什么意义。</p><h3 id="MsgProcessor"><a href="#MsgProcessor" class="headerlink" title="MsgProcessor"></a>MsgProcessor</h3><p>orderer收到交易后需要对交易进行多项检查，不同的通道可以设置不同的MsgProcessor，也就可以进行不同的检查。</p><p>当前Processor分2个：</p><ul><li>应用通道的叫StandardChannel</li><li>系统通道的叫SystemChannel</li></ul><p>StandardChannel会对交易进行以下检查：</p><ul><li>交易内容不能为空</li><li>交易大小不能超过区块大小最大值（默认10MB）</li><li>交易交易签名不符合签名策略</li><li>签名者证书是否过期</li></ul><p>SystemChannel只比StandardChannel多一项：系统配置检查，用来检查以下交易中包含的配置，配置项是否有缺失，或者此项配置是否允许更新等。</p><h3 id="BlockCutter"><a href="#BlockCutter" class="headerlink" title="BlockCutter"></a>BlockCutter</h3><p>BlockCutter用来把收到的交易分成多个组，每组交易会打包到一个区块中。而分组的过程，就是切块，每组交易被称为一个Batch，它有一个缓冲区用来存放待切块交易。</p><p>切块有3个可配置条件：</p><ul><li>缓冲区内交易数，达到区块包含的交易上限（默认500）</li><li>缓冲区内交易总大小，达到区块大小上限（默认10MB）</li><li>缓冲区存在交易，并且未出块的时间，达到切块超时时间（默认2s）</li></ul><p>切块有1个不可配置条件：</p><ul><li>缓冲区收到配置交易，配置交易要放到单独区块，如果缓冲区有交易，缓冲区已有交易会切到1个区块</li></ul><p>超多刚接触Fabric的人有这样一个疑问：排序节点是按什么规则对交易排序的？</p><p>按什么顺序对交易排序并不重要，只要交易在区块内的顺序是一致的，然后所有记账节点，按交易在区块内的顺序，处理交易，最后得到的状态必然是一致的，这也是区块链保持一致性的原理。</p><p>再回过头来说一下实现是什么顺序：哪个交易先写入BlockCutter的缓冲区，哪个交易就在前面，仅此而已。</p><h3 id="BlockWriter"><a href="#BlockWriter" class="headerlink" title="BlockWriter"></a>BlockWriter</h3><p>Orderer的BlockWriter是基于common/ledger实现的，<strong>它用来保存区块文件</strong>，不包含状态数据库等其他数据库，其中有3类区块文件:ram，json和file，file是Orderer和Peer都可使用的，另外2个只能Orderer使用。</p><p>BlockWriter用来向Peer的账本追加区块，但追加区块之前，还需要做另外1件事情，设置区块的元数据。</p><p>区块元数据包含：</p><ul><li>区块签名，存放orderer对区块的SignatureHeader</li><li>最新配置区块的高度，方便获取当前通道最新配置</li><li>交易过滤，为数组，存放区块内所有交易的有效性，使用数字代表无效的原因，由验证交易的记账节点填写</li><li>orderer相关元数据，不同的共识类型，该元数据不同</li></ul><p>但此时只设置其中的3个：区块签名、配置区块高度、orderer相关的元数据。因为交易的有效性在记账节点检查后才能设置。</p><p><strong>为何不在创建区块的时候就设置这些元数据信息，而是在区块经过共识之后？</strong></p><p>共识的过程会传播区块，只让区块包含必要的信息，可以减少区块大小，降低通信量。但元数据占用大小非常小，所以这未必是真实原因。</p><p>BlockWriter还有<strong>另外一个功能：根据一个Batch创建下一个高度的区块</strong>。一个区块包含了：</p><ul><li>Header：区块高度、前一个区块Hash、Data的哈希值</li><li>Data：被序列化的交易列表</li><li>Metadata：区块元数据</li></ul><p>Header只记录Data的哈希值，不包含Metadata哈希值，这样的目的是，在区块创建之后，仍能修改区块。</p><h2 id="Orderer节点启动"><a href="#Orderer节点启动" class="headerlink" title="Orderer节点启动"></a>Orderer节点启动</h2><p>根据Fabric 1.4源码梳理Orderer启动步骤：</p><ul><li>加载配置文件</li><li>设置Logger</li><li>设置本地MSP</li><li>核心启动部分：<ul><li>加载创世块</li><li>创建账本工厂</li><li>创建本机gRPCServer</li><li>如果共识需要集群(raft)，创建集群gRPCServer</li><li>创建Registrar：设置好共识插件，启动各通道，如果共识是raft，还会设置集群的gRPC接口处理函数Step</li><li>创建本机server：它是原子广播的处理服务，融合了Broadcast处理函数、deliver处理函数和registrar</li><li>开启profile</li><li>启动集群gRPC服务</li><li>启动本机gRPC服务</li></ul></li></ul><p>启动流程图可请参考杨宝华的笔记<a href="https://github.com/yeasy/hyperledger_code_fabric/blob/master/process/orderer_start.md" target="_blank" rel="noopener">Orderer 节点启动过程</a>，笔记可能是老版本的Fabric，但依然有参考价值。</p><h2 id="Orderer处理交易的流程"><a href="#Orderer处理交易的流程" class="headerlink" title="Orderer处理交易的流程"></a>Orderer处理交易的流程</h2><h3 id="普通交易在Orderer中的流程"><a href="#普通交易在Orderer中的流程" class="headerlink" title="普通交易在Orderer中的流程"></a>普通交易在Orderer中的流程</h3><p>交易是区块链的核心，交易在Orderer中的流程分3阶段：</p><ol><li>Orderer 的 Broadcast 接口收到来自客户端提交的交易，会获取交易所在的链的资源，并进行首次检查，然后提交给该链的共识，对交易进行排序，最后向客户端发送响应，为下图蓝色部分。</li><li>共识实例是单独运行的，也就是说Orderer把交易交给共识后，共识可能还在处理交易，然而Orderer已经开始向客户端发送提交交易的响应。共识如果发现排序服务的配置如果进行了更新，会再次检查交易，然后利用把Pending的交易分割成一组，然后打包成区块，然后共识机制确保各Orderer节点对区块达成一致，最后将区块写入账本。为下图绿色部分。</li><li>Peer会向Orderer订阅区块事件，每当新区块被Orderer写入账本时，Orderer会把新区块以区块事件的方式，发送给Peer。为下图换色部分。</li></ol><p><img src="http://img.lessisbetter.site/2019-11-21-orderer-tx-flow.png" alt=""></p><p>上面提到Orderer和共识实例分别会对交易进行2次检查，这些检查是相同的，为何要进行两次检查呢？</p><p>代码如下：ProcessMessage 会调用<code>ProcessNormalMsg</code>，对交易进行第一次检查，如果有错误，会向客户端返回错误响应。 SomeConsensurFunc 是一个假的函数名称，但3种共识插件实现，都包含相同的代码片，当消息中 configSeq &lt; seq 时，再次对交易进行检查，如果错误，则丢次此条交易。configSeq是Order函数传入的，即第一次检查交易时的配置号，seq为共识当前运行时的配置号。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bh *Handler)</span> <span class="title">ProcessMessage</span><span class="params">(msg *cb.Envelope, addr <span class="keyword">string</span>)</span> <span class="params">(resp *ab.BroadcastResponse)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    configSeq, err := processor.ProcessNormalMsg(msg)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        logger.Warningf(<span class="string">"[channel: %s] Rejecting broadcast of normal message from %s because of error: %s"</span>, chdr.ChannelId, addr, err)</span><br><span class="line">        <span class="keyword">return</span> &amp;ab.BroadcastResponse&#123;Status: ClassifyError(err), Info: err.Error()&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    err = processor.Order(msg, configSeq)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SomeConsensurFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> msg.configSeq &lt; seq &#123;</span><br><span class="line">        _, err = ch.support.ProcessNormalMsg(msg.normalMsg)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            logger.Warningf(<span class="string">"Discarding bad normal message: %s"</span>, err)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我认为如此设计的原因，考量如下：<br>共识插件应当尽量高效，orderer尽量把能做的做掉，把不能做的交给共识插件，而交易检查就是orderer能做的。共识插件只有在排序服务配置更新后，才需要重新检查交易，以判断是否依然满足规则。排序服务的配置通常是比较稳定的，更新频率很低，所以进行2次校验的频率也是非常低。这种方式，比只在共识插件校验，会拥有更高的整体性能。</p><h3 id="配置交易在Orderer中的流程"><a href="#配置交易在Orderer中的流程" class="headerlink" title="配置交易在Orderer中的流程"></a>配置交易在Orderer中的流程</h3><p>配置交易可以用来创建通道、更新通道配置，与普通交易的处理流程总体是相似的，只不过多了一些地方或者使用不同的函数，比如：</p><ul><li>交易检查函数不是ProcessNormalMsg，而是ProcessConfigMsg</li><li>配置交易单独打包在1个区块</li><li>配置交易写入账本后，要让配置生效，即Orderer应用最新的配置</li><li>…</li></ul><h3 id="使用Raft共识，交易在Orderer中的流程"><a href="#使用Raft共识，交易在Orderer中的流程" class="headerlink" title="使用Raft共识，交易在Orderer中的流程"></a>使用Raft共识，交易在Orderer中的流程</h3><p>上面2中流程都是与具体共识算法无关的，这里补充一个Raft共识的。</p><p><img src="http://img.lessisbetter.site/2020-01-orderer-using-raft.png" alt=""></p><p>使用Raft共识的链处理交易包含了上图中的4步：</p><ul><li>交易：处理交易</li><li>区块：创建区块</li><li>Raft：使用Raft对区块达成共识</li><li>账本：写区块元数据，把区块写入到账本</li></ul><p>如果把图中提到的：转发和Raft去掉，就是以Solo为共识的链的过程。</p><p>下图是更加细化一层的，如果看不懂，建议先读下<a href="http://lessisbetter.site/2019/08/22/etcd-raft-source-data-flow/">Etcd Raft架构设计和源码剖析2：数据流</a>这篇文章。</p><p><img src="http://img.lessisbetter.site/2020-01-fabric-order-with-etcdraft.png" alt=""></p><p>红色圈出来的是etcd/raft的实现，蓝色圈出来的是Fabric使用raft为共识的部分，外面的Broadcast、Deliver是属于Orderer但不属于某条链。</p><p>这张图和etcd与raft交互没有太多不同，只有2个地方：</p><ol><li>chains要把交易转化为区块，再交给raft去共识</li><li>chains的Apply并不是去修改状态机，而是把取消写到账本</li></ol><h2 id="源码简介"><a href="#源码简介" class="headerlink" title="源码简介"></a>源码简介</h2><p>Orderer的代码位于<code>fabric/orderer</code>，其目录结构如下，标注了每个目录结构的功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">➜  fabric git:(readCode) ✗ tree -L 2 orderer</span><br><span class="line">orderer</span><br><span class="line">├── README.md</span><br><span class="line">├── common</span><br><span class="line">│   ├── blockcutter 缓存待打包的交易，切块</span><br><span class="line">│   ├── bootstrap 启动时替换通道创世块</span><br><span class="line">│   ├── broadcast orderer的Broadcast接口</span><br><span class="line">│   ├── cluster （Raft）集群服务</span><br><span class="line">│   ├── localconfig 解析orderer配置文件orderer.yaml</span><br><span class="line">│   ├── metadata 区块元数据填写</span><br><span class="line">│   ├── msgprocessor 交易检查</span><br><span class="line">│   ├── multichannel 多通道支持：Registrar、chainSupport、写区块</span><br><span class="line">│   └── server Orderer节点的服务端程序</span><br><span class="line">├── consensus 共识插件</span><br><span class="line">│   ├── consensus.go 共识插件需要实现的接口等定义</span><br><span class="line">│   ├── etcdraft raft共识插件</span><br><span class="line">│   ├── inactive 未激活时的raft</span><br><span class="line">│   ├── kafka kafka共识插件</span><br><span class="line">│   ├── mocks 测试用的共识插件</span><br><span class="line">│   └── solo solo共识插件</span><br><span class="line">├── main.go orderer程序入口</span><br><span class="line">├── mocks</span><br><span class="line">│   ├── common</span><br><span class="line">│   └── util</span><br><span class="line">└── sample_clients orderer的客户端程序样例</span><br><span class="line">    ├── broadcast_config</span><br><span class="line">    ├── broadcast_msg</span><br><span class="line">    └── deliver_stdout</span><br><span class="line"></span><br><span class="line">23 directories, 3 files</span><br></pre></td></tr></table></figure><p>阅读Orderer源码，深入学习Orderer的时候，建议以下顺序：</p><ul><li>核心的数据结构，主要在multichannel、consensus.go：<a href="http://lessisbetter.site/2019/11/18/fabric-orderer-structs/">Fabric 1.4源码解读 6：Orderer核心数据结构</a></li><li>Orderer的启动</li><li>Broadcast接口</li><li>msgprocessor</li><li>通过Solo掌握共识插件需要做哪些工作</li><li>切块：blockcutter</li><li>写区块：BlockWriter、metadata</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文从宏观的角度介绍了Orderer的功能、核心组成，以及交易在Orderer中的流程，Peer如何从Orderer获取区块。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Orderer介绍&quot;&gt;&lt;a href=&quot;#Orderer介绍&quot; class=&quot;headerlink&quot; title=&quot;Orderer介绍&quot;&gt;&lt;/a&gt;Orderer介绍&lt;/h2&gt;&lt;p&gt;排序服务由一组&lt;strong&gt;排序节点&lt;/strong&gt;组成，它接收客户端提交的交易
      
    
    </summary>
    
    
    
      <category term="区块链" scheme="http://lessisbetter.site/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Fabric" scheme="http://lessisbetter.site/tags/Fabric/"/>
    
  </entry>
  
  <entry>
    <title>Fabric 1.4源码解读 6：Orderer核心数据结构</title>
    <link href="http://lessisbetter.site/2019/11/18/fabric-orderer-structs/"/>
    <id>http://lessisbetter.site/2019/11/18/fabric-orderer-structs/</id>
    <published>2019-11-18T12:45:23.000Z</published>
    <updated>2019-11-18T03:46:55.513Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>许多Orderer的文章，都是从Orderer的启动过程讲起，今天换一种“乐高”角度，先看看有哪些“零件”，再看这些零件怎么配合。</p><p>Orderer负责接收交易，把交易打包成区块，然后区块在所有Orderer节点之间达成一致，再分发给Peer的功能，这涉及了：</p><ul><li>网络：gRPC接收交易，向Peer发送区块</li><li>切块：把交易打包成区块</li><li>共识：所有Orderer节点达成一致</li></ul><p>这些功能是由Orderer核心数据结构组织起来。</p><blockquote><p>在Fabric中，通道和链在概念上都是一条区块链，所以本文中也会可能会混用链和通道。</p></blockquote><h2 id="核心数据结构"><a href="#核心数据结构" class="headerlink" title="核心数据结构"></a>核心数据结构</h2><h3 id="Registrar"><a href="#Registrar" class="headerlink" title="Registrar"></a>Registrar</h3><p><img src="http://img.lessisbetter.site/2019-11-orderer-registrar.png" alt="Registrar"></p><p>代码中，这样描述Registrar：</p><blockquote><p>Registrar serves as a point of access and control for the individual channel resources.</p></blockquote><p>可见它负责了每个channel资源的访问和控制点，也就说，要对某个通道怎么样，得从这入手。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Registrar <span class="keyword">struct</span> &#123;</span><br><span class="line">lock sync.RWMutex</span><br><span class="line"><span class="comment">// 保存了多条链</span></span><br><span class="line">chains <span class="keyword">map</span>[<span class="keyword">string</span>]*ChainSupport</span><br><span class="line"></span><br><span class="line"><span class="comment">// 共识插件</span></span><br><span class="line">consenters         <span class="keyword">map</span>[<span class="keyword">string</span>]consensus.Consenter</span><br><span class="line">ledgerFactory      blockledger.Factory</span><br><span class="line">signer             crypto.LocalSigner</span><br><span class="line">    </span><br><span class="line">systemChannelID    <span class="keyword">string</span></span><br><span class="line">systemChannel      *ChainSupport</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>chains</code>保存了每一条链，每一条链在Orderer中都以<a href="#ChainSupport">ChainSupport</a>代表。</li><li><code>consenters</code>保存了所有的共识插件，每个共识插件都是一个<a href="#Consenter">Consenter</a>，Fabric 1.4中共识插件有Solo、Kafka、EtcdRaft。</li><li><code>ledgerFactory</code>用来读取和创建链的账本。</li><li><code>signer</code>用来对Orderer中的数据进行签名，以及创建<a href="http://lessisbetter.site/2019/11/10/how-fabric-verify-signatures/#解密SignatureHeader">SignatureHeader</a>。</li><li><code>systemChannelID</code>和<code>systemChannel</code>分别是系统链ID、系统链实例。</li></ul><h3 id="ChainSupport"><a href="#ChainSupport" class="headerlink" title="ChainSupport"></a>ChainSupport</h3><p><img src="http://img.lessisbetter.site/2019-11-orderer-chainsupport.png" alt="chainsupport"></p><p>ChainSupport汇集了一条通道所需要的所有资源，所以说一个ChainSupport代表了一条链。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ChainSupport <span class="keyword">struct</span> &#123;</span><br><span class="line">*ledgerResources</span><br><span class="line">msgprocessor.Processor</span><br><span class="line">*BlockWriter</span><br><span class="line">consensus.Chain</span><br><span class="line">cutter blockcutter.Receiver</span><br><span class="line">crypto.LocalSigner</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ChainSupport 是一堆接口的集合，这些接口构成一条链所有的操作，接口可以分为4类：</p><ul><li>账本：<code>ledgerResources</code>、<code>BlockWriter</code>分别是账本读写和把区块写入到账本。</li><li>消息：<code>msgprocessor.Processor</code>、<code>cutter</code>分别是处理交易和把交易切块。</li><li>共识：<code>consensus.Chain</code>是Orderer的共识实例，比如每条链都有自己的Raft共识实例，它们互不干扰。</li><li>签名：<code>crypto.LocalSigner</code>，同Registrar中的介绍。</li></ul><h3 id="Chain"><a href="#Chain" class="headerlink" title="Chain"></a>Chain</h3><p><img src="http://img.lessisbetter.site/2019-11-orderer-chain.png" alt="Chain"></p><p>Chain是接口，它的实现并不一条链，而是一条链的共识实例，可以是Solo、Kafka和EtcdRaft，它运行在单独的协程，使用Channel和ChainSupport通信，它调用其它接口完成切块，以及让所有的Orderer节点对交易达成一致。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Chain defines a way to inject messages for ordering.</span></span><br><span class="line"><span class="comment">// Note, that in order to allow flexibility in the implementation, it is the responsibility of the implementer</span></span><br><span class="line"><span class="comment">// to take the ordered messages, send them through the blockcutter.Receiver supplied via HandleChain to cut blocks,</span></span><br><span class="line"><span class="comment">// and ultimately write the ledger also supplied via HandleChain.  This design allows for two primary flows</span></span><br><span class="line"><span class="comment">// 1. Messages are ordered into a stream, the stream is cut into blocks, the blocks are committed (solo, kafka)</span></span><br><span class="line"><span class="comment">// 2. Messages are cut into blocks, the blocks are ordered, then the blocks are committed (sbft)</span></span><br><span class="line"><span class="keyword">type</span> Chain <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// 普通消息/交易排序</span></span><br><span class="line"><span class="comment">// Order accepts a message which has been processed at a given configSeq.</span></span><br><span class="line"><span class="comment">// If the configSeq advances, it is the responsibility of the consenter</span></span><br><span class="line"><span class="comment">// to revalidate and potentially discard the message</span></span><br><span class="line"><span class="comment">// The consenter may return an error, indicating the message was not accepted</span></span><br><span class="line">Order(env *cb.Envelope, configSeq <span class="keyword">uint64</span>) error</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置消息/交易排序</span></span><br><span class="line"><span class="comment">// Configure accepts a message which reconfigures the channel and will</span></span><br><span class="line"><span class="comment">// trigger an update to the configSeq if committed.  The configuration must have</span></span><br><span class="line"><span class="comment">// been triggered by a ConfigUpdate message. If the config sequence advances,</span></span><br><span class="line"><span class="comment">// it is the responsibility of the consenter to recompute the resulting config,</span></span><br><span class="line"><span class="comment">// discarding the message if the reconfiguration is no longer valid.</span></span><br><span class="line"><span class="comment">// The consenter may return an error, indicating the message was not accepted</span></span><br><span class="line">Configure(config *cb.Envelope, configSeq <span class="keyword">uint64</span>) error</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待排序集群可用</span></span><br><span class="line"><span class="comment">// WaitReady blocks waiting for consenter to be ready for accepting new messages.</span></span><br><span class="line"><span class="comment">// This is useful when consenter needs to temporarily block ingress messages so</span></span><br><span class="line"><span class="comment">// that in-flight messages can be consumed. It could return error if consenter is</span></span><br><span class="line"><span class="comment">// in erroneous states. If this blocking behavior is not desired, consenter could</span></span><br><span class="line"><span class="comment">// simply return nil.</span></span><br><span class="line">WaitReady() error</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当排序集群发送错误时，会关闭返回的通道</span></span><br><span class="line"><span class="comment">// Errored returns a channel which will close when an error has occurred.</span></span><br><span class="line"><span class="comment">// This is especially useful for the Deliver client, who must terminate waiting</span></span><br><span class="line"><span class="comment">// clients when the consenter is not up to date.</span></span><br><span class="line">Errored() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动当前链</span></span><br><span class="line"><span class="comment">// Start should allocate whatever resources are needed for staying up to date with the chain.</span></span><br><span class="line"><span class="comment">// Typically, this involves creating a thread which reads from the ordering source, passes those</span></span><br><span class="line"><span class="comment">// messages to a block cutter, and writes the resulting blocks to the ledger.</span></span><br><span class="line">Start()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止当前链，并释放资源</span></span><br><span class="line"><span class="comment">// Halt frees the resources which were allocated for this Chain.</span></span><br><span class="line">Halt()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Consenter"><a href="#Consenter" class="headerlink" title="Consenter"></a>Consenter</h3><p><img src="http://img.lessisbetter.site/2019-11-orderer-consenter.png" alt="Consenter"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Consenter <span class="keyword">interface</span> &#123;</span><br><span class="line">HandleChain(support ConsenterSupport, metadata *cb.Metadata) (Chain, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Consenter也是接口，它只有1个功能用来创建<code>Chain</code>。每种共识插件，都有自己单独的<strong>consenter实现</strong>，分别用来创建solo实例、kafka实例或etcdraft实例。</p><h3 id="ConsenterSupport"><a href="#ConsenterSupport" class="headerlink" title="ConsenterSupport"></a>ConsenterSupport</h3><p><img src="http://img.lessisbetter.site/2019-11-orderer-consentersupport.png" alt="ConsenterSupport"></p><p>ConsenterSupport为<strong>consenter实现</strong>提供所需的资源，其实就是共识用来访问外部数据的接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConsenterSupport provides the resources available to a Consenter implementation.</span></span><br><span class="line"><span class="keyword">type</span> ConsenterSupport <span class="keyword">interface</span> &#123;</span><br><span class="line">crypto.LocalSigner</span><br><span class="line">msgprocessor.Processor</span><br><span class="line"></span><br><span class="line"><span class="comment">// VerifyBlockSignature verifies a signature of a block with a given optional</span></span><br><span class="line"><span class="comment">// configuration (can be nil).</span></span><br><span class="line">VerifyBlockSignature([]*cb.SignedData, *cb.ConfigEnvelope) error</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供把消息切成块的接口</span></span><br><span class="line"><span class="comment">// BlockCutter returns the block cutting helper for this channel.</span></span><br><span class="line">BlockCutter() blockcutter.Receiver</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前链的orderer配置</span></span><br><span class="line"><span class="comment">// SharedConfig provides the shared config from the channel's current config block.</span></span><br><span class="line">SharedConfig() channelconfig.Orderer</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前链的通道配置</span></span><br><span class="line"><span class="comment">// ChannelConfig provides the channel config from the channel's current config block.</span></span><br><span class="line">ChannelConfig() channelconfig.Channel</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成区块</span></span><br><span class="line"><span class="comment">// CreateNextBlock takes a list of messages and creates the next block based on the block with highest block number committed to the ledger</span></span><br><span class="line"><span class="comment">// Note that either WriteBlock or WriteConfigBlock must be called before invoking this method a second time.</span></span><br><span class="line">CreateNextBlock(messages []*cb.Envelope) *cb.Block</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读区块</span></span><br><span class="line"><span class="comment">// Block returns a block with the given number,</span></span><br><span class="line"><span class="comment">// or nil if such a block doesn't exist.</span></span><br><span class="line">Block(number <span class="keyword">uint64</span>) *cb.Block</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写区块</span></span><br><span class="line"><span class="comment">// WriteBlock commits a block to the ledger.</span></span><br><span class="line">WriteBlock(block *cb.Block, encodedMetadataValue []<span class="keyword">byte</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写配置区块并更新配置</span></span><br><span class="line"><span class="comment">// WriteConfigBlock commits a block to the ledger, and applies the config update inside.</span></span><br><span class="line">WriteConfigBlock(block *cb.Block, encodedMetadataValue []<span class="keyword">byte</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sequence returns the current config squence.</span></span><br><span class="line">Sequence() <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ChainID returns the channel ID this support is associated with.</span></span><br><span class="line">ChainID() <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Height returns the number of blocks in the chain this channel is associated with.</span></span><br><span class="line">Height() <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以原始数据的格式追加区块，不像WriteBlock那样会修改元数据</span></span><br><span class="line"><span class="comment">// Append appends a new block to the ledger in its raw form,</span></span><br><span class="line"><span class="comment">// unlike WriteBlock that also mutates its metadata.</span></span><br><span class="line">Append(block *cb.Block) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="宏观视角"><a href="#宏观视角" class="headerlink" title="宏观视角"></a>宏观视角</h2><p>把上面介绍的各项，融合在一幅图中：</p><ul><li>Registrar 包容万象，主要是ChainSupport和Consenter，Consenter是可插拔的</li><li>ChainSupport 代表了一条链，能够指向属于本条链的共识实例，该共识实例由对应共识类型的Consenter创建</li><li>共识实例使用ConsenterSupport访问共识外部资源</li></ul><p><img src="http://img.lessisbetter.site/2019-11-core-struct-of-orderer.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;许多Orderer的文章，都是从Orderer的启动过程讲起，今天换一种“乐高”角度，先看看有哪些“零件”，再看这些零件怎么配合。&lt;/p&gt;

      
    
    </summary>
    
    
    
      <category term="区块链" scheme="http://lessisbetter.site/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Fabric" scheme="http://lessisbetter.site/tags/Fabric/"/>
    
  </entry>
  
  <entry>
    <title>使用fabric-sdk-go订阅Fabric事件</title>
    <link href="http://lessisbetter.site/2019/11/13/using-fabric-sdk-go-register-event/"/>
    <id>http://lessisbetter.site/2019/11/13/using-fabric-sdk-go-register-event/</id>
    <published>2019-11-13T12:43:13.000Z</published>
    <updated>2019-11-13T08:43:47.825Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://lessisbetter.site/2019/09/02/fabric-sdk-go-chaincode/">使用fabric-sdk-go操作链码</a>，介绍了使用官方Go SDK，安装、实例化和升级链码，调用和查询链码，本文介绍使用fabric-sdk-go订阅事件。</p><h2 id="事件介绍"><a href="#事件介绍" class="headerlink" title="事件介绍"></a>事件介绍</h2><p>本质上就3种事件：</p><ul><li>BlockEvent：获取区块信息</li><li>TransactionEvent：获取交易信息</li><li>ChainCodeEvnet：链码中<strong>自定义的</strong>链码事件</li></ul><p>但每种事件都有2 种类型：</p><ul><li><strong>Filtered</strong>：事件订阅时默认的类型，获取的<strong>信息“不全”</strong>，不同的事件缺失的数据不同，比如链码事件，如果是Filtered的，其响应字段中的Payload是空的，也就是不知道链码事件携带的数据。这种方式能够降低fabric网络和SDK之间的流量，当Filtered后的字段信息就足够时，这种方式非常适合。关于Filtered的更多信息，这篇文章 <a href="http://lessisbetter.site/2019/09/20/fabric-event-source/">Fabric 1.4源码解读 3：Event原理解读</a> 非常有帮助。</li><li><strong>非Filtered</strong> ：可以获取<strong>完整的</strong>区块、交易、链码事件<strong>信息</strong>，这种方式在SDK想获取更多信息时，是非常必要的。</li></ul><p>4 个注册事件的接口1个取消注册的接口如下：</p><table><thead><tr><th style="text-align:center">接口名称</th><th style="text-align:center">描述</th><th style="text-align:center">参数值</th><th style="text-align:center">返回值</th></tr></thead><tbody><tr><td style="text-align:center">RegisterBlockEvent</td><td style="text-align:center">注册块事件</td><td style="text-align:center">filter …fab.BlockFilter</td><td style="text-align:center">fab.Registration, &lt;-chan *fab.BlockEvent, error</td></tr><tr><td style="text-align:center">RegisterFilteredBlockEvent</td><td style="text-align:center">注册过滤块事件</td><td style="text-align:center">无</td><td style="text-align:center">fab.Registration, &lt;-chan *fab.FilteredBlockEvent, error</td></tr><tr><td style="text-align:center">RegisterTxStatusEvent</td><td style="text-align:center">注册交易状态事件</td><td style="text-align:center">txID string</td><td style="text-align:center">fab.Registration, &lt;-chan *fab.TxStatusEvent, error</td></tr><tr><td style="text-align:center">RegisterChaincodeEvent</td><td style="text-align:center">注册链码事件</td><td style="text-align:center">ccID, eventFilter string</td><td style="text-align:center">fab.Registration, &lt;-chan *fab.CCEvent, error</td></tr><tr><td style="text-align:center">Unregister</td><td style="text-align:center">取消事件订阅</td><td style="text-align:center">fab.Registration</td><td style="text-align:center">无</td></tr></tbody></table><p>注册会得到管理可以管理订阅的Registration、接收事件的通道，以及可能注册时发生的错误，关于每个接口的具体介绍、使用，可以参考官方的<a href="https://godoc.org/github.com/hyperledger/fabric-sdk-go/pkg/client/event" target="_blank" rel="noopener">Event文档</a>，其中包含了样例代码，如果想看真实的样例代码，可以参考<a href="#示例项目">示例项目</a>。</p><h2 id="Option介绍"><a href="#Option介绍" class="headerlink" title="Option介绍"></a>Option介绍</h2><p>注册事件需要使用<code>EventClient</code>，创建EventClient时可以指定一些选项，这些选项其实就是事件订阅的选项。</p><p>有3个Option:</p><ul><li><p>func WithBlockEvents() ClientOption</p><p>  指定了此选项，事件就是<strong>非“filtered”</strong>，fabric会向调用SDK客户端发送完整的区块，可以获得订阅事件完整的信息。</p></li><li><p>func WithSeekType(seek seek.Type) ClientOption</p><p>  使用此选项可以<strong>指定从哪个区块高度获取事件</strong>。<code>seek.Type</code>有<code>Oldest</code>、<code>Newest</code>和<code>FromBlock</code> 3种取值，分别代表从第1个区块、最后一个区块和指定区块号开始获取事件，<code>FromBlock</code>需要结合<code>WithBlockNum</code>使用。So，可以通过这个选项<strong>获取历史事件</strong>。</p></li><li><p>func WithBlockNum(from uint64) ClientOption</p><p>  指定区块高度，只有<code>WithSeekType(FromBlock)</code>时才生效。</p></li></ul><h2 id="链码事件多说几句"><a href="#链码事件多说几句" class="headerlink" title="链码事件多说几句"></a>链码事件多说几句</h2><h3 id="链码如何发链码事件"><a href="#链码如何发链码事件" class="headerlink" title="链码如何发链码事件"></a>链码如何发链码事件</h3><p><code>ChaincodeStubInterface</code>有<code>SetEvent</code>的方法，入参分别为事件名称和事件锁携带的信息payload。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ChaincodeStubInterface is used by deployable chaincode apps to access and</span></span><br><span class="line"><span class="comment">// modify their ledgers</span></span><br><span class="line"><span class="keyword">type</span> ChaincodeStubInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// SetEvent allows the chaincode to set an event on the response to the</span></span><br><span class="line">    <span class="comment">// proposal to be included as part of a transaction. The event will be</span></span><br><span class="line">    <span class="comment">// available within the transaction in the committed block regardless of the</span></span><br><span class="line">    <span class="comment">// validity of the transaction.</span></span><br><span class="line">    SetEvent(name <span class="keyword">string</span>, payload []<span class="keyword">byte</span>) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过ChannelClient订阅链码事件介绍"><a href="#通过ChannelClient订阅链码事件介绍" class="headerlink" title="通过ChannelClient订阅链码事件介绍"></a>通过ChannelClient订阅链码事件介绍</h3><p>SDK的channel client也有订阅链码事件的接口：<a href="https://godoc.org/github.com/hyperledger/fabric-sdk-go/pkg/client/channel#Client.RegisterChaincodeEvent" target="_blank" rel="noopener">channel.Client.RegisterChaincodeEvent()</a>，它的定义和event client提供的接口完全一样，但功能上有所差别。</p><p>channel client没有指定 <code>WithBlockEvents</code>，所以这是<strong>Filtered的事件链码</strong>，获取的事件链码中，其Payload为空。</p><h2 id="示例项目"><a href="#示例项目" class="headerlink" title="示例项目"></a>示例项目</h2><p>示例项目<a href="https://github.com/Shitaibin/fabric-sdk-go-sample/tree/master/samples/event" target="_blank" rel="noopener">fabric-sdk-go-sample</a>是结合Fabric的BYFN展示如何使用fabric-sdk-go的项目，它的Event样例部分，介绍了如何使用以上接口订阅Fabric事件，具体请参加该部分<a href="https://github.com/Shitaibin/fabric-sdk-go-sample/blob/master/samples/event/README.md" target="_blank" rel="noopener">README</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://lessisbetter.site/2019/09/02/fabric-sdk-go-chaincode/&quot;&gt;使用fabric-sdk-go操作链码&lt;/a&gt;，介绍了使用官方Go SDK，安装、实例化和升级链码，调用和查询链码，本文介绍使用fa
      
    
    </summary>
    
    
    
      <category term="区块链" scheme="http://lessisbetter.site/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Fabric" scheme="http://lessisbetter.site/tags/Fabric/"/>
    
  </entry>
  
  <entry>
    <title>Fabric 1.4源码解读 5：Fabric是如何验证签名的？</title>
    <link href="http://lessisbetter.site/2019/11/10/how-fabric-verify-signatures/"/>
    <id>http://lessisbetter.site/2019/11/10/how-fabric-verify-signatures/</id>
    <published>2019-11-10T13:23:36.000Z</published>
    <updated>2020-03-30T08:53:34.287Z</updated>
    
    <content type="html"><![CDATA[<h2 id="理论知识"><a href="#理论知识" class="headerlink" title="理论知识"></a>理论知识</h2><p>如果不清楚数字证书、公私钥与签名的关系，建议阅读阮一峰的<a href="https://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html" target="_blank" rel="noopener">数字签名是什么？</a>。</p><h2 id="Fabric证书和密钥文件"><a href="#Fabric证书和密钥文件" class="headerlink" title="Fabric证书和密钥文件"></a>Fabric证书和密钥文件</h2><p>使用Fabric CA或者 cryptogen 工具可以生成证书和私钥文件，这里取 BYFN 例子的文件做介绍，Org1 Admin 账户的文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">➜  first-network git:(release-1.4) ✗ tree crypto-config&#x2F;peerOrganizations&#x2F;org1.example.com&#x2F;users&#x2F;Admin@org1.example.com</span><br><span class="line">crypto-config&#x2F;peerOrganizations&#x2F;org1.example.com&#x2F;users&#x2F;Admin@org1.example.com</span><br><span class="line">├── msp</span><br><span class="line">│   ├── admincerts</span><br><span class="line">│   │   └── Admin@org1.example.com-cert.pem</span><br><span class="line">│   ├── cacerts</span><br><span class="line">│   │   └── ca.org1.example.com-cert.pem</span><br><span class="line">│   ├── keystore</span><br><span class="line">│   │   └── f9f3dddb7fcc40086de6d5ae77f1481abbb99bff7a74839b950720d3dca0d8ee_sk</span><br><span class="line">│   ├── signcerts</span><br><span class="line">│   │   └── Admin@org1.example.com-cert.pem</span><br><span class="line">│   └── tlscacerts</span><br><span class="line">│       └── tlsca.org1.example.com-cert.pem</span><br><span class="line">└── tls</span><br><span class="line">    ├── ca.crt</span><br><span class="line">    ├── client.crt</span><br><span class="line">    └── client.key</span><br></pre></td></tr></table></figure><p>msp目录，为Admin的身份信息：</p><ul><li>admincerts：组织管理员的身份验证证书。</li><li>cacerts：组织的根证书。</li><li>keystore：该用户的私钥，用来对消息签名。</li><li>signcerts：该用户的身份验证证书，被组织根证书签名。</li><li>tlscacerts：TLS通信用的身份证书，为组织的TLS证书。</li></ul><p>tls目录，为TLS通信相关的证书：</p><ul><li>ca.crt：组织根证书</li><li>client.crt：验证当前用户身份的证书，当前为验证管理员的证书</li><li>client.key：当前用户的身份私钥，用来签名</li></ul><h2 id="整体逻辑"><a href="#整体逻辑" class="headerlink" title="整体逻辑"></a>整体逻辑</h2><p>交易是区块链的核心，一切状态的转移都是一条交易，交易的真伪需要使用数字签名进行保证。</p><p>在Fabric中，交易涉及两个概念：</p><ul><li>Proposal：提案</li><li>Transaction：交易</li></ul><p>所以 Proposal 和 Transaction 都需要使用数字签名进行保护，它们相关的消息中，都包含了发送方的身份信息：mspid、证书（证书中实际包含了公钥）。</p><p>提案的实际消息是 SignedProposal，其中包含了：</p><ul><li>数字签名：Signature</li><li>证书、公钥等签名者身份信息：ProposalBytes.Proposal.Header.SignatureHeader.Creator</li></ul><p><img src="http://img.lessisbetter.site/2019-11-signed_proposal.png" alt="signed_proposal"></p><blockquote><p>图来自杨保华的<a href="https://github.com/yeasy/hyperledger_code_fabric" target="_blank" rel="noopener">hyperledger_code_fabric</a> 。</p></blockquote><p>交易中最重要的是Envelope结构体，SDK向Orderer提交交易时，会发送Envelope消息，它包含了：</p><ul><li>数字签名：Signature</li><li>交易发送方的身份信息：Payload.Header.SignatureHeader.Creator</li><li>可选背书节点的身份信息，不同的交易类型，Data包含了不同的信息，如果是需要背书的，可以包含背书的信息、签名和身份信息：Payload.Data.SignedChainccodeDeploymentSpec.OwnerEndorsements.signingidentity</li></ul><p><img src="http://img.lessisbetter.site/2019-11-tx_envelop.jpeg" alt="Signed transaction"></p><blockquote><p>图来自《区块链原理、设计与应用》，为升级链码的交易Envelope结构。</p></blockquote><p>在验证消息的签名时，会从中提取出数字签名Signature，身份信息（证书、公钥）和被签名消息体，完成以下验证：</p><ul><li>使用证书验证发送方的身份，发送方是否属于它所在的组织，以及发送方的公钥没有修改和替换</li><li>使用公钥验证消息是否为发送方签名，并且消息没有被修改</li></ul><p>验证的整体流程如下：</p><p><img src="http://img.lessisbetter.site/2019-11-verify-signature.png" alt="Verify signature"></p><h2 id="验证签名的函数"><a href="#验证签名的函数" class="headerlink" title="验证签名的函数"></a>验证签名的函数</h2><p><code>core/common/validation/msgvalidation.go</code> 提供了2验证消息签名的函数，用来验证Proposal和Transaction，它们会调用相同的函数<code>checkSignatureFromCreator</code>进行数字签名的验证。</p><h3 id="验证Porposal签名"><a href="#验证Porposal签名" class="headerlink" title="验证Porposal签名"></a>验证Porposal签名</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValidateProposalMessage</span><span class="params">(signedProp *pb.SignedProposal)</span> <span class="params">(*pb.Proposal, *common.Header, *pb.ChaincodeHeaderExtension, error)</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从SignatureHeader交易客户端的签名</span></span><br><span class="line"><span class="comment">// validate the signature</span></span><br><span class="line">err = checkSignatureFromCreator(shdr.Creator, signedProp.Signature, signedProp.ProposalBytes, chdr.ChannelId)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// log the exact message on the peer but return a generic error message to</span></span><br><span class="line"><span class="comment">// avoid malicious users scanning for channels</span></span><br><span class="line">putilsLogger.Warningf(<span class="string">"channel [%s]: %s"</span>, chdr.ChannelId, err)</span><br><span class="line">sId := &amp;msp.SerializedIdentity&#123;&#125;</span><br><span class="line">err := proto.Unmarshal(shdr.Creator, sId)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// log the error here as well but still only return the generic error</span></span><br><span class="line">err = errors.Wrap(err, <span class="string">"could not deserialize a SerializedIdentity"</span>)</span><br><span class="line">putilsLogger.Warningf(<span class="string">"channel [%s]: %s"</span>, chdr.ChannelId, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, errors.Errorf(<span class="string">"access denied: channel [%s] creator org [%s]"</span>, chdr.ChannelId, sId.Mspid)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="验证Transaction签名"><a href="#验证Transaction签名" class="headerlink" title="验证Transaction签名"></a>验证Transaction签名</h3><p>Commit阶段会对交易进行验证，会调用此函数，该函数完成了对Transaction的验证，包含发送方数字签名的验证。</p><p>交易是包含背书结果和背书签名的，背书相关的验证并不包含在此，而是专门的背书验证，具体请看<a href="http://lessisbetter.site/2019/09/06/fabric-source-endorser-policy-flow/">Fabric 1.4源码解读 1：背书策略是怎么使用的</a>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ValidateTransaction checks that the transaction envelope is properly formed</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValidateTransaction</span><span class="params">(e *common.Envelope, c channelconfig.ApplicationCapabilities)</span> <span class="params">(*common.Payload, pb.TxValidationCode)</span></span> &#123;</span><br><span class="line">putilsLogger.Debugf(<span class="string">"ValidateTransactionEnvelope starts for envelope %p"</span>, e)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// validate the header</span></span><br><span class="line">chdr, shdr, err := validateCommonHeader(payload.Header)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">putilsLogger.Errorf(<span class="string">"validateCommonHeader returns err %s"</span>, err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, pb.TxValidationCode_BAD_COMMON_HEADER</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// validate the signature in the envelope</span></span><br><span class="line">err = checkSignatureFromCreator(shdr.Creator, e.Signature, e.Payload, chdr.ChannelId)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">putilsLogger.Errorf(<span class="string">"checkSignatureFromCreator returns err %s"</span>, err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, pb.TxValidationCode_BAD_CREATOR_SIGNATURE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// continue the validation in a way that depends on the type specified in the header</span></span><br><span class="line"><span class="keyword">switch</span> common.HeaderType(chdr.Type) &#123;</span><br><span class="line"><span class="keyword">case</span> common.HeaderType_ENDORSER_TRANSACTION:</span><br><span class="line"><span class="comment">// Verify that the transaction ID has been computed properly.</span></span><br><span class="line"><span class="comment">// This check is needed to ensure that the lookup into the ledger</span></span><br><span class="line"><span class="comment">// for the same TxID catches duplicates.</span></span><br><span class="line">err = utils.CheckTxID(</span><br><span class="line">chdr.TxId,</span><br><span class="line">shdr.Nonce,</span><br><span class="line">shdr.Creator)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">putilsLogger.Errorf(<span class="string">"CheckTxID returns err %s"</span>, err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, pb.TxValidationCode_BAD_PROPOSAL_TXID</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是背书交易，背书的签名不在此验证，由背书策略模块进行验证</span></span><br><span class="line">err = validateEndorserTransaction(payload.Data, payload.Header)</span><br><span class="line">putilsLogger.Debugf(<span class="string">"ValidateTransactionEnvelope returns err %s"</span>, err)</span><br></pre></td></tr></table></figure><h2 id="验证签名"><a href="#验证签名" class="headerlink" title="验证签名"></a>验证签名</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// given a creator, a message and a signature,</span></span><br><span class="line"><span class="comment">// this function returns nil if the creator</span></span><br><span class="line"><span class="comment">// is a valid cert and the signature is valid</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkSignatureFromCreator</span><span class="params">(creatorBytes []<span class="keyword">byte</span>, sig []<span class="keyword">byte</span>, msg []<span class="keyword">byte</span>, ChainID <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">putilsLogger.Debugf(<span class="string">"begin"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// check for nil argument</span></span><br><span class="line"><span class="keyword">if</span> creatorBytes == <span class="literal">nil</span> || sig == <span class="literal">nil</span> || msg == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">"nil arguments"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个链有各自的msp</span></span><br><span class="line">mspObj := mspmgmt.GetIdentityDeserializer(ChainID)</span><br><span class="line"><span class="keyword">if</span> mspObj == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.Errorf(<span class="string">"could not get msp for channel [%s]"</span>, ChainID)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取proposal创建者/发送方的Identity</span></span><br><span class="line"><span class="comment">// creatorBytes 中是序列化后的mspid、证书、公钥等信息</span></span><br><span class="line">creator, err := mspObj.DeserializeIdentity(creatorBytes)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.WithMessage(err, <span class="string">"MSP error"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">putilsLogger.Debugf(<span class="string">"creator is %s"</span>, creator.GetIdentifier())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证证书是否有效</span></span><br><span class="line"><span class="comment">// ensure that creator is a valid certificate</span></span><br><span class="line">err = creator.Validate()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.WithMessage(err, <span class="string">"creator certificate is not valid"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">putilsLogger.Debugf(<span class="string">"creator is valid"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// validate the signature</span></span><br><span class="line"><span class="comment">// 验证签名</span></span><br><span class="line">err = creator.Verify(msg, sig)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.WithMessage(err, <span class="string">"creator's signature over the proposal is not valid"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">putilsLogger.Debugf(<span class="string">"exits successfully"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取Identity"><a href="#获取Identity" class="headerlink" title="获取Identity"></a>获取Identity</h3><p>获取当前通道的MSP manager：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetIdentityDeserializer returns the IdentityDeserializer for the given chain</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetIdentityDeserializer</span><span class="params">(chainID <span class="keyword">string</span>)</span> <span class="title">msp</span>.<span class="title">IdentityDeserializer</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> chainID == <span class="string">""</span> &#123;</span><br><span class="line"><span class="keyword">return</span> GetLocalMSP()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> GetManagerForChain(chainID)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetManagerForChain returns the msp manager for the supplied</span></span><br><span class="line"><span class="comment">// chain; if no such manager exists, one is created</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetManagerForChain</span><span class="params">(chainID <span class="keyword">string</span>)</span> <span class="title">msp</span>.<span class="title">MSPManager</span></span> &#123;</span><br><span class="line">m.Lock()</span><br><span class="line"><span class="keyword">defer</span> m.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先从缓存查找</span></span><br><span class="line">mspMgr, ok := mspMap[chainID]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="comment">// 找不到则新建立当前通道Msp manager</span></span><br><span class="line">mspLogger.Debugf(<span class="string">"Created new msp manager for channel `%s`"</span>, chainID)</span><br><span class="line">mspMgmtMgr := &amp;mspMgmtMgr&#123;msp.NewMSPManager(), <span class="literal">false</span>&#125;</span><br><span class="line">mspMap[chainID] = mspMgmtMgr</span><br><span class="line">mspMgr = mspMgmtMgr</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// check for internal mspManagerImpl and mspMgmtMgr types. if a different</span></span><br><span class="line"><span class="comment">// type is found, it's because a developer has added a new type that</span></span><br><span class="line"><span class="comment">// implements the MSPManager interface and should add a case to the logic</span></span><br><span class="line"><span class="comment">// above to handle it.</span></span><br><span class="line"><span class="keyword">if</span> !(reflect.TypeOf(mspMgr).Elem().Name() == <span class="string">"mspManagerImpl"</span> || reflect.TypeOf(mspMgr).Elem().Name() == <span class="string">"mspMgmtMgr"</span>) &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"Found unexpected MSPManager type."</span>)</span><br><span class="line">&#125;</span><br><span class="line">mspLogger.Debugf(<span class="string">"Returning existing manager for channel '%s'"</span>, chainID)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mspMgr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MSPManager has been setup for a channel, which indicates whether the channel</span></span><br><span class="line"><span class="comment">// exists or not</span></span><br><span class="line"><span class="keyword">type</span> mspMgmtMgr <span class="keyword">struct</span> &#123;</span><br><span class="line">msp.MSPManager</span><br><span class="line"><span class="comment">// track whether this MSPManager has been setup successfully</span></span><br><span class="line">up <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>msp.MSPManager</code>是一个接口，从上面代码可以得知，它是利用<code>NewMSPManager</code>创建的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建等待Setup的MSPManager</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMSPManager</span><span class="params">()</span> <span class="title">MSPManager</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;mspManagerImpl&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>疑问是，啥时候Setup的，当前调用路径上没发现这个路径，可能从系统整体流程上，已经保证了，当前调用时，已经创建好了。</p><p>获取Identity，是一个剥洋葱的过程：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mgr *mspMgmtMgr)</span> <span class="title">DeserializeIdentity</span><span class="params">(serializedIdentity []<span class="keyword">byte</span>)</span> <span class="params">(msp.Identity, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> !mgr.up &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"channel doesn't exist"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mgr.MSPManager.DeserializeIdentity(serializedIdentity)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际调用<code>mspManagerImpl</code>的<code>DeserializeIdentity</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DeserializeIdentity returns an identity given its serialized version supplied as argument</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mgr *mspManagerImpl)</span> <span class="title">DeserializeIdentity</span><span class="params">(serializedID []<span class="keyword">byte</span>)</span> <span class="params">(Identity, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// We first deserialize to a SerializedIdentity to get the MSP ID</span></span><br><span class="line">sId := &amp;msp.SerializedIdentity&#123;&#125;</span><br><span class="line">err := proto.Unmarshal(serializedID, sId)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">"could not deserialize a SerializedIdentity"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取发送方的msp实例</span></span><br><span class="line"><span class="comment">// we can now attempt to obtain the MSP</span></span><br><span class="line">msp := mgr.mspsMap[sId.Mspid]</span><br><span class="line"><span class="keyword">if</span> msp == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.Errorf(<span class="string">"MSP %s is unknown"</span>, sId.Mspid)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> t := msp.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> *bccspmsp:</span><br><span class="line"><span class="keyword">return</span> t.deserializeIdentityInternal(sId.IdBytes)</span><br><span class="line"><span class="keyword">case</span> *idemixmsp:</span><br><span class="line"><span class="keyword">return</span> t.deserializeIdentityInternal(sId.IdBytes)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> t.DeserializeIdentity(serializedID)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转到bccspmsp的实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反序列化二进制，得到证书，然后用证书获取公钥，使用证书、公钥和msp，创建Identity</span></span><br><span class="line"><span class="comment">// deserializeIdentityInternal returns an identity given its byte-level representation</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(msp *bccspmsp)</span> <span class="title">deserializeIdentityInternal</span><span class="params">(serializedIdentity []<span class="keyword">byte</span>)</span> <span class="params">(Identity, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// This MSP will always deserialize certs this way</span></span><br><span class="line">bl, _ := pem.Decode(serializedIdentity)</span><br><span class="line"><span class="keyword">if</span> bl == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"could not decode the PEM structure"</span>)</span><br><span class="line">&#125;</span><br><span class="line">cert, err := x509.ParseCertificate(bl.Bytes)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">"parseCertificate failed"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now we have the certificate; make sure that its fields</span></span><br><span class="line"><span class="comment">// (e.g. the Issuer.OU or the Subject.OU) match with the</span></span><br><span class="line"><span class="comment">// MSP id that this MSP has; otherwise it might be an attack</span></span><br><span class="line"><span class="comment">// TODO!</span></span><br><span class="line"><span class="comment">// We can't do it yet because there is no standardized way</span></span><br><span class="line"><span class="comment">// (yet) to encode the MSP ID into the x.509 body of a cert</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从证书中提取公钥，封装一下，满足bccsp.Key接口</span></span><br><span class="line">pub, err := msp.bccsp.KeyImport(cert, &amp;bccsp.X509PublicKeyImportOpts&#123;Temporary: <span class="literal">true</span>&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.WithMessage(err, <span class="string">"failed to import certificate's public key"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用证书、公钥和msp建立角色身份</span></span><br><span class="line"><span class="keyword">return</span> newIdentity(cert, pub, msp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Identity包含了Identity标示符，证书、公钥和所在的msp，创建Identity就是计算以上几项信息的过程：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> identity <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// id contains the identifier (MSPID and identity identifier) for this instance</span></span><br><span class="line">id *IdentityIdentifier</span><br><span class="line"></span><br><span class="line"><span class="comment">// cert contains the x.509 certificate that signs the public key of this instance</span></span><br><span class="line">cert *x509.Certificate</span><br><span class="line"></span><br><span class="line"><span class="comment">// this is the public key of this instance</span></span><br><span class="line">pk bccsp.Key</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference to the MSP that "owns" this identity</span></span><br><span class="line">msp *bccspmsp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newIdentity</span><span class="params">(cert *x509.Certificate, pk bccsp.Key, msp *bccspmsp)</span> <span class="params">(Identity, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> mspIdentityLogger.IsEnabledFor(zapcore.DebugLevel) &#123;</span><br><span class="line">mspIdentityLogger.Debugf(<span class="string">"Creating identity instance for cert %s"</span>, certToPEM(cert))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查证书</span></span><br><span class="line"><span class="comment">// Sanitize first the certificate</span></span><br><span class="line">cert, err := msp.sanitizeCert(cert)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compute identity identifier</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Use the hash of the identity's certificate as id in the IdentityIdentifier</span></span><br><span class="line">hashOpt, err := bccsp.GetHashOpt(msp.cryptoConfig.IdentityIdentifierHashFunction)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.WithMessage(err, <span class="string">"failed getting hash function options"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">digest, err := msp.bccsp.Hash(cert.Raw, hashOpt)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.WithMessage(err, <span class="string">"failed hashing raw certificate to compute the id of the IdentityIdentifier"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id := &amp;IdentityIdentifier&#123;</span><br><span class="line">Mspid: msp.name,</span><br><span class="line">Id:    hex.EncodeToString(digest)&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;identity&#123;id: id, cert: cert, pk: pk, msp: msp&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="验证数字签名"><a href="#验证数字签名" class="headerlink" title="验证数字签名"></a>验证数字签名</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Verify checks against a signature and a message</span></span><br><span class="line"><span class="comment">// to determine whether this identity produced the</span></span><br><span class="line"><span class="comment">// signature; it returns nil if so or an error otherwise</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(id *identity)</span> <span class="title">Verify</span><span class="params">(msg []<span class="keyword">byte</span>, sig []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// mspIdentityLogger.Infof("Verifying signature")</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Compute Hash</span></span><br><span class="line">hashOpt, err := id.getHashOpt(id.msp.cryptoConfig.SignatureHashFamily)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.WithMessage(err, <span class="string">"failed getting hash function options"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">digest, err := id.msp.bccsp.Hash(msg, hashOpt)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.WithMessage(err, <span class="string">"failed computing digest"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> mspIdentityLogger.IsEnabledFor(zapcore.DebugLevel) &#123;</span><br><span class="line">mspIdentityLogger.Debugf(<span class="string">"Verify: digest = %s"</span>, hex.Dump(digest))</span><br><span class="line">mspIdentityLogger.Debugf(<span class="string">"Verify: sig = %s"</span>, hex.Dump(sig))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终会调用bccsp的接口验证签名，SW或者国密</span></span><br><span class="line">valid, err := id.msp.bccsp.Verify(id.pk, sig, digest, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.WithMessage(err, <span class="string">"could not determine the validity of the signature"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> !valid &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">"The signature is invalid"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解密SignatureHeader"><a href="#解密SignatureHeader" class="headerlink" title="解密SignatureHeader"></a>解密SignatureHeader</h2><p>Fabric 使用 <code>SignatureHeader</code> 保存发送方的身份信息，Creator即为序列化后的信息。</p><p><code>SignatureHeaderMaker</code> 接口定义了创建一个 <code>SignatureHeader</code> 的方法，搜索起来实现该接口的结构体很多，本质上只有2个：<code>mspSigner</code> 和 <code>SignatureHeaderCreator</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SignatureHeaderMaker creates a new SignatureHeader</span></span><br><span class="line"><span class="keyword">type</span> SignatureHeaderMaker <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// NewSignatureHeader creates a SignatureHeader with the correct signing identity and a valid nonce</span></span><br><span class="line">NewSignatureHeader() (*cb.SignatureHeader, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// localmsp</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *mspSigner)</span> <span class="title">NewSignatureHeader</span><span class="params">()</span> <span class="params">(*cb.SignatureHeader, error)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// crypto</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bs *SignatureHeaderCreator)</span> <span class="title">NewSignatureHeader</span><span class="params">()</span> <span class="params">(*cb.SignatureHeader, error)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>两个实现本质上是一样的，以 <code>mspSigner</code> 为例进行介绍。首先获取实现SigningIdentity接口的实例，然后调用<code>Serialize</code>得到序列化后的身份信息，再随机生成一个Nonce，创建出<code>SignatureHeader</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewSignatureHeader creates a SignatureHeader with the correct signing identity and a valid nonce</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *mspSigner)</span> <span class="title">NewSignatureHeader</span><span class="params">()</span> <span class="params">(*cb.SignatureHeader, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// 获得SigningIdentity接口实例</span></span><br><span class="line">signer, err := mspmgmt.GetLocalMSP().GetDefaultSigningIdentity()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"Failed getting MSP-based signer [%s]"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化得到creator</span></span><br><span class="line">creatorIdentityRaw, err := signer.Serialize()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"Failed serializing creator public identity [%s]"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一个随机nonce</span></span><br><span class="line">nonce, err := crypto.GetRandomNonce()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"Failed creating nonce [%s]"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sh := &amp;cb.SignatureHeader&#123;&#125;</span><br><span class="line">sh.Creator = creatorIdentityRaw</span><br><span class="line">sh.Nonce = nonce</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sh, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SigningIdentity</code>接口包含了<code>Identity</code>接口，Identity声明了跟证书相关的方法，SigningIdentity则增加了对消息签名的函数<code>Sign</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SigningIdentity <span class="keyword">interface</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Extends Identity</span></span><br><span class="line">Identity</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sign the message</span></span><br><span class="line">Sign(msg []<span class="keyword">byte</span>) ([]<span class="keyword">byte</span>, error)</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetPublicVersion returns the public parts of this identity</span></span><br><span class="line">GetPublicVersion() Identity</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Identity <span class="keyword">interface</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="comment">// Serialize converts an identity to bytes</span></span><br><span class="line">Serialize() ([]<span class="keyword">byte</span>, error)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Serialize</code>的实现，实际只包含了证书和MSPID，说明了<strong>消息中携带的只包含MSPID和证书作为身份信息</strong>，而不是<code>signingidentity</code>的所有字段（signingidentity实现了SigningIdentity接口）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Serialize returns a byte array representation of this identity</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(id *identity)</span> <span class="title">Serialize</span><span class="params">()</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// mspIdentityLogger.Infof("Serializing identity %s", id.id)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Raw格式证书</span></span><br><span class="line">pb := &amp;pem.Block&#123;Bytes: id.cert.Raw, Type: <span class="string">"CERTIFICATE"</span>&#125;</span><br><span class="line">pemBytes := pem.EncodeToMemory(pb)</span><br><span class="line"><span class="keyword">if</span> pemBytes == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"encoding of identity failed"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用MSPID和序列化后的证书，再次序列化得到身份信息 </span></span><br><span class="line">sId := &amp;msp.SerializedIdentity&#123;Mspid: id.id.Mspid, IdBytes: pemBytes&#125;</span><br><span class="line">idBytes, err := proto.Marshal(sId)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrapf(err, <span class="string">"could not marshal a SerializedIdentity structure for identity %s"</span>, id.id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> idBytes, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://github.com/yeasy/hyperledger_code_fabric" target="_blank" rel="noopener">https://github.com/yeasy/hyperledger_code_fabric</a></li><li>《区块链原理、设计与应用》第9章、第10章</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;理论知识&quot;&gt;&lt;a href=&quot;#理论知识&quot; class=&quot;headerlink&quot; title=&quot;理论知识&quot;&gt;&lt;/a&gt;理论知识&lt;/h2&gt;&lt;p&gt;如果不清楚数字证书、公私钥与签名的关系，建议阅读阮一峰的&lt;a href=&quot;https://www.ruanyifeng.co
      
    
    </summary>
    
    
    
      <category term="区块链" scheme="http://lessisbetter.site/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Fabric" scheme="http://lessisbetter.site/tags/Fabric/"/>
    
  </entry>
  
  <entry>
    <title>Go Modules 方法、问题汇总贴</title>
    <link href="http://lessisbetter.site/2019/10/31/go-modules-notes/"/>
    <id>http://lessisbetter.site/2019/10/31/go-modules-notes/</id>
    <published>2019-10-31T09:07:59.000Z</published>
    <updated>2019-10-31T09:29:11.578Z</updated>
    
    <content type="html"><![CDATA[<h2 id="教程资料"><a href="#教程资料" class="headerlink" title="教程资料"></a>教程资料</h2><ul><li>简单操作：<a href="https://segmentfault.com/a/1190000016703769" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016703769</a></li><li>多项介绍：<a href="https://learnku.com/golang/t/33859" target="_blank" rel="noopener">https://learnku.com/golang/t/33859</a></li><li>官方教程：<a href="https://blog.golang.org/using-go-modules" target="_blank" rel="noopener">https://blog.golang.org/using-go-modules</a></li></ul><h2 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h2><h3 id="replace-使用http或https"><a href="#replace-使用http或https" class="headerlink" title="replace 使用http或https"></a>replace 使用http或https</h3><p>在使用go replace时，有2点注意：</p><ul><li>目标仓库不能带协议头，比如http、https，要从域名或者IP开始</li><li>版本号格式要符合语义格式化，测试版本是否符合规则：<a href="https://play.golang.org/p/S_Jz3-Uxh_T" target="_blank" rel="noopener">Go playground 样例代码</a></li></ul><p>直接修改 <code>go.mod</code> 文件格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replace github.com&#x2F;hyperledger&#x2F;fabric v1.4.1 &#x3D;&gt; 192.168.9.251&#x2F;hyperledger&#x2F;fabric v1.4.1-alpha.11-yx</span><br></pre></td></tr></table></figure></p><p>或使用命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod edit -replace&#x3D;github.com&#x2F;hyperledger&#x2F;fabric@v1.4.1&#x3D;192.168.9.251&#x2F;hyperledger&#x2F;fabric@v1.4.1</span><br></pre></td></tr></table></figure></p><h3 id="Gitlab-仓库没开启https"><a href="#Gitlab-仓库没开启https" class="headerlink" title="Gitlab 仓库没开启https"></a>Gitlab 仓库没开启https</h3><p>go mod 默认使用 go get 下载依赖，而 go get 默认使用 https，如果 Gitlab 仓库没有启用 https，需要使用 <code>-insecure</code> 让go get走http。</p><p>问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GOPROXY&#x3D;&quot;&quot; go get github.com&#x2F;hyperledger&#x2F;fabric@v1.4.1</span><br><span class="line">go: 192.168.9.251&#x2F;hyperledger&#x2F;fabric@v1.4.1-alpha.11-yx: unrecognized import path &quot;192.168.9.251&#x2F;hyperledger&#x2F;fabric&quot; (https fetch: Get https:&#x2F;&#x2F;192.168.9.251&#x2F;hyperledger&#x2F;fabric?go-get&#x3D;1: dial tcp 192.168.9.251:443: connect: connection refused)</span><br><span class="line">go: error loading module requirements</span><br></pre></td></tr></table></figure><p>方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GOPROXY&#x3D;&quot;&quot; go get -insecure github.com&#x2F;hyperledger&#x2F;fabric@v1.4.1</span><br></pre></td></tr></table></figure><blockquote><p>注解：遇到问题时，使用 <code>go get -v</code> 可以看到更多信息，有助分析问题。</p></blockquote><h3 id="Go-Modules-代理"><a href="#Go-Modules-代理" class="headerlink" title="Go Modules 代理"></a>Go Modules 代理</h3><p>由于某些网络原因，国内下载 Github 等处的依赖，不够流程，需要设置代理，不同版本的设置如下：</p><ul><li><p>go1.12</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ export GOPROXY&#x3D;https:&#x2F;&#x2F;goproxy.cn</span><br></pre></td></tr></table></figure></li><li><p>go1.13</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ export GOPRIVATE&#x3D;192.168.9.251</span><br><span class="line">$ export GOPROXY&#x3D;https:&#x2F;&#x2F;goproxy.cn,direct</span><br></pre></td></tr></table></figure></li></ul><h3 id="私有仓库"><a href="#私有仓库" class="headerlink" title="私有仓库"></a>私有仓库</h3><p>如果仓库设置为私有，这要求用户必须登录才能访问仓库。</p><p>Go Modules 默认使用 go get 下载依赖，go get 利用 https 或者 http, 但下载过程没有设置用户名和密码的地方，下载依赖时，可能遇到一下错误：</p><ul><li>connection refused</li><li>unkown revision</li></ul><p>可以通过设置Github/Gitlab Access Token结果，通过token的方式，访问仓库，token的获取方式为，登录Gitlab仓库，进入以下页面：</p><p>Gitlab User Setting -&gt; Access Tokens</p><p>在此页面复制下顶端的 <code>Your New Personal Access Token</code>, 然后填写token名字和勾选下方的权限进行创建 Token。</p><p>然后执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global \</span><br><span class="line">url.<span class="string">"http://oauth2:<span class="variable">$&#123;your_access_token&#125;</span>@ip_address_or_domain"</span>.insteadOf \</span><br><span class="line"><span class="string">"http://ip_address_or_domain"</span></span><br></pre></td></tr></table></figure><p>后面再去 go get 的时候，就可顺利下载依赖。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;教程资料&quot;&gt;&lt;a href=&quot;#教程资料&quot; class=&quot;headerlink&quot; title=&quot;教程资料&quot;&gt;&lt;/a&gt;教程资料&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;简单操作：&lt;a href=&quot;https://segmentfault.com/a/119000001670376
      
    
    </summary>
    
    
    
      <category term="Go" scheme="http://lessisbetter.site/tags/Go/"/>
    
  </entry>
  
</feed>
