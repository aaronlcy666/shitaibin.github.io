<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Go语言充电站</title>
  
  <subtitle>大彬 less is better</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lessisbetter.site/"/>
  <updated>2020-03-16T06:18:34.904Z</updated>
  <id>http://lessisbetter.site/</id>
  
  <author>
    <name>大彬</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go官方进程诊断工具gops详解</title>
    <link href="http://lessisbetter.site/2020/03/15/gops-introduction/"/>
    <id>http://lessisbetter.site/2020/03/15/gops-introduction/</id>
    <published>2020-03-15T12:20:47.000Z</published>
    <updated>2020-03-16T06:18:34.904Z</updated>
    
    <content type="html"><![CDATA[<h2 id="gops简介"><a href="#gops简介" class="headerlink" title="gops简介"></a>gops简介</h2><p>gops是Go团队提供的命令行工具，它可以用来获取go进程运行时信息。</p><p>可以查看：</p><ul><li>当前有哪些go语言进程，哪些使用gops的go进程</li><li>进程的概要信息</li><li>进程的调用栈</li><li>进程的内存使用情况</li><li>构建程序的Go版本</li><li>运行时统计信息</li></ul><p>可以获取：</p><ul><li>trace</li><li>cpu profile和memory profile</li></ul><p>还可以：</p><ul><li>让进程进行1次GC</li><li>设置GC百分比</li></ul><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>使用<code>Options</code>配置agent。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"runtime"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/google/gops/agent"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := agent.Listen(agent.Options&#123;</span><br><span class="line">Addr:            <span class="string">"0.0.0.0:8848"</span>,</span><br><span class="line"><span class="comment">// ConfigDir:       "/home/centos/gopsconfig", // 最好使用默认</span></span><br><span class="line">ShutdownCleanup: <span class="literal">true</span>&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试代码</span></span><br><span class="line">_ = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">1000</span>, <span class="number">1000</span>)</span><br><span class="line">runtime.GC()</span><br><span class="line"></span><br><span class="line">_ = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">1000</span>, <span class="number">2000</span>)</span><br><span class="line">runtime.GC()</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Hour)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="agent-Option选项"><a href="#agent-Option选项" class="headerlink" title="agent Option选项"></a>agent Option选项</h2><p>agent有3个配置：</p><ul><li><code>Addr</code>：agent要监听的ip和端口，默认ip为环回地址，端口随机分配。</li><li><code>ConfigDir</code>：该目录存放的不是agent的配置，而是每一个使用了agent的go进程信息，文件以pid命名，内容是该pid进程所监听的端口号，所以其中文件的目的是形成pid到端口的映射。默认值为<code>~/.config/gops</code></li><li><code>ShutdownCleanup</code>：进程退出时，是否清理ConfigDir中的文件，默认值为false，不清理</li></ul><p>通常可以把<code>Addr</code>设置为要监听的IP，把<code>ShutdownCleanup</code>设置为<code>ture</code>，进程退出后，残留在ConfigDir目录的文件不再有用，最好清除掉。</p><p><code>ConfigDir</code>示例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// gopsconfig为设置的ConfigDir目录，2051为pid，8848为端口号。</span><br><span class="line">➜  ~ cat gopsconfig/2051</span><br><span class="line">8848%</span><br><span class="line">➜  ~ netstat -nap | grep `pgrep gopsexample`</span><br><span class="line">tcp6       0      0 :::8848                 :::*                    LISTEN      2051/./gopsexample</span><br></pre></td></tr></table></figure><h2 id="gops原理"><a href="#gops原理" class="headerlink" title="gops原理"></a>gops原理</h2><p>gops的原理是，代码中导入<code>gops/agent</code>，建立agent服务，gops命令连接<code>agent</code>读取进程信息。</p><p><img src="http://img.lessisbetter.site/2020-03-gops.png" alt="gops"></p><p><code>agent</code>的实现原理可以查看<code>agent/handle</code><a href="https://github.com/google/gops/blob/master/agent/agent.go#L182" target="_blank" rel="noopener">函数</a>。</p><p>使用go标准库中原生接口实现相关功能，如同你要在自己的程序中开启pprof类似，只不过这部分功能由<code>gops/agent</code>实现了：</p><ul><li>使用<code>runtime.MemStats</code>获取内存情况</li><li>使用<code>runtime/pprof</code>获取调用栈、cpu profile和memory profile</li><li>使用<code>runtime/trace</code>获取trace</li><li>使用<code>runtime</code>获取stats信息</li><li>使用<code>runtime/debug</code>、<code>GC</code>设置和启动GC</li></ul><p>再谈<code>ConfigDir</code>。从源码上看，<code>ConfigDir</code>对agent并没有用途，对gops有用。当gops和ConfigDir在一台机器上时，即gops查看本机的go进程信息，gops可以通过其中的文件，快速找到agent服务的端口。能够实现：<code>gops &lt;sub-cmd&gt; pid</code>到<code>gops &lt;sub-cmd&gt; 127.0.0.1:port</code>的转换。</p><p>如果代码中通过<code>ConfigDir</code>指定了其他目录，使用<code>gops</code>时，需要添加环境变量<code>GOPS_CONFIG_DIR</code>指向<code>ConfigDir</code>使用的目录。</p><h2 id="子命令介绍"><a href="#子命令介绍" class="headerlink" title="子命令介绍"></a>子命令介绍</h2><p>gops后面可以跟子命令，然后是pid或者远端地址。</p><p>也可以直接跟pid，查看本机进程信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ gops help memstats</span><br><span class="line">gops is a tool to list and diagnose Go processes.</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  gops &lt;cmd&gt; &lt;pid|addr&gt; ...</span><br><span class="line">  gops &lt;pid&gt; # displays process info</span><br><span class="line">  gops help  # displays this help message</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  stack      Prints the stack trace.</span><br><span class="line">  gc         Runs the garbage collector and blocks until successful.</span><br><span class="line">  setgc     Sets the garbage collection target percentage.</span><br><span class="line">  memstats   Prints the allocation and garbage collection stats.</span><br><span class="line">  version    Prints the Go version used to build the program.</span><br><span class="line">  stats      Prints runtime stats.</span><br><span class="line">  trace      Runs the runtime tracer for 5 secs and launches &quot;go tool trace&quot;.</span><br><span class="line">  pprof-heap Reads the heap profile and launches &quot;go tool pprof&quot;.</span><br><span class="line">  pprof-cpu  Reads the CPU profile and launches &quot;go tool pprof&quot;.</span><br><span class="line"></span><br><span class="line">All commands require the agent running on the Go process.</span><br><span class="line">&quot;*&quot; indicates the process is running the agent.</span><br></pre></td></tr></table></figure><h3 id="查看当前机器上go程序进程信息"><a href="#查看当前机器上go程序进程信息" class="headerlink" title="查看当前机器上go程序进程信息"></a>查看当前机器上go程序进程信息</h3><p>查看当前机器上的go进程，可以列出pid、ppid、进程名、可执行程序所使用的go版本，以及可执行程序的路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ gops</span><br><span class="line">67292 66333 gops                         * go1.13    /Users/shitaibin/Workspace/golang_step_by_step/gops/gops</span><br><span class="line">67434 65931 gops                           go1.13    /Users/shitaibin/go/bin/gops</span><br><span class="line">66551 1     gocode                         go1.11.2  /Users/shitaibin/go/bin/gocode</span><br><span class="line">137   1     com.docker.vmnetd              go1.12.7  /Library/PrivilegedHelperTools/com.docker.vmnetd</span><br><span class="line">811   807   com.docker.backend             go1.12.13 /Applications/Docker.app/Contents/MacOS/com.docker.backend</span><br><span class="line">807   746   com.docker.supervisor          go1.12.13 /Applications/Docker.app/Contents/MacOS/com.docker.supervisor</span><br><span class="line">810   807   com.docker.driver.amd64-linux  go1.12.13 /Applications/Docker.app/Contents/MacOS/com.docker.driver.amd64-linux</span><br></pre></td></tr></table></figure><p>带<code>*</code>的是程序中使用了gops/agent，不带<code>*</code>的是普通的go程序。</p><h3 id="go程序进程树"><a href="#go程序进程树" class="headerlink" title="go程序进程树"></a>go程序进程树</h3><p>查看进程树：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ gops tree</span><br><span class="line">...</span><br><span class="line">├── 66333</span><br><span class="line">│   └── [*]  67292 (gops) &#123;go1.13&#125;</span><br><span class="line">├── 1</span><br><span class="line">│   ├── 66551 (gocode) &#123;go1.11.2&#125;</span><br><span class="line">│   └── 137 (com.docker.vmnetd) &#123;go1.12.7&#125;</span><br><span class="line">├── 65931</span><br><span class="line">│   └── 67476 (gops) &#123;go1.13&#125;</span><br><span class="line">└── 746</span><br><span class="line">    └── 807 (com.docker.supervisor) &#123;go1.12.13&#125;</span><br><span class="line">        ├── 811 (com.docker.backend) &#123;go1.12.13&#125;</span><br><span class="line">        └── 810 (com.docker.driver.amd64-linux) &#123;go1.12.13&#125;</span><br></pre></td></tr></table></figure><h3 id="pid：进程概要信息"><a href="#pid：进程概要信息" class="headerlink" title="pid：进程概要信息"></a>pid：进程概要信息</h3><p>查看进程的概要信息，非gops进程也可以：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ gops 67292</span><br><span class="line">parent PID:66333</span><br><span class="line">threads:7</span><br><span class="line">memory usage:0.018%</span><br><span class="line">cpu usage:0.000%</span><br><span class="line">username:shitaibin</span><br><span class="line">cmd+args:./gops</span><br><span class="line">elapsed time:11:28</span><br><span class="line">local/remote:127.0.0.1:54753 &lt;-&gt; :0 (LISTEN)</span><br><span class="line">➜  ~</span><br><span class="line">➜  ~ gops 807</span><br><span class="line">parent PID:746</span><br><span class="line">threads:28</span><br><span class="line">memory usage:0.057%</span><br><span class="line">cpu usage:0.003%</span><br><span class="line">username:shitaibin</span><br><span class="line">cmd+args:/Applications/Docker.app/Contents/MacOS/com.docker.supervisor -watchdog fd:0</span><br><span class="line">elapsed time:27-23:36:35</span><br><span class="line">local/remote:127.0.0.1:54832 &lt;-&gt; :0 ()</span><br><span class="line">local/remote:*:53849 &lt;-&gt; :0 ()</span><br><span class="line">local/remote:127.0.0.1:49473 &lt;-&gt; :0 (LISTEN)</span><br></pre></td></tr></table></figure><h3 id="stack：当前调用栈"><a href="#stack：当前调用栈" class="headerlink" title="stack：当前调用栈"></a>stack：当前调用栈</h3><p>查看使用gops的进程的调用栈：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ gops stack 67292</span><br><span class="line">goroutine 19 [running]:</span><br><span class="line">runtime/pprof.writeGoroutineStacks(0x1197160, 0xc00009c028, 0x0, 0x0)</span><br><span class="line">/Users/shitaibin/goroot/src/runtime/pprof/pprof.go:679 +0x9d</span><br><span class="line">runtime/pprof.writeGoroutine(0x1197160, 0xc00009c028, 0x2, 0x0, 0x0)</span><br><span class="line">/Users/shitaibin/goroot/src/runtime/pprof/pprof.go:668 +0x44</span><br><span class="line">runtime/pprof.(*Profile).WriteTo(0x1275c60, 0x1197160, 0xc00009c028, 0x2, 0xc00009c028, 0x0)</span><br><span class="line">/Users/shitaibin/goroot/src/runtime/pprof/pprof.go:329 +0x3da</span><br><span class="line">github.com/google/gops/agent.handle(0x1665008, 0xc00009c028, 0xc000014068, 0x1, 0x1, 0x0, 0x0)</span><br><span class="line">/Users/shitaibin/go/src/github.com/google/gops/agent/agent.go:185 +0x1ab</span><br><span class="line">github.com/google/gops/agent.listen()</span><br><span class="line">/Users/shitaibin/go/src/github.com/google/gops/agent/agent.go:133 +0x2bf</span><br><span class="line">created by github.com/google/gops/agent.Listen</span><br><span class="line">/Users/shitaibin/go/src/github.com/google/gops/agent/agent.go:111 +0x364</span><br><span class="line"></span><br><span class="line">goroutine 1 [sleep]:</span><br><span class="line">runtime.goparkunlock(...)</span><br><span class="line">/Users/shitaibin/goroot/src/runtime/proc.go:310</span><br><span class="line">time.Sleep(0x34630b8a000)</span><br><span class="line">/Users/shitaibin/goroot/src/runtime/time.go:105 +0x157</span><br><span class="line">main.main()</span><br><span class="line">/Users/shitaibin/Workspace/golang_step_by_step/gops/example.go:15 +0xa3</span><br><span class="line"></span><br><span class="line">goroutine 18 [syscall]:</span><br><span class="line">os/signal.signal_recv(0x0)</span><br><span class="line">/Users/shitaibin/goroot/src/runtime/sigqueue.go:144 +0x96</span><br><span class="line">os/signal.loop()</span><br><span class="line">/Users/shitaibin/goroot/src/os/signal/signal_unix.go:23 +0x22</span><br><span class="line">created by os/signal.init.0</span><br><span class="line">/Users/shitaibin/goroot/src/os/signal/signal_unix.go:29 +0x41</span><br></pre></td></tr></table></figure><h3 id="memstats-内存使用情况"><a href="#memstats-内存使用情况" class="headerlink" title="memstats: 内存使用情况"></a>memstats: 内存使用情况</h3><p>查看gops进程内存使用情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ gops memstats 67944</span><br><span class="line">alloc: 136.80KB (140088 bytes) // 当前分配出去未收回的内存总量</span><br><span class="line">total-alloc: 152.08KB (155728 bytes) // 已分配出去的内存总量</span><br><span class="line">sys: 67.25MB (70518784 bytes) // 当前进程从OS获取的内存总量</span><br><span class="line">lookups: 0</span><br><span class="line">mallocs: 418 // 分配的对象数量</span><br><span class="line">frees: 82 // 释放的对象数量</span><br><span class="line">heap-alloc: 136.80KB (140088 bytes) // 当前分配出去未收回的堆内存总量</span><br><span class="line">heap-sys: 63.56MB (66650112 bytes) // 当前堆从OS获取的内存</span><br><span class="line">heap-idle: 62.98MB (66035712 bytes) // 当前堆中空闲的内存量</span><br><span class="line">heap-in-use: 600.00KB (614400 bytes) // 当前堆使用中的内存量</span><br><span class="line">heap-released: 62.89MB (65945600 bytes)</span><br><span class="line">heap-objects: 336 // 堆中对象数量</span><br><span class="line">stack-in-use: 448.00KB (458752 bytes) // 栈使用中的内存量 </span><br><span class="line">stack-sys: 448.00KB (458752 bytes) // 栈从OS获取的内存总量 </span><br><span class="line">stack-mspan-inuse: 10.89KB (11152 bytes)</span><br><span class="line">stack-mspan-sys: 16.00KB (16384 bytes)</span><br><span class="line">stack-mcache-inuse: 13.56KB (13888 bytes)</span><br><span class="line">stack-mcache-sys: 16.00KB (16384 bytes)</span><br><span class="line">other-sys: 1.01MB (1062682 bytes)</span><br><span class="line">gc-sys: 2.21MB (2312192 bytes)</span><br><span class="line">next-gc: when heap-alloc &gt;= 4.00MB (4194304 bytes) // 下次GC的条件</span><br><span class="line">last-gc: 2020-03-16 10:06:26.743193 +0800 CST // 上次GC的世界</span><br><span class="line">gc-pause-total: 83.84µs // GC总暂停时间</span><br><span class="line">gc-pause: 44891 // 上次GC暂停时间，单位纳秒</span><br><span class="line">num-gc: 2 // 已进行的GC次数</span><br><span class="line">enable-gc: true // 是否开始GC</span><br><span class="line">debug-gc: false</span><br></pre></td></tr></table></figure><h3 id="stats-运行时信息"><a href="#stats-运行时信息" class="headerlink" title="stats: 运行时信息"></a>stats: 运行时信息</h3><p>查看运行时统计信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ gops stats 68125</span><br><span class="line">goroutines: 3</span><br><span class="line">OS threads: 12</span><br><span class="line">GOMAXPROCS: 8</span><br><span class="line">num CPU: 8</span><br></pre></td></tr></table></figure><h3 id="trace"><a href="#trace" class="headerlink" title="trace"></a>trace</h3><p>获取当前运行5s的trace信息，会打开网页：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ gops trace 68125</span><br><span class="line">Tracing now, will take 5 secs...</span><br><span class="line">Trace dump saved to: /var/folders/5g/rz16gqtx3nsdfs7k8sb80jth0000gn/T/trace116447431</span><br><span class="line">2020/03/16 10:23:37 Parsing trace...</span><br><span class="line">2020/03/16 10:23:37 Splitting trace...</span><br><span class="line">2020/03/16 10:23:37 Opening browser. Trace viewer is listening on http://127.0.0.1:55480</span><br></pre></td></tr></table></figure><h3 id="cpu-profile"><a href="#cpu-profile" class="headerlink" title="cpu profile"></a>cpu profile</h3><p>获取cpu profile，并进入交互模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ gops pprof-cpu 68125</span><br><span class="line">Profiling CPU now, will take 30 secs...</span><br><span class="line"></span><br><span class="line">Profile dump saved to: /var/folders/5g/rz16gqtx3nsdfs7k8sb80jth0000gn/T/profile431166544</span><br><span class="line">Binary file saved to: /var/folders/5g/rz16gqtx3nsdfs7k8sb80jth0000gn/T/binary765361519</span><br><span class="line">File: binary765361519</span><br><span class="line">Type: cpu</span><br><span class="line">Time: Mar 16, 2020 at 10:25am (CST)</span><br><span class="line">Duration: 30s, Total samples = 0</span><br><span class="line">No samples were found with the default sample value type.</span><br><span class="line">Try &quot;sample_index&quot; command to analyze different sample values.</span><br><span class="line">Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)</span><br><span class="line">(pprof)</span><br><span class="line">(pprof) top</span><br><span class="line">Showing nodes accounting for 0, 0% of 0 total</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br></pre></td></tr></table></figure><h3 id="memory-profile"><a href="#memory-profile" class="headerlink" title="memory profile"></a>memory profile</h3><p>获取memory profile，并进入交互模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ gops pprof-heap 68125</span><br><span class="line">Profile dump saved to: /var/folders/5g/rz16gqtx3nsdfs7k8sb80jth0000gn/T/profile292136242</span><br><span class="line">Binary file saved to: /var/folders/5g/rz16gqtx3nsdfs7k8sb80jth0000gn/T/binary693335273</span><br><span class="line">File: binary693335273</span><br><span class="line">Type: inuse_space</span><br><span class="line">Time: Mar 16, 2020 at 10:27am (CST)</span><br><span class="line">No samples were found with the default sample value type.</span><br><span class="line">Try &quot;sample_index&quot; command to analyze different sample values.</span><br><span class="line">Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)</span><br><span class="line">(pprof)</span><br><span class="line">(pprof) traces</span><br><span class="line">File: binary693335273</span><br><span class="line">Type: inuse_space</span><br><span class="line">Time: Mar 16, 2020 at 10:27am (CST)</span><br><span class="line">-----------+-------------------------------------------------------</span><br><span class="line">     bytes:  256kB</span><br><span class="line">         0   compress/flate.(*compressor).init</span><br><span class="line">             compress/flate.NewWriter</span><br><span class="line">             compress/gzip.(*Writer).Write</span><br><span class="line">             runtime/pprof.(*profileBuilder).build</span><br><span class="line">             runtime/pprof.profileWriter</span><br><span class="line">-----------+-------------------------------------------------------</span><br><span class="line">     bytes:  64kB</span><br><span class="line">         0   compress/flate.newDeflateFast</span><br><span class="line">             compress/flate.(*compressor).init</span><br><span class="line">             compress/flate.NewWriter</span><br><span class="line">             compress/gzip.(*Writer).Write</span><br><span class="line">             runtime/pprof.(*profileBuilder).build</span><br><span class="line">             runtime/pprof.profileWriter</span><br><span class="line">-----------+-------------------------------------------------------</span><br></pre></td></tr></table></figure><h2 id="使用远程连接"><a href="#使用远程连接" class="headerlink" title="使用远程连接"></a>使用远程连接</h2><p>agent的默认配置<code>Option{}</code>，监听的是环回地址。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ sudo netstat -nap | grep 414</span><br><span class="line">➜  ~ netstat -nap | grep `pgrep gopsexample`</span><br><span class="line">(Not all processes could be identified, non-owned process info</span><br><span class="line"> will not be shown, you would have to be root to see it all.)</span><br><span class="line">tcp        0      0 127.0.0.1:36812         0.0.0.0:*               LISTEN      414/./gopsexample</span><br></pre></td></tr></table></figure><p>修改程序，在<code>Option</code>中设置监听的地址和端口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">agent.Listen(agent.Options&#123;Addr:<span class="string">"0.0.0.0:8848"</span>&#125;)</span><br></pre></td></tr></table></figure><p>在远程主机上重新编译、重启进程，确认进程监听的端口：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ netstat -nap | grep `pgrep gopsexample`</span><br><span class="line">(Not all processes could be identified, non-owned process info</span><br><span class="line"> will not be shown, you would have to be root to see it all.)</span><br><span class="line">tcp6       0      0 :::8848                 :::*                    LISTEN      887/./gopsexample</span><br></pre></td></tr></table></figure><p>在本地主机上使用gops连接远端go进程，并查看数据：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ gops stats 192.168.9.137:8848</span><br><span class="line">goroutines: 3</span><br><span class="line">OS threads: 9</span><br><span class="line">GOMAXPROCS: 4</span><br><span class="line">num CPU: 4</span><br></pre></td></tr></table></figure><p><code>gops</code>后面只能跟pid查看进程简要信息，不能跟ip和port查看远端go进程简要信息，这些简要信息可以通过子命令汇集起来。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ gops 192.168.9.137:8848</span><br><span class="line">gops: unknown subcommand</span><br><span class="line">➜  ~ </span><br><span class="line">➜  ~ gops version 192.168.9.137:8848</span><br><span class="line">go1.13</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;gops简介&quot;&gt;&lt;a href=&quot;#gops简介&quot; class=&quot;headerlink&quot; title=&quot;gops简介&quot;&gt;&lt;/a&gt;gops简介&lt;/h2&gt;&lt;p&gt;gops是Go团队提供的命令行工具，它可以用来获取go进程运行时信息。&lt;/p&gt;
&lt;p&gt;可以查看：&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
    
      <category term="Go" scheme="http://lessisbetter.site/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>为什么PBFT需要3个阶段消息？</title>
    <link href="http://lessisbetter.site/2020/03/15/why-pbft-needs-3-phase-message/"/>
    <id>http://lessisbetter.site/2020/03/15/why-pbft-needs-3-phase-message/</id>
    <published>2020-03-15T01:25:41.000Z</published>
    <updated>2020-03-15T09:06:39.576Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在面试的时候，很多同学的简历熟悉PBFT共识算法，在现场面试的时候，却只能说个主要逻辑，离完整的算法，还差十万八千里，相似从网络上看了一些文章，就算是熟悉了。当我问“为什么PBFT需要3个阶段消息？2个阶段行不行”时，还没有人能回答出来。</p><p>回答这个问题，还要从PBFT要解决的本质问题说起，所以我打算以这样一个思路，为大家回答问题：</p><ul><li>PBFT与拜占庭问题</li><li>拜占庭节点在网络中的行为</li><li>什么是3阶段消息</li><li>3阶段消息解决什么问题</li><li>为什么不能只有前2个阶段</li><li>论文使用的2个不变性</li><li>为什么3个阶段可以达成一致性</li></ul><h2 id="PBFT与拜占庭问题"><a href="#PBFT与拜占庭问题" class="headerlink" title="PBFT与拜占庭问题"></a>PBFT与拜占庭问题</h2><blockquote><p>莱斯利·兰波特在其论文[1]中描述了如下拜占庭问题：</p><p>一组拜占庭帝国的将军分别各率领一支军队共同围困一座城市。为了简化问题，将各支军队的行动策略限定为进攻或撤离两种。因为部分军队进攻，或部分军队撤离可能会造成灾难性后果，因此各位将军必须通过投票来达成一致策略，即所有军队一起进攻或所有军队一起撤离。因为各位将军分处城市不同方向，他们只能通过信使互相联系。在投票过程中，每位将军都将自己投票进攻还是撤退的信息，通过信使分别通知其他所有将军，这样一来每位将军根据自己的投票，和其他所有将军送来的信息，就可以知道共同的投票结果，而决定行动策略。</p><p>问题在于，将军中可能出现叛徒(坏将军)，他们不仅可能向较为糟糕的策略投票，还可能选择性地发送投票信息。阻止好将军达成一致的形成策略。</p><p>摘自：<a href="https://zh.wikipedia.org/wiki/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">维基百科：拜占庭将军问题</a>，有删改。</p></blockquote><p><em>很多人喜欢玩狼人杀，我也喜欢，但我玩的很菜</em>，我用狼人杀跟拜占庭将军问题做个类比。</p><p>在狼人杀开局的时候，你是好人，并且不知道自己的队友是谁，也不知道狼人是谁，但所有的好人都有一个共同的目的：干死狼人，好人获胜。所以游戏中需要使用技巧和策略，达成目的。</p><p>拜占庭将军问题是类似的，好的将军不知道其他将军是好的，还是坏的，但所有好的将军的目的是：行动一致，共同进退。所以，它们也需要策略达成一致。</p><p>BFT是一类解决拜占庭将军问题的策略/算法：让非拜占庭节点达成一致的算法。在这类论文中，拜占庭节点指“坏”的将军，非拜占庭节点指“好”的将军。</p><p>PBFT是实用拜占庭算法（<a href="http://pmg.csail.mit.edu/papers/osdi99.pdf" target="_blank" rel="noopener">Practical Byzantine Fault Tolerance</a>）的缩写，该论文与1999年发表，另外2001年又发表了一篇<a href="http://www.pmg.csail.mit.edu/papers/bft-tocs.pdf" target="_blank" rel="noopener">Practical Byzantine Fault Tolerance and Proactive Recovery</a>，让PBFT拥有恢复能力。</p><p>PBFT作为解决拜占庭问题的策略：<strong>非拜占庭节点不知道哪些是拜占庭节点，哪些是非拜占庭节点，PBFT要让非拜占庭节点达成一致</strong>。</p><h2 id="拜占庭节点在网络中的行为"><a href="#拜占庭节点在网络中的行为" class="headerlink" title="拜占庭节点在网络中的行为"></a>拜占庭节点在网络中的行为</h2><p>拜占庭问题是在分布式对等网络，对通信容错所提出来的。在真实世界中，拜占庭问题是什么样的？</p><p>通常使用拜占庭行为，描述拜占庭节点可能的行为，拜占庭行为有：</p><ul><li>任何不遵守协议的动作</li><li>恶意代码、节点</li><li>代码bug</li><li>网络故障、数据包损坏</li><li>磁盘崩掉、重复丢失</li><li>无权限时加入</li><li>…</li></ul><h2 id="什么是3阶段消息"><a href="#什么是3阶段消息" class="headerlink" title="什么是3阶段消息"></a>什么是3阶段消息</h2><p><img src="http://img.lessisbetter.site/2020-03-pbft-3-phase-message.png" alt="3阶段消息"></p><p>3阶段消息是：Pre-prepare、Prepare和Commit。每个消息都会包含数字签名，证明消息的发送者，以及消息类型，下文中会省略。</p><p>Pre-prepare消息由主节点发出，包含：</p><ul><li>当前view：v</li><li>主节点分配给请求的序号n</li><li>请求的摘要d</li><li>请求本身m</li></ul><p><strong>务必记牢，m、v、n、d，后面会使用缩写</strong>。</p><p>Prepare是副本节点收到Pre-prepare消息后，做出的响应，发送给所有副本节点，包含：</p><ul><li>v</li><li>n</li><li>d</li></ul><p>Prepared状态：副本i有Pre-prepare消息，且收到2f个有效的Prepare消息。</p><p>副本i达到Prepared状态，可以发送Commit消息，Commit消息的内容和Prepare消息内容相同，但消息类型和数字签名是不同的，所以可以区分。</p><p>m可以使用d代替，所以Prepare和Commit消息使用d代替m，来节省通信量。</p><h2 id="3阶段消息解决什么问题"><a href="#3阶段消息解决什么问题" class="headerlink" title="3阶段消息解决什么问题"></a>3阶段消息解决什么问题</h2><p>前面提到，PBFT解决的是拜占庭问题的一致性，即让非拜占庭节点达成一致。更具体的说：<strong>让请求m，在view内使用序号n，并且完成执行m，向客户端发送响应</strong>。</p><h2 id="为什么不能只有前2个阶段消息"><a href="#为什么不能只有前2个阶段消息" class="headerlink" title="为什么不能只有前2个阶段消息"></a>为什么不能只有前2个阶段消息</h2><p>这个问题的等价问题是：为什么Pre-prepare和Prepare消息，不能让非拜占庭节点达成一致？</p><p>Pre-prepare消息的目的是，主节点为请求m，分配了视图v和序号n，让至少f+1个非拜占庭节点对这个分配组合<code>&lt;m, v, n&gt;</code>达成一致，并且不存在<code>&lt;m&#39;, v, n&gt;</code>，即不存在有2个消息使用同一个v和n的情况。</p><p><strong>Prepared状态可以证明非拜占庭节点在只有请求m使用<code>&lt;v, n&gt;</code>上达成一致</strong>。主节点本身是认可<code>&lt;m, v, n&gt;</code>的，所以副本只需要收集2f个Prepare消息，而不是2f+1个Prepare消息，就可以计算出至少f个副本节点是非拜占庭节点，它们认可m使用<code>&lt;v, n&gt;</code>，并且没有另外1个消息可以使用<code>&lt;v, n&gt;</code>。</p><p>既然1个<code>&lt;v, n&gt;</code>只能对应1个请求m了，达到Prepared状态后，副本i执行请求m，不就达成一致了么？</p><p>并不能。<strong>Prepared是一个局部视角，不是全局一致</strong>，即副本i看到了非拜占庭节点认可了<code>&lt;m, v, n&gt;</code>，但整个系统包含3f+1个节点，异步的系统中，存在丢包、延时、拜占庭节点故意向部分节点发送Prepare等拜占庭行文，<strong>副本i无法确定，其他副本也达到Prepared状态。如果少于f个副本成为Prepared状态，然后执行了请求m，系统就出现了不一致。</strong></p><p>所以，前2个阶段的消息，并不能让非拜占庭节点达成一致。</p><p>如果你了解2PC或者Paxos，我相信可以更容易理解上面的描述。2PC或Paxos，第一步只是用来锁定资源，第2步才是真正去Do Action。把Pre-prepare和Prepare理解为第一步，资源是<code>&lt;v, n&gt;</code>，只有第一步是达不成一致性的。</p><h2 id="2个不变性"><a href="#2个不变性" class="headerlink" title="2个不变性"></a>2个不变性</h2><p>PBFT的论文提到了2个不变性，这2个不变性，<strong>用来证明PBFT如何让非拜占庭节点达成一致性</strong>。</p><p><strong>第1个不变性</strong>，它是由Pre-prepare和Prepare消息所共同确保的不变性：非拜占庭节点在同一个view内对请求的序号达成共识。关于这个不变性，已经在<a href="#为什么不能只有前2个阶段消息">为什么不能只有前2个阶段消息</a>中论述过。</p><p>介绍第2个不变性之前，需要介绍2个定义。</p><ul><li>committed-local：副本i已经是Prepared状态，并且收到了2f+1个Commit消息。</li><li>committed：至少f+1个非拜占庭节点已经是Prepared状态。</li></ul><p><img src="http://img.lessisbetter.site/2020-03-pbft-committed.png" alt=""></p><p><strong>第2个不变性</strong>，如果副本i是committed-local，那么一定存在committed。</p><p>2f+1个Commit消息，去掉最多f个拜占庭节点伪造的消息，得出至少f+1个非拜占庭节点发送了Commit消息，即至少f+1个非拜占庭节点是Prepared状态。所以第2个不变性成立。</p><h2 id="为什么3个阶段消息可以达成一致性"><a href="#为什么3个阶段消息可以达成一致性" class="headerlink" title="为什么3个阶段消息可以达成一致性"></a>为什么3个阶段消息可以达成一致性</h2><p>committed意味着有f+1个非拜占庭节点可以执行请求，而committed-local意味着，副本i看到了有f+1个非拜占庭节点可以执行请求，f+1个非拜占庭节点执行请求，也就达成了，让非拜占庭节点一致。</p><p>虽然我前面使用了2PC和Paxos做类比，但不意味着PBFT的Commit阶段就相当于，2PC和Paxos的第2步。因为2PC和Paxos处理的CFT场景，不存在拜占庭节点，它们的主节点充当了统计功能，统计有多少节点完成了第一步。PBFT中节点是存在拜占庭节点的，主节点并不是可靠(信)的，不能依赖主节点统计是否有f+1个非拜占庭节点达成了Prepared，而是每个节点各自统计，committed-local让节点看到了，系统一定可以达成一致，才去执行请求。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了2个阶段消息是无法达成一致的原因，而为什么3阶段消息可以。最核心的还是要理解好，PBFT解决了什么问题，以及它是如何解决的。</p><p><strong>PBFT解决的是在拜占庭环境下，如何提供一致性，以及如何持续的提供一致性的问题</strong>。本文只介绍了如何提供一致性，没有提如何持续提供一致性，即PBFT的可用性。现在，不妨思考一下，View Change是如何保证切换时一致性的，是否也需要2个不变性的支持呢？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在面试的时候，很多同学的简历熟悉PBFT共识算法，在现场面试的时候，却只能说个主要逻辑，离完整的算法，还差十万八千里，相似从网络上看了一些文
      
    
    </summary>
    
    
    
      <category term="区块链" scheme="http://lessisbetter.site/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="PBFT" scheme="http://lessisbetter.site/tags/PBFT/"/>
    
  </entry>
  
  <entry>
    <title>一张思维导图看懂PBFT</title>
    <link href="http://lessisbetter.site/2020/03/11/pbft-xmind/"/>
    <id>http://lessisbetter.site/2020/03/11/pbft-xmind/</id>
    <published>2020-03-11T13:08:05.000Z</published>
    <updated>2020-03-15T09:19:39.701Z</updated>
    
    <content type="html"><![CDATA[<p>最近央行发布的《金融分布式账本安全规范》中提到了区块链系统要提供BFT共识，把之前整理的PBFT的思维导图分享给大家。</p><p><em>新标签页中打开，查看高清大图。</em></p><p><img src="http://img.lessisbetter.site/PBFT-xmind.svg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近央行发布的《金融分布式账本安全规范》中提到了区块链系统要提供BFT共识，把之前整理的PBFT的思维导图分享给大家。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;新标签页中打开，查看高清大图。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.lessisbetter.site
      
    
    </summary>
    
    
    
      <category term="区块链" scheme="http://lessisbetter.site/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="PBFT" scheme="http://lessisbetter.site/tags/PBFT/"/>
    
  </entry>
  
  <entry>
    <title>向Fabric贡献代码</title>
    <link href="http://lessisbetter.site/2020/03/03/contribute-to-fabric/"/>
    <id>http://lessisbetter.site/2020/03/03/contribute-to-fabric/</id>
    <published>2020-03-03T12:33:19.000Z</published>
    <updated>2020-03-03T06:39:16.980Z</updated>
    
    <content type="html"><![CDATA[<div class="row">    <embed src="http://img.lessisbetter.site/contribute-to-fabric.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    <summary type="html">
    
      
      
        

	&lt;div class=&quot;row&quot;&gt;
    &lt;embed src=&quot;http://img.lessisbetter.site/contribute-to-fabric.pdf&quot; width=&quot;100%&quot; height=&quot;550&quot; type=&quot;application/pdf&quot;
      
    
    </summary>
    
    
    
      <category term="Fabric" scheme="http://lessisbetter.site/tags/Fabric/"/>
    
  </entry>
  
  <entry>
    <title>从因果关系谈个人能力建设和面试</title>
    <link href="http://lessisbetter.site/2020/03/01/causal-relationship-and-personal-ability/"/>
    <id>http://lessisbetter.site/2020/03/01/causal-relationship-and-personal-ability/</id>
    <published>2020-03-01T03:13:38.000Z</published>
    <updated>2020-03-01T04:51:56.148Z</updated>
    
    <content type="html"><![CDATA[<p>昨天睡前了看了一本收藏已久的书，是关于投资的，叫<a href="https://book.douban.com/subject/30450383/" target="_blank" rel="noopener">《伟大的时代-深度解读价值投资》</a>，这是一本采访了国内价值投资者的书籍，从这些投资者的话语里，看到了一些共性的东西，寻找垄断企业持续发展的根因，也就获得了投资收益，这个果。</p><p>今天起床后，就想到了因果关系、面试、个人能力，在这些角度进行了一些思考，在此记录下思考的成果，这篇文章会介绍：</p><ul><li>因果关系应该关注因，还是关注果？</li><li>如何从因果关系角度，建设个人能力？</li><li>如何从因果关系角度，发现优秀的面试者？</li></ul><h3 id="价值投资中的因果关系"><a href="#价值投资中的因果关系" class="headerlink" title="价值投资中的因果关系"></a>价值投资中的因果关系</h3><p>这些投资者的共性是，都提到了要寻找垄断，并且能够持续垄断的企业，并投资这些企业。</p><p><strong>垄断是“果”，持续垄断也是过，它们需要“因”</strong>。</p><p>怎么才能有垄断，并且持续垄断呢？</p><p>需要找到企业的文化、价值观、制度，这些软性的东西、虚的东西，是企业<strong>不断发展和进化</strong>的根基，这些是企业保持垄断，或成长为垄断的基石，垄断创造收益，收益是实。应了阿里一句话：把虚做实，把实做虚。</p><p>所以，企业文化、价值观和制度是“因”，垄断是“果”。</p><p>如果垄断是“因”，企业收益就是“果”。</p><p><img src="http://img.lessisbetter.site/2020-03-cr-monopoly.png" alt=""></p><p>收益的因不只有垄断，但垄断可以带来巨大收益。</p><h3 id="关注因，还是关注果？"><a href="#关注因，还是关注果？" class="headerlink" title="关注因，还是关注果？"></a>关注因，还是关注果？</h3><p>从企业文化、垄断和收益，这3者看，因果关系可以形成链条，组成一条因果链，一个元素即可以是因，又可以是果。</p><p>比如，垄断是企业文化的果，是收益因。</p><p>说关注因是对的，关注果也是对的，关注因果链中，<strong>关注最根本的“因”，才是最对的</strong>。</p><p>说一个开发者最容易体会的例子：解决bug，需要定位问题的“根因”，只解决中间原因，并不能真正解决bug。</p><p><img src="http://img.lessisbetter.site/2020-03-cr-root-cause.png" alt=""></p><h3 id="如何从因果关系角度，建设个人能力？"><a href="#如何从因果关系角度，建设个人能力？" class="headerlink" title="如何从因果关系角度，建设个人能力？"></a>如何从因果关系角度，建设个人能力？</h3><p>我把<strong>中级</strong>技术开发者的能力，分成5个维度：技术深度、技术广度、商业思维能力、管理能力和演讲能力。</p><p>不同岗位、层次看到的能力维度是不一样的，比如CTO在找技术总监时的岗位时，需要有体系建设的能力。所以上面强调的是中级开发者。</p><p><img src="http://img.lessisbetter.site/2020-03-cr-personal-ability.png" alt=""></p><p>这5个维度的能力是因，项目、职位、收入这些是果。</p><p>果是我们的目标，是我们要达到的地方。而因才是我们要关注的地方。</p><p>建设能力，能力就转变成了“果”，那对应的因是什么呢？</p><p>建设能力的“因”是<strong>持续学习</strong>。</p><p><img src="http://img.lessisbetter.site/2020-03-cr-continuelearn.png" alt=""></p><p>这几年的付费学习，可把持续学习给玩坏了，总是弥漫着一种贩卖焦虑的气息，但不可否认的是，持续学习的人，总有机会。</p><p>持续学习，有很多种通俗的说法:</p><ol><li>活到老，学到老。</li><li>永不止步。</li><li>不给自己设限。</li><li>Stay foolish, Stay hungry。——乔布斯</li><li>…</li></ol><p>关于技术上的持续学习，曹大（Xargin）最近这篇文章值得一看<a href="https://xargin.com/how-to-learn/" target="_blank" rel="noopener">《工程师应该怎么学习》</a>。</p><h3 id="如何从因果关系角度，发现优秀的面试者？"><a href="#如何从因果关系角度，发现优秀的面试者？" class="headerlink" title="如何从因果关系角度，发现优秀的面试者？"></a>如何从因果关系角度，发现优秀的面试者？</h3><p>我考察候选人的经历不是特别多，1年下来，简历晒过几百份，候选人也面过几十个了，有一些体会，今天就借着因果关系，浅谈一下。</p><p><strong>面试的本质，是挖掘面试者当前的能力和持续学习的能力</strong>。</p><p>上面这句代表2个观点：</p><ol><li>简历是“果”，能力是“因”。</li><li>招进来能持续创建价值是未来的“果”，持续学习是“因”。</li></ol><p>阿里有句土话，用来招聘很适合：没有过程的结果是垃圾，没有结果的过程是放屁。</p><p>上半句用来筛选简历，如果简历只写自己参与、做过了什么，而没有成果，这份简历就是垃圾。而写不好简历的面试者，能力很难优秀。</p><p>下半句用来面试，面试者是怎么取得这些成果的，TA具有哪些能力才取得了这些成果？</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>因果关系，还让我深刻的想到一句话：<strong>抓住事物的主要矛盾</strong>。</p><p>咱们国家的发展，不一直就是党和政府在抓主要矛盾，解决主要矛盾的过程吗。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;昨天睡前了看了一本收藏已久的书，是关于投资的，叫&lt;a href=&quot;https://book.douban.com/subject/30450383/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《伟大的时代-深度解读价值投资》&lt;/a&gt;，这是一本采访了国内
      
    
    </summary>
    
    
    
      <category term="职业发展" scheme="http://lessisbetter.site/tags/%E8%81%8C%E4%B8%9A%E5%8F%91%E5%B1%95/"/>
    
  </entry>
  
  <entry>
    <title>Fabric 1.4源码解读 9：从账本角度看Peer</title>
    <link href="http://lessisbetter.site/2020/01/03/fabric-peer-ledger/"/>
    <id>http://lessisbetter.site/2020/01/03/fabric-peer-ledger/</id>
    <published>2020-01-03T12:58:03.000Z</published>
    <updated>2020-02-14T07:02:17.527Z</updated>
    
    <content type="html"><![CDATA[<p>区块链最核心的是<strong>可信数据</strong>，所有的功能与设计根源都是数据。本次从数据存储的角度，看一看Peer。</p><h2 id="账本"><a href="#账本" class="headerlink" title="账本"></a>账本</h2><p>区块链的数据存储在账本中，账本包含：</p><ul><li>区块存储<ul><li>区块文件</li><li>区块索引数据库</li></ul></li><li>世界状态数据库</li><li>历史数据库</li><li>私有数据数据库</li></ul><p>关于账本以上各数据库的工具，<a href="https://hyperledger-fabric-cn.readthedocs.io/zh/latest/ledger/ledger.html" target="_blank" rel="noopener">官方文档</a>中对区块存储和世界状态数据库介绍的比较详细了，但我们介绍下它没有提到的。</p><h3 id="区块文件和区块索引数据库"><a href="#区块文件和区块索引数据库" class="headerlink" title="区块文件和区块索引数据库"></a>区块文件和区块索引数据库</h3><p>区块是保存在文件中的，<strong>为了快速查找区块、交易</strong>，Fabric建立了索引，指明某通道某区块高度的第x个交易，是存在哪个文件，偏移量是多少。当然，索引还包含了区块高度、区块hash等，方便根据高度、hash查询区块。</p><p><img src="http://img.lessisbetter.site/2020-01-blockfile-index.png" alt=""></p><p>上图展示了一个区块文件存储区块的情况，每个区块包含：</p><ul><li>区块长度</li><li>区块头</li><li>每条交易长度、交易数据</li></ul><p>每个区块的开始位置、交易的开始位置，在写区块的时候记录下来，然后写到索引数据库（Index DB）。</p><p><strong>整个Fabric网络只有1个区块索引数据库，也就是多通道共用一个</strong>。</p><h3 id="历史数据库"><a href="#历史数据库" class="headerlink" title="历史数据库"></a>历史数据库</h3><p><strong>用来记录交易中每个状态数据的历史信息，直白点可以理解为链码中某个key的历史数值</strong>。它的key实际是<code>{通道id+链码id, key, 区块高度, 交易在区块中的序号}</code>组成的<strong>复合key</strong>，值为空，并且只包含有效的交易。</p><p>有这样一个问题：值为空，到底怎么查询到历史状态呢？</p><p>答：通过历史数据库合成复合key，但复合key中没有交易在区块中的序号，创建一个迭代器，迭代器可以获取包含key的复合key，然后从复合key中提取到交易在区块的序号，然后去区块文件中提取交易，再提取到写集的Value，就可以合成某个key的所有历史值。</p><p>因此<strong>查询历史状态，需要结合历史数据库和区块文件</strong>。</p><h2 id="各数据库实现"><a href="#各数据库实现" class="headerlink" title="各数据库实现"></a>各数据库实现</h2><p><strong>区块文件使用文件直接存储区块，没有使用数据库的原因</strong>是：区块是一种自然的追加操作，写入后不再修改，即不会覆盖历史区块，使用文件系统直接存储区块，可以达到区块最快落盘的目的，因为向文件写区块是顺序写，而写数据库是随机写，磁盘（包含HD、SSD）的顺序写性能要高于随机写。</p><p>世界状态数据库可以使用leveldb或者CouchDB，CouchDB支持富查询功能，当链码数据按JSON建模时，CouchDB可以提供更好的数据查询，更多CouchDB的信息见文档<a href="https://stone-fabric.readthedocs.io/zh/latest/couchdb_tutorial.html" target="_blank" rel="noopener">使用 CouchDB</a>。</p><p>其他数据库都使用leveldb作为底层存储。</p><p><img src="http://img.lessisbetter.site/2020-01-peer-ledger-storage.png" alt=""></p><p><strong>提醒</strong>：Fabric支持多通道，逻辑上每个通道拥有一个账本。实现上区块文件是按通道名隔离开了，使用leveldb的各数据库，被各通道共用。</p><h2 id="从数据看Peer功能"><a href="#从数据看Peer功能" class="headerlink" title="从数据看Peer功能"></a>从数据看Peer功能</h2><p>和账本相关的概念还有<strong>区块、交易和状态</strong>，从账本的角度看，账本向上支撑了2类功能：</p><ol><li>数据同步：广播与同步区块</li><li>交易背书：模拟执行交易</li></ol><p>在下图中，数据同步和交易背书分别使用蓝色和橙色的线圈出，底部剩下的2层为账本。</p><p><img src="http://img.lessisbetter.site/2020-01-03-usage-of-peer-ledger.png" alt=""></p><h3 id="账本-1"><a href="#账本-1" class="headerlink" title="账本"></a>账本</h3><p><code>core/ledger</code>实现了Peer的账本功能，包含了账本中的各项数据库，它依赖<code>common/ledger</code>实现区块文件存储，区块文件存储包含3类：</p><ul><li><code>File</code>：把区块保存在文件中，生产环境使用，orderer和peer皆可使用</li><li><code>Json</code>：把文件保证JSON格式的文件中，使用在非生产环境，仅供orderer使用</li><li><code>Ram</code> ：把区块保存在内存中，使用在非生产环境，仅供orderer使用</li></ul><p><code>core/ledger</code>中的：</p><ul><li><code>PeerLedger</code>接口，代表<strong>Peer账本</strong>，主要用来向账本写区块和私有数据，查询区块、交易和私有数据</li><li><code>Txsimulator</code>接口，代表<strong>交易模拟器</strong>，用来模拟执行1条交易</li><li><code>QueryExecutor</code>接口用来查询<strong>最新的</strong>数据</li><li><code>HistoryQueryExecutor</code>接口用来查询<strong>历史</strong>状态</li></ul><h3 id="同步数据"><a href="#同步数据" class="headerlink" title="同步数据"></a>同步数据</h3><p>同步数据有2种方式：</p><ul><li>Deliver服务，Peer使用事件从Orderer获取区块</li><li>Peer向其他节点请求获取某个区间的区块</li></ul><p>虽然Peer获取区块的方式有2种，但收到区块，处理区块的方式只有1种，所以下面分3小节介绍。</p><h4 id="使用Deliver同步区块"><a href="#使用Deliver同步区块" class="headerlink" title="使用Deliver同步区块"></a>使用Deliver同步区块</h4><p>Deliver用来以事件的方式获取区块，场景有2点：</p><ul><li>Peer从Oderer获取区块</li><li>客户端/SDK从Peer获取区块</li></ul><p>在<a href="http://lessisbetter.site/2019/12/17/fabric-blocks-from-orderer-to-peer/">Fabric 1.4源码解读 8：Orderer和Peer的交互</a>中已经介绍了Peer从Orderer获取区块，这里再做一点补充。</p><p>Deliver服务是Orderer和Peer都使用的功能，但Orderer并没有<code>core/ledger</code>，所以从设计和实现上，<code>common/deliver</code>是从<code>common/ledger</code>中直接读区块，而不是<code>core/ledger</code>读区块。</p><h4 id="Peer请求区块"><a href="#Peer请求区块" class="headerlink" title="Peer请求区块"></a>Peer请求区块</h4><p>每个Peer可以通过Gossip得知同通道的、所连接的Peer信息，其中一项就是对方Peer账本的高度。账本高度低的Peer可以向高度高的Peer发送<strong>StateRequest</strong>，请求获取某个连续区间的区块。</p><p>Peer上负责StateRequest的是<code>gossip/state</code>模块，它负责：</p><ul><li>创建StateRequest请求</li><li>处理StateRequest请求，生成StateRequest响应</li><li>处理StateRequest响应</li></ul><p>创建请求：假设Peer1比Peer2少50个区块，并且配置了Peer每次最多取10个区块，Peer1会创建5个StateRequest请求，顺序的向Peer2进行请求，Peer1收到前一个请求的响应后，才发出下一个请求。</p><p>处理请求：实际是从账本读取所请求区块的过程，这个过程主要是读取区块文件，如果区块涉及私密数据，也涉及读取私密数据库，这部分功能主要由<code>gossip/privdata</code>完成，<code>gossip/state</code>把读到的区块和私密数据生成请求响应。</p><h4 id="Peer处理收到的区块"><a href="#Peer处理收到的区块" class="headerlink" title="Peer处理收到的区块"></a>Peer处理收到的区块</h4><p>Peer从Orderer和其他Peer哪获取的区块，最终都会进入到<code>gossip/state</code>，区块会被放入到一个区块缓冲区：<strong>PayloadsBuffer</strong>，默认大小为存储200个区块。</p><p>每个通道账本都有一个goroutine，从各自的PayloadsBuffer拿下一个高度的区块，交给<code>gossip/privdata</code>进行区块的验证和写入。</p><h5 id="验证区块"><a href="#验证区块" class="headerlink" title="验证区块"></a>验证区块</h5><p>这部分功能由<code>core/handler/validation</code>完成。在Fabric 1.4中，StateImpl会调用QueryExecutor查询状态，但实际StateImpl没有被调用。</p><p>验证区块主要是并发验证区块中的交易：</p><ul><li>验证交易中的字段</li><li>验证是否满足背书策略</li><li>验证交易是否调用最新版本的链码</li><li>验证交易是否重复</li></ul><p>交易验证的结果，即交易是否有效，并不会保存在交易中，这样区块中记录所有交易的DataHash就变化了。区块中所有交易的有效性存储在区块的元数据中，区块元数据中有一个有效性数组，依次存放了每个交易的有效性，使用数组的下标，与交易在数组中的顺序，一一对应。</p><p>交易验证后，会修改区块的元数据，把无效的交易设置为响应的无效序号。</p><p>如果缺失区块的私有数据，<code>gossip/privdata</code>会创建获取私有数据的请求，并获取私有数据，当区块和私有数据都准备齐全后，开始<strong>commit</strong>区块和私有数据。</p><h5 id="区块写入账本"><a href="#区块写入账本" class="headerlink" title="区块写入账本"></a>区块写入账本</h5><p>包含2大块：</p><ul><li>交易MVCC验证<ul><li>Fabric要求世界状态数据库支持MVCC，即多版本并发控制，以便交易能够并发执行（背书），在真正修改状态的时候，才判断读写的数据是否冲突，冲突的交易会被标记为无效。关于MVCC我们在下文的背书部分再详细介绍。</li></ul></li><li>把区块写入数据库，以及修改各数据库：<ul><li>把区块写入到区块文件</li><li>把区块、交易的索引写入到索引数据库</li><li>把<strong>有效交易</strong>的写集更新到世界状态</li><li>提交历史数据库</li><li>提交私密数据库</li></ul></li></ul><h5 id="写区块完成后"><a href="#写区块完成后" class="headerlink" title="写区块完成后"></a>写区块完成后</h5><p>写区块完成后，还需要做一些<strong>修剪</strong>操作：私密数据是有有效期的，比如存活100个区块时间，假如在1000高度写入了某私有数据，第1100写入账本后，私密数据就要从私密数据库被抹除。</p><h3 id="背书"><a href="#背书" class="headerlink" title="背书"></a>背书</h3><p>Peer除了记账的另外一个角色就是背书，背书很重要的一个环节就是模拟执行交易。</p><h4 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h4><p>Fabric为了提供更高的系统性能，支持并发的执行交易，交易在执行过程中会读写世界状态数据库，也就存在并发访问数据库的场景，为了安全的访问数据库数据，就需要对数据库的并发进行限制。</p><p>Draveness在<a href="https://draveness.me/database-concurrency-control" target="_blank" rel="noopener">浅谈数据库并发控制 - 锁和 MVCC</a>种介绍了并发控制3种手段：悲观锁、乐观锁和MVCC。</p><p>Fabric选择了MVCC，它要求世界状态数据库支持MVCC，本质上讲任何支持MVCC的数据库，都可以用来实现状态数据库。</p><p>MVCC是多版本并发控制的缩写，它是一种思想，而不是一种具体的算法，所以不同的数据库实现的MVCC不同。</p><p>在MVCC的数据存储中，数据有版本的概念，写一个数据的值，实际上是创建了一个新的版本来保存数据。</p><p>MVCC可以实现并发读写的能力，当读数据时，先确定待读数据的版本，然后从该版本读取数据，写数据时，创建新的版本保存数据。读数据必然是已经存在的版本，而写数据是新的版本，因此读写可以并行。</p><p><img src="http://img.lessisbetter.site/2020-01-mvcc-read-write.png" alt=""></p><h4 id="Fabric对MVCC的使用"><a href="#Fabric对MVCC的使用" class="headerlink" title="Fabric对MVCC的使用"></a>Fabric对MVCC的使用</h4><p>背书节点在模拟执行交易的过程中，会生成读写集，<strong>读集和写集分别是所有待写key读出来时的版本和待写入的新值</strong>。</p><p>交易并发执行到写入区块的过程中存在2种<strong>读写冲突</strong>的情况：</p><ol><li>同一个区块中的前后两笔交易，后面的交易读集包含某个key，但key在前面交易的写集：也就说后面交易读的是老版本的数据，是一种脏读的情况</li><li>区块中交易的读集的某个key，某之前区块的交易写集修改：背书跟写区块是并发执行的，背书时产生的写集，直到写区块才会更新到世界状态数据库，这里存在一段时间，即key已经有了新版本的数据，只是还没有提交到数据库。如果这期间有新的交易模拟执行，就会读到老版本数据，也是一种脏读的情况</li></ol><p>有效交易的写集会被应用到世界状态数据库，被修改数据都会有一个新的版本，这个版本是逻辑版本，成为Hight，由<code>{区块高度,交易在区块内的顺序}</code>组成。</p><blockquote><p>注：验证函数为 <code>validateTx</code>，读写集冲突错误为 <code>TxValidationCode_MVCC_READ_CONFLICT</code> ，另一个读写冲突错误为 <code>TxValidationCode_PHANTOM_READ_CONFLICT</code>， 因为执行过程中有RangeQuery，查询某个区间的Key，也需要验证这些Key是否冲突，底层本质还是读写集的验证。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文从账本的视角，介绍了Peer的账本，以及和账本打交道的功能。</p><p>真正企业级的区块链、大用户规模的区块链，必然能够支撑大量的并发交易，这对账本以及底层存储，都会提出更高的性能要求、磁盘利用率要求，所以理解和掌握账本和存储机制是非常有必要的。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://draveness.me/database-concurrency-control" target="_blank" rel="noopener">浅谈数据库并发控制 - 锁和 MVCC</a></li><li><a href="https://en.wikipedia.org/wiki/Multiversion_concurrency_control" target="_blank" rel="noopener">WIKI: MVCC</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;区块链最核心的是&lt;strong&gt;可信数据&lt;/strong&gt;，所有的功能与设计根源都是数据。本次从数据存储的角度，看一看Peer。&lt;/p&gt;
&lt;h2 id=&quot;账本&quot;&gt;&lt;a href=&quot;#账本&quot; class=&quot;headerlink&quot; title=&quot;账本&quot;&gt;&lt;/a&gt;账本&lt;/h2&gt;&lt;
      
    
    </summary>
    
    
    
      <category term="区块链" scheme="http://lessisbetter.site/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Fabric" scheme="http://lessisbetter.site/tags/Fabric/"/>
    
  </entry>
  
  <entry>
    <title>WAL(预写式日志)简介</title>
    <link href="http://lessisbetter.site/2020/01/02/wal-introduction/"/>
    <id>http://lessisbetter.site/2020/01/02/wal-introduction/</id>
    <published>2020-01-02T12:56:32.000Z</published>
    <updated>2020-01-02T02:57:24.717Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Write Ahead Logging，简称WAL，也被翻译成<strong>预写式日志</strong>，是数据库技术中实现事务日志(Transaction Journal)的一种标准方法，可以实现<strong>单机</strong>事务的原子性，同时可以提高数据库的写入效率。</p><p>思考如下场景，如何确保原子性：写操作修改数据库中a和b的值，二者是一个事务，需要把a和b的最新值持久化到磁盘，假如保存完a的值，系统宕机了，重新启动后，a的值已经写入，但b待写入的值已经丢失，如何发现事务没有完成呢？如何保证事务的原子性呢？</p><p>可以为事务加锁，也为事务增加标志位，修改完磁盘数据后，标志位设置事务为完成，事务状态保存在磁盘中，假使保存事务状态的过程中宕机了，就把事务回滚掉。实现REDO和UNDO，就能实现原子性。</p><p>数据库中针对<strong>Crash</strong>和<strong>Recovery</strong>的解决方案是WAL。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>WAL的核心思想是<strong>先写日志再写数据文件</strong>，修改数据文件必须发生在修改操作记录在日志文件之后。</p><blockquote><p>本文的日志指事务的操作日志，本文提到的日志都是指事务日志，不再特殊声明。</p></blockquote><p><img src="http://img.lessisbetter.site/2019-12-wal.png" alt="WAL"></p><p>我们看WAL怎么<strong>解决宕机和恢复的问题</strong>：</p><ul><li>写WAL前宕机了，重启后，数据处于事务未执行的状态。</li><li>写WAL时宕机了，重启后，可以检查到WAL数据不正确，回滚当事务前的状态。</li><li>写WAL后宕机了，重启后，把WAL中记录的操作，应用到数据库文件中，得到事务执行后的状态。</li></ul><p>如此，保证了数据的恢复和事务的原子性。</p><p>上面提到的都是写操作，看一下使用WAL时的<strong>读操作</strong>。WAL中可能包含了未写入到数据库文件中的最新值，如果读最新值就需要从WAL中读取，如果WAL中未读到，从数据库读到的就是最新的数据。</p><p><strong>检查点</strong>：写入到WAL文件中的操作记录并不一定会立刻应用到数据库文件上，这个过程是异步的，设计检查点来记录已经被应用到数据库文件上的操作序号，检查点后面的操作记录等待被应用到数据库文件上。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>WAL的作用是解决宕机和恢复的问题，同时也有其他优点：</p><ol><li><strong>提高写数据的性能</strong><ol><li>WAL是顺序写，数据库文件是随机写，顺序写性能高于随机写</li><li>减少写磁盘次数<ol><li>不直接修改数据库真实数据</li><li>合并若干小的事务，一次性commit到数据库</li></ol></li></ol></li><li>保证事务<strong>原子性</strong></li><li>保证事务<strong>一致性</strong></li><li><strong>并发读写</strong>，比如SQLite中，读写、读读都是可以并行的，比如读时需要找到WAL某个值最后写入的位置，就可以从该位置读数据，而写操作是在WAL文件后Append，二者并行。但写写不能并行，因为2次写操作都要向WAL文件Append数据，无法同时进行。</li><li>WAL文件中记录了数据的历史版本，因此可以读取历史版本的值，甚至把状态回滚到某个历史版本。</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>SQLite提到了WAL的几项缺点：</p><ol><li>WAL需要VFS的支持。</li><li>所有使用数据库的进程必须在同一个机器上，以为WAL是单机的。</li><li>多读少写的场景WAL比rollback-journal类型要慢1%~2%。</li></ol><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>WAL几乎是<strong>数据存储</strong>(数据库只是数据存储的一个类别，只不过这个类别很大)的标配：</p><ul><li>Raft可以使用WAL保存log Entry以及状态</li><li>数据库<ul><li>PgSQL使用WAL实现事务日志实现事务原子性、一致性，提升性能</li><li>SQLite使用WAL实现原子事务和回滚</li><li>MySQL使用WAL保证数据不丢失的情况下提升性能</li><li>leveldb也使用WAL提升性能，保证操作原子性</li></ul></li></ul><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><ul><li><a href="https://juejin.im/post/5b04a93151882542672666e8" target="_blank" rel="noopener">菜鸟学数据库——WAL模式及其原理</a></li><li><a href="http://mysql.taobao.org/monthly/2017/03/02/" target="_blank" rel="noopener">PgSQL · 特性分析 · Write-Ahead Logging机制浅析</a></li><li><a href="https://www.postgresql.org/docs/9.1/wal-intro.html" target="_blank" rel="noopener">PostgreSQL 9.1.24 Documentation: Chapter 29. Reliability and the Write-Ahead Log</a></li><li><a href="https://www.sqlite.org/wal.html" target="_blank" rel="noopener">SQLite: Write-Ahead Logging</a></li><li><a href="https://mysqlserverteam.com/mysql-8-0-new-lock-free-scalable-wal-design/" target="_blank" rel="noopener">MySQL 8.0: New Lock free, scalable WAL design</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;Write Ahead Logging，简称WAL，也被翻译成&lt;strong&gt;预写式日志&lt;/strong&gt;，是数据库技术中实现事务日志(Tr
      
    
    </summary>
    
    
    
      <category term="分布式" scheme="http://lessisbetter.site/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="存储" scheme="http://lessisbetter.site/tags/%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>Fabric 1.4源码解读 8：Orderer和Peer的交互</title>
    <link href="http://lessisbetter.site/2019/12/17/fabric-blocks-from-orderer-to-peer/"/>
    <id>http://lessisbetter.site/2019/12/17/fabric-blocks-from-orderer-to-peer/</id>
    <published>2019-12-17T12:14:34.000Z</published>
    <updated>2019-12-17T06:19:58.910Z</updated>
    
    <content type="html"><![CDATA[<p>Peer与Orderer的交互主要是组织的Peer主节点从Orderer获取区块，本文就来介绍，Peer是如何从Orderer获取区块的，顺带介绍为何Peer从Orderer获取的区块“好慢”。</p><h2 id="网络拓扑"><a href="#网络拓扑" class="headerlink" title="网络拓扑"></a>网络拓扑</h2><p>假设存在如下的Fabric网络拓扑情况，本文使用此拓扑进行介绍Orderer到Peer的区块传播情况：</p><p>网络中存在两家组织：Org1和Org2，它们分别拥有Peer1作为主节点，连向了排序服务的Orderer1节点。</p><p>网络中存在2个应用channel：channel1和channel2，它们的账本分别是channel1 ledger和channel2 ledger，Org1和Org2都加入了这2个channel。</p><p><strong>channel间是隔离的，所以Peer和Orderer对不同的channel都会分别处理</strong>。</p><h2 id="宏观视角"><a href="#宏观视角" class="headerlink" title="宏观视角"></a>宏观视角</h2><p>下图展示了Orderer向Peer传递区块的宏观视角，能够展示<strong>多个通道在Orderer和Peer间传递区块的情况</strong>：</p><ol><li>Orderer上有2个通道的账本，每个Peer分别有2个Deliver Server对应2个通道的账本，从账本读取区块，发送给Peer。</li><li>每个Peer有2个Deliver Client，也对应2个通道，接收Orderer发来的区块，加入到缓冲区Payloads Buffer，然后再从Payloads Buffer中提取区块，验证后写入对应的通道账本。</li></ol><p><img src="http://img.lessisbetter.site/2019-12-spread-of-blocks-new.png" alt=""></p><p>后面，介绍区块同步某个通道区块的情况。</p><h2 id="单通道区块同步"><a href="#单通道区块同步" class="headerlink" title="单通道区块同步"></a>单通道区块同步</h2><p><strong>Peer利用Deliver从Orderer获取区块</strong>，就像SDK利用Deliver从Peer获取区块一样，Deliver服务端的处理是一样的，Deliver客户端的处理就由SDK、Peer自行处理了。</p><p>Deliver本质是一个事件订阅接口，Leading Peer启动后，会为每个通道，分别向Orderer节点注册<strong>区块事件</strong>，并且指定结束的区块高度为<code>uint</code>类型的最大值，这是为了不停的从orderer获取区块。</p><p>通过建立的gRPC连接，Orderer源源不断的向Peer发送区块，具体流程，如下图所示：</p><ol><li>Orderer调用<code>deliverBlock</code>函数，该函数是循环函数，获取区块直到指定高度。</li><li>每当有新区块产生，<code>deliverBlock</code>能利用<code>NextBlock</code>从通道账本中读到最新的区块，如果没有最新区块，<code>NextBlock</code>会阻塞。</li><li><code>deliverBlock</code>把获取的区块封装成区块事件，发送给Peer（写入到gRPC缓冲区）。</li><li>Peer从gRPC读到区块事件，把区块提取出来后，加入到<strong>Payloads Buffer</strong>，Payloads Buffer默认大小为200（通过源码和日志发现，Payloads Buffer实际存储202个区块），如果Orderer想向Peer发送更多的区块，必须等Payloads Buffer被消费，有空闲的位置才可以。</li><li><code>deliverPayloads</code>为循环函数，不断<strong>消费</strong>Payloads Buffer中的区块，执行区块验证，添加区块剩余元数据，最后写入通道账本。</li><li>写通道账本包含区块写入区块账本，修改世界状态数据库，历史索引等。</li></ol><p><img src="http://img.lessisbetter.site/2019-12-orderer-to-peer.png" alt=""></p><h2 id="为何Peer从Orderer获取区块慢？"><a href="#为何Peer从Orderer获取区块慢？" class="headerlink" title="为何Peer从Orderer获取区块慢？"></a>为何Peer从Orderer获取区块慢？</h2><p>在性能测试过程中，我们发现Orderer排序完成后，Peer还在不断的从Orderer获取区块，而不是所有排序后的区块都先发送给Peer，Peer缓存起来，慢慢去验证？</p><p>上面提到Orderer向Peer发送的区块，Peer收到后先存到Payloads Buffer中，Buffer有空闲位置的时候，Orderer发送的区块才能写入Buffer，deliverBlock 1次循环才能完成，才可以发送下一个区块。</p><p>但Payloads Buffer大小是有限的，当Buffer满后，Orderer发送区块的操作也会收到阻塞。</p><p>我们可以把Orderer和Peer间发送区块可以抽象一下，它们就是<strong>生产者-消费者模型</strong>，它们中间是缓冲区，Orderer是生产者，向缓冲区写数据，Peer是消费者，从缓冲区读数据，缓冲区满了会阻塞生产者写数据。</p><p>所以<strong>Orderer向Peer发送数据的快慢，取决消费者的速度，即取决于deliverPayloads处理一个区块的快慢</strong>。</p><p>deliverPayloads慢在把区块写入区块账本，也就是写账本，成了整个网络的瓶颈。</p><h2 id="为何不让Peer缓存所有未处理的区块？"><a href="#为何不让Peer缓存所有未处理的区块？" class="headerlink" title="为何不让Peer缓存所有未处理的区块？"></a>为何不让Peer缓存所有未处理的区块？</h2><p>从我们测试的情况看，Orderer排序的速度远快于Peer，Peer和Orderer的高度差可以达到10万+，如果让Peer来缓存这些区块，然后再做处理是需要耗费大量的空间。</p><p>在生产者-消费者模型中，只需要要消费者时刻都有数据处理即可。虽然Orderer和Peer之间是网络传输，测试网络比较可靠，传输速度远比Peer处理区块要快。</p><p>Payloads Buffer可以让网络传输区块和Peer处理区块并行，这样缩短了一个区块从Orderer中发出，到Peer写入区块到账本的总时间，提升Fabric网络整体性能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Peer与Orderer的交互主要是组织的Peer主节点从Orderer获取区块，本文就来介绍，Peer是如何从Orderer获取区块的，顺带介绍为何Peer从Orderer获取的区块“好慢”。&lt;/p&gt;
&lt;h2 id=&quot;网络拓扑&quot;&gt;&lt;a href=&quot;#网络拓扑&quot; class
      
    
    </summary>
    
    
    
      <category term="区块链" scheme="http://lessisbetter.site/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Fabric" scheme="http://lessisbetter.site/tags/Fabric/"/>
    
  </entry>
  
  <entry>
    <title>Fabric 2.0 特性一览</title>
    <link href="http://lessisbetter.site/2019/12/16/fabric-2-0/"/>
    <id>http://lessisbetter.site/2019/12/16/fabric-2-0/</id>
    <published>2019-12-16T12:30:11.000Z</published>
    <updated>2019-12-16T09:35:14.045Z</updated>
    
    <content type="html"><![CDATA[<p>Fabric 2.0 Beta版前几日已经发布了，浏览了官方文档和Release Notes，对特性进行了记录，</p><ul><li><a href="https://hyperledger-fabric.readthedocs.io/en/master/whatsnew.html" target="_blank" rel="noopener">官方文档</a></li><li><a href="https://github.com/hyperledger/fabric/releases/tag/v2.0.0-beta" target="_blank" rel="noopener">Relase Notes</a></li></ul><p><img src="http://img.lessisbetter.site/2019-12-fabric-2.0.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Fabric 2.0 Beta版前几日已经发布了，浏览了官方文档和Release Notes，对特性进行了记录，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://hyperledger-fabric.readthedocs.io/en/master/whatsn
      
    
    </summary>
    
    
    
      <category term="区块链" scheme="http://lessisbetter.site/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Fabric" scheme="http://lessisbetter.site/tags/Fabric/"/>
    
  </entry>
  
  <entry>
    <title>Fabric 1.4源码解读 7：Orderer架构解读</title>
    <link href="http://lessisbetter.site/2019/11/21/fabric-orderer-architecture/"/>
    <id>http://lessisbetter.site/2019/11/21/fabric-orderer-architecture/</id>
    <published>2019-11-21T12:07:54.000Z</published>
    <updated>2020-01-10T09:30:42.951Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Orderer介绍"><a href="#Orderer介绍" class="headerlink" title="Orderer介绍"></a>Orderer介绍</h2><p>排序服务由一组<strong>排序节点</strong>组成，它接收客户端提交的交易，把交易打包成区块，确保排序节点间达成一致的区块内容和顺序，提供区块链的<strong>一致性</strong>服务。</p><p><img src="http://img.lessisbetter.site/2019-11-fabric-orderer-network.png" alt=""></p><blockquote><p>图片源自《区块链原理、设计与应用》，当时Fabric还不支持raft</p></blockquote><p>排序服务所提供的一致性，依赖<strong>确定性的共识算法</strong>，而非比特币、以太坊等公有链，所采用的概率性共识算法。确定性的共识算法是区块上链，即不可修改。Fabric所采用的共识算法有Solo、Kafka、EtcdRaft。</p><p>客户端<strong>通过Broadcast接口向Orderer提交背书过的交易</strong>，客户端（此处广义指用户客户端和<strong>Peer节点</strong>）<strong>通过Deliver接口订阅区块事件，从Orderer获取区块</strong>。</p><p>更多的排序服务介绍请参考这篇官方文档<a href="https://hyperledger-fabric-cn.readthedocs.io/zh/latest/orderer/ordering_service.html" target="_blank" rel="noopener">排序服务</a>。</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><img src="http://img.lessisbetter.site/2019-11-arch-of-orderer.png" alt="Architecture of Orderer"></p><blockquote><p>本图依赖 Fabric 1.4 源码分析而得</p></blockquote><p>Orderer由：多通道、共识插件、消息处理器、本地配置、区块元数据、gRPC服务端、账本等组成，其中gRPC中的Deliver、Ledger是通用的（Peer也有），其余都是Orderer独有的。</p><h3 id="多通道"><a href="#多通道" class="headerlink" title="多通道"></a>多通道</h3><p>Fabric 支持多通道特性，而Orderer是多通道的核心组成部分。多通道由Registrar、ChainSupport、BlockWriter等一些重要部件组成。</p><p>Registrar是所有通道资源的汇总，访问每一条通道，都要经由Registrar，更多信息请看<a href="http://lessisbetter.site/2019/11/18/fabric-orderer-structs/#Registrar">Registrar</a>。</p><p>ChainSupport代表了每一条通道，它融合了一条通道所有的资源，更多信息请看<a href="http://lessisbetter.site/2019/11/18/fabric-orderer-structs/#ChainSupport">ChainSupport</a>。</p><p>BlockWriter 是区块达成共识后，Orderer写入区块到账本需要使用的接口。</p><h3 id="共识插件"><a href="#共识插件" class="headerlink" title="共识插件"></a>共识插件</h3><p>Fabric的共识是插件化的，抽象出了Orderer所使用的共识接口，任何一种共识插件，只要满足给定的接口，就可以配合Fabric Orderer使用。</p><p>当前共识有3种插件：Solo、Kafka、EtcdRaft。Solo用于实验环境，Kafka和EtcdRaft用于生产环境，Kafka和EtcdRaft都是CFT算法，但EtcdRaft比Kafka更易配置。</p><p>EtcdRaft实在Fabric 1.4开始引入的，如果之前的生产环境使用Kafka作为共识，可以遵循Fabric给的指导，把Kafka共识，迁移到Raft共识。</p><h3 id="gRPC通信"><a href="#gRPC通信" class="headerlink" title="gRPC通信"></a>gRPC通信</h3><p>Orderer只有2个gRPC接口：</p><ul><li>Broadcast：用来接收客户端提交的待排序交易</li><li>Deliver：客户端（包括Peer节点）用来从Orderer节点获取已经达成一致的区块</li></ul><p>其中，Broadcast是Orderer独有的，而Devliver是通用的，因为客户端也可以利用Deliver接口从Peer节点获取区块、交易等。</p><p>关于Broadcast和Orderer更多介绍可以参考杨保华的2篇笔记：</p><ul><li><a href="https://github.com/yeasy/hyperledger_code_fabric/blob/master/process/orderer_broadcast.md" target="_blank" rel="noopener">Orderer 节点 Broadcast 请求的处理</a></li><li><a href="https://github.com/yeasy/hyperledger_code_fabric/blob/master/process/orderer_deliver.md" target="_blank" rel="noopener">Orderer 节点 Deliver 请求的处理</a>。<h3 id="Local-Config"><a href="#Local-Config" class="headerlink" title="Local Config"></a>Local Config</h3></li></ul><p>用来解析orderer节点的配置文件: <code>orderer.yaml</code>，并保存入内存。</p><p>该配置文件中的配置，是节点本地的配置，不需要Orderer节点间统一的配置，因此不需要上链，相关配置有：</p><ul><li>网络相关配置</li><li>账本类型、位置</li><li>raft文件位置</li><li>…</li></ul><p>而上链的配置，被称为通道配置，需要使用配置交易进行更新，这部分配置，写在<code>configtx.yaml</code>中，和Orderer相关的有：</p><ul><li>共识类型</li><li>区块大小</li><li>切区块的时间</li><li>区块内交易数</li><li>各种共识的相关配置</li><li>…</li></ul><h3 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h3><p>区块中有4个元数据：</p><ul><li>区块签名，存放orderer对区块的SignatureHeader</li><li>最新配置区块的高度，方便获取当前通道最新配置</li><li>交易过滤，为数组，存放区块内所有交易的有效性，使用数字代表无效的原因，由验证交易的记账节点填写</li><li>orderer相关元数据，不同的共识类型，该元数据不同</li></ul><p>区块Header中记录了Data.Hash()，Data是所有交易后序列化的结果，但不包含区块元数据，所以区块元数据是可以在产生区块后修改的。即，即使元数据上链了，但这数据是可以修改的，只不过修改也没有什么意义。</p><h3 id="MsgProcessor"><a href="#MsgProcessor" class="headerlink" title="MsgProcessor"></a>MsgProcessor</h3><p>orderer收到交易后需要对交易进行多项检查，不同的通道可以设置不同的MsgProcessor，也就可以进行不同的检查。</p><p>当前Processor分2个：</p><ul><li>应用通道的叫StandardChannel</li><li>系统通道的叫SystemChannel</li></ul><p>StandardChannel会对交易进行以下检查：</p><ul><li>交易内容不能为空</li><li>交易大小不能超过区块大小最大值（默认10MB）</li><li>交易交易签名不符合签名策略</li><li>签名者证书是否过期</li></ul><p>SystemChannel只比StandardChannel多一项：系统配置检查，用来检查以下交易中包含的配置，配置项是否有缺失，或者此项配置是否允许更新等。</p><h3 id="BlockCutter"><a href="#BlockCutter" class="headerlink" title="BlockCutter"></a>BlockCutter</h3><p>BlockCutter用来把收到的交易分成多个组，每组交易会打包到一个区块中。而分组的过程，就是切块，每组交易被称为一个Batch，它有一个缓冲区用来存放待切块交易。</p><p>切块有3个可配置条件：</p><ul><li>缓冲区内交易数，达到区块包含的交易上限（默认500）</li><li>缓冲区内交易总大小，达到区块大小上限（默认10MB）</li><li>缓冲区存在交易，并且未出块的时间，达到切块超时时间（默认2s）</li></ul><p>切块有1个不可配置条件：</p><ul><li>缓冲区收到配置交易，配置交易要放到单独区块，如果缓冲区有交易，缓冲区已有交易会切到1个区块</li></ul><p>超多刚接触Fabric的人有这样一个疑问：排序节点是按什么规则对交易排序的？</p><p>按什么顺序对交易排序并不重要，只要交易在区块内的顺序是一致的，然后所有记账节点，按交易在区块内的顺序，处理交易，最后得到的状态必然是一致的，这也是区块链保持一致性的原理。</p><p>再回过头来说一下实现是什么顺序：哪个交易先写入BlockCutter的缓冲区，哪个交易就在前面，仅此而已。</p><h3 id="BlockWriter"><a href="#BlockWriter" class="headerlink" title="BlockWriter"></a>BlockWriter</h3><p>Orderer的BlockWriter是基于common/ledger实现的，<strong>它用来保存区块文件</strong>，不包含状态数据库等其他数据库，其中有3类区块文件:ram，json和file，file是Orderer和Peer都可使用的，另外2个只能Orderer使用。</p><p>BlockWriter用来向Peer的账本追加区块，但追加区块之前，还需要做另外1件事情，设置区块的元数据。</p><p>区块元数据包含：</p><ul><li>区块签名，存放orderer对区块的SignatureHeader</li><li>最新配置区块的高度，方便获取当前通道最新配置</li><li>交易过滤，为数组，存放区块内所有交易的有效性，使用数字代表无效的原因，由验证交易的记账节点填写</li><li>orderer相关元数据，不同的共识类型，该元数据不同</li></ul><p>但此时只设置其中的3个：区块签名、配置区块高度、orderer相关的元数据。因为交易的有效性在记账节点检查后才能设置。</p><p><strong>为何不在创建区块的时候就设置这些元数据信息，而是在区块经过共识之后？</strong></p><p>共识的过程会传播区块，只让区块包含必要的信息，可以减少区块大小，降低通信量。但元数据占用大小非常小，所以这未必是真实原因。</p><p>BlockWriter还有<strong>另外一个功能：根据一个Batch创建下一个高度的区块</strong>。一个区块包含了：</p><ul><li>Header：区块高度、前一个区块Hash、Data的哈希值</li><li>Data：被序列化的交易列表</li><li>Metadata：区块元数据</li></ul><p>Header只记录Data的哈希值，不包含Metadata哈希值，这样的目的是，在区块创建之后，仍能修改区块。</p><h2 id="Orderer节点启动"><a href="#Orderer节点启动" class="headerlink" title="Orderer节点启动"></a>Orderer节点启动</h2><p>根据Fabric 1.4源码梳理Orderer启动步骤：</p><ul><li>加载配置文件</li><li>设置Logger</li><li>设置本地MSP</li><li>核心启动部分：<ul><li>加载创世块</li><li>创建账本工厂</li><li>创建本机gRPCServer</li><li>如果共识需要集群(raft)，创建集群gRPCServer</li><li>创建Registrar：设置好共识插件，启动各通道，如果共识是raft，还会设置集群的gRPC接口处理函数Step</li><li>创建本机server：它是原子广播的处理服务，融合了Broadcast处理函数、deliver处理函数和registrar</li><li>开启profile</li><li>启动集群gRPC服务</li><li>启动本机gRPC服务</li></ul></li></ul><p>启动流程图可请参考杨宝华的笔记<a href="https://github.com/yeasy/hyperledger_code_fabric/blob/master/process/orderer_start.md" target="_blank" rel="noopener">Orderer 节点启动过程</a>，笔记可能是老版本的Fabric，但依然有参考价值。</p><h2 id="Orderer处理交易的流程"><a href="#Orderer处理交易的流程" class="headerlink" title="Orderer处理交易的流程"></a>Orderer处理交易的流程</h2><h3 id="普通交易在Orderer中的流程"><a href="#普通交易在Orderer中的流程" class="headerlink" title="普通交易在Orderer中的流程"></a>普通交易在Orderer中的流程</h3><p>交易是区块链的核心，交易在Orderer中的流程分3阶段：</p><ol><li>Orderer 的 Broadcast 接口收到来自客户端提交的交易，会获取交易所在的链的资源，并进行首次检查，然后提交给该链的共识，对交易进行排序，最后向客户端发送响应，为下图蓝色部分。</li><li>共识实例是单独运行的，也就是说Orderer把交易交给共识后，共识可能还在处理交易，然而Orderer已经开始向客户端发送提交交易的响应。共识如果发现排序服务的配置如果进行了更新，会再次检查交易，然后利用把Pending的交易分割成一组，然后打包成区块，然后共识机制确保各Orderer节点对区块达成一致，最后将区块写入账本。为下图绿色部分。</li><li>Peer会向Orderer订阅区块事件，每当新区块被Orderer写入账本时，Orderer会把新区块以区块事件的方式，发送给Peer。为下图换色部分。</li></ol><p><img src="http://img.lessisbetter.site/2019-11-21-orderer-tx-flow.png" alt=""></p><p>上面提到Orderer和共识实例分别会对交易进行2次检查，这些检查是相同的，为何要进行两次检查呢？</p><p>代码如下：ProcessMessage 会调用<code>ProcessNormalMsg</code>，对交易进行第一次检查，如果有错误，会向客户端返回错误响应。 SomeConsensurFunc 是一个假的函数名称，但3种共识插件实现，都包含相同的代码片，当消息中 configSeq &lt; seq 时，再次对交易进行检查，如果错误，则丢次此条交易。configSeq是Order函数传入的，即第一次检查交易时的配置号，seq为共识当前运行时的配置号。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bh *Handler)</span> <span class="title">ProcessMessage</span><span class="params">(msg *cb.Envelope, addr <span class="keyword">string</span>)</span> <span class="params">(resp *ab.BroadcastResponse)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    configSeq, err := processor.ProcessNormalMsg(msg)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        logger.Warningf(<span class="string">"[channel: %s] Rejecting broadcast of normal message from %s because of error: %s"</span>, chdr.ChannelId, addr, err)</span><br><span class="line">        <span class="keyword">return</span> &amp;ab.BroadcastResponse&#123;Status: ClassifyError(err), Info: err.Error()&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    err = processor.Order(msg, configSeq)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SomeConsensurFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> msg.configSeq &lt; seq &#123;</span><br><span class="line">        _, err = ch.support.ProcessNormalMsg(msg.normalMsg)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            logger.Warningf(<span class="string">"Discarding bad normal message: %s"</span>, err)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我认为如此设计的原因，考量如下：<br>共识插件应当尽量高效，orderer尽量把能做的做掉，把不能做的交给共识插件，而交易检查就是orderer能做的。共识插件只有在排序服务配置更新后，才需要重新检查交易，以判断是否依然满足规则。排序服务的配置通常是比较稳定的，更新频率很低，所以进行2次校验的频率也是非常低。这种方式，比只在共识插件校验，会拥有更高的整体性能。</p><h3 id="配置交易在Orderer中的流程"><a href="#配置交易在Orderer中的流程" class="headerlink" title="配置交易在Orderer中的流程"></a>配置交易在Orderer中的流程</h3><p>配置交易可以用来创建通道、更新通道配置，与普通交易的处理流程总体是相似的，只不过多了一些地方或者使用不同的函数，比如：</p><ul><li>交易检查函数不是ProcessNormalMsg，而是ProcessConfigMsg</li><li>配置交易单独打包在1个区块</li><li>配置交易写入账本后，要让配置生效，即Orderer应用最新的配置</li><li>…</li></ul><h3 id="使用Raft共识，交易在Orderer中的流程"><a href="#使用Raft共识，交易在Orderer中的流程" class="headerlink" title="使用Raft共识，交易在Orderer中的流程"></a>使用Raft共识，交易在Orderer中的流程</h3><p>上面2中流程都是与具体共识算法无关的，这里补充一个Raft共识的。</p><p><img src="http://img.lessisbetter.site/2020-01-orderer-using-raft.png" alt=""></p><p>使用Raft共识的链处理交易包含了上图中的4步：</p><ul><li>交易：处理交易</li><li>区块：创建区块</li><li>Raft：使用Raft对区块达成共识</li><li>账本：写区块元数据，把区块写入到账本</li></ul><p>如果把图中提到的：转发和Raft去掉，就是以Solo为共识的链的过程。</p><p>下图是更加细化一层的，如果看不懂，建议先读下<a href="http://lessisbetter.site/2019/08/22/etcd-raft-source-data-flow/">Etcd Raft架构设计和源码剖析2：数据流</a>这篇文章。</p><p><img src="http://img.lessisbetter.site/2020-01-fabric-order-with-etcdraft.png" alt=""></p><p>红色圈出来的是etcd/raft的实现，蓝色圈出来的是Fabric使用raft为共识的部分，外面的Broadcast、Deliver是属于Orderer但不属于某条链。</p><p>这张图和etcd与raft交互没有太多不同，只有2个地方：</p><ol><li>chains要把交易转化为区块，再交给raft去共识</li><li>chains的Apply并不是去修改状态机，而是把取消写到账本</li></ol><h2 id="源码简介"><a href="#源码简介" class="headerlink" title="源码简介"></a>源码简介</h2><p>Orderer的代码位于<code>fabric/orderer</code>，其目录结构如下，标注了每个目录结构的功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">➜  fabric git:(readCode) ✗ tree -L 2 orderer</span><br><span class="line">orderer</span><br><span class="line">├── README.md</span><br><span class="line">├── common</span><br><span class="line">│   ├── blockcutter 缓存待打包的交易，切块</span><br><span class="line">│   ├── bootstrap 启动时替换通道创世块</span><br><span class="line">│   ├── broadcast orderer的Broadcast接口</span><br><span class="line">│   ├── cluster （Raft）集群服务</span><br><span class="line">│   ├── localconfig 解析orderer配置文件orderer.yaml</span><br><span class="line">│   ├── metadata 区块元数据填写</span><br><span class="line">│   ├── msgprocessor 交易检查</span><br><span class="line">│   ├── multichannel 多通道支持：Registrar、chainSupport、写区块</span><br><span class="line">│   └── server Orderer节点的服务端程序</span><br><span class="line">├── consensus 共识插件</span><br><span class="line">│   ├── consensus.go 共识插件需要实现的接口等定义</span><br><span class="line">│   ├── etcdraft raft共识插件</span><br><span class="line">│   ├── inactive 未激活时的raft</span><br><span class="line">│   ├── kafka kafka共识插件</span><br><span class="line">│   ├── mocks 测试用的共识插件</span><br><span class="line">│   └── solo solo共识插件</span><br><span class="line">├── main.go orderer程序入口</span><br><span class="line">├── mocks</span><br><span class="line">│   ├── common</span><br><span class="line">│   └── util</span><br><span class="line">└── sample_clients orderer的客户端程序样例</span><br><span class="line">    ├── broadcast_config</span><br><span class="line">    ├── broadcast_msg</span><br><span class="line">    └── deliver_stdout</span><br><span class="line"></span><br><span class="line">23 directories, 3 files</span><br></pre></td></tr></table></figure><p>阅读Orderer源码，深入学习Orderer的时候，建议以下顺序：</p><ul><li>核心的数据结构，主要在multichannel、consensus.go：<a href="http://lessisbetter.site/2019/11/18/fabric-orderer-structs/">Fabric 1.4源码解读 6：Orderer核心数据结构</a></li><li>Orderer的启动</li><li>Broadcast接口</li><li>msgprocessor</li><li>通过Solo掌握共识插件需要做哪些工作</li><li>切块：blockcutter</li><li>写区块：BlockWriter、metadata</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文从宏观的角度介绍了Orderer的功能、核心组成，以及交易在Orderer中的流程，Peer如何从Orderer获取区块。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Orderer介绍&quot;&gt;&lt;a href=&quot;#Orderer介绍&quot; class=&quot;headerlink&quot; title=&quot;Orderer介绍&quot;&gt;&lt;/a&gt;Orderer介绍&lt;/h2&gt;&lt;p&gt;排序服务由一组&lt;strong&gt;排序节点&lt;/strong&gt;组成，它接收客户端提交的交易
      
    
    </summary>
    
    
    
      <category term="区块链" scheme="http://lessisbetter.site/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Fabric" scheme="http://lessisbetter.site/tags/Fabric/"/>
    
  </entry>
  
  <entry>
    <title>Fabric 1.4源码解读 6：Orderer核心数据结构</title>
    <link href="http://lessisbetter.site/2019/11/18/fabric-orderer-structs/"/>
    <id>http://lessisbetter.site/2019/11/18/fabric-orderer-structs/</id>
    <published>2019-11-18T12:45:23.000Z</published>
    <updated>2019-11-18T03:46:55.513Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>许多Orderer的文章，都是从Orderer的启动过程讲起，今天换一种“乐高”角度，先看看有哪些“零件”，再看这些零件怎么配合。</p><p>Orderer负责接收交易，把交易打包成区块，然后区块在所有Orderer节点之间达成一致，再分发给Peer的功能，这涉及了：</p><ul><li>网络：gRPC接收交易，向Peer发送区块</li><li>切块：把交易打包成区块</li><li>共识：所有Orderer节点达成一致</li></ul><p>这些功能是由Orderer核心数据结构组织起来。</p><blockquote><p>在Fabric中，通道和链在概念上都是一条区块链，所以本文中也会可能会混用链和通道。</p></blockquote><h2 id="核心数据结构"><a href="#核心数据结构" class="headerlink" title="核心数据结构"></a>核心数据结构</h2><h3 id="Registrar"><a href="#Registrar" class="headerlink" title="Registrar"></a>Registrar</h3><p><img src="http://img.lessisbetter.site/2019-11-orderer-registrar.png" alt="Registrar"></p><p>代码中，这样描述Registrar：</p><blockquote><p>Registrar serves as a point of access and control for the individual channel resources.</p></blockquote><p>可见它负责了每个channel资源的访问和控制点，也就说，要对某个通道怎么样，得从这入手。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Registrar <span class="keyword">struct</span> &#123;</span><br><span class="line">lock sync.RWMutex</span><br><span class="line"><span class="comment">// 保存了多条链</span></span><br><span class="line">chains <span class="keyword">map</span>[<span class="keyword">string</span>]*ChainSupport</span><br><span class="line"></span><br><span class="line"><span class="comment">// 共识插件</span></span><br><span class="line">consenters         <span class="keyword">map</span>[<span class="keyword">string</span>]consensus.Consenter</span><br><span class="line">ledgerFactory      blockledger.Factory</span><br><span class="line">signer             crypto.LocalSigner</span><br><span class="line">    </span><br><span class="line">systemChannelID    <span class="keyword">string</span></span><br><span class="line">systemChannel      *ChainSupport</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>chains</code>保存了每一条链，每一条链在Orderer中都以<a href="#ChainSupport">ChainSupport</a>代表。</li><li><code>consenters</code>保存了所有的共识插件，每个共识插件都是一个<a href="#Consenter">Consenter</a>，Fabric 1.4中共识插件有Solo、Kafka、EtcdRaft。</li><li><code>ledgerFactory</code>用来读取和创建链的账本。</li><li><code>signer</code>用来对Orderer中的数据进行签名，以及创建<a href="http://lessisbetter.site/2019/11/10/how-fabric-verify-signatures/#解密SignatureHeader">SignatureHeader</a>。</li><li><code>systemChannelID</code>和<code>systemChannel</code>分别是系统链ID、系统链实例。</li></ul><h3 id="ChainSupport"><a href="#ChainSupport" class="headerlink" title="ChainSupport"></a>ChainSupport</h3><p><img src="http://img.lessisbetter.site/2019-11-orderer-chainsupport.png" alt="chainsupport"></p><p>ChainSupport汇集了一条通道所需要的所有资源，所以说一个ChainSupport代表了一条链。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ChainSupport <span class="keyword">struct</span> &#123;</span><br><span class="line">*ledgerResources</span><br><span class="line">msgprocessor.Processor</span><br><span class="line">*BlockWriter</span><br><span class="line">consensus.Chain</span><br><span class="line">cutter blockcutter.Receiver</span><br><span class="line">crypto.LocalSigner</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ChainSupport 是一堆接口的集合，这些接口构成一条链所有的操作，接口可以分为4类：</p><ul><li>账本：<code>ledgerResources</code>、<code>BlockWriter</code>分别是账本读写和把区块写入到账本。</li><li>消息：<code>msgprocessor.Processor</code>、<code>cutter</code>分别是处理交易和把交易切块。</li><li>共识：<code>consensus.Chain</code>是Orderer的共识实例，比如每条链都有自己的Raft共识实例，它们互不干扰。</li><li>签名：<code>crypto.LocalSigner</code>，同Registrar中的介绍。</li></ul><h3 id="Chain"><a href="#Chain" class="headerlink" title="Chain"></a>Chain</h3><p><img src="http://img.lessisbetter.site/2019-11-orderer-chain.png" alt="Chain"></p><p>Chain是接口，它的实现并不一条链，而是一条链的共识实例，可以是Solo、Kafka和EtcdRaft，它运行在单独的协程，使用Channel和ChainSupport通信，它调用其它接口完成切块，以及让所有的Orderer节点对交易达成一致。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Chain defines a way to inject messages for ordering.</span></span><br><span class="line"><span class="comment">// Note, that in order to allow flexibility in the implementation, it is the responsibility of the implementer</span></span><br><span class="line"><span class="comment">// to take the ordered messages, send them through the blockcutter.Receiver supplied via HandleChain to cut blocks,</span></span><br><span class="line"><span class="comment">// and ultimately write the ledger also supplied via HandleChain.  This design allows for two primary flows</span></span><br><span class="line"><span class="comment">// 1. Messages are ordered into a stream, the stream is cut into blocks, the blocks are committed (solo, kafka)</span></span><br><span class="line"><span class="comment">// 2. Messages are cut into blocks, the blocks are ordered, then the blocks are committed (sbft)</span></span><br><span class="line"><span class="keyword">type</span> Chain <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// 普通消息/交易排序</span></span><br><span class="line"><span class="comment">// Order accepts a message which has been processed at a given configSeq.</span></span><br><span class="line"><span class="comment">// If the configSeq advances, it is the responsibility of the consenter</span></span><br><span class="line"><span class="comment">// to revalidate and potentially discard the message</span></span><br><span class="line"><span class="comment">// The consenter may return an error, indicating the message was not accepted</span></span><br><span class="line">Order(env *cb.Envelope, configSeq <span class="keyword">uint64</span>) error</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置消息/交易排序</span></span><br><span class="line"><span class="comment">// Configure accepts a message which reconfigures the channel and will</span></span><br><span class="line"><span class="comment">// trigger an update to the configSeq if committed.  The configuration must have</span></span><br><span class="line"><span class="comment">// been triggered by a ConfigUpdate message. If the config sequence advances,</span></span><br><span class="line"><span class="comment">// it is the responsibility of the consenter to recompute the resulting config,</span></span><br><span class="line"><span class="comment">// discarding the message if the reconfiguration is no longer valid.</span></span><br><span class="line"><span class="comment">// The consenter may return an error, indicating the message was not accepted</span></span><br><span class="line">Configure(config *cb.Envelope, configSeq <span class="keyword">uint64</span>) error</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待排序集群可用</span></span><br><span class="line"><span class="comment">// WaitReady blocks waiting for consenter to be ready for accepting new messages.</span></span><br><span class="line"><span class="comment">// This is useful when consenter needs to temporarily block ingress messages so</span></span><br><span class="line"><span class="comment">// that in-flight messages can be consumed. It could return error if consenter is</span></span><br><span class="line"><span class="comment">// in erroneous states. If this blocking behavior is not desired, consenter could</span></span><br><span class="line"><span class="comment">// simply return nil.</span></span><br><span class="line">WaitReady() error</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当排序集群发送错误时，会关闭返回的通道</span></span><br><span class="line"><span class="comment">// Errored returns a channel which will close when an error has occurred.</span></span><br><span class="line"><span class="comment">// This is especially useful for the Deliver client, who must terminate waiting</span></span><br><span class="line"><span class="comment">// clients when the consenter is not up to date.</span></span><br><span class="line">Errored() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动当前链</span></span><br><span class="line"><span class="comment">// Start should allocate whatever resources are needed for staying up to date with the chain.</span></span><br><span class="line"><span class="comment">// Typically, this involves creating a thread which reads from the ordering source, passes those</span></span><br><span class="line"><span class="comment">// messages to a block cutter, and writes the resulting blocks to the ledger.</span></span><br><span class="line">Start()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止当前链，并释放资源</span></span><br><span class="line"><span class="comment">// Halt frees the resources which were allocated for this Chain.</span></span><br><span class="line">Halt()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Consenter"><a href="#Consenter" class="headerlink" title="Consenter"></a>Consenter</h3><p><img src="http://img.lessisbetter.site/2019-11-orderer-consenter.png" alt="Consenter"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Consenter <span class="keyword">interface</span> &#123;</span><br><span class="line">HandleChain(support ConsenterSupport, metadata *cb.Metadata) (Chain, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Consenter也是接口，它只有1个功能用来创建<code>Chain</code>。每种共识插件，都有自己单独的<strong>consenter实现</strong>，分别用来创建solo实例、kafka实例或etcdraft实例。</p><h3 id="ConsenterSupport"><a href="#ConsenterSupport" class="headerlink" title="ConsenterSupport"></a>ConsenterSupport</h3><p><img src="http://img.lessisbetter.site/2019-11-orderer-consentersupport.png" alt="ConsenterSupport"></p><p>ConsenterSupport为<strong>consenter实现</strong>提供所需的资源，其实就是共识用来访问外部数据的接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConsenterSupport provides the resources available to a Consenter implementation.</span></span><br><span class="line"><span class="keyword">type</span> ConsenterSupport <span class="keyword">interface</span> &#123;</span><br><span class="line">crypto.LocalSigner</span><br><span class="line">msgprocessor.Processor</span><br><span class="line"></span><br><span class="line"><span class="comment">// VerifyBlockSignature verifies a signature of a block with a given optional</span></span><br><span class="line"><span class="comment">// configuration (can be nil).</span></span><br><span class="line">VerifyBlockSignature([]*cb.SignedData, *cb.ConfigEnvelope) error</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供把消息切成块的接口</span></span><br><span class="line"><span class="comment">// BlockCutter returns the block cutting helper for this channel.</span></span><br><span class="line">BlockCutter() blockcutter.Receiver</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前链的orderer配置</span></span><br><span class="line"><span class="comment">// SharedConfig provides the shared config from the channel's current config block.</span></span><br><span class="line">SharedConfig() channelconfig.Orderer</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前链的通道配置</span></span><br><span class="line"><span class="comment">// ChannelConfig provides the channel config from the channel's current config block.</span></span><br><span class="line">ChannelConfig() channelconfig.Channel</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成区块</span></span><br><span class="line"><span class="comment">// CreateNextBlock takes a list of messages and creates the next block based on the block with highest block number committed to the ledger</span></span><br><span class="line"><span class="comment">// Note that either WriteBlock or WriteConfigBlock must be called before invoking this method a second time.</span></span><br><span class="line">CreateNextBlock(messages []*cb.Envelope) *cb.Block</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读区块</span></span><br><span class="line"><span class="comment">// Block returns a block with the given number,</span></span><br><span class="line"><span class="comment">// or nil if such a block doesn't exist.</span></span><br><span class="line">Block(number <span class="keyword">uint64</span>) *cb.Block</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写区块</span></span><br><span class="line"><span class="comment">// WriteBlock commits a block to the ledger.</span></span><br><span class="line">WriteBlock(block *cb.Block, encodedMetadataValue []<span class="keyword">byte</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写配置区块并更新配置</span></span><br><span class="line"><span class="comment">// WriteConfigBlock commits a block to the ledger, and applies the config update inside.</span></span><br><span class="line">WriteConfigBlock(block *cb.Block, encodedMetadataValue []<span class="keyword">byte</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sequence returns the current config squence.</span></span><br><span class="line">Sequence() <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ChainID returns the channel ID this support is associated with.</span></span><br><span class="line">ChainID() <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Height returns the number of blocks in the chain this channel is associated with.</span></span><br><span class="line">Height() <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以原始数据的格式追加区块，不像WriteBlock那样会修改元数据</span></span><br><span class="line"><span class="comment">// Append appends a new block to the ledger in its raw form,</span></span><br><span class="line"><span class="comment">// unlike WriteBlock that also mutates its metadata.</span></span><br><span class="line">Append(block *cb.Block) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="宏观视角"><a href="#宏观视角" class="headerlink" title="宏观视角"></a>宏观视角</h2><p>把上面介绍的各项，融合在一幅图中：</p><ul><li>Registrar 包容万象，主要是ChainSupport和Consenter，Consenter是可插拔的</li><li>ChainSupport 代表了一条链，能够指向属于本条链的共识实例，该共识实例由对应共识类型的Consenter创建</li><li>共识实例使用ConsenterSupport访问共识外部资源</li></ul><p><img src="http://img.lessisbetter.site/2019-11-core-struct-of-orderer.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;许多Orderer的文章，都是从Orderer的启动过程讲起，今天换一种“乐高”角度，先看看有哪些“零件”，再看这些零件怎么配合。&lt;/p&gt;

      
    
    </summary>
    
    
    
      <category term="区块链" scheme="http://lessisbetter.site/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Fabric" scheme="http://lessisbetter.site/tags/Fabric/"/>
    
  </entry>
  
  <entry>
    <title>使用fabric-sdk-go订阅Fabric事件</title>
    <link href="http://lessisbetter.site/2019/11/13/using-fabric-sdk-go-register-event/"/>
    <id>http://lessisbetter.site/2019/11/13/using-fabric-sdk-go-register-event/</id>
    <published>2019-11-13T12:43:13.000Z</published>
    <updated>2019-11-13T08:43:47.825Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://lessisbetter.site/2019/09/02/fabric-sdk-go-chaincode/">使用fabric-sdk-go操作链码</a>，介绍了使用官方Go SDK，安装、实例化和升级链码，调用和查询链码，本文介绍使用fabric-sdk-go订阅事件。</p><h2 id="事件介绍"><a href="#事件介绍" class="headerlink" title="事件介绍"></a>事件介绍</h2><p>本质上就3种事件：</p><ul><li>BlockEvent：获取区块信息</li><li>TransactionEvent：获取交易信息</li><li>ChainCodeEvnet：链码中<strong>自定义的</strong>链码事件</li></ul><p>但每种事件都有2 种类型：</p><ul><li><strong>Filtered</strong>：事件订阅时默认的类型，获取的<strong>信息“不全”</strong>，不同的事件缺失的数据不同，比如链码事件，如果是Filtered的，其响应字段中的Payload是空的，也就是不知道链码事件携带的数据。这种方式能够降低fabric网络和SDK之间的流量，当Filtered后的字段信息就足够时，这种方式非常适合。关于Filtered的更多信息，这篇文章 <a href="http://lessisbetter.site/2019/09/20/fabric-event-source/">Fabric 1.4源码解读 3：Event原理解读</a> 非常有帮助。</li><li><strong>非Filtered</strong> ：可以获取<strong>完整的</strong>区块、交易、链码事件<strong>信息</strong>，这种方式在SDK想获取更多信息时，是非常必要的。</li></ul><p>4 个注册事件的接口1个取消注册的接口如下：</p><table><thead><tr><th style="text-align:center">接口名称</th><th style="text-align:center">描述</th><th style="text-align:center">参数值</th><th style="text-align:center">返回值</th></tr></thead><tbody><tr><td style="text-align:center">RegisterBlockEvent</td><td style="text-align:center">注册块事件</td><td style="text-align:center">filter …fab.BlockFilter</td><td style="text-align:center">fab.Registration, &lt;-chan *fab.BlockEvent, error</td></tr><tr><td style="text-align:center">RegisterFilteredBlockEvent</td><td style="text-align:center">注册过滤块事件</td><td style="text-align:center">无</td><td style="text-align:center">fab.Registration, &lt;-chan *fab.FilteredBlockEvent, error</td></tr><tr><td style="text-align:center">RegisterTxStatusEvent</td><td style="text-align:center">注册交易状态事件</td><td style="text-align:center">txID string</td><td style="text-align:center">fab.Registration, &lt;-chan *fab.TxStatusEvent, error</td></tr><tr><td style="text-align:center">RegisterChaincodeEvent</td><td style="text-align:center">注册链码事件</td><td style="text-align:center">ccID, eventFilter string</td><td style="text-align:center">fab.Registration, &lt;-chan *fab.CCEvent, error</td></tr><tr><td style="text-align:center">Unregister</td><td style="text-align:center">取消事件订阅</td><td style="text-align:center">fab.Registration</td><td style="text-align:center">无</td></tr></tbody></table><p>注册会得到管理可以管理订阅的Registration、接收事件的通道，以及可能注册时发生的错误，关于每个接口的具体介绍、使用，可以参考官方的<a href="https://godoc.org/github.com/hyperledger/fabric-sdk-go/pkg/client/event" target="_blank" rel="noopener">Event文档</a>，其中包含了样例代码，如果想看真实的样例代码，可以参考<a href="#示例项目">示例项目</a>。</p><h2 id="Option介绍"><a href="#Option介绍" class="headerlink" title="Option介绍"></a>Option介绍</h2><p>注册事件需要使用<code>EventClient</code>，创建EventClient时可以指定一些选项，这些选项其实就是事件订阅的选项。</p><p>有3个Option:</p><ul><li><p>func WithBlockEvents() ClientOption</p><p>  指定了此选项，事件就是<strong>非“filtered”</strong>，fabric会向调用SDK客户端发送完整的区块，可以获得订阅事件完整的信息。</p></li><li><p>func WithSeekType(seek seek.Type) ClientOption</p><p>  使用此选项可以<strong>指定从哪个区块高度获取事件</strong>。<code>seek.Type</code>有<code>Oldest</code>、<code>Newest</code>和<code>FromBlock</code> 3种取值，分别代表从第1个区块、最后一个区块和指定区块号开始获取事件，<code>FromBlock</code>需要结合<code>WithBlockNum</code>使用。So，可以通过这个选项<strong>获取历史事件</strong>。</p></li><li><p>func WithBlockNum(from uint64) ClientOption</p><p>  指定区块高度，只有<code>WithSeekType(FromBlock)</code>时才生效。</p></li></ul><h2 id="链码事件多说几句"><a href="#链码事件多说几句" class="headerlink" title="链码事件多说几句"></a>链码事件多说几句</h2><h3 id="链码如何发链码事件"><a href="#链码如何发链码事件" class="headerlink" title="链码如何发链码事件"></a>链码如何发链码事件</h3><p><code>ChaincodeStubInterface</code>有<code>SetEvent</code>的方法，入参分别为事件名称和事件锁携带的信息payload。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ChaincodeStubInterface is used by deployable chaincode apps to access and</span></span><br><span class="line"><span class="comment">// modify their ledgers</span></span><br><span class="line"><span class="keyword">type</span> ChaincodeStubInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// SetEvent allows the chaincode to set an event on the response to the</span></span><br><span class="line">    <span class="comment">// proposal to be included as part of a transaction. The event will be</span></span><br><span class="line">    <span class="comment">// available within the transaction in the committed block regardless of the</span></span><br><span class="line">    <span class="comment">// validity of the transaction.</span></span><br><span class="line">    SetEvent(name <span class="keyword">string</span>, payload []<span class="keyword">byte</span>) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过ChannelClient订阅链码事件介绍"><a href="#通过ChannelClient订阅链码事件介绍" class="headerlink" title="通过ChannelClient订阅链码事件介绍"></a>通过ChannelClient订阅链码事件介绍</h3><p>SDK的channel client也有订阅链码事件的接口：<a href="https://godoc.org/github.com/hyperledger/fabric-sdk-go/pkg/client/channel#Client.RegisterChaincodeEvent" target="_blank" rel="noopener">channel.Client.RegisterChaincodeEvent()</a>，它的定义和event client提供的接口完全一样，但功能上有所差别。</p><p>channel client没有指定 <code>WithBlockEvents</code>，所以这是<strong>Filtered的事件链码</strong>，获取的事件链码中，其Payload为空。</p><h2 id="示例项目"><a href="#示例项目" class="headerlink" title="示例项目"></a>示例项目</h2><p>示例项目<a href="https://github.com/Shitaibin/fabric-sdk-go-sample/tree/master/samples/event" target="_blank" rel="noopener">fabric-sdk-go-sample</a>是结合Fabric的BYFN展示如何使用fabric-sdk-go的项目，它的Event样例部分，介绍了如何使用以上接口订阅Fabric事件，具体请参加该部分<a href="https://github.com/Shitaibin/fabric-sdk-go-sample/blob/master/samples/event/README.md" target="_blank" rel="noopener">README</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://lessisbetter.site/2019/09/02/fabric-sdk-go-chaincode/&quot;&gt;使用fabric-sdk-go操作链码&lt;/a&gt;，介绍了使用官方Go SDK，安装、实例化和升级链码，调用和查询链码，本文介绍使用fa
      
    
    </summary>
    
    
    
      <category term="区块链" scheme="http://lessisbetter.site/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Fabric" scheme="http://lessisbetter.site/tags/Fabric/"/>
    
  </entry>
  
  <entry>
    <title>Fabric 1.4源码解读 5：Fabric是如何验证签名的？</title>
    <link href="http://lessisbetter.site/2019/11/10/how-fabric-verify-signatures/"/>
    <id>http://lessisbetter.site/2019/11/10/how-fabric-verify-signatures/</id>
    <published>2019-11-10T13:23:36.000Z</published>
    <updated>2019-11-18T07:30:42.775Z</updated>
    
    <content type="html"><![CDATA[<h2 id="理论知识"><a href="#理论知识" class="headerlink" title="理论知识"></a>理论知识</h2><p>如果不清楚数字证书、公私钥与签名的关系，建议阅读阮一峰的<a href="https://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html" target="_blank" rel="noopener">数字签名是什么？</a>。</p><h2 id="Fabric证书和密钥文件"><a href="#Fabric证书和密钥文件" class="headerlink" title="Fabric证书和密钥文件"></a>Fabric证书和密钥文件</h2><p>使用Fabric CA或者 cryptogen 工具可以生成证书和私钥文件，这里取 BYFN 例子的文件做介绍，Org1 Admin 账户的文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">➜  first-network git:(release-1.4) ✗ tree crypto-config/peerOrganizations/org1.example.com/users/Admin@org1.example.com</span><br><span class="line">crypto-config/peerOrganizations/org1.example.com/users/Admin@org1.example.com</span><br><span class="line">├── msp</span><br><span class="line">│   ├── admincerts</span><br><span class="line">│   │   └── Admin@org1.example.com-cert.pem</span><br><span class="line">│   ├── cacerts</span><br><span class="line">│   │   └── ca.org1.example.com-cert.pem</span><br><span class="line">│   ├── keystore</span><br><span class="line">│   │   └── f9f3dddb7fcc40086de6d5ae77f1481abbb99bff7a74839b950720d3dca0d8ee_sk</span><br><span class="line">│   ├── signcerts</span><br><span class="line">│   │   └── Admin@org1.example.com-cert.pem</span><br><span class="line">│   └── tlscacerts</span><br><span class="line">│       └── tlsca.org1.example.com-cert.pem</span><br><span class="line">└── tls</span><br><span class="line">    ├── ca.crt</span><br><span class="line">    ├── client.crt</span><br><span class="line">    └── client.key</span><br></pre></td></tr></table></figure><p>msp目录，为Admin的身份信息：</p><ul><li>admincerts：组织管理员的身份验证证书。</li><li>cacerts：组织的根证书。</li><li>keystore：该用户的私钥，用来对消息签名。</li><li>signcerts：该用户的身份验证证书，被组织根证书签名。</li><li>tlscacerts：TLS通信用的身份证书，为组织的TLS证书。</li></ul><p>tls目录，为TLS通信相关的证书：</p><ul><li>ca.crt：组织根证书</li><li>client.crt：验证当前用户身份的证书，当前为验证管理员的证书</li><li>client.key：当前用户的身份私钥，用来签名</li></ul><h2 id="整体逻辑"><a href="#整体逻辑" class="headerlink" title="整体逻辑"></a>整体逻辑</h2><p>交易是区块链的核心，一切状态的转移都是一条交易，交易的真伪需要使用数字签名进行保证。</p><p>在Fabric中，交易涉及两个概念：</p><ul><li>Proposal：提案</li><li>Transaction：交易</li></ul><p>所以 Proposal 和 Transaction 都需要使用数字签名进行保护，它们相关的消息中，都包含了发送方的身份信息：mspid、证书（证书中实际包含了公钥）。</p><p>提案的实际消息是 SignedProposal，其中包含了：</p><ul><li>数字签名：Signature</li><li>证书、公钥等签名者身份信息：ProposalBytes.Proposal.Header.SignatureHeader.Creator</li></ul><p><img src="http://img.lessisbetter.site/2019-11-signed_proposal.png" alt="signed_proposal"></p><blockquote><p>图来自杨保华的<a href="https://github.com/yeasy/hyperledger_code_fabric" target="_blank" rel="noopener">hyperledger_code_fabric</a> 。</p></blockquote><p>交易中最重要的是Envelope结构体，SDK向Orderer提交交易时，会发送Envelope消息，它包含了：</p><ul><li>数字签名：Signature</li><li>交易发送方的身份信息：Payload.Header.SignatureHeader.Creator</li><li>可选背书节点的身份信息，不同的交易类型，Data包含了不同的信息，如果是需要背书的，可以包含背书的信息、签名和身份信息：Payload.Data.SignedChainccodeDeploymentSpec.OwnerEndorsements.signingidentity</li></ul><p><img src="http://img.lessisbetter.site/2019-11-tx_envelop.jpeg" alt="Signed transaction"></p><blockquote><p>图来自《区块链原理、设计与应用》，为升级链码的交易Envelope结构。</p></blockquote><p>在验证消息的签名时，会从中提取出数字签名Signature，身份信息（证书、公钥）和被签名消息体，完成以下验证：</p><ul><li>使用证书验证发送方的身份，发送方是否属于它所在的组织，以及发送方的公钥没有修改和替换</li><li>使用公钥验证消息是否为发送方签名，并且消息没有被修改</li></ul><p>验证的整体流程如下：</p><p><img src="http://img.lessisbetter.site/2019-11-verify-signature.png" alt="Verify signature"></p><h2 id="验证签名的函数"><a href="#验证签名的函数" class="headerlink" title="验证签名的函数"></a>验证签名的函数</h2><p><code>core/common/validation/msgvalidation.go</code> 提供了2验证消息签名的函数，用来验证Proposal和Transaction，它们会调用相同的函数<code>checkSignatureFromCreator</code>进行数字签名的验证。</p><h3 id="验证Porposal签名"><a href="#验证Porposal签名" class="headerlink" title="验证Porposal签名"></a>验证Porposal签名</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValidateProposalMessage</span><span class="params">(signedProp *pb.SignedProposal)</span> <span class="params">(*pb.Proposal, *common.Header, *pb.ChaincodeHeaderExtension, error)</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从SignatureHeader交易客户端的签名</span></span><br><span class="line"><span class="comment">// validate the signature</span></span><br><span class="line">err = checkSignatureFromCreator(shdr.Creator, signedProp.Signature, signedProp.ProposalBytes, chdr.ChannelId)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// log the exact message on the peer but return a generic error message to</span></span><br><span class="line"><span class="comment">// avoid malicious users scanning for channels</span></span><br><span class="line">putilsLogger.Warningf(<span class="string">"channel [%s]: %s"</span>, chdr.ChannelId, err)</span><br><span class="line">sId := &amp;msp.SerializedIdentity&#123;&#125;</span><br><span class="line">err := proto.Unmarshal(shdr.Creator, sId)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// log the error here as well but still only return the generic error</span></span><br><span class="line">err = errors.Wrap(err, <span class="string">"could not deserialize a SerializedIdentity"</span>)</span><br><span class="line">putilsLogger.Warningf(<span class="string">"channel [%s]: %s"</span>, chdr.ChannelId, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, errors.Errorf(<span class="string">"access denied: channel [%s] creator org [%s]"</span>, chdr.ChannelId, sId.Mspid)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="验证Transaction签名"><a href="#验证Transaction签名" class="headerlink" title="验证Transaction签名"></a>验证Transaction签名</h3><p>Commit阶段会对交易进行验证，会调用此函数，该函数完成了对Transaction的验证，包含发送方数字签名的验证。</p><p>交易是包含背书结果和背书签名的，背书相关的验证并不包含在此，而是专门的背书验证，具体请看<a href="http://lessisbetter.site/2019/09/06/fabric-source-endorser-policy-flow/">Fabric 1.4源码解读 1：背书策略是怎么使用的</a>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ValidateTransaction checks that the transaction envelope is properly formed</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValidateTransaction</span><span class="params">(e *common.Envelope, c channelconfig.ApplicationCapabilities)</span> <span class="params">(*common.Payload, pb.TxValidationCode)</span></span> &#123;</span><br><span class="line">putilsLogger.Debugf(<span class="string">"ValidateTransactionEnvelope starts for envelope %p"</span>, e)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// validate the header</span></span><br><span class="line">chdr, shdr, err := validateCommonHeader(payload.Header)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">putilsLogger.Errorf(<span class="string">"validateCommonHeader returns err %s"</span>, err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, pb.TxValidationCode_BAD_COMMON_HEADER</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// validate the signature in the envelope</span></span><br><span class="line">err = checkSignatureFromCreator(shdr.Creator, e.Signature, e.Payload, chdr.ChannelId)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">putilsLogger.Errorf(<span class="string">"checkSignatureFromCreator returns err %s"</span>, err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, pb.TxValidationCode_BAD_CREATOR_SIGNATURE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// continue the validation in a way that depends on the type specified in the header</span></span><br><span class="line"><span class="keyword">switch</span> common.HeaderType(chdr.Type) &#123;</span><br><span class="line"><span class="keyword">case</span> common.HeaderType_ENDORSER_TRANSACTION:</span><br><span class="line"><span class="comment">// Verify that the transaction ID has been computed properly.</span></span><br><span class="line"><span class="comment">// This check is needed to ensure that the lookup into the ledger</span></span><br><span class="line"><span class="comment">// for the same TxID catches duplicates.</span></span><br><span class="line">err = utils.CheckTxID(</span><br><span class="line">chdr.TxId,</span><br><span class="line">shdr.Nonce,</span><br><span class="line">shdr.Creator)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">putilsLogger.Errorf(<span class="string">"CheckTxID returns err %s"</span>, err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, pb.TxValidationCode_BAD_PROPOSAL_TXID</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是背书交易，背书的签名不在此验证，由背书策略模块进行验证</span></span><br><span class="line">err = validateEndorserTransaction(payload.Data, payload.Header)</span><br><span class="line">putilsLogger.Debugf(<span class="string">"ValidateTransactionEnvelope returns err %s"</span>, err)</span><br></pre></td></tr></table></figure><h2 id="验证签名"><a href="#验证签名" class="headerlink" title="验证签名"></a>验证签名</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// given a creator, a message and a signature,</span></span><br><span class="line"><span class="comment">// this function returns nil if the creator</span></span><br><span class="line"><span class="comment">// is a valid cert and the signature is valid</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkSignatureFromCreator</span><span class="params">(creatorBytes []<span class="keyword">byte</span>, sig []<span class="keyword">byte</span>, msg []<span class="keyword">byte</span>, ChainID <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">putilsLogger.Debugf(<span class="string">"begin"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// check for nil argument</span></span><br><span class="line"><span class="keyword">if</span> creatorBytes == <span class="literal">nil</span> || sig == <span class="literal">nil</span> || msg == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">"nil arguments"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个链有各自的msp</span></span><br><span class="line">mspObj := mspmgmt.GetIdentityDeserializer(ChainID)</span><br><span class="line"><span class="keyword">if</span> mspObj == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.Errorf(<span class="string">"could not get msp for channel [%s]"</span>, ChainID)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取proposal创建者/发送方的Identity</span></span><br><span class="line"><span class="comment">// creatorBytes 中是序列化后的mspid、证书、公钥等信息</span></span><br><span class="line">creator, err := mspObj.DeserializeIdentity(creatorBytes)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.WithMessage(err, <span class="string">"MSP error"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">putilsLogger.Debugf(<span class="string">"creator is %s"</span>, creator.GetIdentifier())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证证书是否有效</span></span><br><span class="line"><span class="comment">// ensure that creator is a valid certificate</span></span><br><span class="line">err = creator.Validate()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.WithMessage(err, <span class="string">"creator certificate is not valid"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">putilsLogger.Debugf(<span class="string">"creator is valid"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// validate the signature</span></span><br><span class="line"><span class="comment">// 验证签名</span></span><br><span class="line">err = creator.Verify(msg, sig)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.WithMessage(err, <span class="string">"creator's signature over the proposal is not valid"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">putilsLogger.Debugf(<span class="string">"exits successfully"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取Identity"><a href="#获取Identity" class="headerlink" title="获取Identity"></a>获取Identity</h3><p>获取当前通道的MSP manager：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetIdentityDeserializer returns the IdentityDeserializer for the given chain</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetIdentityDeserializer</span><span class="params">(chainID <span class="keyword">string</span>)</span> <span class="title">msp</span>.<span class="title">IdentityDeserializer</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> chainID == <span class="string">""</span> &#123;</span><br><span class="line"><span class="keyword">return</span> GetLocalMSP()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> GetManagerForChain(chainID)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetManagerForChain returns the msp manager for the supplied</span></span><br><span class="line"><span class="comment">// chain; if no such manager exists, one is created</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetManagerForChain</span><span class="params">(chainID <span class="keyword">string</span>)</span> <span class="title">msp</span>.<span class="title">MSPManager</span></span> &#123;</span><br><span class="line">m.Lock()</span><br><span class="line"><span class="keyword">defer</span> m.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先从缓存查找</span></span><br><span class="line">mspMgr, ok := mspMap[chainID]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="comment">// 找不到则新建立当前通道Msp manager</span></span><br><span class="line">mspLogger.Debugf(<span class="string">"Created new msp manager for channel `%s`"</span>, chainID)</span><br><span class="line">mspMgmtMgr := &amp;mspMgmtMgr&#123;msp.NewMSPManager(), <span class="literal">false</span>&#125;</span><br><span class="line">mspMap[chainID] = mspMgmtMgr</span><br><span class="line">mspMgr = mspMgmtMgr</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// check for internal mspManagerImpl and mspMgmtMgr types. if a different</span></span><br><span class="line"><span class="comment">// type is found, it's because a developer has added a new type that</span></span><br><span class="line"><span class="comment">// implements the MSPManager interface and should add a case to the logic</span></span><br><span class="line"><span class="comment">// above to handle it.</span></span><br><span class="line"><span class="keyword">if</span> !(reflect.TypeOf(mspMgr).Elem().Name() == <span class="string">"mspManagerImpl"</span> || reflect.TypeOf(mspMgr).Elem().Name() == <span class="string">"mspMgmtMgr"</span>) &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"Found unexpected MSPManager type."</span>)</span><br><span class="line">&#125;</span><br><span class="line">mspLogger.Debugf(<span class="string">"Returning existing manager for channel '%s'"</span>, chainID)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mspMgr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MSPManager has been setup for a channel, which indicates whether the channel</span></span><br><span class="line"><span class="comment">// exists or not</span></span><br><span class="line"><span class="keyword">type</span> mspMgmtMgr <span class="keyword">struct</span> &#123;</span><br><span class="line">msp.MSPManager</span><br><span class="line"><span class="comment">// track whether this MSPManager has been setup successfully</span></span><br><span class="line">up <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>msp.MSPManager</code>是一个接口，从上面代码可以得知，它是利用<code>NewMSPManager</code>创建的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建等待Setup的MSPManager</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMSPManager</span><span class="params">()</span> <span class="title">MSPManager</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;mspManagerImpl&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>疑问是，啥时候Setup的，当前调用路径上没发现这个路径，可能从系统整体流程上，已经保证了，当前调用时，已经创建好了。</p><p>获取Identity，是一个剥洋葱的过程：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mgr *mspMgmtMgr)</span> <span class="title">DeserializeIdentity</span><span class="params">(serializedIdentity []<span class="keyword">byte</span>)</span> <span class="params">(msp.Identity, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> !mgr.up &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"channel doesn't exist"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mgr.MSPManager.DeserializeIdentity(serializedIdentity)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际调用<code>mspManagerImpl</code>的<code>DeserializeIdentity</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DeserializeIdentity returns an identity given its serialized version supplied as argument</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mgr *mspManagerImpl)</span> <span class="title">DeserializeIdentity</span><span class="params">(serializedID []<span class="keyword">byte</span>)</span> <span class="params">(Identity, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// We first deserialize to a SerializedIdentity to get the MSP ID</span></span><br><span class="line">sId := &amp;msp.SerializedIdentity&#123;&#125;</span><br><span class="line">err := proto.Unmarshal(serializedID, sId)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">"could not deserialize a SerializedIdentity"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取发送方的msp实例</span></span><br><span class="line"><span class="comment">// we can now attempt to obtain the MSP</span></span><br><span class="line">msp := mgr.mspsMap[sId.Mspid]</span><br><span class="line"><span class="keyword">if</span> msp == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.Errorf(<span class="string">"MSP %s is unknown"</span>, sId.Mspid)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> t := msp.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> *bccspmsp:</span><br><span class="line"><span class="keyword">return</span> t.deserializeIdentityInternal(sId.IdBytes)</span><br><span class="line"><span class="keyword">case</span> *idemixmsp:</span><br><span class="line"><span class="keyword">return</span> t.deserializeIdentityInternal(sId.IdBytes)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> t.DeserializeIdentity(serializedID)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转到bccspmsp的实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反序列化二进制，得到证书，然后用证书获取公钥，使用证书、公钥和msp，创建Identity</span></span><br><span class="line"><span class="comment">// deserializeIdentityInternal returns an identity given its byte-level representation</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(msp *bccspmsp)</span> <span class="title">deserializeIdentityInternal</span><span class="params">(serializedIdentity []<span class="keyword">byte</span>)</span> <span class="params">(Identity, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// This MSP will always deserialize certs this way</span></span><br><span class="line">bl, _ := pem.Decode(serializedIdentity)</span><br><span class="line"><span class="keyword">if</span> bl == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"could not decode the PEM structure"</span>)</span><br><span class="line">&#125;</span><br><span class="line">cert, err := x509.ParseCertificate(bl.Bytes)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">"parseCertificate failed"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now we have the certificate; make sure that its fields</span></span><br><span class="line"><span class="comment">// (e.g. the Issuer.OU or the Subject.OU) match with the</span></span><br><span class="line"><span class="comment">// MSP id that this MSP has; otherwise it might be an attack</span></span><br><span class="line"><span class="comment">// TODO!</span></span><br><span class="line"><span class="comment">// We can't do it yet because there is no standardized way</span></span><br><span class="line"><span class="comment">// (yet) to encode the MSP ID into the x.509 body of a cert</span></span><br><span class="line"></span><br><span class="line">pub, err := msp.bccsp.KeyImport(cert, &amp;bccsp.X509PublicKeyImportOpts&#123;Temporary: <span class="literal">true</span>&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.WithMessage(err, <span class="string">"failed to import certificate's public key"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> newIdentity(cert, pub, msp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Identity包含了Identity标示符，证书、公钥和所在的msp，创建Identity就是计算以上几项信息的过程：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> identity <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// id contains the identifier (MSPID and identity identifier) for this instance</span></span><br><span class="line">id *IdentityIdentifier</span><br><span class="line"></span><br><span class="line"><span class="comment">// cert contains the x.509 certificate that signs the public key of this instance</span></span><br><span class="line">cert *x509.Certificate</span><br><span class="line"></span><br><span class="line"><span class="comment">// this is the public key of this instance</span></span><br><span class="line">pk bccsp.Key</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference to the MSP that "owns" this identity</span></span><br><span class="line">msp *bccspmsp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newIdentity</span><span class="params">(cert *x509.Certificate, pk bccsp.Key, msp *bccspmsp)</span> <span class="params">(Identity, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> mspIdentityLogger.IsEnabledFor(zapcore.DebugLevel) &#123;</span><br><span class="line">mspIdentityLogger.Debugf(<span class="string">"Creating identity instance for cert %s"</span>, certToPEM(cert))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查证书</span></span><br><span class="line"><span class="comment">// Sanitize first the certificate</span></span><br><span class="line">cert, err := msp.sanitizeCert(cert)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compute identity identifier</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Use the hash of the identity's certificate as id in the IdentityIdentifier</span></span><br><span class="line">hashOpt, err := bccsp.GetHashOpt(msp.cryptoConfig.IdentityIdentifierHashFunction)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.WithMessage(err, <span class="string">"failed getting hash function options"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">digest, err := msp.bccsp.Hash(cert.Raw, hashOpt)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.WithMessage(err, <span class="string">"failed hashing raw certificate to compute the id of the IdentityIdentifier"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id := &amp;IdentityIdentifier&#123;</span><br><span class="line">Mspid: msp.name,</span><br><span class="line">Id:    hex.EncodeToString(digest)&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;identity&#123;id: id, cert: cert, pk: pk, msp: msp&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="验证数字签名"><a href="#验证数字签名" class="headerlink" title="验证数字签名"></a>验证数字签名</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Verify checks against a signature and a message</span></span><br><span class="line"><span class="comment">// to determine whether this identity produced the</span></span><br><span class="line"><span class="comment">// signature; it returns nil if so or an error otherwise</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(id *identity)</span> <span class="title">Verify</span><span class="params">(msg []<span class="keyword">byte</span>, sig []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// mspIdentityLogger.Infof("Verifying signature")</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Compute Hash</span></span><br><span class="line">hashOpt, err := id.getHashOpt(id.msp.cryptoConfig.SignatureHashFamily)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.WithMessage(err, <span class="string">"failed getting hash function options"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">digest, err := id.msp.bccsp.Hash(msg, hashOpt)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.WithMessage(err, <span class="string">"failed computing digest"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> mspIdentityLogger.IsEnabledFor(zapcore.DebugLevel) &#123;</span><br><span class="line">mspIdentityLogger.Debugf(<span class="string">"Verify: digest = %s"</span>, hex.Dump(digest))</span><br><span class="line">mspIdentityLogger.Debugf(<span class="string">"Verify: sig = %s"</span>, hex.Dump(sig))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终会调用bccsp的接口验证签名，SW或者国密</span></span><br><span class="line">valid, err := id.msp.bccsp.Verify(id.pk, sig, digest, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.WithMessage(err, <span class="string">"could not determine the validity of the signature"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> !valid &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">"The signature is invalid"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解密SignatureHeader"><a href="#解密SignatureHeader" class="headerlink" title="解密SignatureHeader"></a>解密SignatureHeader</h2><p>Fabric 使用 <code>SignatureHeader</code> 保存发送方的身份信息，Creator即为序列化后的信息。</p><p><code>SignatureHeaderMaker</code> 接口定义了创建一个 <code>SignatureHeader</code> 的方法，搜索起来实现该接口的结构体很多，本质上只有2个：<code>mspSigner</code> 和 <code>SignatureHeaderCreator</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SignatureHeaderMaker creates a new SignatureHeader</span></span><br><span class="line"><span class="keyword">type</span> SignatureHeaderMaker <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// NewSignatureHeader creates a SignatureHeader with the correct signing identity and a valid nonce</span></span><br><span class="line">NewSignatureHeader() (*cb.SignatureHeader, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// localmsp</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *mspSigner)</span> <span class="title">NewSignatureHeader</span><span class="params">()</span> <span class="params">(*cb.SignatureHeader, error)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// crypto</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bs *SignatureHeaderCreator)</span> <span class="title">NewSignatureHeader</span><span class="params">()</span> <span class="params">(*cb.SignatureHeader, error)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>两个实现本质上是一样的，以 <code>mspSigner</code> 为例进行介绍。首先获取实现SigningIdentity接口的实例，然后调用<code>Serialize</code>得到序列化后的身份信息，再随机生成一个Nonce，创建出<code>SignatureHeader</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewSignatureHeader creates a SignatureHeader with the correct signing identity and a valid nonce</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *mspSigner)</span> <span class="title">NewSignatureHeader</span><span class="params">()</span> <span class="params">(*cb.SignatureHeader, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// 获得SigningIdentity接口实例</span></span><br><span class="line">signer, err := mspmgmt.GetLocalMSP().GetDefaultSigningIdentity()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"Failed getting MSP-based signer [%s]"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化得到creator</span></span><br><span class="line">creatorIdentityRaw, err := signer.Serialize()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"Failed serializing creator public identity [%s]"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一个随机nonce</span></span><br><span class="line">nonce, err := crypto.GetRandomNonce()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"Failed creating nonce [%s]"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sh := &amp;cb.SignatureHeader&#123;&#125;</span><br><span class="line">sh.Creator = creatorIdentityRaw</span><br><span class="line">sh.Nonce = nonce</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sh, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SigningIdentity</code>接口包含了<code>Identity</code>接口，Identity声明了跟证书相关的方法，SigningIdentity则增加了对消息签名的函数<code>Sign</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SigningIdentity <span class="keyword">interface</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Extends Identity</span></span><br><span class="line">Identity</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sign the message</span></span><br><span class="line">Sign(msg []<span class="keyword">byte</span>) ([]<span class="keyword">byte</span>, error)</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetPublicVersion returns the public parts of this identity</span></span><br><span class="line">GetPublicVersion() Identity</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Identity <span class="keyword">interface</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="comment">// Serialize converts an identity to bytes</span></span><br><span class="line">Serialize() ([]<span class="keyword">byte</span>, error)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Serialize</code>的实现，实际只包含了证书和MSPID，说明了<strong>消息中携带的只包含MSPID和证书作为身份信息</strong>，而不是<code>signingidentity</code>的所有字段（signingidentity实现了SigningIdentity接口）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Serialize returns a byte array representation of this identity</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(id *identity)</span> <span class="title">Serialize</span><span class="params">()</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// mspIdentityLogger.Infof("Serializing identity %s", id.id)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Raw格式证书</span></span><br><span class="line">pb := &amp;pem.Block&#123;Bytes: id.cert.Raw, Type: <span class="string">"CERTIFICATE"</span>&#125;</span><br><span class="line">pemBytes := pem.EncodeToMemory(pb)</span><br><span class="line"><span class="keyword">if</span> pemBytes == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"encoding of identity failed"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用MSPID和序列化后的证书，再次序列化得到身份信息 </span></span><br><span class="line">sId := &amp;msp.SerializedIdentity&#123;Mspid: id.id.Mspid, IdBytes: pemBytes&#125;</span><br><span class="line">idBytes, err := proto.Marshal(sId)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrapf(err, <span class="string">"could not marshal a SerializedIdentity structure for identity %s"</span>, id.id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> idBytes, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://github.com/yeasy/hyperledger_code_fabric" target="_blank" rel="noopener">https://github.com/yeasy/hyperledger_code_fabric</a></li><li>《区块链原理、设计与应用》第9章、第10章</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;理论知识&quot;&gt;&lt;a href=&quot;#理论知识&quot; class=&quot;headerlink&quot; title=&quot;理论知识&quot;&gt;&lt;/a&gt;理论知识&lt;/h2&gt;&lt;p&gt;如果不清楚数字证书、公私钥与签名的关系，建议阅读阮一峰的&lt;a href=&quot;https://www.ruanyifeng.co
      
    
    </summary>
    
    
    
      <category term="区块链" scheme="http://lessisbetter.site/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Fabric" scheme="http://lessisbetter.site/tags/Fabric/"/>
    
  </entry>
  
  <entry>
    <title>Go Modules 方法、问题汇总贴</title>
    <link href="http://lessisbetter.site/2019/10/31/go-modules-notes/"/>
    <id>http://lessisbetter.site/2019/10/31/go-modules-notes/</id>
    <published>2019-10-31T09:07:59.000Z</published>
    <updated>2019-10-31T09:29:11.578Z</updated>
    
    <content type="html"><![CDATA[<h2 id="教程资料"><a href="#教程资料" class="headerlink" title="教程资料"></a>教程资料</h2><ul><li>简单操作：<a href="https://segmentfault.com/a/1190000016703769" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016703769</a></li><li>多项介绍：<a href="https://learnku.com/golang/t/33859" target="_blank" rel="noopener">https://learnku.com/golang/t/33859</a></li><li>官方教程：<a href="https://blog.golang.org/using-go-modules" target="_blank" rel="noopener">https://blog.golang.org/using-go-modules</a></li></ul><h2 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h2><h3 id="replace-使用http或https"><a href="#replace-使用http或https" class="headerlink" title="replace 使用http或https"></a>replace 使用http或https</h3><p>在使用go replace时，有2点注意：</p><ul><li>目标仓库不能带协议头，比如http、https，要从域名或者IP开始</li><li>版本号格式要符合语义格式化，测试版本是否符合规则：<a href="https://play.golang.org/p/S_Jz3-Uxh_T" target="_blank" rel="noopener">Go playground 样例代码</a></li></ul><p>直接修改 <code>go.mod</code> 文件格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replace github.com/hyperledger/fabric v1.4.1 =&gt; 192.168.9.251/hyperledger/fabric v1.4.1-alpha.11-yx</span><br></pre></td></tr></table></figure></p><p>或使用命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod edit -replace=github.com/hyperledger/fabric@v1.4.1=192.168.9.251/hyperledger/fabric@v1.4.1</span><br></pre></td></tr></table></figure></p><h3 id="Gitlab-仓库没开启https"><a href="#Gitlab-仓库没开启https" class="headerlink" title="Gitlab 仓库没开启https"></a>Gitlab 仓库没开启https</h3><p>go mod 默认使用 go get 下载依赖，而 go get 默认使用 https，如果 Gitlab 仓库没有启用 https，需要使用 <code>-insecure</code> 让go get走http。</p><p>问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GOPROXY=&quot;&quot; go get github.com/hyperledger/fabric@v1.4.1</span><br><span class="line">go: 192.168.9.251/hyperledger/fabric@v1.4.1-alpha.11-yx: unrecognized import path &quot;192.168.9.251/hyperledger/fabric&quot; (https fetch: Get https://192.168.9.251/hyperledger/fabric?go-get=1: dial tcp 192.168.9.251:443: connect: connection refused)</span><br><span class="line">go: error loading module requirements</span><br></pre></td></tr></table></figure><p>方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GOPROXY=&quot;&quot; go get -insecure github.com/hyperledger/fabric@v1.4.1</span><br></pre></td></tr></table></figure><blockquote><p>注解：遇到问题时，使用 <code>go get -v</code> 可以看到更多信息，有助分析问题。</p></blockquote><h3 id="Go-Modules-代理"><a href="#Go-Modules-代理" class="headerlink" title="Go Modules 代理"></a>Go Modules 代理</h3><p>由于某些网络原因，国内下载 Github 等处的依赖，不够流程，需要设置代理，不同版本的设置如下：</p><ul><li><p>go1.12</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ export GOPROXY=https://goproxy.cn</span><br></pre></td></tr></table></figure></li><li><p>go1.13</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ export GOPRIVATE=192.168.9.251</span><br><span class="line">$ export GOPROXY=https://goproxy.cn,direct</span><br></pre></td></tr></table></figure></li></ul><h3 id="私有仓库"><a href="#私有仓库" class="headerlink" title="私有仓库"></a>私有仓库</h3><p>如果仓库设置为私有，这要求用户必须登录才能访问仓库。</p><p>Go Modules 默认使用 go get 下载依赖，go get 利用 https 或者 http, 但下载过程没有设置用户名和密码的地方，下载依赖时，可能遇到一下错误：</p><ul><li>connection refused</li><li>unkown revision</li></ul><p>可以通过设置Github/Gitlab Access Token结果，通过token的方式，访问仓库，token的获取方式为，登录Gitlab仓库，进入以下页面：</p><p>Gitlab User Setting -&gt; Access Tokens</p><p>在此页面复制下顶端的 <code>Your New Personal Access Token</code>, 然后填写token名字和勾选下方的权限进行创建 Token。</p><p>然后执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global \</span><br><span class="line">url.<span class="string">"http://oauth2:<span class="variable">$&#123;your_access_token&#125;</span>@ip_address_or_domain"</span>.insteadOf \</span><br><span class="line"><span class="string">"http://ip_address_or_domain"</span></span><br></pre></td></tr></table></figure><p>后面再去 go get 的时候，就可顺利下载依赖。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;教程资料&quot;&gt;&lt;a href=&quot;#教程资料&quot; class=&quot;headerlink&quot; title=&quot;教程资料&quot;&gt;&lt;/a&gt;教程资料&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;简单操作：&lt;a href=&quot;https://segmentfault.com/a/119000001670376
      
    
    </summary>
    
    
    
      <category term="Go" scheme="http://lessisbetter.site/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>fabric-sdk-go 配置项分类</title>
    <link href="http://lessisbetter.site/2019/10/31/fabric-sdk-go-configure-graph/"/>
    <id>http://lessisbetter.site/2019/10/31/fabric-sdk-go-configure-graph/</id>
    <published>2019-10-31T03:41:49.000Z</published>
    <updated>2019-10-31T03:46:04.725Z</updated>
    
    <content type="html"><![CDATA[<p>fabric-sdk-go 配置文件示例 <a href="https://github.com/hyperledger/fabric-sdk-go/blob/master/test/fixtures/config/config_e2e.yaml" target="_blank" rel="noopener">config_e2e</a>。</p><p>配置项内容可按以下分类：</p><p><img src="http://img.lessisbetter.site/2019-10-fabric-sdk-go-conf-yaml.png" alt="fabric-sdk-go configure"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;fabric-sdk-go 配置文件示例 &lt;a href=&quot;https://github.com/hyperledger/fabric-sdk-go/blob/master/test/fixtures/config/config_e2e.yaml&quot; target=&quot;_bla
      
    
    </summary>
    
    
    
      <category term="区块链" scheme="http://lessisbetter.site/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Fabric" scheme="http://lessisbetter.site/tags/Fabric/"/>
    
  </entry>
  
  <entry>
    <title>Fabric 1.4源码解读 4：交易背书流程解读</title>
    <link href="http://lessisbetter.site/2019/10/29/fabric-transaction-endorser-source/"/>
    <id>http://lessisbetter.site/2019/10/29/fabric-transaction-endorser-source/</id>
    <published>2019-10-29T10:05:43.000Z</published>
    <updated>2019-12-26T06:23:23.715Z</updated>
    
    <content type="html"><![CDATA[<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>在 <a href="http://lessisbetter.site/2019/07/17/fabric-concepts-notes/">快速入门Fabric核心概念和框架</a> 这篇文章中，介绍了 Fabric 的很多概念，其中也包含了交易、提案（Proposal）和链码。同时也介绍了，交易的执行流程，链码的调用流程等。</p><p>本文聚焦介绍交易流程的一个环节：交易背书，以下的3幅图，在<a href="http://lessisbetter.site/2019/07/17/fabric-concepts-notes/">快速入门Fabric核心概念和框架</a> 中都有介绍，有必要的话，去读一下上下文信息。</p><h3 id="交易宏观流程"><a href="#交易宏观流程" class="headerlink" title="交易宏观流程"></a>交易宏观流程</h3><p><img src="http://img.lessisbetter.site/2019-07-tx-flow.png" alt=""></p><p>交易的详细流程请阅读 <a href="http://lessisbetter.site/2019/07/17/fabric-concepts-notes/#%E4%BA%A4%E6%98%93">交易流程</a>，了解交易流程的几大环节。</p><h3 id="链码调用流程"><a href="#链码调用流程" class="headerlink" title="链码调用流程"></a>链码调用流程</h3><p><img src="http://img.lessisbetter.site/2019-07-fabric-invoke-chaincode.png" alt=""></p><p>上图，展示了客户端、Peer，以及链码容器 3大主体在交易流程中的背书过程，请关注一下Peer中的 Handler，它负责和链码容器交互。</p><h3 id="提案背书流程"><a href="#提案背书流程" class="headerlink" title="提案背书流程"></a>提案背书流程</h3><p><img src="http://img.lessisbetter.site/2019-07-chaincode_swimlane.png" alt=""></p><p>上图，从接近源码的层面，展示了交易背书过程。其中Fabric、Shim 是 Peer 中的模块，ChainCode 代表链码容器，Endorser Chaincode 代表 Peer 对交易提案和模拟执行结果进行背书。</p><p>如果了解过Chaincode，你会知道 Shim 是链码容器和 Peer 交互所依赖的模块。</p><p>最后推荐一份保华大佬整理的 <a href="https://github.com/yeasy/hyperledger_code_fabric/blob/master/process/peer_endorse.md" target="_blank" rel="noopener">Peer 提案背书过程</a>，是读源码前，必读的资料。虽然精简，但把重要的核心流程都串联起来了。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="Proposal定义"><a href="#Proposal定义" class="headerlink" title="Proposal定义"></a>Proposal定义</h3><p>客户端发送被背书节点的是 <code>SignedProposal</code> ，它包含了签名和Proposal，这是它在<code>proposal.proto</code>中的组成简介，：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SignedProposal</span><br><span class="line">|\_ Signature                                    (signature on the Proposal message by the creator specified in the header)</span><br><span class="line"> \_ Proposal</span><br><span class="line">    |\_ Header                                   (the header for this proposal)</span><br><span class="line">     \_ Payload                                  (the payload for this proposal)</span><br></pre></td></tr></table></figure><p><code>proposal.proto</code>这个文件还简要介绍了Client和背书节点之间通信的消息类型和过程。</p><h4 id="Proposal"><a href="#Proposal" class="headerlink" title="Proposal"></a>Proposal</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SignedProposal <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// The bytes of Proposal</span></span><br><span class="line">ProposalBytes []<span class="keyword">byte</span> <span class="string">`protobuf:"bytes,1,opt,name=proposal_bytes,json=proposalBytes,proto3" json:"proposal_bytes,omitempty"`</span></span><br><span class="line"><span class="comment">// Signaure over proposalBytes; this signature is to be verified against</span></span><br><span class="line"><span class="comment">// the creator identity contained in the header of the Proposal message</span></span><br><span class="line"><span class="comment">// marshaled as proposalBytes</span></span><br><span class="line">Signature            []<span class="keyword">byte</span>   <span class="string">`protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Proposal <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// The header of the proposal. It is the bytes of the Header</span></span><br><span class="line">Header []<span class="keyword">byte</span> <span class="string">`protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`</span></span><br><span class="line"><span class="comment">// The payload of the proposal as defined by the type in the proposal</span></span><br><span class="line"><span class="comment">// header.</span></span><br><span class="line">Payload []<span class="keyword">byte</span> <span class="string">`protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`</span></span><br><span class="line"><span class="comment">// Optional extensions to the proposal. Its content depends on the Header's</span></span><br><span class="line"><span class="comment">// type field.  For the type CHAINCODE, it might be the bytes of a</span></span><br><span class="line"><span class="comment">// ChaincodeAction message.</span></span><br><span class="line">Extension            []<span class="keyword">byte</span>   <span class="string">`protobuf:"bytes,3,opt,name=extension,proto3" json:"extension,omitempty"`</span></span><br><span class="line">XXX_NoUnkeyedLiteral <span class="keyword">struct</span>&#123;&#125; <span class="string">`json:"-"`</span></span><br><span class="line">XXX_unrecognized     []<span class="keyword">byte</span>   <span class="string">`json:"-"`</span></span><br><span class="line">XXX_sizecache        <span class="keyword">int32</span>    <span class="string">`json:"-"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Header <span class="keyword">struct</span> &#123;</span><br><span class="line">ChannelHeader        []<span class="keyword">byte</span>   <span class="string">`protobuf:"bytes,1,opt,name=channel_header,json=channelHeader,proto3" json:"channel_header,omitempty"`</span></span><br><span class="line">SignatureHeader      []<span class="keyword">byte</span>   <span class="string">`protobuf:"bytes,2,opt,name=signature_header,json=signatureHeader,proto3" json:"signature_header,omitempty"`</span></span><br><span class="line">XXX_NoUnkeyedLiteral <span class="keyword">struct</span>&#123;&#125; <span class="string">`json:"-"`</span></span><br><span class="line">XXX_unrecognized     []<span class="keyword">byte</span>   <span class="string">`json:"-"`</span></span><br><span class="line">XXX_sizecache        <span class="keyword">int32</span>    <span class="string">`json:"-"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Header is a generic replay prevention and identity message to include in a signed payload</span></span><br><span class="line"><span class="keyword">type</span> ChannelHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">Type <span class="keyword">int32</span> <span class="string">`protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`</span></span><br><span class="line"><span class="comment">// Version indicates message protocol version</span></span><br><span class="line">Version <span class="keyword">int32</span> <span class="string">`protobuf:"varint,2,opt,name=version,proto3" json:"version,omitempty"`</span></span><br><span class="line"><span class="comment">// Timestamp is the local time when the message was created</span></span><br><span class="line"><span class="comment">// by the sender</span></span><br><span class="line">Timestamp *timestamp.Timestamp <span class="string">`protobuf:"bytes,3,opt,name=timestamp,proto3" json:"timestamp,omitempty"`</span></span><br><span class="line"><span class="comment">// Identifier of the channel this message is bound for</span></span><br><span class="line">ChannelId <span class="keyword">string</span> <span class="string">`protobuf:"bytes,4,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty"`</span></span><br><span class="line"><span class="comment">// An unique identifier that is used end-to-end.</span></span><br><span class="line"><span class="comment">//  -  set by higher layers such as end user or SDK</span></span><br><span class="line"><span class="comment">//  -  passed to the endorser (which will check for uniqueness)</span></span><br><span class="line"><span class="comment">//  -  as the header is passed along unchanged, it will be</span></span><br><span class="line"><span class="comment">//     be retrieved by the committer (uniqueness check here as well)</span></span><br><span class="line"><span class="comment">//  -  to be stored in the ledger</span></span><br><span class="line">TxId <span class="keyword">string</span> <span class="string">`protobuf:"bytes,5,opt,name=tx_id,json=txId,proto3" json:"tx_id,omitempty"`</span></span><br><span class="line"><span class="comment">// The epoch in which this header was generated, where epoch is defined based on block height</span></span><br><span class="line"><span class="comment">// Epoch in which the response has been generated. This field identifies a</span></span><br><span class="line"><span class="comment">// logical window of time. A proposal response is accepted by a peer only if</span></span><br><span class="line"><span class="comment">// two conditions hold:</span></span><br><span class="line"><span class="comment">// 1. the epoch specified in the message is the current epoch</span></span><br><span class="line"><span class="comment">// 2. this message has been only seen once during this epoch (i.e. it hasn't</span></span><br><span class="line"><span class="comment">//    been replayed)</span></span><br><span class="line">Epoch <span class="keyword">uint64</span> <span class="string">`protobuf:"varint,6,opt,name=epoch,proto3" json:"epoch,omitempty"`</span></span><br><span class="line"><span class="comment">// Extension that may be attached based on the header type</span></span><br><span class="line">Extension []<span class="keyword">byte</span> <span class="string">`protobuf:"bytes,7,opt,name=extension,proto3" json:"extension,omitempty"`</span></span><br><span class="line"><span class="comment">// If mutual TLS is employed, this represents</span></span><br><span class="line"><span class="comment">// the hash of the client's TLS certificate</span></span><br><span class="line">TlsCertHash          []<span class="keyword">byte</span>   <span class="string">`protobuf:"bytes,8,opt,name=tls_cert_hash,json=tlsCertHash,proto3" json:"tls_cert_hash,omitempty"`</span></span><br><span class="line">XXX_NoUnkeyedLiteral <span class="keyword">struct</span>&#123;&#125; <span class="string">`json:"-"`</span></span><br><span class="line">XXX_unrecognized     []<span class="keyword">byte</span>   <span class="string">`json:"-"`</span></span><br><span class="line">XXX_sizecache        <span class="keyword">int32</span>    <span class="string">`json:"-"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SignatureHeader <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Creator of the message, a marshaled msp.SerializedIdentity</span></span><br><span class="line">Creator []<span class="keyword">byte</span> <span class="string">`protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`</span></span><br><span class="line"><span class="comment">// Arbitrary number that may only be used once. Can be used to detect replay attacks.</span></span><br><span class="line">Nonce                []<span class="keyword">byte</span>   <span class="string">`protobuf:"bytes,2,opt,name=nonce,proto3" json:"nonce,omitempty"`</span></span><br><span class="line">XXX_NoUnkeyedLiteral <span class="keyword">struct</span>&#123;&#125; <span class="string">`json:"-"`</span></span><br><span class="line">XXX_unrecognized     []<span class="keyword">byte</span>   <span class="string">`json:"-"`</span></span><br><span class="line">XXX_sizecache        <span class="keyword">int32</span>    <span class="string">`json:"-"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="gRPC定义"><a href="#gRPC定义" class="headerlink" title="gRPC定义"></a>gRPC定义</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EndorserClient is the client API for Endorser service.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.</span></span><br><span class="line"><span class="keyword">type</span> EndorserClient <span class="keyword">interface</span> &#123;</span><br><span class="line">ProcessProposal(ctx context.Context, in *SignedProposal, opts ...grpc.CallOption) (*ProposalResponse, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// EndorserServer is the server API for Endorser service.</span></span><br><span class="line"><span class="keyword">type</span> EndorserServer <span class="keyword">interface</span> &#123;</span><br><span class="line">ProcessProposal(context.Context, *SignedProposal) (*ProposalResponse, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SDK发送Proposal"><a href="#SDK发送Proposal" class="headerlink" title="SDK发送Proposal"></a>SDK发送Proposal</h3><h3 id="Peer接收Proposal"><a href="#Peer接收Proposal" class="headerlink" title="Peer接收Proposal"></a>Peer接收Proposal</h3><h3 id="Peer处理Proposal主流程"><a href="#Peer处理Proposal主流程" class="headerlink" title="Peer处理Proposal主流程"></a>Peer处理Proposal主流程</h3><p>主要是把背书节点的背书工作聚合一下：</p><ol><li>Proposal预处理</li><li>获取交易执行模拟器，模拟执行Proposal</li><li>如果模拟执行成功，调用ESCC对Proposal和结果进行背书，如果模拟执行失败直接返回背书失败的响应</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Endorser)</span> <span class="title">ProcessProposal</span><span class="params">(ctx context.Context, signedProp *pb.SignedProposal)</span> <span class="params">(*pb.ProposalResponse, error)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 0 -- check and validate</span></span><br><span class="line"><span class="comment">// 这里有相当多的工作量</span></span><br><span class="line">vr, err := e.preProcess(signedProp)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">resp := vr.resp</span><br><span class="line"><span class="keyword">return</span> resp, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">prop, hdrExt, chainID, txid := vr.prop, vr.hdrExt, vr.chainID, vr.txid</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定账本模拟器</span></span><br><span class="line"><span class="comment">// obtaining once the tx simulator for this proposal. This will be nil</span></span><br><span class="line"><span class="comment">// for chainless proposals</span></span><br><span class="line"><span class="comment">// Also obtain a history query executor for history queries, since tx simulator does not cover history</span></span><br><span class="line"><span class="keyword">var</span> txsim ledger.TxSimulator</span><br><span class="line"><span class="keyword">var</span> historyQueryExecutor ledger.HistoryQueryExecutor</span><br><span class="line"><span class="keyword">if</span> acquireTxSimulator(chainID, vr.hdrExt.ChaincodeId) &#123;</span><br><span class="line"><span class="keyword">if</span> txsim, err = e.s.GetTxSimulator(chainID, txid); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;pb.ProposalResponse&#123;Response: &amp;pb.Response&#123;Status: <span class="number">500</span>, Message: err.Error()&#125;&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">defer</span> txsim.Done()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> historyQueryExecutor, err = e.s.GetHistoryQueryExecutor(chainID); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;pb.ProposalResponse&#123;Response: &amp;pb.Response&#123;Status: <span class="number">500</span>, Message: err.Error()&#125;&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">txParams := &amp;ccprovider.TransactionParams&#123;</span><br><span class="line">ChannelID:            chainID,</span><br><span class="line">TxID:                 txid,</span><br><span class="line">SignedProp:           signedProp,</span><br><span class="line">Proposal:             prop,</span><br><span class="line">TXSimulator:          txsim,</span><br><span class="line">HistoryQueryExecutor: historyQueryExecutor,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// this could be a request to a chainless SysCC</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟执行交易，失败则返回背书失败的响应</span></span><br><span class="line"><span class="comment">// 1 -- simulate</span></span><br><span class="line">cd, res, simulationResult, ccevent, err := e.SimulateProposal(txParams, hdrExt.ChaincodeId)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;pb.ProposalResponse&#123;Response: &amp;pb.Response&#123;Status: <span class="number">500</span>, Message: err.Error()&#125;&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> res != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> res.Status &gt;= shim.ERROR &#123;</span><br><span class="line">endorserLogger.Errorf(<span class="string">"[%s][%s] simulateProposal() resulted in chaincode %s response status %d for txid: %s"</span>, chainID, shorttxid(txid), hdrExt.ChaincodeId, res.Status, txid)</span><br><span class="line"><span class="keyword">var</span> cceventBytes []<span class="keyword">byte</span></span><br><span class="line"><span class="keyword">if</span> ccevent != <span class="literal">nil</span> &#123;</span><br><span class="line">cceventBytes, err = putils.GetBytesChaincodeEvent(ccevent)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">"failed to marshal event bytes"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pResp, err := putils.CreateProposalResponseFailure(prop.Header, prop.Payload, res, simulationResult, cceventBytes, hdrExt.ChaincodeId, hdrExt.PayloadVisibility)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;pb.ProposalResponse&#123;Response: &amp;pb.Response&#123;Status: <span class="number">500</span>, Message: err.Error()&#125;&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pResp, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对模拟执行的结果进行签名背书</span></span><br><span class="line"><span class="comment">// 2 -- endorse and get a marshalled ProposalResponse message</span></span><br><span class="line"><span class="keyword">var</span> pResp *pb.ProposalResponse</span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO till we implement global ESCC, CSCC for system chaincodes</span></span><br><span class="line"><span class="comment">// chainless proposals (such as CSCC) don't have to be endorsed</span></span><br><span class="line"><span class="keyword">if</span> chainID == <span class="string">""</span> &#123;</span><br><span class="line">pResp = &amp;pb.ProposalResponse&#123;Response: res&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Note: To endorseProposal(), we pass the released txsim. Hence, an error would occur if we try to use this txsim</span></span><br><span class="line">pResp, err = e.endorseProposal(ctx, chainID, txid, signedProp, prop, res, simulationResult, ccevent, hdrExt.PayloadVisibility, hdrExt.ChaincodeId, txsim, cd)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set the proposal response payload - it</span></span><br><span class="line"><span class="comment">// contains the "return value" from the</span></span><br><span class="line"><span class="comment">// chaincode invocation</span></span><br><span class="line">pResp.Response = res</span><br><span class="line"></span><br><span class="line"><span class="comment">// total failed proposals = ProposalsReceived-SuccessfulProposals</span></span><br><span class="line">e.Metrics.SuccessfulProposals.Add(<span class="number">1</span>)</span><br><span class="line">success = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pResp, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="preProcess-检查和获取信息"><a href="#preProcess-检查和获取信息" class="headerlink" title="preProcess 检查和获取信息"></a>preProcess 检查和获取信息</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// preProcess checks the tx proposal headers, uniqueness and ACL</span></span><br><span class="line"><span class="comment">// 检查proposal、ACL</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Endorser)</span> <span class="title">preProcess</span><span class="params">(signedProp *pb.SignedProposal)</span> <span class="params">(*validateResult, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// 包含proposal、header、chainID、txid等信息</span></span><br><span class="line">vr := &amp;validateResult&#123;&#125;</span><br><span class="line"><span class="comment">// at first, we check whether the message is valid</span></span><br><span class="line"><span class="comment">// 检查proposal，并获取各种需要的信息</span></span><br><span class="line">prop, hdr, hdrExt, err := validation.ValidateProposalMessage(signedProp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">e.Metrics.ProposalValidationFailed.Add(<span class="number">1</span>)</span><br><span class="line">vr.resp = &amp;pb.ProposalResponse&#123;Response: &amp;pb.Response&#123;Status: <span class="number">500</span>, Message: err.Error()&#125;&#125;</span><br><span class="line"><span class="keyword">return</span> vr, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取Header中的2个Header</span></span><br><span class="line">chdr, err := putils.UnmarshalChannelHeader(hdr.ChannelHeader)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">vr.resp = &amp;pb.ProposalResponse&#123;Response: &amp;pb.Response&#123;Status: <span class="number">500</span>, Message: err.Error()&#125;&#125;</span><br><span class="line"><span class="keyword">return</span> vr, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shdr, err := putils.GetSignatureHeader(hdr.SignatureHeader)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">vr.resp = &amp;pb.ProposalResponse&#123;Response: &amp;pb.Response&#123;Status: <span class="number">500</span>, Message: err.Error()&#125;&#125;</span><br><span class="line"><span class="keyword">return</span> vr, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否调用了不可外部（用户）的系统链码</span></span><br><span class="line"><span class="comment">// 先找到链码实例，然后调用链码的方法判断本身是否可调用</span></span><br><span class="line"><span class="comment">// block invocations to security-sensitive system chaincodes</span></span><br><span class="line"><span class="keyword">if</span> e.s.IsSysCCAndNotInvokableExternal(hdrExt.ChaincodeId.Name) &#123;</span><br><span class="line">endorserLogger.Errorf(<span class="string">"Error: an attempt was made by %#v to invoke system chaincode %s"</span>, shdr.Creator, hdrExt.ChaincodeId.Name)</span><br><span class="line">err = errors.Errorf(<span class="string">"chaincode %s cannot be invoked through a proposal"</span>, hdrExt.ChaincodeId.Name)</span><br><span class="line">vr.resp = &amp;pb.ProposalResponse&#123;Response: &amp;pb.Response&#123;Status: <span class="number">500</span>, Message: err.Error()&#125;&#125;</span><br><span class="line"><span class="keyword">return</span> vr, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">chainID := chdr.ChannelId</span><br><span class="line">txid := chdr.TxId</span><br><span class="line">endorserLogger.Debugf(<span class="string">"[%s][%s] processing txid: %s"</span>, chainID, shorttxid(txid), txid)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> chainID != <span class="string">""</span> &#123;</span><br><span class="line"><span class="comment">// labels that provide context for failure metrics</span></span><br><span class="line">meterLabels := []<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"channel"</span>, chainID,</span><br><span class="line"><span class="string">"chaincode"</span>, hdrExt.ChaincodeId.Name + <span class="string">":"</span> + hdrExt.ChaincodeId.Version,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查交易是否已上链</span></span><br><span class="line"><span class="comment">// Here we handle uniqueness check and ACLs for proposals targeting a chain</span></span><br><span class="line"><span class="comment">// Notice that ValidateProposalMessage has already verified that TxID is computed properly</span></span><br><span class="line"><span class="keyword">if</span> _, err = e.s.GetTransactionByID(chainID, txid); err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// increment failure due to duplicate transactions. Useful for catching replay attacks in</span></span><br><span class="line"><span class="comment">// addition to benign retries</span></span><br><span class="line">e.Metrics.DuplicateTxsFailure.With(meterLabels...).Add(<span class="number">1</span>)</span><br><span class="line">err = errors.Errorf(<span class="string">"duplicate transaction found [%s]. Creator [%x]"</span>, txid, shdr.Creator)</span><br><span class="line">vr.resp = &amp;pb.ProposalResponse&#123;Response: &amp;pb.Response&#123;Status: <span class="number">500</span>, Message: err.Error()&#125;&#125;</span><br><span class="line"><span class="keyword">return</span> vr, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户链码检查ACL</span></span><br><span class="line"><span class="comment">// check ACL only for application chaincodes; ACLs</span></span><br><span class="line"><span class="comment">// for system chaincodes are checked elsewhere</span></span><br><span class="line"><span class="keyword">if</span> !e.s.IsSysCC(hdrExt.ChaincodeId.Name) &#123;</span><br><span class="line"><span class="comment">// check that the proposal complies with the Channel's writers</span></span><br><span class="line"><span class="keyword">if</span> err = e.s.CheckACL(signedProp, chdr, shdr, hdrExt); err != <span class="literal">nil</span> &#123;</span><br><span class="line">e.Metrics.ProposalACLCheckFailed.With(meterLabels...).Add(<span class="number">1</span>)</span><br><span class="line">vr.resp = &amp;pb.ProposalResponse&#123;Response: &amp;pb.Response&#123;Status: <span class="number">500</span>, Message: err.Error()&#125;&#125;</span><br><span class="line"><span class="keyword">return</span> vr, err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// chainless proposals do not/cannot affect ledger and cannot be submitted as transactions</span></span><br><span class="line"><span class="comment">// ignore uniqueness checks; also, chainless proposals are not validated using the policies</span></span><br><span class="line"><span class="comment">// of the chain since by definition there is no chain; they are validated against the local</span></span><br><span class="line"><span class="comment">// MSP of the peer instead by the call to ValidateProposalMessage above</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存提取的各信息</span></span><br><span class="line">vr.prop, vr.hdrExt, vr.chainID, vr.txid = prop, hdrExt, chainID, txid</span><br><span class="line"><span class="keyword">return</span> vr, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ValidateProposalMessage checks the validity of a SignedProposal message</span></span><br><span class="line"><span class="comment">// this function returns Header and ChaincodeHeaderExtension messages since they</span></span><br><span class="line"><span class="comment">// have been unmarshalled and validated</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValidateProposalMessage</span><span class="params">(signedProp *pb.SignedProposal)</span> <span class="params">(*pb.Proposal, *common.Header, *pb.ChaincodeHeaderExtension, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> signedProp == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, errors.New(<span class="string">"nil arguments"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">putilsLogger.Debugf(<span class="string">"ValidateProposalMessage starts for signed proposal %p"</span>, signedProp)</span><br><span class="line"></span><br><span class="line"><span class="comment">// extract the Proposal message from signedProp</span></span><br><span class="line">prop, err := utils.GetProposal(signedProp.ProposalBytes)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1) look at the ProposalHeader</span></span><br><span class="line">hdr, err := utils.GetHeader(prop.Header)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// validate the header</span></span><br><span class="line">chdr, shdr, err := validateCommonHeader(hdr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从SignatureHeader交易客户端的签名</span></span><br><span class="line"><span class="comment">// validate the signature</span></span><br><span class="line">err = checkSignatureFromCreator(shdr.Creator, signedProp.Signature, signedProp.ProposalBytes, chdr.ChannelId)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// log the exact message on the peer but return a generic error message to</span></span><br><span class="line"><span class="comment">// avoid malicious users scanning for channels</span></span><br><span class="line">putilsLogger.Warningf(<span class="string">"channel [%s]: %s"</span>, chdr.ChannelId, err)</span><br><span class="line">sId := &amp;msp.SerializedIdentity&#123;&#125;</span><br><span class="line">err := proto.Unmarshal(shdr.Creator, sId)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// log the error here as well but still only return the generic error</span></span><br><span class="line">err = errors.Wrap(err, <span class="string">"could not deserialize a SerializedIdentity"</span>)</span><br><span class="line">putilsLogger.Warningf(<span class="string">"channel [%s]: %s"</span>, chdr.ChannelId, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, errors.Errorf(<span class="string">"access denied: channel [%s] creator org [%s]"</span>, chdr.ChannelId, sId.Mspid)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查txid的计算是否符合规则</span></span><br><span class="line"><span class="comment">// Verify that the transaction ID has been computed properly.</span></span><br><span class="line"><span class="comment">// This check is needed to ensure that the lookup into the ledger</span></span><br><span class="line"><span class="comment">// for the same TxID catches duplicates.</span></span><br><span class="line">err = utils.CheckTxID(</span><br><span class="line">chdr.TxId,</span><br><span class="line">shdr.Nonce,</span><br><span class="line">shdr.Creator)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依据不同的proposal类型对proposal分别进行检查</span></span><br><span class="line"><span class="comment">// continue the validation in a way that depends on the type specified in the header</span></span><br><span class="line"><span class="keyword">switch</span> common.HeaderType(chdr.Type) &#123;</span><br><span class="line"><span class="keyword">case</span> common.HeaderType_CONFIG:</span><br><span class="line"><span class="comment">//which the types are different the validation is the same</span></span><br><span class="line"><span class="comment">//viz, validate a proposal to a chaincode. If we need other</span></span><br><span class="line"><span class="comment">//special validation for confguration, we would have to implement</span></span><br><span class="line"><span class="comment">//special validation</span></span><br><span class="line"><span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> common.HeaderType_ENDORSER_TRANSACTION:</span><br><span class="line"><span class="comment">// 主要是提取ChaincodeHeaderExtension</span></span><br><span class="line"><span class="comment">// validation of the proposal message knowing it's of type CHAINCODE</span></span><br><span class="line">chaincodeHdrExt, err := validateChaincodeProposalMessage(prop, hdr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> prop, hdr, chaincodeHdrExt, err</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">//NOTE : we proably need a case</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, errors.Errorf(<span class="string">"unsupported proposal type %d"</span>, common.HeaderType(chdr.Type))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="背书节点模拟执行交易"><a href="#背书节点模拟执行交易" class="headerlink" title="背书节点模拟执行交易"></a>背书节点模拟执行交易</h3><h4 id="获取模拟器"><a href="#获取模拟器" class="headerlink" title="获取模拟器"></a>获取模拟器</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Support contains functions that the endorser requires to execute its tasks</span></span><br><span class="line"><span class="keyword">type</span> Support <span class="keyword">interface</span> &#123;</span><br><span class="line">crypto.SignerSupport</span><br><span class="line"><span class="comment">// IsSysCCAndNotInvokableExternal returns true if the supplied chaincode is</span></span><br><span class="line"><span class="comment">// ia system chaincode and it NOT invokable</span></span><br><span class="line">IsSysCCAndNotInvokableExternal(name <span class="keyword">string</span>) <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// GetTxSimulator returns the transaction simulator for the specified ledger</span></span><br><span class="line"><span class="comment">// a client may obtain more than one such simulator; they are made unique</span></span><br><span class="line"><span class="comment">// by way of the supplied txid</span></span><br><span class="line">GetTxSimulator(ledgername <span class="keyword">string</span>, txid <span class="keyword">string</span>) (ledger.TxSimulator, error)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetTxSimulator returns the transaction simulator for the specified ledger</span></span><br><span class="line"><span class="comment">// a client may obtain more than one such simulator; they are made unique</span></span><br><span class="line"><span class="comment">// by way of the supplied txid</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SupportImpl)</span> <span class="title">GetTxSimulator</span><span class="params">(ledgername <span class="keyword">string</span>, txid <span class="keyword">string</span>)</span> <span class="params">(ledger.TxSimulator, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// 使用账本和txid创建模拟器，每个交易有单独的模拟器</span></span><br><span class="line">lgr := s.Peer.GetLedger(ledgername)</span><br><span class="line"><span class="keyword">if</span> lgr == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.Errorf(<span class="string">"Channel does not exist: %s"</span>, ledgername)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> lgr.NewTxSimulator(txid)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewTxSimulator returns new `ledger.TxSimulator`</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *kvLedger)</span> <span class="title">NewTxSimulator</span><span class="params">(txid <span class="keyword">string</span>)</span> <span class="params">(ledger.TxSimulator, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> l.txtmgmt.NewTxSimulator(txid)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewTxSimulator implements method in interface `txmgmt.TxMgr`</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(txmgr *LockBasedTxMgr)</span> <span class="title">NewTxSimulator</span><span class="params">(txid <span class="keyword">string</span>)</span> <span class="params">(ledger.TxSimulator, error)</span></span> &#123;</span><br><span class="line">logger.Debugf(<span class="string">"constructing new tx simulator"</span>)</span><br><span class="line">s, err := newLockBasedTxSimulator(txmgr, txid)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">txmgr.commitRWLock.RLock()</span><br><span class="line"><span class="keyword">return</span> s, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 就2项重要的：查询执行器、读写集构建器</span></span><br><span class="line"><span class="comment">// LockBasedTxSimulator is a transaction simulator used in `LockBasedTxMgr`</span></span><br><span class="line"><span class="keyword">type</span> lockBasedTxSimulator <span class="keyword">struct</span> &#123;</span><br><span class="line">lockBasedQueryExecutor</span><br><span class="line">rwsetBuilder              *rwsetutil.RWSetBuilder</span><br><span class="line">writePerformed            <span class="keyword">bool</span></span><br><span class="line">pvtdataQueriesPerformed   <span class="keyword">bool</span></span><br><span class="line">simulationResultsComputed <span class="keyword">bool</span></span><br><span class="line">paginatedQueriesPerformed <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newLockBasedTxSimulator</span><span class="params">(txmgr *LockBasedTxMgr, txid <span class="keyword">string</span>)</span> <span class="params">(*lockBasedTxSimulator, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建读写集构建器，能帮助构建读写集</span></span><br><span class="line">rwsetBuilder := rwsetutil.NewRWSetBuilder()</span><br><span class="line">helper := newQueryHelper(txmgr, rwsetBuilder)</span><br><span class="line">logger.Debugf(<span class="string">"constructing new tx simulator txid = [%s]"</span>, txid)</span><br><span class="line"><span class="keyword">return</span> &amp;lockBasedTxSimulator&#123;lockBasedQueryExecutor&#123;helper, txid&#125;, rwsetBuilder, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LockBasedQueryExecutor is a query executor used in `LockBasedTxMgr`</span></span><br><span class="line"><span class="comment">// "只读"，不包含写相关的操作</span></span><br><span class="line"><span class="keyword">type</span> lockBasedQueryExecutor <span class="keyword">struct</span> &#123;</span><br><span class="line">helper *queryHelper</span><br><span class="line">txid   <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模拟执行"><a href="#模拟执行" class="headerlink" title="模拟执行"></a>模拟执行</h4><h5 id="endorser部分"><a href="#endorser部分" class="headerlink" title="endorser部分"></a>endorser部分</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> acquireTxSimulator(chainID, vr.hdrExt.ChaincodeId) &#123;</span><br><span class="line"><span class="keyword">if</span> txsim, err = e.s.GetTxSimulator(chainID, txid); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;pb.ProposalResponse&#123;Response: &amp;pb.Response&#123;Status: <span class="number">500</span>, Message: err.Error()&#125;&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> txsim.Done()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 历史查询器</span></span><br><span class="line"><span class="keyword">if</span> historyQueryExecutor, err = e.s.GetHistoryQueryExecutor(chainID); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;pb.ProposalResponse&#123;Response: &amp;pb.Response&#123;Status: <span class="number">500</span>, Message: err.Error()&#125;&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">txParams := &amp;ccprovider.TransactionParams&#123;</span><br><span class="line">ChannelID:            chainID,</span><br><span class="line">TxID:                 txid,</span><br><span class="line">SignedProp:           signedProp,</span><br><span class="line">Proposal:             prop,</span><br><span class="line">TXSimulator:          txsim,<span class="comment">// 模拟器在此</span></span><br><span class="line">HistoryQueryExecutor: historyQueryExecutor,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// this could be a request to a chainless SysCC</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> if the proposal has an extension, it will be of type ChaincodeAction;</span></span><br><span class="line"><span class="comment">//       if it's present it means that no simulation is to be performed because</span></span><br><span class="line"><span class="comment">//       we're trying to emulate a submitting peer. On the other hand, we need</span></span><br><span class="line"><span class="comment">//       to validate the supplied action before endorsing it</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟执行交易，失败则返回背书失败的响应</span></span><br><span class="line"><span class="comment">// 1 -- simulate</span></span><br><span class="line">cd, res, simulationResult, ccevent, err := e.SimulateProposal(txParams, hdrExt.ChaincodeId)</span><br></pre></td></tr></table></figure><p>调用chaincode模块模拟执行交易，获取交易执行的公开和私密数据读写集，以及交易执行产生的事件，并把结果返回给上层进行背书。</p><p>其中还包含了私密数据的处理，会把它取出来，然后通过Gossip传播给在私密数据中的Peer节点。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SimulateProposal simulates the proposal by calling the chaincode</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Endorser)</span> <span class="title">SimulateProposal</span><span class="params">(txParams *ccprovider.TransactionParams, cid *pb.ChaincodeID)</span> <span class="params">(ccprovider.ChaincodeDefinition, *pb.Response, []<span class="keyword">byte</span>, *pb.ChaincodeEvent, error)</span></span> &#123;</span><br><span class="line">endorserLogger.Debugf(<span class="string">"[%s][%s] Entry chaincode: %s"</span>, txParams.ChannelID, shorttxid(txParams.TxID), cid)</span><br><span class="line"><span class="keyword">defer</span> endorserLogger.Debugf(<span class="string">"[%s][%s] Exit"</span>, txParams.ChannelID, shorttxid(txParams.TxID))</span><br><span class="line"><span class="comment">// we do expect the payload to be a ChaincodeInvocationSpec</span></span><br><span class="line"><span class="comment">// if we are supporting other payloads in future, this be glaringly point</span></span><br><span class="line"><span class="comment">// as something that should change</span></span><br><span class="line"><span class="comment">// 根据Proposal生成Invoke需要的信息</span></span><br><span class="line">cis, err := putils.GetChaincodeInvocationSpec(txParams.Proposal)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链码的元数据</span></span><br><span class="line"><span class="keyword">var</span> cdLedger ccprovider.ChaincodeDefinition</span><br><span class="line"><span class="keyword">var</span> version <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置version</span></span><br><span class="line"><span class="keyword">if</span> !e.s.IsSysCC(cid.Name) &#123;</span><br><span class="line"><span class="comment">// 根据要调用的链码名称，从lscc获取链码的元数据</span></span><br><span class="line">cdLedger, err = e.s.GetChaincodeDefinition(cid.Name, txParams.TXSimulator)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, errors.WithMessage(err, fmt.Sprintf(<span class="string">"make sure the chaincode %s has been successfully instantiated and try again"</span>, cid.Name))</span><br><span class="line">&#125;</span><br><span class="line">version = cdLedger.CCVersion()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际被打桩了，无实现</span></span><br><span class="line">err = e.s.CheckInstantiationPolicy(cid.Name, version, cdLedger)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// scc版本是固定的"latest"</span></span><br><span class="line">version = util.GetSysCCVersion()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---3. execute the proposal and get simulation results</span></span><br><span class="line"><span class="keyword">var</span> simResult *ledger.TxSimulationResults</span><br><span class="line"><span class="keyword">var</span> pubSimResBytes []<span class="keyword">byte</span></span><br><span class="line"><span class="keyword">var</span> res *pb.Response</span><br><span class="line"><span class="keyword">var</span> ccevent *pb.ChaincodeEvent</span><br><span class="line"><span class="comment">// 模拟执行，执行结果保存在模拟器</span></span><br><span class="line">res, ccevent, err = e.callChaincode(txParams, version, cis.ChaincodeSpec.Input, cid)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">endorserLogger.Errorf(<span class="string">"[%s][%s] failed to invoke chaincode %s, error: %+v"</span>, txParams.ChannelID, shorttxid(txParams.TxID), cid, err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> txParams.TXSimulator != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 通过模拟器获取模拟执行结果，包含公开和私密数据2份读写集</span></span><br><span class="line"><span class="keyword">if</span> simResult, err = txParams.TXSimulator.GetTxSimulationResults(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">txParams.TXSimulator.Done()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存在私密数据</span></span><br><span class="line"><span class="keyword">if</span> simResult.PvtSimulationResults != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> cid.Name == <span class="string">"lscc"</span> &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> remove once we can store collection configuration outside of LSCC</span></span><br><span class="line">txParams.TXSimulator.Done()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, errors.New(<span class="string">"Private data is forbidden to be used in instantiate"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取要通过Gossip传播的私密数据</span></span><br><span class="line">pvtDataWithConfig, err := e.AssemblePvtRWSet(simResult.PvtSimulationResults, txParams.TXSimulator)</span><br><span class="line"><span class="comment">// To read collection config need to read collection updates before</span></span><br><span class="line"><span class="comment">// releasing the lock, hence txParams.TXSimulator.Done()  moved down here</span></span><br><span class="line">txParams.TXSimulator.Done()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, errors.WithMessage(err, <span class="string">"failed to obtain collections config"</span>)</span><br><span class="line">&#125;</span><br><span class="line">endorsedAt, err := e.s.GetLedgerHeight(txParams.ChannelID)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, errors.WithMessage(err, fmt.Sprint(<span class="string">"failed to obtain ledger height for channel"</span>, txParams.ChannelID))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Add ledger height at which transaction was endorsed,</span></span><br><span class="line"><span class="comment">// `endorsedAt` is obtained from the block storage and at times this could be 'endorsement Height + 1'.</span></span><br><span class="line"><span class="comment">// However, since we use this height only to select the configuration (3rd parameter in distributePrivateData) and</span></span><br><span class="line"><span class="comment">// manage transient store purge for orphaned private writesets (4th parameter in distributePrivateData), this works for now.</span></span><br><span class="line"><span class="comment">// Ideally, ledger should add support in the simulator as a first class function `GetHeight()`.</span></span><br><span class="line">pvtDataWithConfig.EndorsedAt = endorsedAt</span><br><span class="line"><span class="comment">// 把私密数据同通道id、交易id和区块高度发出去，代表私密数据所属的区块和交易</span></span><br><span class="line"><span class="keyword">if</span> err := e.distributePrivateData(txParams.ChannelID, txParams.TxID, pvtDataWithConfig, endorsedAt); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交易模拟完成，释放模拟器占用的资源</span></span><br><span class="line">txParams.TXSimulator.Done()</span><br><span class="line"><span class="comment">// 获取模拟执行的公开结果</span></span><br><span class="line"><span class="keyword">if</span> pubSimResBytes, err = simResult.GetPubSimulationBytes(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回链码元数据、模拟执行结果、交易执行产生的事件</span></span><br><span class="line"><span class="keyword">return</span> cdLedger, res, pubSimResBytes, ccevent, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>callChaincode</code> 调用chaincode模块执行链码。在前面的流程中，还没有区分系统链码SCC和用户链码UCC，SCC和UCC都会通过<code>Execute</code>函数被传递给chaincode模块而执行。</p><p>如果是调用<code>lscc</code>部署或升级UCC，会调用<code>ExecuteLegacyInit</code>执行链码容器的初始化。</p><p>最后返回链码模拟执行结果和事件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// call specified chaincode (system or user)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Endorser)</span> <span class="title">callChaincode</span><span class="params">(txParams *ccprovider.TransactionParams, version <span class="keyword">string</span>, input *pb.ChaincodeInput, cid *pb.ChaincodeID)</span> <span class="params">(*pb.Response, *pb.ChaincodeEvent, error)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// scc也在这执行</span></span><br><span class="line"><span class="comment">// is this a system chaincode</span></span><br><span class="line">res, ccevent, err = e.s.Execute(txParams, txParams.ChannelID, cid.Name, version, txParams.TxID, txParams.SignedProp, txParams.Proposal, input)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是调用lscc部署或升级链码，会走这段流程</span></span><br><span class="line"><span class="keyword">if</span> cid.Name == <span class="string">"lscc"</span> &amp;&amp; <span class="built_in">len</span>(input.Args) &gt;= <span class="number">3</span> &amp;&amp; (<span class="keyword">string</span>(input.Args[<span class="number">0</span>]) == <span class="string">"deploy"</span> || <span class="keyword">string</span>(input.Args[<span class="number">0</span>]) == <span class="string">"upgrade"</span>) &#123;</span><br><span class="line">userCDS, err := putils.GetChaincodeDeploymentSpec(input.Args[<span class="number">2</span>], e.PlatformRegistry)</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 进行链码容器初始化，最后会调用链码的Init的函数</span></span><br><span class="line">_, _, err = e.s.ExecuteLegacyInit(txParams, txParams.ChannelID, cds.ChaincodeSpec.ChaincodeId.Name, cds.ChaincodeSpec.ChaincodeId.Version, txParams.TxID, txParams.SignedProp, txParams.Proposal, cds)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ----- END -------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res, ccevent, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Support</code> 接口实际集合了众多背书节点需要的外部模块功能，比如链码、系统链码、ACL等。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Support contains functions that the endorser requires to execute its tasks</span></span><br><span class="line"><span class="keyword">type</span> Support <span class="keyword">interface</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// SupportImpl provides an implementation of the endorser.Support interface</span></span><br><span class="line"><span class="comment">// issuing calls to various static methods of the peer</span></span><br><span class="line"><span class="keyword">type</span> SupportImpl <span class="keyword">struct</span> &#123;</span><br><span class="line">*PluginEndorser</span><br><span class="line">crypto.SignerSupport</span><br><span class="line">Peer             peer.Operations</span><br><span class="line">PeerSupport      peer.Support</span><br><span class="line">ChaincodeSupport *chaincode.ChaincodeSupport</span><br><span class="line">SysCCProvider    *scc.Provider</span><br><span class="line">ACLProvider      aclmgmt.ACLProvider</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Execute</code>就是调用<code>ChaincodeSupport.Execute</code>实现的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Execute a proposal and return the chaincode response</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SupportImpl)</span> <span class="title">Execute</span><span class="params">(txParams *ccprovider.TransactionParams, cid, name, version, txid <span class="keyword">string</span>, signedProp *pb.SignedProposal, prop *pb.Proposal, input *pb.ChaincodeInput)</span> <span class="params">(*pb.Response, *pb.ChaincodeEvent, error)</span></span> &#123;</span><br><span class="line">cccid := &amp;ccprovider.CCContext&#123;</span><br><span class="line">Name:    name,</span><br><span class="line">Version: version,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// decorate the chaincode input</span></span><br><span class="line">decorators := library.InitRegistry(library.Config&#123;&#125;).Lookup(library.Decoration).([]decoration.Decorator)</span><br><span class="line">input.Decorations = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">byte</span>)</span><br><span class="line">input = decoration.Apply(prop, input, decorators...)</span><br><span class="line">txParams.ProposalDecorations = input.Decorations</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> s.ChaincodeSupport.Execute(txParams, cccid, input)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="chaincode部分"><a href="#chaincode部分" class="headerlink" title="chaincode部分"></a>chaincode部分</h5><p>通过上面的接口，跨入chaincode模块的大门。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *ChaincodeSupport)</span> <span class="title">Execute</span><span class="params">(txParams *ccprovider.TransactionParams, cccid *ccprovider.CCContext, input *pb.ChaincodeInput)</span> <span class="params">(*pb.Response, *pb.ChaincodeEvent, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// Invoke得到ChaincodeMessage</span></span><br><span class="line">resp, err := cs.Invoke(txParams, cccid, input)</span><br><span class="line"><span class="comment">// 根据ChaincodeMessage得到Response和事件</span></span><br><span class="line"><span class="keyword">return</span> processChaincodeExecutionResult(txParams.TxID, cccid.Name, resp, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *ChaincodeSupport)</span> <span class="title">Invoke</span><span class="params">(txParams *ccprovider.TransactionParams, cccid *ccprovider.CCContext, input *pb.ChaincodeInput)</span> <span class="params">(*pb.ChaincodeMessage, error)</span></span> &#123;</span><br><span class="line">h, err := cs.Launch(txParams.ChannelID, cccid.Name, cccid.Version, txParams.TXSimulator)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行调用链码的交易（和链码之间的消息为ChaincodeMessage_TRANSACTION）</span></span><br><span class="line">cctype := pb.ChaincodeMessage_TRANSACTION</span><br><span class="line"><span class="keyword">return</span> cs.execute(cctype, txParams, cccid, input, h)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="获取链码执行环境"><a href="#获取链码执行环境" class="headerlink" title="获取链码执行环境"></a>获取链码执行环境</h5><p><code>Launch</code> 可以获取链码执行环境，即用户链码容器，如果已实例化的链码，在当前背书节点上，链码容器未启动，则启动链码容器，<code>Launch</code>会返回一个跟链码容器交互Handler。</p><p>某个 Peer 上可以部署多个链码容器，Peer 为了和这些链码容器交互/通信，给每个链码容器都创建了一个 Handler，Handler 携带了 Peer 和链码容器交互的资源。</p><p><img src="http://img.lessisbetter.site/2019-10-peer-cc-handler.png" alt=""></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Launch starts executing chaincode if it is not already running. This method</span></span><br><span class="line"><span class="comment">// blocks until the peer side handler gets into ready state or encounters a fatal</span></span><br><span class="line"><span class="comment">// error. If the chaincode is already running, it simply returns.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *ChaincodeSupport)</span> <span class="title">Launch</span><span class="params">(chainID, chaincodeName, chaincodeVersion <span class="keyword">string</span>, qe ledger.QueryExecutor)</span> <span class="params">(*Handler, error)</span></span> &#123;</span><br><span class="line">cname := chaincodeName + <span class="string">":"</span> + chaincodeVersion</span><br><span class="line"><span class="keyword">if</span> h := cs.HandlerRegistry.Handler(cname); h != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> h, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动链码容器 ...</span></span><br><span class="line"></span><br><span class="line">h := cs.HandlerRegistry.Handler(cname)</span><br><span class="line"><span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrapf(err, <span class="string">"[channel %s] claimed to start chaincode container for %s but could not find handler"</span>, chainID, cname)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> h, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链码容器的启动过程，不是本文的重点，所以不继续深入Launch的调用细节。</p><h5 id="模拟执行交易"><a href="#模拟执行交易" class="headerlink" title="模拟执行交易"></a>模拟执行交易</h5><p><code>execute</code>封装出执行交易的消息，然后使用 Handler 执行交易。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// execute executes a transaction and waits for it to complete until a timeout value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *ChaincodeSupport)</span> <span class="title">execute</span><span class="params">(cctyp pb.ChaincodeMessage_Type, txParams *ccprovider.TransactionParams, cccid *ccprovider.CCContext, input *pb.ChaincodeInput, h *Handler)</span> <span class="params">(*pb.ChaincodeMessage, error)</span></span> &#123;</span><br><span class="line">input.Decorations = txParams.ProposalDecorations</span><br><span class="line"><span class="comment">// 创建消息</span></span><br><span class="line">ccMsg, err := createCCMessage(cctyp, txParams.ChannelID, txParams.TxID, input)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.WithMessage(err, <span class="string">"failed to create chaincode message"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行交易</span></span><br><span class="line">ccresp, err := h.Execute(txParams, cccid, ccMsg, cs.ExecuteTimeout)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.WithMessage(err, fmt.Sprintf(<span class="string">"error sending"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ccresp, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意以下这个参数 <code>txParams *ccprovider.TransactionParams</code> 其类型定义如下，它包含了一条交易执行过程中的信息和资源，所以交易传递的过程中，一直有这个参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TransactionParams are parameters which are tied to a particular transaction</span></span><br><span class="line"><span class="comment">// and which are required for invoking chaincode.</span></span><br><span class="line"><span class="keyword">type</span> TransactionParams <span class="keyword">struct</span> &#123;</span><br><span class="line">TxID                 <span class="keyword">string</span></span><br><span class="line">ChannelID            <span class="keyword">string</span></span><br><span class="line">SignedProp           *pb.SignedProposal</span><br><span class="line">Proposal             *pb.Proposal</span><br><span class="line">TXSimulator          ledger.TxSimulator</span><br><span class="line">HistoryQueryExecutor ledger.HistoryQueryExecutor</span><br><span class="line">CollectionStore      privdata.CollectionStore</span><br><span class="line">IsInitTransaction    <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// this is additional data passed to the chaincode</span></span><br><span class="line">ProposalDecorations <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Handler 执行交易的过程如下，创建交易执行的上下文 Context，因为链码容器在执行交易的时候，会和 Peer 之间进行多次通信，进行数据的读写，上下文可以让数据读写获取到正确的信息。</p><p>之后 Handler 把消息发送给链码容器，并等待链码容器发来包含执行结果的消息，或者执行超时，默认执行时间是 30s。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Handler)</span> <span class="title">Execute</span><span class="params">(txParams *ccprovider.TransactionParams, cccid *ccprovider.CCContext, msg *pb.ChaincodeMessage, timeout time.Duration)</span> <span class="params">(*pb.ChaincodeMessage, error)</span></span> &#123;</span><br><span class="line">chaincodeLogger.Debugf(<span class="string">"Entry"</span>)</span><br><span class="line"><span class="keyword">defer</span> chaincodeLogger.Debugf(<span class="string">"Exit"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私密数据</span></span><br><span class="line">txParams.CollectionStore = h.getCollectionStore(msg.ChannelId)</span><br><span class="line"><span class="comment">// 是否是执行链码初始化</span></span><br><span class="line">txParams.IsInitTransaction = (msg.Type == pb.ChaincodeMessage_INIT)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建交易context</span></span><br><span class="line">txctx, err := h.TXContexts.Create(txParams)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 退出时（执行交易完毕），释放交易上下文资源</span></span><br><span class="line"><span class="keyword">defer</span> h.TXContexts.Delete(msg.ChannelId, msg.Txid)</span><br><span class="line"></span><br><span class="line"><span class="comment">// proposal保存到msg</span></span><br><span class="line"><span class="keyword">if</span> err := h.setChaincodeProposal(txParams.SignedProp, txParams.Proposal, msg); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向链码容器发送msg</span></span><br><span class="line">h.serialSendAsync(msg)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待链码容器响应，或者超时</span></span><br><span class="line"><span class="keyword">var</span> ccresp *pb.ChaincodeMessage</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> ccresp = &lt;-txctx.ResponseNotifier:</span><br><span class="line"><span class="comment">// response is sent to user or calling chaincode. ChaincodeMessage_ERROR</span></span><br><span class="line"><span class="comment">// are typically treated as error</span></span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(timeout):</span><br><span class="line">err = errors.New(<span class="string">"timeout expired while executing transaction"</span>)</span><br><span class="line">ccName := cccid.Name + <span class="string">":"</span> + cccid.Version</span><br><span class="line">h.Metrics.ExecuteTimeouts.With(</span><br><span class="line"><span class="string">"chaincode"</span>, ccName,</span><br><span class="line">).Add(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ccresp, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="处理链码容器模拟响应"><a href="#处理链码容器模拟响应" class="headerlink" title="处理链码容器模拟响应"></a>处理链码容器模拟响应</h5><p>链码容器执行的响应会向上传递，直到 <code>ChaincodeSupport.Execute</code>，它调用 <code>processChaincodeExecutionResult</code> 把链码容器返回的响应，转化为交易模拟执行的 Response，而 Response 最终会返回给Endorser，大家可去调用流程上翻。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processChaincodeExecutionResult</span><span class="params">(txid, ccName <span class="keyword">string</span>, resp *pb.ChaincodeMessage, err error)</span> <span class="params">(*pb.Response, *pb.ChaincodeEvent, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, errors.Wrapf(err, <span class="string">"failed to execute transaction %s"</span>, txid)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> resp == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, errors.Errorf(<span class="string">"nil response from transaction %s"</span>, txid)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> resp.ChaincodeEvent != <span class="literal">nil</span> &#123;</span><br><span class="line">resp.ChaincodeEvent.ChaincodeId = ccName</span><br><span class="line">resp.ChaincodeEvent.TxId = txid</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> resp.Type &#123;</span><br><span class="line"><span class="comment">// 交易执行成功则提取Payload中保存的Response</span></span><br><span class="line"><span class="keyword">case</span> pb.ChaincodeMessage_COMPLETED:</span><br><span class="line">res := &amp;pb.Response&#123;&#125;</span><br><span class="line">err := proto.Unmarshal(resp.Payload, res)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, errors.Wrapf(err, <span class="string">"failed to unmarshal response for transaction %s"</span>, txid)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res, resp.ChaincodeEvent, <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 失败，则提取Payload中保存的错误信息</span></span><br><span class="line"><span class="keyword">case</span> pb.ChaincodeMessage_ERROR:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, resp.ChaincodeEvent, errors.Errorf(<span class="string">"transaction returned with failure: %s"</span>, resp.Payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, errors.Errorf(<span class="string">"unexpected response type %d for transaction %s"</span>, resp.Type, txid)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="释放模拟器资源"><a href="#释放模拟器资源" class="headerlink" title="释放模拟器资源"></a>释放模拟器资源</h4><p>回想一下，在 <code>Endorser.SimulateProposal</code> 中，它获取了 交易模拟执行器 <code>TXSimulator</code>，这里面可是有很多资源的，如果不及时释放，在高 TPS 下，Peer压力上大，资源泄露，性能低下等问题会爆发出来。</p><p><code>txParams.TXSimulator.Done()</code> 用来释放资源，上文提到 <code>TxSimulator</code> 包含了 <code>QueryExecutor</code>, <code>lockBasedQueryExecutor</code> 实现了 <code>QueryExecutor</code>，也就是说，主要是释放查询操作相关的资源。</p><p>从源码可以看到会释放读写锁以及迭代器资源，如果不及时释放，后果果然不堪。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Done implements method in interface `ledger.QueryExecutor`</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *lockBasedQueryExecutor)</span> <span class="title">Done</span><span class="params">()</span></span> &#123;</span><br><span class="line">logger.Debugf(<span class="string">"Done with transaction simulation / query execution [%s]"</span>, q.txid)</span><br><span class="line">q.helper.done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *queryHelper)</span> <span class="title">done</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> h.doneInvoked &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line">h.txmgr.commitRWLock.RUnlock()</span><br><span class="line">h.doneInvoked = <span class="literal">true</span></span><br><span class="line"><span class="comment">// 释放迭代器</span></span><br><span class="line"><span class="keyword">for</span> _, itr := <span class="keyword">range</span> h.itrs &#123;</span><br><span class="line">itr.Close()</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ESCC处理模拟执行结果"><a href="#ESCC处理模拟执行结果" class="headerlink" title="ESCC处理模拟执行结果"></a>ESCC处理模拟执行结果</h3><p>上文提到，模拟执行的 Response 会最终回到 Endorser，Endorser 会调用 ESCC 对结果进行背书，最终生成 <code>ProposalResponse</code>，我们看一下这个过程。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Endorser)</span> <span class="title">ProcessProposal</span><span class="params">(ctx context.Context, signedProp *pb.SignedProposal)</span> <span class="params">(*pb.ProposalResponse, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// Pre-process, simulate</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> chainID == <span class="string">""</span> &#123;</span><br><span class="line">pResp = &amp;pb.ProposalResponse&#123;Response: res&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Note: To endorseProposal(), we pass the released txsim. Hence, an error would occur if we try to use this txsim</span></span><br><span class="line">pResp, err = e.endorseProposal(ctx, chainID, txid, signedProp, prop, res, simulationResult, ccevent, hdrExt.PayloadVisibility, hdrExt.ChaincodeId, txsim, cd)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Endorser-endorseProposal"><a href="#Endorser-endorseProposal" class="headerlink" title="Endorser.endorseProposal"></a>Endorser.endorseProposal</h5><p>背书链码实现了可插拔，可以使用不同的ESCC，系统链码和用户链码的背书过程是不同的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// endorse the proposal by calling the ESCC</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Endorser)</span> <span class="title">endorseProposal</span><span class="params">(_ context.Context, chainID <span class="keyword">string</span>, txid <span class="keyword">string</span>, signedProp *pb.SignedProposal, proposal *pb.Proposal, response *pb.Response, simRes []<span class="keyword">byte</span>, event *pb.ChaincodeEvent, visibility []<span class="keyword">byte</span>, ccid *pb.ChaincodeID, txsim ledger.TxSimulator, cd ccprovider.ChaincodeDefinition)</span> <span class="params">(*pb.ProposalResponse, error)</span></span> &#123;</span><br><span class="line">endorserLogger.Debugf(<span class="string">"[%s][%s] Entry chaincode: %s"</span>, chainID, shorttxid(txid), ccid)</span><br><span class="line"><span class="keyword">defer</span> endorserLogger.Debugf(<span class="string">"[%s][%s] Exit"</span>, chainID, shorttxid(txid))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统链码和用户链码使用不同的ESCC</span></span><br><span class="line">isSysCC := cd == <span class="literal">nil</span></span><br><span class="line"><span class="comment">// 1) extract the name of the escc that is requested to endorse this chaincode</span></span><br><span class="line"><span class="keyword">var</span> escc <span class="keyword">string</span></span><br><span class="line"><span class="comment">// ie, "lscc" or system chaincodes</span></span><br><span class="line"><span class="keyword">if</span> isSysCC &#123;</span><br><span class="line">escc = <span class="string">"escc"</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">escc = cd.Endorsement()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">endorserLogger.Debugf(<span class="string">"[%s][%s] escc for chaincode %s is %s"</span>, chainID, shorttxid(txid), ccid, escc)</span><br><span class="line"></span><br><span class="line"><span class="comment">// marshalling event bytes</span></span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="keyword">var</span> eventBytes []<span class="keyword">byte</span></span><br><span class="line"><span class="keyword">if</span> event != <span class="literal">nil</span> &#123;</span><br><span class="line">eventBytes, err = putils.GetBytesChaincodeEvent(event)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">"failed to marshal event bytes"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set version of executing chaincode</span></span><br><span class="line"><span class="keyword">if</span> isSysCC &#123;</span><br><span class="line"><span class="comment">// if we want to allow mixed fabric levels we should</span></span><br><span class="line"><span class="comment">// set syscc version to ""</span></span><br><span class="line">ccid.Version = util.GetSysCCVersion()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ccid.Version = cd.CCVersion()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建背书上下文信息</span></span><br><span class="line">ctx := Context&#123;</span><br><span class="line">PluginName:     escc, <span class="comment">// 插件名称</span></span><br><span class="line">Channel:        chainID,</span><br><span class="line">SignedProposal: signedProp,</span><br><span class="line">ChaincodeID:    ccid,</span><br><span class="line">Event:          eventBytes,</span><br><span class="line">SimRes:         simRes,</span><br><span class="line">Response:       response,</span><br><span class="line">Visibility:     visibility,</span><br><span class="line">Proposal:       proposal,</span><br><span class="line">TxID:           txid,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用插件背书</span></span><br><span class="line"><span class="keyword">return</span> e.s.EndorseWithPlugin(ctx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>背书插件实现下面的接口即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Plugin endorses a proposal response</span></span><br><span class="line"><span class="keyword">type</span> Plugin <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// Endorse signs the given payload(ProposalResponsePayload bytes), and optionally mutates it.</span></span><br><span class="line"><span class="comment">// Returns:</span></span><br><span class="line"><span class="comment">// The Endorsement: A signature over the payload, and an identity that is used to verify the signature</span></span><br><span class="line"><span class="comment">// The payload that was given as input (could be modified within this function)</span></span><br><span class="line"><span class="comment">// Or error on failure</span></span><br><span class="line">Endorse(payload []<span class="keyword">byte</span>, sp *peer.SignedProposal) (*peer.Endorsement, []<span class="keyword">byte</span>, error)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Init injects dependencies into the instance of the Plugin</span></span><br><span class="line">Init(dependencies ...Dependency) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用插件背书，需获取插件实例，然后组装响应Payload，它包含了交易执行的多种结果，然后对Payload以及签名的Proposal背书。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EndorseWithPlugin endorses the response with a plugin</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pe *PluginEndorser)</span> <span class="title">EndorseWithPlugin</span><span class="params">(ctx Context)</span> <span class="params">(*pb.ProposalResponse, error)</span></span> &#123;</span><br><span class="line">endorserLogger.Debug(<span class="string">"Entering endorsement for"</span>, ctx)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ctx.Response == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"response is nil"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ctx.Response.Status &gt;= shim.ERRORTHRESHOLD &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;pb.ProposalResponse&#123;Response: ctx.Response&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取插件</span></span><br><span class="line">plugin, err := pe.getOrCreatePlugin(PluginName(ctx.PluginName), ctx.Channel)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">endorserLogger.Warning(<span class="string">"Endorsement with plugin for"</span>, ctx, <span class="string">" failed:"</span>, err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.Errorf(<span class="string">"plugin with name %s could not be used: %v"</span>, ctx.PluginName, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把模拟执行的信息组成生成背书响应Payload</span></span><br><span class="line">prpBytes, err := proposalResponsePayloadFromContext(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">endorserLogger.Warning(<span class="string">"Endorsement with plugin for"</span>, ctx, <span class="string">" failed:"</span>, err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">"failed assembling proposal response payload"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对Payload和签名的Proposal进行背书</span></span><br><span class="line">endorsement, prpBytes, err := plugin.Endorse(prpBytes, ctx.SignedProposal)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">endorserLogger.Warning(<span class="string">"Endorsement with plugin for"</span>, ctx, <span class="string">" failed:"</span>, err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.WithStack(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resp := &amp;pb.ProposalResponse&#123;</span><br><span class="line">Version:     <span class="number">1</span>,</span><br><span class="line">Endorsement: endorsement,</span><br><span class="line">Payload:     prpBytes,</span><br><span class="line">Response:    ctx.Response,</span><br><span class="line">&#125;</span><br><span class="line">endorserLogger.Debug(<span class="string">"Exiting"</span>, ctx)</span><br><span class="line"><span class="keyword">return</span> resp, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>系统提供的默认背书插件如下，<strong>本质是对交易执行结果和Proposal签名人信息进行签名。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Endorse signs the given payload(ProposalResponsePayload bytes), and optionally mutates it.</span></span><br><span class="line"><span class="comment">// Returns:</span></span><br><span class="line"><span class="comment">// The Endorsement: A signature over the payload, and an identity that is used to verify the signature</span></span><br><span class="line"><span class="comment">// The payload that was given as input (could be modified within this function)</span></span><br><span class="line"><span class="comment">// Or error on failure</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *DefaultEndorsement)</span> <span class="title">Endorse</span><span class="params">(prpBytes []<span class="keyword">byte</span>, sp *peer.SignedProposal)</span> <span class="params">(*peer.Endorsement, []<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// 提取Proposal的签名人</span></span><br><span class="line">signer, err := e.SigningIdentityForRequest(sp)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, errors.New(fmt.Sprintf(<span class="string">"failed fetching signing identity: %v"</span>, err))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到签名人身份</span></span><br><span class="line"><span class="comment">// serialize the signing identity</span></span><br><span class="line">identityBytes, err := signer.Serialize()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, errors.New(fmt.Sprintf(<span class="string">"could not serialize the signing identity: %v"</span>, err))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对Payload和身份进行签名</span></span><br><span class="line"><span class="comment">// sign the concatenation of the proposal response and the serialized endorser identity with this endorser's key</span></span><br><span class="line">signature, err := signer.Sign(<span class="built_in">append</span>(prpBytes, identityBytes...))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, errors.New(fmt.Sprintf(<span class="string">"could not sign the proposal response payload: %v"</span>, err))</span><br><span class="line">&#125;</span><br><span class="line">endorsement := &amp;peer.Endorsement&#123;Signature: signature, Endorser: identityBytes&#125;</span><br><span class="line"><span class="keyword">return</span> endorsement, prpBytes, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发送Response"><a href="#发送Response" class="headerlink" title="发送Response"></a>发送Response</h3><p><code>ProcessProposal</code> 会把 ProposalResponse 作为返回值，剩下的就交给 gRPC，发送给请求方了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文从宏观和源码层面，解读了交易提案背书涉及的数据结构，以及其主要背书流程，核心可以主要包含以下几步：</p><ol><li>检查Proposal</li><li>为交易创建模拟器，并调用模拟器模拟执行交易，生成执行结果</li><li>背书模块对执行结果和Proposal身份信息背书（签名），然后生成背书响应发送给客户端</li></ol><p>关于背书流程，本文未涉及的环节有：</p><ol><li>Proposal中各字段，层层递进的含义</li><li>模拟执行交易，是链码执行函数，并和Peer交互的过程，以及模拟执行的各种资源</li><li>2种插件化ESCC的实现</li></ol><p>后面的章节，会对相关源码实现做进一步分析。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;流程&quot;&gt;&lt;a href=&quot;#流程&quot; class=&quot;headerlink&quot; title=&quot;流程&quot;&gt;&lt;/a&gt;流程&lt;/h2&gt;&lt;p&gt;在 &lt;a href=&quot;http://lessisbetter.site/2019/07/17/fabric-concepts-notes/&quot;
      
    
    </summary>
    
    
    
      <category term="区块链" scheme="http://lessisbetter.site/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Fabric" scheme="http://lessisbetter.site/tags/Fabric/"/>
    
  </entry>
  
  <entry>
    <title>Go垃圾回收 1：历史和原理</title>
    <link href="http://lessisbetter.site/2019/10/20/go-gc-1-history-and-priciple/"/>
    <id>http://lessisbetter.site/2019/10/20/go-gc-1-history-and-priciple/</id>
    <published>2019-10-20T03:13:11.000Z</published>
    <updated>2020-02-04T09:31:33.639Z</updated>
    
    <content type="html"><![CDATA[<p>新老朋友好久不见，我是大彬。今天为大家带来的分享是Go语言垃圾回收，这篇文章筹划的了很久，因为GC也是很强大的一个话题，关于GC已经有很多篇论文还有书籍，想通过一篇文章来介绍Go语言的垃圾回收是困难的，所以决定分几篇文章来完成Go语言垃圾回收的相关话题：</p><ol><li>Go垃圾回收 1: 历史和原理</li><li>Go垃圾回收 2: GC主要流程</li><li>Go垃圾回收 3: 源码分析</li><li>Go垃圾回收 4: GC对性能的影响与优化</li></ol><p>虽然划分成了3部分，但每个子话题依然很大，依然难写，依然大而不全，每一篇文章都会有宏观与细节，这样的大而不全对于不了解GC的朋友是好事，即可以有宏观上的认识，又可以有重要细节的感知。</p><p>这篇文章就是第一个话题：Go垃圾回收历史和原理，希望各位有所收获。</p><h2 id="Go语言垃圾回收简介"><a href="#Go语言垃圾回收简介" class="headerlink" title="Go语言垃圾回收简介"></a>Go语言垃圾回收简介</h2><p><strong>垃圾</strong>指内存中不再使用的内存区域，自动发现与释放这种内存区域的过程就是垃圾回收。</p><p>内存资源是有限的，而垃圾回收可以让内存重复使用，并且减轻开发者对内存管理的负担，减少程序中的内存问题。</p><p>以下是从网上对垃圾回收的2个定义：</p><blockquote><ol><li>Garbage consists of objects that are dead.</li><li>In tracing garbage collection, the term is sometimes used to mean objects that are known to be dead; that is, objects that are unreachable.</li></ol></blockquote><h3 id="Go垃圾回收发展史"><a href="#Go垃圾回收发展史" class="headerlink" title="Go垃圾回收发展史"></a>Go垃圾回收发展史</h3><ul><li><a href="https://golang.org/doc/go1.1#performance" target="_blank" rel="noopener">go1.1</a>，提高效率和垃圾回收精确度。</li><li><a href="https://golang.org/doc/go1.3#garbage_collector" target="_blank" rel="noopener">go1.3</a>，提高了垃圾回收的精确度。</li><li><p><a href="https://golang.org/doc/go1.4#runtime" target="_blank" rel="noopener">go1.4</a>，之前版本的runtime大部分是使用C写的，这个版本大量使用Go进行了重写，让GC有了扫描stack的能力，进一步提高了垃圾回收的精确度。</p></li><li><p><a href="https://golang.org/doc/go1.5#gc" target="_blank" rel="noopener">go1.5</a>，目标是降低GC延迟，采用了<strong>并发标记和并发清除，三色标记</strong>，<strong>write barrier</strong>，以及实现了更好的<strong>回收器调度</strong>，设计<a href="https://docs.google.com/document/d/16Y4IsnNRCN43Mx0NZc5YXZLovrHvvLhK_h0KN8woTO4/edit" target="_blank" rel="noopener">文档1</a>，<a href="https://golang.org/s/go15gcpacing" target="_blank" rel="noopener">文档2</a>，以及这个版本的<a href="https://talks.golang.org/2015/go-gc.pdf" title="Go talk: go1.5" target="_blank" rel="noopener">Go talk</a>。</p></li><li><a href="https://golang.org/doc/go1.6" target="_blank" rel="noopener">go1.6</a>，小优化，当程序使用大量内存时，GC暂停时间有所降低。</li><li><a href="https://golang.org/doc/go1.7" target="_blank" rel="noopener">go1.7</a>，小优化，当程序有大量空闲goroutine，stack大小波动比较大时，GC暂停时间有显著降低。</li><li><a href="https://golang.org/doc/go1.8" target="_blank" rel="noopener">go1.8</a>，<strong>write barrier切换到hybrid write barrier</strong>，以消除STW中的re-scan，把STW的最差情况降低到<strong>50us</strong>，设计<a href="https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md" target="_blank" rel="noopener">文档</a>。</li><li><a href="https://golang.org/doc/go1.9#gc" target="_blank" rel="noopener">go1.9</a>，提升指标比较多，1）过去 <a href="https://golang.org/pkg/runtime/#GC" target="_blank" rel="noopener"><code>runtime.GC</code></a>, <a href="https://golang.org/pkg/runtime/debug/#SetGCPercent" target="_blank" rel="noopener"><code>debug.SetGCPercent</code></a>, 和 <a href="https://golang.org/pkg/runtime/debug/#FreeOSMemory" target="_blank" rel="noopener"><code>debug.FreeOSMemory</code></a>都不能触发<strong>并发GC</strong>，他们触发的GC都是阻塞的，go1.9可以了，变成了在垃圾回收之前只阻塞调用GC的goroutine。2）<a href="https://golang.org/pkg/runtime/debug/#SetGCPercent" target="_blank" rel="noopener"><code>debug.SetGCPercent</code></a>只在有必要的情况下才会触发GC。</li><li><a href="https://golang.org/doc/go1.10#performance" target="_blank" rel="noopener">go.1.10</a>，小优化，加速了GC，程序应当运行更快<em>一点点</em>。</li><li><a href="https://golang.org/doc/go1.12" target="_blank" rel="noopener">go1.12</a>，显著提高了堆内存存在大碎片情况下的sweeping性能，能够降低GC后立即分配内存的延迟。</li></ul><p>以上的历史版本信息都来自<a href="https://golang.org/doc/devel/release.html" target="_blank" rel="noopener">Go release归档</a>，有兴趣可以去翻阅一下。</p><h3 id="Go垃圾回收主要流程"><a href="#Go垃圾回收主要流程" class="headerlink" title="Go垃圾回收主要流程"></a>Go垃圾回收主要流程</h3><p>下面这幅图来自Go1.5的<a href="https://talks.golang.org/2015/go-gc.pdf" title="Go talk: go1.5" target="_blank" rel="noopener">go talk</a>，虽然go1.12的GC与go1.5有了许多改变，但总体的流程没有较大改变，并且也找不到官方更新的图了，所有就用这幅图介绍GC主流程。</p><p><img src="http://img.lessisbetter.site/2019-10-gc-go1.7.png" alt="Go GC"></p><p>Go 垃圾回收是分<strong>轮次</strong>的，每一轮GC都是从 Off 状态开始，如果不是 Off 状态，则代表上一轮GC还未完成，如果这时修改指针的值，是直接修改的。</p><p>Go 垃圾回收的主要分2部分，第1部分是扫描所有对象进行三色标记，标记为黑色、灰色和白色，标记完成后只有黑色和白色对象，黑色代表使用中对象，白色对象代表垃圾，灰色是白色过渡到黑色的中间临时状态，第2部分是清扫垃圾，即清理白色对象。</p><p>第1部分包含了栈扫描、标记和标记结束3个阶段。在栈扫描之前有2个重要的准备：STW（Stop The World）和开启<strong>写屏障</strong>（WB，Write Barrier）。</p><p>STW是为了暂停当前所有运行中的goroutine，进行一些准备工作，比如开启WB，把全局变量，以及每个goroutine中的 <strong>Root对象</strong> 收集起来，Root对象是标记扫描的源头，可以从Root对象依次索引到使用中的对象。</p><p><img src="http://img.lessisbetter.site/2019-10-obj-tree.png" alt="Objects Reference Tree"></p><blockquote><p>假设内存中的对象用圆圈表示，那根据对象的指向关系，所有的对象可以组成若干依赖树，每一个 Root对象 都是树根，按图索骥能找到每一个使用中的对象。但树根不一定是Root对象，也有可能是垃圾，使用灰色树根代表Root对象，白色树根代表垃圾。</p></blockquote><p>每个P都有一个 <code>mcache</code> ，每个 <code>mcache</code> 都有1个Span用来存放 TinyObject，TinyObject 都是不包含指针的对象，所以这些对象可以直接标记为黑色，然后关闭 STW。</p><blockquote><p>如果不了解mcache和Tiny对象，赶紧翻一下这篇文章<a href="https://mp.weixin.qq.com/s/3gGbJaeuvx4klqcv34hmmw" title="Go内存分配那些事，就这么简单!" target="_blank" rel="noopener">Go内存分配那些事</a>。</p></blockquote><p>每个P都有1个进行扫描标记的 goroutine，可以进行并发标记，关闭STW后，这些 goroutine 就变成可运行状态，接收 Go Scheduler 的调度，被调度时执行1轮标记，它负责第1部分任务：栈扫描、标记和标记结束。</p><p><strong>栈扫描阶段</strong>就是把前面搜集的Root对象找出来，标记为黑色，然后把它们引用的对象也找出来，标记为灰色，并且加入到<strong>gcWork队列</strong>，gcWork队列保存了灰色的对象，每个灰色的对象都是一个Work。</p><p>后面可以进入<strong>标记阶段</strong>，它是一个循环，不断的从gcWork队列中取出work，所指向的对象标记为黑色，该对象指向的对象标记为灰色，然后加入队列，直到队列为空。</p><p>然后进入<strong>标记结束阶段</strong>，再次开启STW，不同的版本处理方式是不同的。</p><p>在Go1.7的版本是<strong>Dijkstra写屏障</strong>，这个写屏障只监控堆上指针数据的变动，由于成本原因，没有监控栈上指针的变动，由于应用goroutine和GC的标记goroutine都在运行，当栈上的指针指向的对象变更为白色对象时，这个白色对象应当标记为黑色，需要再次扫描全局变量和栈，以免释放这类不该释放的对象。</p><p>在Go1.8及以后的版本引入了<strong>混合写屏障</strong>，这个写屏障依然不监控栈上指针的变动，但是它的策略，使得无需再次扫描栈和全局变量，但依然需要STW然后进行一些检查。</p><p>标记结束阶段的最后会关闭写屏障，然后关闭STW，唤醒熟睡已久的负责清扫垃圾的goroutine。</p><p><strong>清扫goroutine是应用启动后立即创建的一个后台goroutine</strong>，它会立刻进入睡眠，等待被唤醒，然后执行垃圾清理：把白色对象挨个清理掉，清扫goroutine和应用goroutine是并发进行的。清扫完成之后，它再次进入睡眠状态，等待下次被唤醒。</p><p>最后执行一些数据统计和状态修改的工作，并且设置好触发下一轮GC的阈值，把GC状态设置为Off。</p><p><strong>以上就是Go垃圾回收的主要流程，但和go1.12的源码稍微有一些不同</strong>，比如标记结束后，就开始设置各种状态数据以及把GC状态成了Off，在开启一轮GC时，会自动检测当前是否处于Off，如果不是Off，则当前goroutine会调用清扫函数，帮助清扫goroutine一起清扫span，实际的Go垃圾回收流程以源码为准。</p><p>主要流程是宏观一点的角度，接下去会扩散一下，介绍主要流程中提到的各种概念，比如三色标记、并发标记清理、STW、写屏障、辅助GC、GC persent。</p><h2 id="几类垃圾回收思想"><a href="#几类垃圾回收思想" class="headerlink" title="几类垃圾回收思想"></a>几类垃圾回收思想</h2><p>垃圾回收的研究已经存在了几十年，远在Go诞生之前，就存在了多种垃圾回收的思想，我们这里看几个跟Go垃圾回收相关的几个。</p><h3 id="Tracing-GC"><a href="#Tracing-GC" class="headerlink" title="Tracing GC"></a>Tracing GC</h3><p>WIKI介绍：<a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Tracing_garbage_collection</a></p><p>Tracing GC 是垃圾回收的一个大类，另外一个大类是<strong>引用计数</strong>，关于各种垃圾回收的类别可以看下这个系列文章<a href="https://liujiacai.net/blog/2018/08/04/incremental-gc/" target="_blank" rel="noopener">深入浅出垃圾回收</a>。</p><p>本文主要介绍Tracing GC的简要原理，我们首先看一下引用树的概念。把内存中所有的对象，都作为一个节点，对象A中的指针，指向了对象B，就存在从对象A指向对象B的一条边，对象B也可能指向了其他对象，那么根据指向关系就能生成一颗对象引用树。</p><p><img src="http://img.lessisbetter.site/2019-10-obj-ref-tree.png" alt="Objects Reference Tree"></p><p>把内存中所有的对象引用树组合起来，就组成了一幅图。</p><p><img src="http://img.lessisbetter.site/2019-10-mem-obj.png" alt="Memory Objects"></p><p>Tracing GC中有2类对象：</p><ol><li>可到达对象，即使用中对象</li><li>不可到达对象，即垃圾</li></ol><p>Tracing GC使用对象引用树找到所有可到达的对象，找到可到达对象有2个原则。</p><p><strong>原则1：被程序中调用栈，或者全局变量指向的对象是可到达对象。</strong></p><p><img src="http://img.lessisbetter.site/2019-10-obj-root.png" alt="Root Objects"></p><p><strong>原则2：被可到达对象指向的对象也是可到达对象。</strong></p><p>A是可到达的，并且B被A引用，所以B也是可到达的。</p><p><img src="http://img.lessisbetter.site/2019-10-obj-reachable.png" alt="Reachable Objects"></p><p>Tracing GC使用任何一种图论的遍历算法，都可以从<strong>Root对象</strong>，根据引用关系找到所有的可到达对象，并把他们做标记。Tracing GC扫描后，<strong>黑色</strong>对象为可到达对象，剩下的<strong>白色</strong>对象为不可到达对象。</p><blockquote><p>原生的 Tracing GC 只有黑色和白色2种颜色。</p></blockquote><p><img src="http://img.lessisbetter.site/2019-10-obj-traced.png" alt="Tracing GC"></p><h3 id="增量式垃圾回收思想"><a href="#增量式垃圾回收思想" class="headerlink" title="增量式垃圾回收思想"></a>增量式垃圾回收思想</h3><p>垃圾回收离不开STW，STW是Stop The World，指会暂停所有正在执行的用户线程/协程，进行垃圾回收的操作，STW为垃圾对象的扫描和标记提供了必要的条件。</p><p><strong>非增量式垃圾</strong>回收需要STW，在STW期间完成<strong>所有</strong>垃圾对象的标记，STW结束后慢慢的执行垃圾对象的清理。</p><p><strong>增量式垃圾回收</strong>也需要STW，在STW期间完成<strong>部分</strong>垃圾对象的标记，然后结束STW继续执行用户线程，一段时间后再次执行STW再标记<strong>部分</strong>垃圾对象，这个过程会多次重复执行，直到<strong>所有</strong>垃圾对象标记完成。</p><p><img src="http://img.lessisbetter.site/2019-10-increment-gc.png" alt="Increment GC"></p><p>GC算法有3大性能指标：吞吐量、最大暂停时间（最大的STW占时）、内存占用率。<strong>增量式垃圾回收不能提高吞吐量，但和非增量式垃圾回收相比，每次STW的时间更短，能够降低最大暂停时间</strong>，就是Go每个版本Release Note中提到的GC延迟、GC暂停时间。</p><p>下图是非增量式GC和增量式GC的对比：</p><p><img src="http://img.lessisbetter.site/2019-10-normal-vs-incremnt.png" alt="Normal V.S. Increment GC"></p><blockquote><p>以上图片来自 <a href="https://blog.heroku.com/incremental-gc" target="_blank" rel="noopener">Incremental Garbage Collection in Ruby 2.2</a> ，它也很好的介绍了增量式垃圾回收的思想。</p></blockquote><h3 id="并发垃圾回收"><a href="#并发垃圾回收" class="headerlink" title="并发垃圾回收"></a>并发垃圾回收</h3><p>减少最大暂停时间还有一种思路：并发垃圾回收，注意不是并行垃圾回收。</p><p><strong>并行垃圾回收</strong>是每个核上都跑垃圾回收的线程，同时进行垃圾回收，这期间为STW，会暂停用户线程的执行。</p><p><strong>并发垃圾回收</strong>是先STW找到所有的Root对象，然后结束STW，让垃圾标记线程和用户线程并发执行，垃圾标记完成后，再次开启STW，再次扫描和标记，以免释放使用中的内存。</p><p>并发垃圾回收和并行垃圾回收的重要区别就是不会持续暂停用户线程，并发垃圾回收也降低了STW的时间，达到了减少最大暂停时间的目的。</p><p><img src="https://dt-cdn.net/images/the-different-gc-algorithms-510-ed7afde0fb.png" alt=""></p><blockquote><p>图片来自 <a href="https://www.dynatrace.com/resources/ebooks/javabook/reduce-garbage-collection-pause-time/" target="_blank" rel="noopener">Reducing Garbage-Collection Pause Time</a> ，橙色线条为垃圾回收线程的运行，蓝色线条为用户线程。</p></blockquote><h2 id="Go垃圾回收主要原理"><a href="#Go垃圾回收主要原理" class="headerlink" title="Go垃圾回收主要原理"></a>Go垃圾回收主要原理</h2><h3 id="三色标记"><a href="#三色标记" class="headerlink" title="三色标记"></a>三色标记</h3><p><strong>为什么需要三色标记？</strong></p><p>三色标记的目的，主要是利用Tracing GC做增量式垃圾回收，降低最大暂停时间。原生Tracing GC只有黑色和白色，没有中间的状态，这就要求GC扫描过程必须一次性完成，得到最后的黑色和白色对象。在前面增量式GC中介绍到了，这种方式会存在较大的暂停时间。</p><p>三色标记增加了中间状态灰色，增量式GC运行过程中，应用线程的运行可能改变了对象引用树，只要让黑色对象不直接引用白色对象，GC就可以增量式的运行，减少停顿时间。</p><p><strong>什么是三色标记？</strong></p><p>三色标记，望文生义可以知道它由3种颜色组成：</p><ol><li>黑色 Black：表示对象是<strong>可达的</strong>，即使用中的对象，黑色是已经被扫描的对象。</li><li>灰色 Gary：表示<strong>被黑色对象直接引用的对象</strong>，但还没对它进行扫描。</li><li>白色 White：白色是对象的初始颜色，如果扫描完成后，对象依然还是白色的，说明此对象是垃圾对象。</li></ol><p>三色标记规则：黑色不能指向白色对象。即黑色可以指向灰色，灰色可以指向白色。</p><p>三色标记主要流程：</p><ol><li>初始所有对象被标记为白色。</li><li>寻找所有Root对象，比如被线程直接引用的对象，把Root对象标记为灰色。</li><li>把灰色对象标记为黑色，并它们引用的对象标记为灰色。</li><li>持续遍历每一个灰色对象，直到没有灰色对象。</li><li>剩余白色对象为垃圾对象。</li></ol><p>推荐一篇结合Go代码展示了三色标记的过程的优秀文章：<br><a href="https://making.pusher.com/golangs-real-time-gc-in-theory-and-practice/" target="_blank" rel="noopener">Golang’s Real-time GC in Theory and Practice</a> 。</p><p><strong>记录三色的方法简介</strong></p><p>Go1.12 使用位图和队列结合表示三种颜色状态：</p><ol><li>白色：位图没有标记被扫描。</li><li>灰色：位图被标记已扫描，并且对象在队列。</li><li>黑色：位图被标记已扫描，并且对象已从队列弹出。</li></ol><p>位图是全局的，表示了Heap中内存块是否被扫描，是否包含指针等。</p><p>队列有全局的一个和每个P有一个本地队列，扫描对象进行标记的过程，优先处理本P的队列，其思想与P的g本地队列和全局队列类似，减少资源竞争，提高并行化。</p><h3 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h3><p>我们结合一段用户代码介绍写屏障：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A.Next = B</span><br><span class="line">A.Next = &amp;C&#123;&#125;</span><br></pre></td></tr></table></figure><p>三色标记的扫描线程是跟用户线程并发执行的，考虑这种情况：</p><p>用户线程执行完 <code>A.Next = B</code> 后，扫描线程把A标记为黑色，B标记为灰色，用户线程执行 <code>A.Next = &amp;C{}</code> ，C是新对象，被标记为白色，由于A已经被扫描，不会重复扫描，所以C不会被标记为灰色，造成了黑色对象指向白色对象的情况，这种三色标记中是不允许的，结果是C被认为是垃圾对象，最终被清扫掉，当访问C时会造成非法内存访问而Panic。</p><p>写屏障可以解决这个问题，当对象引用树发生改变时，即对象指向关系发生变化时，将被指向的对象标记为灰色，维护了三色标记的约束：黑色对象不能直接引用白色对象，这避免了使用中的对象被释放。</p><p>有写屏障后，用户线程执行 <code>A.Next = &amp;C{}</code> 后，写屏障把C标记为灰色。</p><h3 id="并发标记"><a href="#并发标记" class="headerlink" title="并发标记"></a>并发标记</h3><p>并发垃圾回收的主要思想上文已经介绍，Go的垃圾回收为每个P都分配了一个gcMarker协程，用于并发标记对象，这样有些P在标记对象，而有些P上继续运行用户协程。</p><p>Go的并发标记有4种运行模式，还没深入研究，这里举一个并发标记的场景：在goroutine的调度过程中，如果当前P上已经没有g可以执行，也偷不到g时，P就空闲下来了，这时候可以运行当前P的gcMarker协程。</p><h3 id="触发GC"><a href="#触发GC" class="headerlink" title="触发GC"></a>触发GC</h3><p>GC有3种触发方式：</p><ul><li><p>辅助GC</p><p>在分配内存时，会判断当前的Heap内存分配量是否达到了触发一轮GC的阈值（每轮GC完成后，该阈值会被动态设置），如果超过阈值，则启动一轮GC。</p></li><li><p>调用<code>runtime.GC()</code>强制启动一轮GC。</p></li><li><p><strong>sysmon</strong>是运行时的守护进程，当超过 <code>forcegcperiod</code> (2分钟)没有运行GC会启动一轮GC。</p></li></ul><h3 id="GC调节参数"><a href="#GC调节参数" class="headerlink" title="GC调节参数"></a>GC调节参数</h3><p>Go垃圾回收不像Java垃圾回收那样，有很多参数可供调节，Go为了保证使用GC的简洁性，只提供了一个参数<code>GOGC</code>。</p><p><code>GOGC</code>代表了占用中的内存增长比率，达到该比率时应当触发1次GC，该参数可以通过环境变量设置。</p><p>它的单位是百分比，取值范围并不是 [0, 100]，可以是1000，甚至2000，2000时代表2000%，即20倍。</p><p>假如当前heap占用内存为4MB，<code>GOGC = 75</code>，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 * (1+75%) = 7MB</span><br></pre></td></tr></table></figure><p>等heap占用内存大小达到7MB时会触发1轮GC。</p><p><code>GOGC</code>还有2个特殊值：</p><ol><li><code>&quot;off&quot;</code> : 代表关闭GC</li><li><code>0</code> : 代表持续进行垃圾回收，只用于调试 </li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了Go垃圾回收的发展史，以及Go垃圾回收的一些主要概念，是为掌握Go垃圾回收提供一个基础。下期文章将把本文提到的概念串起来，介绍Go垃圾回收的主要流程，下期见。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://cloud.tencent.com/developer/article/1186944" target="_blank" rel="noopener">一个专家眼中的Go与Java垃圾回收算法大对比</a></p><p>这篇文章介绍了一些垃圾回收的标准，比如GC吞吐量、分配性能、暂停时间等等。</p></li><li><p><a href="https://www.infoq.cn/article/2017/03/garbage-collection-algorithm" target="_blank" rel="noopener">理解垃圾回收算法</a></p><p>这篇文章介绍了几种常见的垃圾机制，并使用gif展示回收过程。</p></li></ul><ul><li><p><a href="https://liujiacai.net/blog/2018/06/15/garbage-collection-intro/" target="_blank" rel="noopener">深入浅出垃圾回收（一）简介篇</a>，<a href="https://liujiacai.net/blog/2018/08/04/incremental-gc/" target="_blank" rel="noopener">深入浅出垃圾回收（三）增量式 GC</a>，<a href="https://liujiacai.net/blog/2018/08/18/generational-gc/" target="_blank" rel="noopener">深入浅出垃圾回收（四）分代式 GC</a></p><p>这个系列文章介绍了垃圾回收的概念、策略，以及三色标记等增量回收，以及分代收集。</p></li><li><p><a href="https://engineering.linecorp.com/en/blog/go-gc/" target="_blank" rel="noopener">Go gc</a></p><p>这篇文章做了Go和Java GC的简单对比表。看起来Go Gc比JVM GC少很多东西，但这其中解释了一些理由。</p><p>Go没有使用compaction来解决碎片问题，而是使用了TCMalloc来减缓碎片和优化分配。</p></li></ul><table><thead><tr><th></th><th>JAVA (JAVA8 HOTSPOT VM)</th><th>GO</th></tr></thead><tbody><tr><td>Collector</td><td>Several collectors (Serial, Parallel, CMS, G1)</td><td>CMS</td></tr><tr><td>Compaction</td><td>Compacts</td><td>Does not compact</td></tr><tr><td>Generational GC</td><td>Generational GC</td><td>Non-generational GC</td></tr><tr><td>Tuning parameters</td><td>Depends on the collector.Multiple parameters available.</td><td>Go垃圾回收 only</td></tr></tbody></table><ul><li><p><a href="https://juejin.im/post/5d2825bff265da1b6836e8d4" target="_blank" rel="noopener">【译】 Golang 中的垃圾回收（一）</a></p><p>这篇文章是William Kennedy垃圾回收系列文章的第一篇的译文，这个文章从宏观的角度介绍了垃圾回收的原理，把垃圾回收跟调度结合起来介绍，分析了Go GC是如何实现低延时的。并且详细介绍了并发标记、STW、并发清除等。</p></li><li><p><a href="https://i6448038.github.io/2019/03/04/golang-garbage-collector/" target="_blank" rel="noopener">图解Golang的GC算法</a></p><p>RyuGou用图的方式简述了三色标记法的标记清除过程以及写屏障。</p></li><li><p><a href="https://making.pusher.com/golangs-real-time-gc-in-theory-and-practice/" target="_blank" rel="noopener">Golang’s Real-time GC in Theory and Practice</a></p><p>这篇文章有一个非常棒的GC动画。</p></li><li><p><a href="https://blog.wangriyu.wang/2019/04-Golang-GC.html" target="_blank" rel="noopener">学习 Golang GC</a></p><p>这篇文章对GC的历史、原理、goroutine栈，Go GC历史，基础原理，触发时间都有介绍，是一篇大而全的文章，但每个部分确实也都不详细，值得再参考。</p></li><li><p><a href="http://legendtkl.com/2017/04/28/golang-gc/" target="_blank" rel="noopener">Golang 垃圾回收剖析</a></p></li></ul><ul><li><p><a href="https://www.cnblogs.com/zkweb/p/7880099.html" target="_blank" rel="noopener">Golang源码探索(三) GC的实现原理</a></p><p>Go垃圾回收的绝佳源码文章，图文并茂，从内存分配，讲到垃圾回收。</p></li></ul><ul><li><p><a href="https://talks.golang.org/2015/go-gc.pdf" target="_blank" rel="noopener">Go talk 2015: Go Gc: Latency Problem Solved</a></p><p>go1.5降低GC延迟的PPT介绍。</p></li><li><p><a href="https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md" target="_blank" rel="noopener">Proposal: Eliminate STW stack re-scanning</a></p><p>消除Go垃圾回收中第二次STW的re-scanning的提案。</p></li></ul><blockquote><ol><li>如果这篇文章对你有帮助，不妨关注下我的Github，有文章会收到通知。</li><li>本文作者：<a href="http://lessisbetter.site/about/">大彬</a></li><li>如果喜欢本文，随意转载，但请保留此原文链接：<a href="http://lessisbetter.site/2019/10/20/go-gc-1-history-and-priciple/">http://lessisbetter.site/2019/10/20/go-gc-1-history-and-priciple/</a></li></ol></blockquote><p><div style="color:#0096FF; text-align:center">关注公众号，获取最新Golang文章</div><br><img src="http://img.lessisbetter.site/blog-gzh.png" style="border:0" align="center"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;新老朋友好久不见，我是大彬。今天为大家带来的分享是Go语言垃圾回收，这篇文章筹划的了很久，因为GC也是很强大的一个话题，关于GC已经有很多篇论文还有书籍，想通过一篇文章来介绍Go语言的垃圾回收是困难的，所以决定分几篇文章来完成Go语言垃圾回收的相关话题：&lt;/p&gt;
&lt;ol&gt;

      
    
    </summary>
    
    
    
      <category term="Go" scheme="http://lessisbetter.site/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Fabric 1.4源码解读 3：事件(Event)原理解读</title>
    <link href="http://lessisbetter.site/2019/09/20/fabric-event-source/"/>
    <id>http://lessisbetter.site/2019/09/20/fabric-event-source/</id>
    <published>2019-09-20T11:46:41.000Z</published>
    <updated>2020-01-07T06:22:24.737Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Event是应用和Fabric网络交互的一种方式，应用可以通过<strong>SDK</strong>向<strong>Peer</strong>订阅某种类型的事件，当Peer发现事件发生时，可以把Event发送给应用，应用获取到通知信息。</p><h2 id="Event功能介绍"><a href="#Event功能介绍" class="headerlink" title="Event功能介绍"></a>Event功能介绍</h2><p>Event从来源上可以分为2类：</p><ol><li>链码容器发出的Event</li><li>Peer上账本变更发出的Event</li></ol><p><img src="http://img.lessisbetter.site/2019-09-sdk-event.png" alt="fabric event"></p><p><em>图源自<a href="https://medium.com/coinmonks/tutorial-chaincode-event-listener-on-hyperledger-fabric-java-sdk-557304f1fe28" target="_blank" rel="noopener">Tutorial Chaincode Event Listener on Hyperledger Fabric Java SDK</a></em></p><p>翻阅Node SDK和Go SDK的文档，发现SDK提供了4类事件：</p><ol><li>BlockEvent，可以用来监控被添加到账本上的区块。客户端需要Admin权限，这样才能读取完整的区块，每产生一个区块，它都会接收到通知。区块中有交易，交易中有chaincode event，所以可以通过BlockEvent获取其他事件。</li><li>FilteredBlockEvent，可以用来监控简要的区块信息，当不只关心区块包含了哪些交易，交易是否成功时，它非常实用，还可以降低网络负载。它包含区块的部分信息，所以被称为filtered，信息有channel ID，区块号，交易的validation code。</li><li>TransactionStatusEvent，可以用来监控某个交易在当前组织的peer何时完成。可以得到交易的validation code和交易所在区块。</li><li>ChaincodeEvent，用来监听Chaincode发出的事件，不同的链码可以自定义自己的事件，所以这个更具有个性化。包含了交易id、区块号、链码id、事件名称，事件内容。如果想要查看事件内容，客户端所使用的账号，必须是Admin权限。</li></ol><p>另外，订阅事件时可以指定开启和结束的区块号范围，如果开始的区块号已经产生，即区块已经写入账本，可以重放事件，更多信息可以看下面的文档。</p><p>关于Event的2篇重要文档，深深感觉Node SDK的文档，比Go SDK的文档丰富。</p><ul><li><a href="https://fabric-sdk-node.github.io/tutorial-channel-events.html" target="_blank" rel="noopener">Hyperledger Fabric SDK for node.js Tutorial: How to use the channel-based event service</a></li><li><a href="https://hyperledger-fabric-cn.readthedocs.io/zh/latest/peer_event_services.html" target="_blank" rel="noopener">Peer channel-based event services — hyperledger-fabricdocs master 文档</a></li></ul><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>上一节的介绍能够知道有哪些Event，各有什么作用，这一节介绍SDK和Peer是如何进行事件交互的。</p><p>SDK和Peer之间是通过gRPC通信的，gRPC的<a href="https://github.com/hyperledger/fabric/blob/release-1.4/protos/peer/events.proto" target="_blank" rel="noopener">protos的定义文件</a>4种message：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FilteredBlock，给FilteredBlockEvent使用</span><br><span class="line">FilteredTransaction，结合下一个，给FilteredTransactionEvent使用</span><br><span class="line">FilteredTransactionActions</span><br><span class="line">FilteredChaincodeAction，给ChaincodeEvent使用</span><br></pre></td></tr></table></figure><p>和1个Response，其中使用了oneof。</p><ul><li>status，指http status，成功的时候无需使用，错误的时候可以使用指明错误。</li><li>block，给BlockEvent使用</li><li>FilteredBlock，给另外3种事件使用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// DeliverResponse</span><br><span class="line">message DeliverResponse &#123;</span><br><span class="line">    oneof Type &#123;</span><br><span class="line">        common.Status status = 1;</span><br><span class="line">        common.Block block = 2;</span><br><span class="line">        FilteredBlock filtered_block = 3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及2个gRPC通信接口:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">service Deliver &#123;</span><br><span class="line">    // deliver first requires an Envelope of type ab.DELIVER_SEEK_INFO with</span><br><span class="line">    // Payload data as a marshaled orderer.SeekInfo message,</span><br><span class="line">    // then a stream of block replies is received</span><br><span class="line">    rpc Deliver (stream common.Envelope) returns (stream DeliverResponse) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    // deliver first requires an Envelope of type ab.DELIVER_SEEK_INFO with</span><br><span class="line">    // Payload data as a marshaled orderer.SeekInfo message,</span><br><span class="line">    // then a stream of **filtered** block replies is received</span><br><span class="line">    rpc DeliverFiltered (stream common.Envelope) returns (stream DeliverResponse) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>咦，4个Event，怎么只有2个接口？</p><p>配合下图，我们做一番讲解。</p><p><img src="http://img.lessisbetter.site/2019-11-fabric-events.png" alt="fabric sdk go event"></p><p>对于Peer而言，只有2中类型的订阅：</p><ol><li>BlockEvent，即完整的区块</li><li>FilteredBlockEvent，即不完整的区块，可以根据FilteredBlockEvent中的信息，生成FilteredTransactionEvent信息和ChainCodeEvent信息</li></ol><p>图中深蓝色和绿色的线分别代表BlockEvent和FilteredBlockEvent相关的数据流，BlockEvent使用的是Deliver函数，FilteredBlockEvent使用的是DeliverFiltered函数。</p><p>每一个事件订阅，都是一个gRPC连接，Peer会不断的从账本读区块，然后根据区块生成事件，发送给客户端。</p><p>Go SDK中实现了一个Dispatcher，就是提供这么一个中转的功能，对上层应用提供4中类型的事件，把4种事件注册请求转换为2种，调用DeliverClient把事件订阅请求发送给Peer，又把Peer发来的2种事件，转换为应用订阅的事件响应。</p><p>Peer启动时，启动gRPC服务后，会注册好DeliverServer接收事件订阅，然后调用deliverBlocks进入循环，在新区块产生后，会生成订阅的BlockEvent或FilteredBlockEvent，利用ResponseSender把事件发送给SDK。</p><h2 id="event-pb-go源码"><a href="#event-pb-go源码" class="headerlink" title="event.pb.go源码"></a>event.pb.go源码</h2><p>这就是根据<code>events.proto</code>生成的Go文件，负责创建gRPC通信的客户端和服务端，以及两边的消息发送。</p><p>主要关注下2个接口：</p><p><code>deliverClient</code>实现了<code>DeliverClient</code>，已经在该源文件实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DeliverClient is the client API for Deliver service.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.</span></span><br><span class="line"><span class="keyword">type</span> DeliverClient <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// deliver first requires an Envelope of type ab.DELIVER_SEEK_INFO with</span></span><br><span class="line"><span class="comment">// Payload data as a marshaled orderer.SeekInfo message,</span></span><br><span class="line"><span class="comment">// then a stream of block replies is received</span></span><br><span class="line">Deliver(ctx context.Context, opts ...grpc.CallOption) (Deliver_DeliverClient, error)</span><br><span class="line"><span class="comment">// deliver first requires an Envelope of type ab.DELIVER_SEEK_INFO with</span></span><br><span class="line"><span class="comment">// Payload data as a marshaled orderer.SeekInfo message,</span></span><br><span class="line"><span class="comment">// then a stream of **filtered** block replies is received</span></span><br><span class="line">DeliverFiltered(ctx context.Context, opts ...grpc.CallOption) (Deliver_DeliverFilteredClient, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DeliverServer</code>是服务端的接口，需要Peer实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DeliverServer is the server API for Deliver service.</span></span><br><span class="line"><span class="keyword">type</span> DeliverServer <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// deliver first requires an Envelope of type ab.DELIVER_SEEK_INFO with</span></span><br><span class="line"><span class="comment">// Payload data as a marshaled orderer.SeekInfo message,</span></span><br><span class="line"><span class="comment">// then a stream of block replies is received</span></span><br><span class="line">Deliver(Deliver_DeliverServer) error</span><br><span class="line"><span class="comment">// deliver first requires an Envelope of type ab.DELIVER_SEEK_INFO with</span></span><br><span class="line"><span class="comment">// Payload data as a marshaled orderer.SeekInfo message,</span></span><br><span class="line"><span class="comment">// then a stream of **filtered** block replies is received</span></span><br><span class="line">DeliverFiltered(Deliver_DeliverFilteredServer) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Peer-event源码"><a href="#Peer-event源码" class="headerlink" title="Peer event源码"></a>Peer event源码</h2><p>Peer干了这么几件事：</p><ol><li>注册gRPC服务，即注册接受客户端发来的事件订阅的函数</li><li>gRPC收到消息，订阅相应事件注册处理函数</li><li>处理函数持续向客户端发送区块事件，直到结束</li></ol><h3 id="添加Deliver服务"><a href="#添加Deliver服务" class="headerlink" title="添加Deliver服务"></a>添加Deliver服务</h3><p><code>serve</code>是Peer启动后的运行的主函数，它会创建gRPC server，以及创建DeliverEvent server，并把它绑定到gRPC server上。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// peer/node/start.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serve</span><span class="params">(args []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 创建peer的gRPC server</span></span><br><span class="line">    peerServer, err := peer.NewPeerServer(listenAddr, serverConfig)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        logger.Fatalf(<span class="string">"Failed to create peer server (%s)"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 创建和启动基于gRPC的event deliver server</span></span><br><span class="line">    abServer := peer.NewDeliverEventsServer(mutualTLS, policyCheckerProvider, &amp;peer.DeliverChainManager&#123;&#125;, metricsProvider)</span><br><span class="line">    pb.RegisterDeliverServer(peerServer.Server(), abServer)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建DeliverEventsServer，实际是创建好处理事件订阅的handler。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core/peer/deliverevents.go</span></span><br><span class="line"><span class="comment">// NewDeliverEventsServer creates a peer.Deliver server to deliver block and</span></span><br><span class="line"><span class="comment">// filtered block events</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDeliverEventsServer</span><span class="params">(mutualTLS <span class="keyword">bool</span>, policyCheckerProvider PolicyCheckerProvider, chainManager deliver.ChainManager, metricsProvider metrics.Provider)</span> <span class="title">peer</span>.<span class="title">DeliverServer</span></span> &#123;</span><br><span class="line">timeWindow := viper.GetDuration(<span class="string">"peer.authentication.timewindow"</span>)</span><br><span class="line"><span class="keyword">if</span> timeWindow == <span class="number">0</span> &#123;</span><br><span class="line">defaultTimeWindow := <span class="number">15</span> * time.Minute</span><br><span class="line">logger.Warningf(<span class="string">"`peer.authentication.timewindow` not set; defaulting to %s"</span>, defaultTimeWindow)</span><br><span class="line">timeWindow = defaultTimeWindow</span><br><span class="line">&#125;</span><br><span class="line">metrics := deliver.NewMetrics(metricsProvider)</span><br><span class="line"><span class="keyword">return</span> &amp;server&#123;</span><br><span class="line"><span class="comment">// 创建handler</span></span><br><span class="line">dh:                    deliver.NewHandler(chainManager, timeWindow, mutualTLS, metrics),</span><br><span class="line">policyCheckerProvider: policyCheckerProvider,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewHandler creates an implementation of the Handler interface.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewHandler</span><span class="params">(cm ChainManager, timeWindow time.Duration, mutualTLS <span class="keyword">bool</span>, metrics *Metrics)</span> *<span class="title">Handler</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Handler&#123;</span><br><span class="line">ChainManager:     cm,</span><br><span class="line">TimeWindow:       timeWindow,</span><br><span class="line">BindingInspector: InspectorFunc(comm.NewBindingInspector(mutualTLS, ExtractChannelHeaderCertHash)),</span><br><span class="line">Metrics:          metrics,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>server</code>实现了<code>DeliverServer</code>接口，当gRPC接收到事件注册时，就可以调用Deliver或者FilteredDeliver被调用时，就调用server的<code>DeliverFiltered</code>或者<code>Deliver</code>函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// server holds the dependencies necessary to create a deliver server</span><br><span class="line">type server struct &#123;</span><br><span class="line">dh                    *deliver.Handler</span><br><span class="line">policyCheckerProvider PolicyCheckerProvider</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接收事件订阅"><a href="#接收事件订阅" class="headerlink" title="接收事件订阅"></a>接收事件订阅</h3><p>BlockEvent的注册和事件处理主要流程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server.Deliver -&gt; Handler.Handle -&gt;</span><br><span class="line">deliverBlocks -&gt; SendBlockResponse -&gt; blockResponseSender.SendBlockResponse -&gt; gRPC生成的server Send函数</span><br></pre></td></tr></table></figure><p>FilteredBlockEvent的注册和事件处理主要流程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server.DeliverFiltered -&gt; Handler.Handle -&gt;</span><br><span class="line">deliverBlocks -&gt; SendBlockResponse -&gt; filteredBlockResponseSender.SendBlockResponseg -&gt; RPC生成的server Send函数</span><br></pre></td></tr></table></figure><p>它们2个流程是类似的，下面就以BlockEvent的流程介绍。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Deliver sends a stream of blocks to a client after commitment</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span> <span class="title">Deliver</span><span class="params">(srv peer.Deliver_DeliverServer)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">logger.Debugf(<span class="string">"Starting new Deliver handler"</span>)</span><br><span class="line"><span class="keyword">defer</span> dumpStacktraceOnPanic()</span><br><span class="line"><span class="comment">// getting policy checker based on resources.Event_Block resource name</span></span><br><span class="line">deliverServer := &amp;deliver.Server&#123;</span><br><span class="line">PolicyChecker: s.policyCheckerProvider(resources.Event_Block),</span><br><span class="line">Receiver:      srv,</span><br><span class="line"><span class="comment">// 创建了sender</span></span><br><span class="line">ResponseSender: &amp;blockResponseSender&#123;</span><br><span class="line">Deliver_DeliverServer: srv,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s.dh.Handle(srv.Context(), deliverServer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handle receives incoming deliver requests.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Handler)</span> <span class="title">Handle</span><span class="params">(ctx context.Context, srv *Server)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">addr := util.ExtractRemoteAddress(ctx)</span><br><span class="line">logger.Debugf(<span class="string">"Starting new deliver loop for %s"</span>, addr)</span><br><span class="line">h.Metrics.StreamsOpened.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">defer</span> h.Metrics.StreamsClosed.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">logger.Debugf(<span class="string">"Attempting to read seek info message from %s"</span>, addr)</span><br><span class="line">envelope, err := srv.Recv()</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">logger.Debugf(<span class="string">"Received EOF from %s, hangup"</span>, addr)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logger.Warningf(<span class="string">"Error reading from %s: %s"</span>, addr, err)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主体</span></span><br><span class="line">status, err := h.deliverBlocks(ctx, srv, envelope)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = srv.SendStatusResponse(status)</span><br><span class="line"><span class="keyword">if</span> status != cb.Status_SUCCESS &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">logger.Warningf(<span class="string">"Error sending to %s: %s"</span>, addr, err)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logger.Debugf(<span class="string">"Waiting for new SeekInfo from %s"</span>, addr)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>deliverBlocks</code>的主要作用就是不停的获取区块，然后调用sender发送事件，其中还包含了事件订阅信息的获取，错误处理等。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Handler)</span> <span class="title">deliverBlocks</span><span class="params">(ctx context.Context, srv *Server, envelope *cb.Envelope)</span> <span class="params">(status cb.Status, err error)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">var</span> block *cb.Block</span><br><span class="line"><span class="keyword">var</span> status cb.Status</span><br><span class="line"></span><br><span class="line">iterCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 获取下一个区块，当账本Append Block时，就可以拿到要写入到账本的区块</span></span><br><span class="line">block, status = cursor.Next()</span><br><span class="line"><span class="built_in">close</span>(iterCh)</span><br><span class="line">&#125;()</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 发送区块</span></span><br><span class="line"><span class="keyword">if</span> err := srv.SendBlockResponse(block); err != <span class="literal">nil</span> &#123;</span><br><span class="line">logger.Warningf(<span class="string">"[channel: %s] Error sending to %s: %s"</span>, chdr.ChannelId, addr, err)</span><br><span class="line"><span class="keyword">return</span> cb.Status_INTERNAL_SERVER_ERROR, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h.Metrics.BlocksSent.With(labels...).Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止判断</span></span><br><span class="line"><span class="keyword">if</span> stopNum == block.Header.Number &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Iterator</code>接口用来获取区块.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Iterator is useful for a chain Reader to stream blocks as they are created</span></span><br><span class="line"><span class="keyword">type</span> Iterator <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// Next blocks until there is a new block available, or returns an error if</span></span><br><span class="line"><span class="comment">// the next block is no longer retrievable</span></span><br><span class="line">Next() (*cb.Block, cb.Status)</span><br><span class="line"><span class="comment">// Close releases resources acquired by the Iterator</span></span><br><span class="line">Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Fabric有3种类型的账本：ram、json和file，它们都实现了这个接口，这里主要是为了辅助解释事件机制，我们看一个最简单的：ram的实现。</p><p><code>Next()</code>拿到的区块是从<code>simpleList.SetNext()</code>存进去的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Next blocks until there is a new block available, or returns an error if the</span></span><br><span class="line"><span class="comment">// next block is no longer retrievable</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cu *cursor)</span> <span class="title">Next</span><span class="params">()</span> <span class="params">(*cb.Block, cb.Status)</span></span> &#123;</span><br><span class="line"><span class="comment">// This only loops once, as signal reading indicates non-nil next</span></span><br><span class="line"><span class="comment">// 实际只执行1次</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 拿到区块</span></span><br><span class="line">next := cu.list.getNext()</span><br><span class="line"><span class="keyword">if</span> next != <span class="literal">nil</span> &#123;</span><br><span class="line">cu.list = next</span><br><span class="line"><span class="keyword">return</span> cu.list.block, cb.Status_SUCCESS</span><br><span class="line">&#125;</span><br><span class="line">&lt;-cu.list.signal</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *simpleList)</span> <span class="title">getNext</span><span class="params">()</span> *<span class="title">simpleList</span></span> &#123;</span><br><span class="line">s.lock.RLock()</span><br><span class="line"><span class="keyword">defer</span> s.lock.RUnlock()</span><br><span class="line"><span class="keyword">return</span> s.next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *simpleList)</span> <span class="title">setNext</span><span class="params">(n *simpleList)</span></span> &#123;</span><br><span class="line">s.lock.Lock()</span><br><span class="line"><span class="keyword">defer</span> s.lock.Unlock()</span><br><span class="line">s.next = n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Append()</code>是账本对外提供的接口，当要把区块追加到账本时，会调用此函数，该函数会调用<code>setNext()</code>设置待追加的区块。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Append appends a new block to the ledger</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rl *ramLedger)</span> <span class="title">Append</span><span class="params">(block *cb.Block)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">rl.lock.Lock()</span><br><span class="line"><span class="keyword">defer</span> rl.lock.Unlock()</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">rl.appendBlock(block)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rl *ramLedger)</span> <span class="title">appendBlock</span><span class="params">(block *cb.Block)</span></span> &#123;</span><br><span class="line">next := &amp;simpleList&#123;</span><br><span class="line">signal: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">block:  block,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置最新的区块</span></span><br><span class="line">rl.newest.setNext(next)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发送事件消息"><a href="#发送事件消息" class="headerlink" title="发送事件消息"></a>发送事件消息</h3><p><code>blockResponseSender.SendBlockResponse</code>是BlockEvent的事件发送函数，实际就是调用gRPC生成的函数。</p><p><code>blockResponseSender</code>是在<code>server.Deliver</code>中创建的，它实际就是<code>peer.Deliver_DeliverServer</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// blockResponseSender structure used to send block responses</span></span><br><span class="line"><span class="keyword">type</span> blockResponseSender <span class="keyword">struct</span> &#123;</span><br><span class="line">peer.Deliver_DeliverServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SendBlockResponse generates deliver response with block message</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(brs *blockResponseSender)</span> <span class="title">SendBlockResponse</span><span class="params">(block *common.Block)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">response := &amp;peer.DeliverResponse&#123;</span><br><span class="line">Type: &amp;peer.DeliverResponse_Block&#123;Block: block&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> brs.Send(response)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Go-SDK源码"><a href="#Go-SDK源码" class="headerlink" title="Go SDK源码"></a>Go SDK源码</h2><p>社区正在重构fabric-sdk-go，所以这里不着重介绍sdk的源码了，提醒几个重要的点，可能以后还有。</p><p><code>Deliver</code>和<code>DeliverFiltered</code>被封装成了2个全局函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">// Deliver creates a Deliver stream</span><br><span class="line">Deliver = func(client pb.DeliverClient) (deliverStream, error) &#123;</span><br><span class="line">return client.Deliver(context.Background())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// DeliverFiltered creates a DeliverFiltered stream</span><br><span class="line">DeliverFiltered = func(client pb.DeliverClient) (deliverStream, error) &#123;</span><br><span class="line">return client.DeliverFiltered(context.Background())</span><br><span class="line">&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>它们会被调用，进一步封装成provider，provider会为dispatch服务：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// deliverProvider is the connection provider used for connecting to the Deliver service</span></span><br><span class="line"><span class="keyword">var</span> deliverProvider = <span class="function"><span class="keyword">func</span><span class="params">(context fabcontext.Client, chConfig fab.ChannelCfg, peer fab.Peer)</span> <span class="params">(api.Connection, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> peer == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"Peer is nil"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">eventEndpoint, ok := peer.(api.EventEndpoint)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"peer is not an EventEndpoint"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> deliverconn.New(context, chConfig, deliverconn.Deliver, peer.URL(), eventEndpoint.Opts()...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h3><p><code>Dispatcher</code>会保存BlockEvent和FilteredBlockEvent的注册，以及用2个map<code>txRegistrations</code>和<code>ccRegistrations</code>保存交易和Chaincode Event的注册，<code>handlers</code>是各种注册事件的处理函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dispatcher is responsible for handling all events, including connection and registration events originating from the client,</span></span><br><span class="line"><span class="comment">// and events originating from the channel event service. All events are processed in a single Go routine</span></span><br><span class="line"><span class="comment">// in order to avoid any race conditions and to ensure that events are processed in the order in which they are received.</span></span><br><span class="line"><span class="comment">// This also avoids the need for synchronization.</span></span><br><span class="line"><span class="comment">// The lastBlockNum member MUST be first to ensure it stays 64-bit aligned on 32-bit machines.</span></span><br><span class="line"><span class="keyword">type</span> Dispatcher <span class="keyword">struct</span> &#123;</span><br><span class="line">lastBlockNum <span class="keyword">uint64</span> <span class="comment">// Must be first, do not move</span></span><br><span class="line">params</span><br><span class="line">updateLastBlockInfoOnly    <span class="keyword">bool</span></span><br><span class="line">state                      <span class="keyword">int32</span></span><br><span class="line">eventch                    <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">blockRegistrations         []*BlockReg</span><br><span class="line">filteredBlockRegistrations []*FilteredBlockReg</span><br><span class="line">handlers                   <span class="keyword">map</span>[reflect.Type]Handler</span><br><span class="line">txRegistrations            <span class="keyword">map</span>[<span class="keyword">string</span>]*TxStatusReg</span><br><span class="line">ccRegistrations            <span class="keyword">map</span>[<span class="keyword">string</span>]*ChaincodeReg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册事件"><a href="#注册事件" class="headerlink" title="注册事件"></a>注册事件</h3><p>这是Dispatcher的事件注册函数，在它眼里，不止有4个事件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RegisterHandler registers an event handler</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ed *Dispatcher)</span> <span class="title">RegisterHandler</span><span class="params">(t <span class="keyword">interface</span>&#123;&#125;, h Handler)</span></span> &#123;</span><br><span class="line">htype := reflect.TypeOf(t)</span><br><span class="line"><span class="keyword">if</span> _, ok := ed.handlers[htype]; !ok &#123;</span><br><span class="line">logger.Debugf(<span class="string">"Registering handler for %s on dispatcher %T"</span>, htype, ed)</span><br><span class="line">ed.handlers[htype] = h</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">logger.Debugf(<span class="string">"Cannot register handler %s on dispatcher %T since it's already registered"</span>, htype, ed)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册各注册事件的处理函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RegisterHandlers registers all of the handlers by event type</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ed *Dispatcher)</span> <span class="title">RegisterHandlers</span><span class="params">()</span></span> &#123;</span><br><span class="line">ed.RegisterHandler(&amp;RegisterChaincodeEvent&#123;&#125;, ed.handleRegisterCCEvent)</span><br><span class="line">ed.RegisterHandler(&amp;RegisterTxStatusEvent&#123;&#125;, ed.handleRegisterTxStatusEvent)</span><br><span class="line">ed.RegisterHandler(&amp;RegisterBlockEvent&#123;&#125;, ed.handleRegisterBlockEvent)</span><br><span class="line">ed.RegisterHandler(&amp;RegisterFilteredBlockEvent&#123;&#125;, ed.handleRegisterFilteredBlockEvent)</span><br><span class="line">ed.RegisterHandler(&amp;UnregisterEvent&#123;&#125;, ed.handleUnregisterEvent)</span><br><span class="line">ed.RegisterHandler(&amp;StopEvent&#123;&#125;, ed.HandleStopEvent)</span><br><span class="line">ed.RegisterHandler(&amp;TransferEvent&#123;&#125;, ed.HandleTransferEvent)</span><br><span class="line">ed.RegisterHandler(&amp;StopAndTransferEvent&#123;&#125;, ed.HandleStopAndTransferEvent)</span><br><span class="line">ed.RegisterHandler(&amp;RegistrationInfoEvent&#123;&#125;, ed.handleRegistrationInfoEvent)</span><br><span class="line"></span><br><span class="line"><span class="comment">// The following events are used for testing only</span></span><br><span class="line">ed.RegisterHandler(&amp;fab.BlockEvent&#123;&#125;, ed.handleBlockEvent)</span><br><span class="line">ed.RegisterHandler(&amp;fab.FilteredBlockEvent&#123;&#125;, ed.handleFilteredBlockEvent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接收Peer事件"><a href="#接收Peer事件" class="headerlink" title="接收Peer事件"></a>接收Peer事件</h3><p><code>handleEvent</code>用来处理来自Peer的事件，不同的类型调用不同的handler。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ed *Dispatcher)</span> <span class="title">handleEvent</span><span class="params">(e esdispatcher.Event)</span></span> &#123;</span><br><span class="line">delevent := e.(*connection.Event)</span><br><span class="line">evt := delevent.Event.(*pb.DeliverResponse)</span><br><span class="line"><span class="keyword">switch</span> response := evt.Type.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> *pb.DeliverResponse_Status:</span><br><span class="line">ed.handleDeliverResponseStatus(response)</span><br><span class="line"><span class="keyword">case</span> *pb.DeliverResponse_Block:</span><br><span class="line">ed.HandleBlock(response.Block, delevent.SourceURL)</span><br><span class="line"><span class="keyword">case</span> *pb.DeliverResponse_FilteredBlock:</span><br><span class="line">ed.HandleFilteredBlock(response.FilteredBlock, delevent.SourceURL)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">logger.Errorf(<span class="string">"handler not found for deliver response type %T"</span>, response)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>HandleBlock</code>把Event封装是BlockEvent退给应用。可以看到BlockEvent也会发布FilteredBlockEvent。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HandleBlock handles a block event</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ed *Dispatcher)</span> <span class="title">HandleBlock</span><span class="params">(block *cb.Block, sourceURL <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">logger.Debugf(<span class="string">"Handling block event - Block #%d"</span>, block.Header.Number)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := ed.updateLastBlockNum(block.Header.Number); err != <span class="literal">nil</span> &#123;</span><br><span class="line">logger.Error(err.Error())</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ed.updateLastBlockInfoOnly &#123;</span><br><span class="line">ed.updateLastBlockInfoOnly = <span class="literal">false</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logger.Debug(<span class="string">"Publishing block event..."</span>)</span><br><span class="line">ed.publishBlockEvents(block, sourceURL)</span><br><span class="line">ed.publishFilteredBlockEvents(toFilteredBlock(block), sourceURL)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ed *Dispatcher)</span> <span class="title">publishBlockEvents</span><span class="params">(block *cb.Block, sourceURL <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, reg := <span class="keyword">range</span> ed.blockRegistrations &#123;</span><br><span class="line"><span class="keyword">if</span> !reg.Filter(block) &#123;</span><br><span class="line">logger.Debugf(<span class="string">"Not sending block event for block #%d since it was filtered out."</span>, block.Header.Number)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ed.eventConsumerTimeout &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> reg.Eventch &lt;- NewBlockEvent(block, sourceURL):</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">logger.Warn(<span class="string">"Unable to send to block event channel."</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ed.eventConsumerTimeout == <span class="number">0</span> &#123;</span><br><span class="line">reg.Eventch &lt;- NewBlockEvent(block, sourceURL)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> reg.Eventch &lt;- NewBlockEvent(block, sourceURL):</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(ed.eventConsumerTimeout):</span><br><span class="line">logger.Warn(<span class="string">"Timed out sending block event."</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FilteredBlockEvent能解析出TransactionEvent和ChaincodeEvent：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ed *Dispatcher)</span> <span class="title">publishFilteredBlockEvents</span><span class="params">(fblock *pb.FilteredBlock, sourceURL <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> fblock == <span class="literal">nil</span> &#123;</span><br><span class="line">logger.Warn(<span class="string">"Filtered block is nil. Event will not be published"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logger.Debugf(<span class="string">"Publishing filtered block event: %#v"</span>, fblock)</span><br><span class="line"></span><br><span class="line">checkFilteredBlockRegistrations(ed, fblock, sourceURL)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, tx := <span class="keyword">range</span> fblock.FilteredTransactions &#123;</span><br><span class="line"><span class="comment">// 发布交易订阅</span></span><br><span class="line">ed.publishTxStatusEvents(tx, fblock.Number, sourceURL)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Only send a chaincode event if the transaction has committed</span></span><br><span class="line"><span class="keyword">if</span> tx.TxValidationCode == pb.TxValidationCode_VALID &#123;</span><br><span class="line">txActions := tx.GetTransactionActions()</span><br><span class="line"><span class="keyword">if</span> txActions == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(txActions.ChaincodeActions) == <span class="number">0</span> &#123;</span><br><span class="line">logger.Debugf(<span class="string">"No chaincode action found for TxID[%s], block[%d], source URL[%s]"</span>, tx.Txid, fblock.Number, sourceURL)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, action := <span class="keyword">range</span> txActions.ChaincodeActions &#123;</span><br><span class="line"><span class="keyword">if</span> action.ChaincodeEvent != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 发布chaincode event订阅</span></span><br><span class="line">ed.publishCCEvents(action.ChaincodeEvent, fblock.Number, sourceURL)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">logger.Debugf(<span class="string">"Cannot publish CCEvents for block[%d] and source URL[%s] since Tx Validation Code[%d] is not valid"</span>, fblock.Number, sourceURL, tx.TxValidationCode)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ed *Dispatcher)</span> <span class="title">publishTxStatusEvents</span><span class="params">(tx *pb.FilteredTransaction, blockNum <span class="keyword">uint64</span>, sourceURL <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">logger.Debugf(<span class="string">"Publishing Tx Status event for TxID [%s]..."</span>, tx.Txid)</span><br><span class="line"><span class="keyword">if</span> reg, ok := ed.txRegistrations[tx.Txid]; ok &#123;</span><br><span class="line">logger.Debugf(<span class="string">"Sending Tx Status event for TxID [%s] to registrant..."</span>, tx.Txid)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ed.eventConsumerTimeout &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> reg.Eventch &lt;- NewTxStatusEvent(tx.Txid, tx.TxValidationCode, blockNum, sourceURL):</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">logger.Warn(<span class="string">"Unable to send to Tx Status event channel."</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ed.eventConsumerTimeout == <span class="number">0</span> &#123;</span><br><span class="line">reg.Eventch &lt;- NewTxStatusEvent(tx.Txid, tx.TxValidationCode, blockNum, sourceURL)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> reg.Eventch &lt;- NewTxStatusEvent(tx.Txid, tx.TxValidationCode, blockNum, sourceURL):</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(ed.eventConsumerTimeout):</span><br><span class="line">logger.Warn(<span class="string">"Timed out sending Tx Status event."</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ed *Dispatcher)</span> <span class="title">publishCCEvents</span><span class="params">(ccEvent *pb.ChaincodeEvent, blockNum <span class="keyword">uint64</span>, sourceURL <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, reg := <span class="keyword">range</span> ed.ccRegistrations &#123;</span><br><span class="line">logger.Debugf(<span class="string">"Matching CCEvent[%s,%s] against Reg[%s,%s] ..."</span>, ccEvent.ChaincodeId, ccEvent.EventName, reg.ChaincodeID, reg.EventFilter)</span><br><span class="line"><span class="keyword">if</span> reg.ChaincodeID == ccEvent.ChaincodeId &amp;&amp; reg.EventRegExp.MatchString(ccEvent.EventName) &#123;</span><br><span class="line">logger.Debugf(<span class="string">"... matched CCEvent[%s,%s] against Reg[%s,%s]"</span>, ccEvent.ChaincodeId, ccEvent.EventName, reg.ChaincodeID, reg.EventFilter)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ed.eventConsumerTimeout &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> reg.Eventch &lt;- NewChaincodeEvent(ccEvent.ChaincodeId, ccEvent.EventName, ccEvent.TxId, ccEvent.Payload, blockNum, sourceURL):</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">logger.Warn(<span class="string">"Unable to send to CC event channel."</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ed.eventConsumerTimeout == <span class="number">0</span> &#123;</span><br><span class="line">reg.Eventch &lt;- NewChaincodeEvent(ccEvent.ChaincodeId, ccEvent.EventName, ccEvent.TxId, ccEvent.Payload, blockNum, sourceURL)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> reg.Eventch &lt;- NewChaincodeEvent(ccEvent.ChaincodeId, ccEvent.EventName, ccEvent.TxId, ccEvent.Payload, blockNum, sourceURL):</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(ed.eventConsumerTimeout):</span><br><span class="line">logger.Warn(<span class="string">"Timed out sending CC event."</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了：</p><ol><li>Peer支持的2类Even，</li><li>Peer是如何支持事件订阅，和发送事件的，</li><li>SDK支持的4类Event，这4类Event和Peer的2类Event的关系</li><li>SDK和Peer之间的gRPC通信</li></ol><p>更多SDK事件的使用，请参考<a href="https://godoc.org/github.com/hyperledger/fabric-sdk-go/pkg/client/event#New" target="_blank" rel="noopener">文档</a>。</p><p>Fabric事件介绍的[官方文档(<a href="https://stone-fabric.readthedocs.io/zh/latest/peer_event_services.html)。" target="_blank" rel="noopener">https://stone-fabric.readthedocs.io/zh/latest/peer_event_services.html)。</a></p><p>Fabric在examples中还提供了一个<a href="https://github.com/hyperledger/fabric/tree/release-1.4/examples/events/eventsclient" target="_blank" rel="noopener">eventclient</a>样例，看这个样例更有助于理解Fabric event的原理，以及是如何交互的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Event是应用和Fabric网络交互的一种方式，应用可以通过&lt;strong&gt;SDK&lt;/strong&gt;向&lt;strong&gt;Peer&lt;/stro
      
    
    </summary>
    
    
    
      <category term="区块链" scheme="http://lessisbetter.site/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Fabric" scheme="http://lessisbetter.site/tags/Fabric/"/>
    
  </entry>
  
  <entry>
    <title>Fabric 1.4源码解读 2：系统链码SCC是如何部署的</title>
    <link href="http://lessisbetter.site/2019/09/11/fabric-deploy-scc/"/>
    <id>http://lessisbetter.site/2019/09/11/fabric-deploy-scc/</id>
    <published>2019-09-11T03:37:27.000Z</published>
    <updated>2019-09-11T06:28:37.317Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一份Peer节点启动的INFO级别日志如下，可以发现：</p><ol><li>先注册了scc目录下的lscc, cscc, qscc，未注册chaincode目录下的lifecycle</li><li>然后又依次部署了上述scc。</li></ol><p>本文的目的就是梳理出，系统链码的部署流程，这是peer节点提供背书、链码管理、配置、查询等功能的基础。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">2019-09-09 07:52:09.409 UTC [gossip.gossip] start -&gt; INFO 013 Gossip instance peer1.org1.example.com:8051 started</span><br><span class="line">2019-09-09 07:52:09.418 UTC [sccapi] deploySysCC -&gt; INFO 014 system chaincode lscc/(github.com/hyperledger/fabric/core/scc/lscc) deployed</span><br><span class="line">2019-09-09 07:52:09.420 UTC [cscc] Init -&gt; INFO 015 Init CSCC</span><br><span class="line">2019-09-09 07:52:09.422 UTC [sccapi] deploySysCC -&gt; INFO 016 system chaincode cscc/(github.com/hyperledger/fabric/core/scc/cscc) deployed</span><br><span class="line">2019-09-09 07:52:09.424 UTC [qscc] Init -&gt; INFO 017 Init QSCC</span><br><span class="line">2019-09-09 07:52:09.424 UTC [sccapi] deploySysCC -&gt; INFO 018 system chaincode qscc/(github.com/hyperledger/fabric/core/scc/qscc) deployed</span><br><span class="line">2019-09-09 07:52:09.425 UTC [sccapi] deploySysCC -&gt; INFO 019 system chaincode (+lifecycle,github.com/hyperledger/fabric/core/chaincode/lifecycle) disabled</span><br><span class="line">...</span><br><span class="line">2019-09-09 07:52:14.386 UTC [sccapi] deploySysCC -&gt; INFO 031 system chaincode lscc/mychannel(github.com/hyperledger/fabric/core/scc/lscc) deployed</span><br><span class="line">2019-09-09 07:52:14.386 UTC [cscc] Init -&gt; INFO 032 Init CSCC</span><br><span class="line">2019-09-09 07:52:14.386 UTC [sccapi] deploySysCC -&gt; INFO 033 system chaincode cscc/mychannel(github.com/hyperledger/fabric/core/scc/cscc) deployed</span><br><span class="line">2019-09-09 07:52:14.387 UTC [qscc] Init -&gt; INFO 034 Init QSCC</span><br><span class="line">2019-09-09 07:52:14.387 UTC [sccapi] deploySysCC -&gt; INFO 035 system chaincode qscc/mychannel(github.com/hyperledger/fabric/core/scc/qscc) deployed</span><br><span class="line">2019-09-09 07:52:14.387 UTC [sccapi] deploySysCC -&gt; INFO 036 system chaincode (+lifecycle,github.com/hyperledger/fabric/core/chaincode/lifecycle) disabled</span><br></pre></td></tr></table></figure><h2 id="宏观流程"><a href="#宏观流程" class="headerlink" title="宏观流程"></a>宏观流程</h2><blockquote><p>提醒，本文使用<strong>SCC代指系统链码</strong>，使用scc代指core.scc模块。</p></blockquote><p>在介绍源码之前，先给出总体流程，以便看源码的时候不会迷失。</p><p>部署SCC会涉及到4个模块：</p><ol><li>peer.node，它是peer的主程序，可以调用core.scc进行注册和部署SCC</li><li>core.scc，它包含了lscc、qscc、cscc这3个scc，以及SCC的注册和部署</li><li>core.chaincode，它是链码管理，普通链码和SCC都会走该模块，去部署和调用链码，和链码容器交互，并且它还提供了1个链码容器的工具shim</li><li>core.container，它是实现链码容器，有2种链码容器，SCC使用的InprocVM，和普通链码使用的DockerVM</li></ol><p>注册和部署的简要流程如下：</p><p><img src="http://img.lessisbetter.site/2019-09-deploy-scc-flow.png" alt=""></p><ol><li>peer运行启动程序</li><li>注册scc<ol><li>peer.node创建好lscc、cscc、qscc等scc实例，以及从配置文件读取的scc</li><li>peer.node调用core.scc依次注册每一个scc实例</li><li>core.scc调用core.container把scc实例信息注册到container</li></ol></li><li>部署scc<ol><li>peer.node调用core.scc依次部署每一个注册的scc</li><li>core.scc部署scc的流程复用普通链码部署流程，调用core.chaincode</li><li>core.chaincode执行启动链码容器，scc也有链码容器是Inproc类型，不是Docker类型</li><li>core.chaincode会调用core.container建立scc的Inproc容器实例</li><li>core.container调用core.chaincode.shim启动容器内的程序，并负责和peer通信</li><li>启动完成后，core.chaincode向容器发送Init消息，让容器初始化，容器初始化完成会发送响应消息给core.chaincode，core.chaincode部署scc完成</li></ol></li></ol><h2 id="总流程"><a href="#总流程" class="headerlink" title="总流程"></a>总流程</h2><blockquote><p>列出源码的过程，会省略大量不相关代码，用<code>...</code>代替。</p></blockquote><p>peer启动过程中，会调用<code>node.serve</code>，其中包含了为系统链码注册SCC和部署SCC。之后，还会为应用通道部署SCC，说明每个通道有各自的SCC，这里省略掉这部分。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serve</span><span class="params">(args []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 获取support，会注册SCC</span></span><br><span class="line">    <span class="comment">// Initialize chaincode service</span></span><br><span class="line">    chaincodeSupport, ccp, sccp, packageProvider := startChaincodeServer(peerHost, aclProvider, pr, opsSystem)</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 为系统通道部署已经注册的SCC</span></span><br><span class="line">    <span class="comment">// deploy system chaincodes</span></span><br><span class="line">sccp.DeploySysCCs(<span class="string">""</span>, ccp)</span><br><span class="line">logger.Infof(<span class="string">"Deployed system chaincodes"</span>)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注册SCC"><a href="#注册SCC" class="headerlink" title="注册SCC"></a>注册SCC</h2><p>注册SCC的流程：</p><p>peer.node -&gt; core.scc -&gt; core.container</p><h3 id="peer-node"><a href="#peer-node" class="headerlink" title="peer.node"></a>peer.node</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// startChaincodeServer will finish chaincode related initialization, including:</span></span><br><span class="line"><span class="comment">// 1) setup local chaincode install path</span></span><br><span class="line"><span class="comment">// 2) create chaincode specific tls CA</span></span><br><span class="line"><span class="comment">// 3) start the chaincode specific gRPC listening service</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startChaincodeServer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">peerHost <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">aclProvider aclmgmt.ACLProvider,</span></span></span><br><span class="line"><span class="function"><span class="params">pr *platforms.Registry,</span></span></span><br><span class="line"><span class="function"><span class="params">ops *operations.System,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(*chaincode.ChaincodeSupport, ccprovider.ChaincodeProvider, *scc.Provider, *persistence.PackageProvider)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="comment">// 会注册SCC</span></span><br><span class="line">chaincodeSupport, ccp, sccp := registerChaincodeSupport(</span><br><span class="line">ccSrv,</span><br><span class="line">ccEndpoint,</span><br><span class="line">ca,</span><br><span class="line">packageProvider,</span><br><span class="line">aclProvider,</span><br><span class="line">pr,</span><br><span class="line">lifecycleSCC,</span><br><span class="line">ops,</span><br><span class="line">)</span><br><span class="line"><span class="keyword">go</span> ccSrv.Start()</span><br><span class="line"><span class="keyword">return</span> chaincodeSupport, ccp, sccp, packageProvider</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">registerChaincodeSupport</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">grpcServer *comm.GRPCServer,</span></span></span><br><span class="line"><span class="function"><span class="params">ccEndpoint <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">ca tlsgen.CA,</span></span></span><br><span class="line"><span class="function"><span class="params">packageProvider *persistence.PackageProvider,</span></span></span><br><span class="line"><span class="function"><span class="params">aclProvider aclmgmt.ACLProvider,</span></span></span><br><span class="line"><span class="function"><span class="params">pr *platforms.Registry,</span></span></span><br><span class="line"><span class="function"><span class="params">lifecycleSCC *lifecycle.SCC,</span></span></span><br><span class="line"><span class="function"><span class="params">ops *operations.System,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(*chaincode.ChaincodeSupport, ccprovider.ChaincodeProvider, *scc.Provider)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// SCC的VM provider</span></span><br><span class="line">ipRegistry := inproccontroller.NewRegistry()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建SCC provider</span></span><br><span class="line">sccp := scc.NewProvider(peer.Default, peer.DefaultSupport, ipRegistry)</span><br><span class="line"><span class="comment">// 创建lscc实例</span></span><br><span class="line">    lsccInst := lscc.New(sccp, aclProvider, pr)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 普通链码，docker容器类型的VM provider</span></span><br><span class="line">dockerProvider := dockercontroller.NewProvider(</span><br><span class="line">viper.GetString(<span class="string">"peer.id"</span>),</span><br><span class="line">viper.GetString(<span class="string">"peer.networkId"</span>),</span><br><span class="line">ops.Provider,</span><br><span class="line">)</span><br><span class="line">dockerVM := dockercontroller.NewDockerVM(</span><br><span class="line">dockerProvider.PeerID,</span><br><span class="line">dockerProvider.NetworkID,</span><br><span class="line">dockerProvider.BuildMetrics,</span><br><span class="line">)</span><br><span class="line">    ...</span><br><span class="line">    chaincodeSupport := chaincode.NewChaincodeSupport(</span><br><span class="line">chaincode.GlobalConfig(),</span><br><span class="line">ccEndpoint,</span><br><span class="line">userRunsCC,</span><br><span class="line">ca.CertBytes(),</span><br><span class="line">authenticator,</span><br><span class="line">packageProvider,</span><br><span class="line">lsccInst, <span class="comment">// chaincodeSupport的声明周期管理使用了lscc，而不是lifecycle</span></span><br><span class="line">aclProvider,</span><br><span class="line">container.NewVMController(</span><br><span class="line"><span class="keyword">map</span>[<span class="keyword">string</span>]container.VMProvider&#123;</span><br><span class="line">dockercontroller.ContainerType: dockerProvider,</span><br><span class="line">inproccontroller.ContainerType: ipRegistry,</span><br><span class="line">&#125;,</span><br><span class="line">),</span><br><span class="line">sccp,</span><br><span class="line">pr,</span><br><span class="line">peer.DefaultSupport,</span><br><span class="line">ops.Provider,</span><br><span class="line">)</span><br><span class="line">ipRegistry.ChaincodeSupport = chaincodeSupport</span><br><span class="line"><span class="comment">// chaincode provider，可以用来创建cscc</span></span><br><span class="line">ccp := chaincode.NewProvider(chaincodeSupport)</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 创建cscc、qscc</span></span><br><span class="line">csccInst := cscc.New(ccp, sccp, aclProvider)</span><br><span class="line">qsccInst := qscc.New(aclProvider)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Now that chaincode is initialized, register all system chaincodes.</span></span><br><span class="line">sccs := scc.CreatePluginSysCCs(sccp)</span><br><span class="line"><span class="comment">// 加入lscc、cscc、qscc</span></span><br><span class="line"><span class="comment">// lifecycleSCC在1.4中disable了</span></span><br><span class="line"><span class="comment">// sccs是用户自定义的系统链码</span></span><br><span class="line"><span class="keyword">for</span> _, cc := <span class="keyword">range</span> <span class="built_in">append</span>([]scc.SelfDescribingSysCC&#123;lsccInst, csccInst, qsccInst, lifecycleSCC&#125;, sccs...) &#123;</span><br><span class="line"><span class="comment">// 注册每一个SCC</span></span><br><span class="line">sccp.RegisterSysCC(cc)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">return</span> chaincodeSupport, ccp, sccp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="core-scc"><a href="#core-scc" class="headerlink" title="core.scc"></a>core.scc</h3><p>注册某1个系统合约。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Provider implements sysccprovider.SystemChaincodeProvider</span></span><br><span class="line"><span class="keyword">type</span> Provider <span class="keyword">struct</span> &#123;</span><br><span class="line">Peer        peer.Operations</span><br><span class="line">PeerSupport peer.Support</span><br><span class="line">Registrar   Registrar             <span class="comment">// 注册</span></span><br><span class="line">SysCCs      []SelfDescribingSysCC <span class="comment">// 注册的scc，包含失败的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RegisterSysCC registers a system chaincode with the syscc provider.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Provider)</span> <span class="title">RegisterSysCC</span><span class="params">(scc SelfDescribingSysCC)</span></span> &#123;</span><br><span class="line"><span class="comment">// 收集/注册scc到scc provider</span></span><br><span class="line">p.SysCCs = <span class="built_in">append</span>(p.SysCCs, scc)</span><br><span class="line">_, err := p.registerSysCC(scc)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">sysccLogger.Panicf(<span class="string">"Could not register system chaincode: %s"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// registerSysCC registers the given system chaincode with the peer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Provider)</span> <span class="title">registerSysCC</span><span class="params">(syscc SelfDescribingSysCC)</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// 检测该scc是否开启或不在白名单</span></span><br><span class="line"><span class="keyword">if</span> !syscc.Enabled() || !isWhitelisted(syscc) &#123;</span><br><span class="line">sysccLogger.Info(fmt.Sprintf(<span class="string">"system chaincode (%s,%s,%t) disabled"</span>, syscc.Name(), syscc.Path(), syscc.Enabled()))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// XXX This is an ugly hack, version should be tied to the chaincode instance, not he peer binary</span></span><br><span class="line">version := util.GetSysCCVersion()</span><br><span class="line"></span><br><span class="line"><span class="comment">// cc的描述信息</span></span><br><span class="line">ccid := &amp;ccintf.CCID&#123;</span><br><span class="line">Name:    syscc.Name(),</span><br><span class="line">Version: version,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注册scc的chaincode</span></span><br><span class="line">err := p.Registrar.Register(ccid, syscc.Chaincode())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">//if the type is registered, the instance may not be... keep going</span></span><br><span class="line"><span class="keyword">if</span> _, ok := err.(inproccontroller.SysCCRegisteredErr); !ok &#123;</span><br><span class="line">errStr := fmt.Sprintf(<span class="string">"could not register (%s,%v): %s"</span>, syscc.Path(), syscc, err)</span><br><span class="line">sysccLogger.Error(errStr)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, fmt.Errorf(errStr)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sysccLogger.Infof(<span class="string">"system chaincode %s(%s) registered"</span>, syscc.Name(), syscc.Path())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Registrar provides a way for system chaincodes to be registered</span></span><br><span class="line"><span class="keyword">type</span> Registrar <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// Register registers a system chaincode</span></span><br><span class="line">Register(ccid *ccintf.CCID, cc shim.Chaincode) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="core-container"><a href="#core-container" class="headerlink" title="core.container"></a>core.container</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Register registers system chaincode with given path. The deploy should be called to initialize</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Registry)</span> <span class="title">Register</span><span class="params">(ccid *ccintf.CCID, cc shim.Chaincode)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">r.mutex.Lock()</span><br><span class="line"><span class="keyword">defer</span> r.mutex.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册系统链码</span></span><br><span class="line">name := ccid.GetName()</span><br><span class="line">inprocLogger.Debugf(<span class="string">"Registering chaincode instance: %s"</span>, name)</span><br><span class="line">tmp := r.typeRegistry[name]</span><br><span class="line"><span class="keyword">if</span> tmp != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> SysCCRegisteredErr(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r.typeRegistry[name] = &amp;inprocContainer&#123;chaincode: cc&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Registry stores registered system chaincodes.</span></span><br><span class="line"><span class="comment">// It implements container.VMProvider and scc.Registrar</span></span><br><span class="line"><span class="keyword">type</span> Registry <span class="keyword">struct</span> &#123;</span><br><span class="line">mutex        sync.Mutex</span><br><span class="line">typeRegistry <span class="keyword">map</span>[<span class="keyword">string</span>]*inprocContainer <span class="comment">// 已注册链码映射</span></span><br><span class="line">instRegistry <span class="keyword">map</span>[<span class="keyword">string</span>]*inprocContainer <span class="comment">// 链码示例映射</span></span><br><span class="line"></span><br><span class="line">ChaincodeSupport ccintf.CCSupport</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="部署SCC"><a href="#部署SCC" class="headerlink" title="部署SCC"></a>部署SCC</h2><p>部署SCC的流程：</p><p>peer.node -&gt; core.scc -&gt; core.chaincode -&gt; core.container</p><h3 id="peer-node-1"><a href="#peer-node-1" class="headerlink" title="peer.node"></a>peer.node</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serve</span><span class="params">(args []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="comment">// 为系统通道部署已经注册的SCC</span></span><br><span class="line"><span class="comment">// deploy system chaincodes</span></span><br><span class="line">sccp.DeploySysCCs(<span class="string">""</span>, ccp)</span><br><span class="line">    logger.Infof(<span class="string">"Deployed system chaincodes"</span>)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="core-scc-1"><a href="#core-scc-1" class="headerlink" title="core.scc"></a>core.scc</h3><p><code>DeploySysCCs</code>会为chainID对应的channel，部署注册过程中收集的每一个SCC，它们在<code>p.SysCCs</code>中。</p><p>部署链码实际是一笔交易，为了复用普通链码的部署流程，core.scc使用<code>deploySysCC</code>封装部署链码需要的参数，链码是实际部署，走core.chaincode流程。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DeploySysCCs is the hook for system chaincodes where system chaincodes are registered with the fabric</span></span><br><span class="line"><span class="comment">//note the chaincode must still be deployed and launched like a user chaincode will be</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Provider)</span> <span class="title">DeploySysCCs</span><span class="params">(chainID <span class="keyword">string</span>, ccp ccprovider.ChaincodeProvider)</span></span> &#123;</span><br><span class="line"><span class="comment">// 部署每一个scc</span></span><br><span class="line"><span class="keyword">for</span> _, sysCC := <span class="keyword">range</span> p.SysCCs &#123;</span><br><span class="line">deploySysCC(chainID, ccp, sysCC)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// deploySysCC deploys the given system chaincode on a chain</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deploySysCC</span><span class="params">(chainID <span class="keyword">string</span>, ccprov ccprovider.ChaincodeProvider, syscc SelfDescribingSysCC)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// disable或不在白名单的scc不执行部署</span></span><br><span class="line"><span class="keyword">if</span> !syscc.Enabled() || !isWhitelisted(syscc) &#123;</span><br><span class="line">sysccLogger.Info(fmt.Sprintf(<span class="string">"system chaincode (%s,%s) disabled"</span>, syscc.Name(), syscc.Path()))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为scc生成txid，因为部署链码的过程需要txParams，与普通链码的流程相同</span></span><br><span class="line">txid := util.GenerateUUID()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Note, this structure is barely initialized,</span></span><br><span class="line"><span class="comment">// we omit the history query executor, the proposal</span></span><br><span class="line"><span class="comment">// and the signed proposal</span></span><br><span class="line">txParams := &amp;ccprovider.TransactionParams&#123;</span><br><span class="line">TxID:      txid,</span><br><span class="line">ChannelID: chainID,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置交易执行模拟器，系统通道chainID为""，所以系统通道的scc没有模拟器</span></span><br><span class="line"><span class="keyword">if</span> chainID != <span class="string">""</span> &#123;</span><br><span class="line"><span class="comment">// 获取链/通道的账本</span></span><br><span class="line">lgr := peer.GetLedger(chainID)</span><br><span class="line"><span class="keyword">if</span> lgr == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"syschain %s start up failure - unexpected nil ledger for channel %s"</span>, syscc.Name(), chainID))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据交易id创建链码模拟器</span></span><br><span class="line">txsim, err := lgr.NewTxSimulator(txid)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定链码执行模拟器</span></span><br><span class="line">txParams.TXSimulator = txsim</span><br><span class="line"><span class="keyword">defer</span> txsim.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">chaincodeID := &amp;pb.ChaincodeID&#123;Path: syscc.Path(), Name: syscc.Name()&#125;</span><br><span class="line">spec := &amp;pb.ChaincodeSpec&#123;Type: pb.ChaincodeSpec_Type(pb.ChaincodeSpec_Type_value[<span class="string">"GOLANG"</span>]), ChaincodeId: chaincodeID, Input: &amp;pb.ChaincodeInput&#123;Args: syscc.InitArgs()&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ChaincodeDeploymentSpec_SYSTEM标明：部署SCC</span></span><br><span class="line">chaincodeDeploymentSpec := &amp;pb.ChaincodeDeploymentSpec&#123;ExecEnv: pb.ChaincodeDeploymentSpec_SYSTEM, ChaincodeSpec: spec&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// XXX This is an ugly hack, version should be tied to the chaincode instance, not he peer binary</span></span><br><span class="line">version := util.GetSysCCVersion()</span><br><span class="line"></span><br><span class="line">cccid := &amp;ccprovider.CCContext&#123;</span><br><span class="line">Name:    chaincodeDeploymentSpec.ChaincodeSpec.ChaincodeId.Name,</span><br><span class="line">Version: version,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 部署SCC</span></span><br><span class="line">resp, _, err := ccprov.ExecuteLegacyInit(txParams, cccid, chaincodeDeploymentSpec)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; resp.Status != shim.OK &#123;</span><br><span class="line">err = errors.New(resp.Message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sysccLogger.Infof(<span class="string">"system chaincode %s/%s(%s) deployed"</span>, syscc.Name(), chainID, syscc.Path())</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ChaincodeProvider provides an abstraction layer that is</span></span><br><span class="line"><span class="comment">// used for different packages to interact with code in the</span></span><br><span class="line"><span class="comment">// chaincode package without importing it; more methods</span></span><br><span class="line"><span class="comment">// should be added below if necessary</span></span><br><span class="line"><span class="keyword">type</span> ChaincodeProvider <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// Execute executes a standard chaincode invocation for a chaincode and an input</span></span><br><span class="line">Execute(txParams *TransactionParams, cccid *CCContext, input *pb.ChaincodeInput) (*pb.Response, *pb.ChaincodeEvent, error)</span><br><span class="line"><span class="comment">// ExecuteLegacyInit is a special case for executing chaincode deployment specs,</span></span><br><span class="line"><span class="comment">// which are not already in the LSCC, needed for old lifecycle</span></span><br><span class="line">ExecuteLegacyInit(txParams *TransactionParams, cccid *CCContext, spec *pb.ChaincodeDeploymentSpec) (*pb.Response, *pb.ChaincodeEvent, error)</span><br><span class="line"><span class="comment">// Stop stops the chaincode give</span></span><br><span class="line">Stop(ccci *ChaincodeContainerInfo) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="core-chaincode"><a href="#core-chaincode" class="headerlink" title="core.chaincode"></a>core.chaincode</h3><p><code>CCProviderImpl</code>实现了<code>ChaincodeProvider</code>接口，可以用来部署链码，<code>ExecuteLegacyInit</code>会执行2项：</p><ol><li>启动链码容器</li><li>执行链码Init函数，链码容器启动后，peer和链码容器通过消息通信，<code>ChaincodeMessage_INIT</code>是执行链码容器的Init函数</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExecuteLegacyInit executes a chaincode which is not in the LSCC table</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CCProviderImpl)</span> <span class="title">ExecuteLegacyInit</span><span class="params">(txParams *ccprovider.TransactionParams, cccid *ccprovider.CCContext, spec *pb.ChaincodeDeploymentSpec)</span> <span class="params">(*pb.Response, *pb.ChaincodeEvent, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> c.cs.ExecuteLegacyInit(txParams, cccid, spec)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ExecuteLegacyInit is a temporary method which should be removed once the old style lifecycle</span></span><br><span class="line"><span class="comment">// is entirely deprecated.  Ideally one release after the introduction of the new lifecycle.</span></span><br><span class="line"><span class="comment">// It does not attempt to start the chaincode based on the information from lifecycle, but instead</span></span><br><span class="line"><span class="comment">// accepts the container information directly in the form of a ChaincodeDeploymentSpec.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *ChaincodeSupport)</span> <span class="title">ExecuteLegacyInit</span><span class="params">(txParams *ccprovider.TransactionParams, cccid *ccprovider.CCContext, spec *pb.ChaincodeDeploymentSpec)</span> <span class="params">(*pb.Response, *pb.ChaincodeEvent, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// 部署链码需要的信息</span></span><br><span class="line">    ccci := ccprovider.DeploymentSpecToChaincodeContainerInfo(spec)</span><br><span class="line">ccci.Version = cccid.Version</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动容器</span></span><br><span class="line">err := cs.LaunchInit(ccci)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cname := ccci.Name + <span class="string">":"</span> + ccci.Version</span><br><span class="line">h := cs.HandlerRegistry.Handler(cname)</span><br><span class="line"><span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, errors.Wrapf(err, <span class="string">"[channel %s] claimed to start chaincode container for %s but could not find handler"</span>, txParams.ChannelID, cname)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用链码Init</span></span><br><span class="line">resp, err := cs.execute(pb.ChaincodeMessage_INIT, txParams, cccid, spec.GetChaincodeSpec().Input, h)</span><br><span class="line"><span class="keyword">return</span> processChaincodeExecutionResult(txParams.TxID, cccid.Name, resp, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>LaunchInit</code>是启动容器的一层检查，实际启动由<code>Launcher.Launch</code>完成。启动链码容器是异步的，会创建单独的goroutine去执行。</p><p>core.chaincode使用<code>Runtime</code>接口操控链码容器的启停。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LaunchInit bypasses getting the chaincode spec from the LSCC table</span></span><br><span class="line"><span class="comment">// as in the case of v1.0-v1.2 lifecycle, the chaincode will not yet be</span></span><br><span class="line"><span class="comment">// defined in the LSCC table</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *ChaincodeSupport)</span> <span class="title">LaunchInit</span><span class="params">(ccci *ccprovider.ChaincodeContainerInfo)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">cname := ccci.Name + <span class="string">":"</span> + ccci.Version</span><br><span class="line"><span class="comment">// 已经有handler，即容器已经启动。调用链码的时候，也会获取handler</span></span><br><span class="line"><span class="keyword">if</span> cs.HandlerRegistry.Handler(cname) != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 否则启动容器，设置handler</span></span><br><span class="line"><span class="keyword">return</span> cs.Launcher.Launch(ccci)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RuntimeLauncher)</span> <span class="title">Launch</span><span class="params">(ccci *ccprovider.ChaincodeContainerInfo)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> startFailCh <span class="keyword">chan</span> error</span><br><span class="line"><span class="keyword">var</span> timeoutCh &lt;-<span class="keyword">chan</span> time.Time</span><br><span class="line"></span><br><span class="line">startTime := time.Now()</span><br><span class="line">cname := ccci.Name + <span class="string">":"</span> + ccci.Version</span><br><span class="line">launchState, alreadyStarted := r.Registry.Launching(cname)</span><br><span class="line"><span class="comment">// 链码容器未启动，启动容器</span></span><br><span class="line"><span class="keyword">if</span> !alreadyStarted &#123;</span><br><span class="line">startFailCh = <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="number">1</span>)</span><br><span class="line">timeoutCh = time.NewTimer(r.StartupTimeout).C</span><br><span class="line"></span><br><span class="line">codePackage, err := r.getCodePackage(ccci)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 启动容器</span></span><br><span class="line"><span class="keyword">if</span> err := r.Runtime.Start(ccci, codePackage); err != <span class="literal">nil</span> &#123;</span><br><span class="line">startFailCh &lt;- errors.WithMessage(err, <span class="string">"error starting container"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">exitCode, err := r.Runtime.Wait(ccci)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">launchState.Notify(errors.Wrap(err, <span class="string">"failed to wait on container exit"</span>))</span><br><span class="line">&#125;</span><br><span class="line">launchState.Notify(errors.Errorf(<span class="string">"container exited with %d"</span>, exitCode))</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Runtime is used to manage chaincode runtime instances.</span></span><br><span class="line"><span class="keyword">type</span> Runtime <span class="keyword">interface</span> &#123;</span><br><span class="line">Start(ccci *ccprovider.ChaincodeContainerInfo, codePackage []<span class="keyword">byte</span>) error</span><br><span class="line">Stop(ccci *ccprovider.ChaincodeContainerInfo) error</span><br><span class="line">Wait(ccci *ccprovider.ChaincodeContainerInfo) (<span class="keyword">int</span>, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ContainerRuntime</code>是core.chaincode封装出来和core.container交互的，在这里它会创建启动链码请求，交给container。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start launches chaincode in a runtime environment.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ContainerRuntime)</span> <span class="title">Start</span><span class="params">(ccci *ccprovider.ChaincodeContainerInfo, codePackage []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">cname := ccci.Name + <span class="string">":"</span> + ccci.Version</span><br><span class="line"></span><br><span class="line">lc, err := c.LaunchConfig(cname, ccci.Type)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">chaincodeLogger.Debugf(<span class="string">"start container: %s"</span>, cname)</span><br><span class="line">chaincodeLogger.Debugf(<span class="string">"start container with args: %s"</span>, strings.Join(lc.Args, <span class="string">" "</span>))</span><br><span class="line">chaincodeLogger.Debugf(<span class="string">"start container with env:\n\t%s"</span>, strings.Join(lc.Envs, <span class="string">"\n\t"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动链码的请求</span></span><br><span class="line">scr := container.StartContainerReq&#123;</span><br><span class="line">Builder: &amp;container.PlatformBuilder&#123;</span><br><span class="line">Type:             ccci.Type,</span><br><span class="line">Name:             ccci.Name,</span><br><span class="line">Version:          ccci.Version,</span><br><span class="line">Path:             ccci.Path,</span><br><span class="line">CodePackage:      codePackage,</span><br><span class="line">PlatformRegistry: c.PlatformRegistry,</span><br><span class="line">&#125;,</span><br><span class="line">Args:          lc.Args,</span><br><span class="line">Env:           lc.Envs,</span><br><span class="line">FilesToUpload: lc.Files,</span><br><span class="line">CCID: ccintf.CCID&#123;</span><br><span class="line">Name:    ccci.Name,</span><br><span class="line">Version: ccci.Version,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理容器操作请求</span></span><br><span class="line"><span class="keyword">if</span> err := c.Processor.Process(ccci.ContainerType, scr); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.WithMessage(err, <span class="string">"error starting container"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Processor processes vm and container requests.</span></span><br><span class="line"><span class="keyword">type</span> Processor <span class="keyword">interface</span> &#123;</span><br><span class="line">Process(vmtype <span class="keyword">string</span>, req container.VMCReq) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="core-container-1"><a href="#core-container-1" class="headerlink" title="core.container"></a>core.container</h3><p><code>VMController</code>实现了Processor，它会按指定的类型建立虚拟机，明明就是容器，为啥内部又叫VM，VM有2种：</p><ol><li>InprocVM，意思是运行在单独进程中的虚拟机，但不是指操作系统的进程，而是指一个隔离的环境，SCC是这类。</li><li>DockerVM，指利用Docker启动的容器，普通链码就是这类。</li></ol><p>类型是存在<code>ccci.ContainerType</code>中的，<code>ccci</code>包含了部署链码所需要的信息，这个信息在core.chaincode很早就获取到了，可以往前翻。</p><p><code>Process</code>就是创建VM，然后利用VM处理请求的过程。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据请求对VM进行某种操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(vmc *VMController)</span> <span class="title">Process</span><span class="params">(vmtype <span class="keyword">string</span>, req VMCReq)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建vm</span></span><br><span class="line">v := vmc.newVM(vmtype)</span><br><span class="line">ccid := req.GetCCID()</span><br><span class="line">id := ccid.GetName()</span><br><span class="line"></span><br><span class="line">vmc.lockContainer(id)</span><br><span class="line"><span class="keyword">defer</span> vmc.unlockContainer(id)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把vm传递给请求，即用该vm执行请求内容</span></span><br><span class="line"><span class="keyword">return</span> req.Do(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="虚拟机创建"><a href="#虚拟机创建" class="headerlink" title="虚拟机创建"></a>虚拟机创建</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用指定类型的vm provider创建vm</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(vmc *VMController)</span> <span class="title">newVM</span><span class="params">(typ <span class="keyword">string</span>)</span> <span class="title">VM</span></span> &#123;</span><br><span class="line">v, ok := vmc.vmProviders[typ]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">vmLogger.Panicf(<span class="string">"Programming error: unsupported VM type: %s"</span>, typ)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> v.NewVM()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewVMController creates a new instance of VMController</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewVMController</span><span class="params">(vmProviders <span class="keyword">map</span>[<span class="keyword">string</span>]VMProvider)</span> *<span class="title">VMController</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;VMController&#123;</span><br><span class="line">containerLocks: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*refCountedLock),</span><br><span class="line">vmProviders:    vmProviders,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建VM需要使用<code>NewVMController</code>，回过去找它的创建地方。</p><p>在注册SCC的过程中，调用<code>registerChaincodeSupport</code>创建了<code>chaincodeSupport</code>，其中一个字段为创建<code>NewVMController</code>，就包含了2类Vm provider：</p><ol><li>ipRegistry，SCC的</li><li>dockerProvider，普通链码的</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">registerChaincodeSupport</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">grpcServer *comm.GRPCServer,</span></span></span><br><span class="line"><span class="function"><span class="params">ccEndpoint <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">ca tlsgen.CA,</span></span></span><br><span class="line"><span class="function"><span class="params">packageProvider *persistence.PackageProvider,</span></span></span><br><span class="line"><span class="function"><span class="params">aclProvider aclmgmt.ACLProvider,</span></span></span><br><span class="line"><span class="function"><span class="params">pr *platforms.Registry,</span></span></span><br><span class="line"><span class="function"><span class="params">lifecycleSCC *lifecycle.SCC,</span></span></span><br><span class="line"><span class="function"><span class="params">ops *operations.System,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(*chaincode.ChaincodeSupport, ccprovider.ChaincodeProvider, *scc.Provider)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// SCC的VM provider</span></span><br><span class="line">ipRegistry := inproccontroller.NewRegistry()</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 普通链码，docker容器类型的VM provider</span></span><br><span class="line">dockerProvider := dockercontroller.NewProvider(</span><br><span class="line">viper.GetString(<span class="string">"peer.id"</span>),</span><br><span class="line">viper.GetString(<span class="string">"peer.networkId"</span>),</span><br><span class="line">ops.Provider,</span><br><span class="line">)</span><br><span class="line">    ...</span><br><span class="line">    chaincodeSupport := chaincode.NewChaincodeSupport(</span><br><span class="line">chaincode.GlobalConfig(),</span><br><span class="line">ccEndpoint,</span><br><span class="line">userRunsCC,</span><br><span class="line">ca.CertBytes(),</span><br><span class="line">authenticator,</span><br><span class="line">packageProvider,</span><br><span class="line">lsccInst, <span class="comment">// chaincodeSupport的声明周期管理使用了lscc，而不是lifecycle</span></span><br><span class="line">aclProvider,</span><br><span class="line">        <span class="comment">// 创建了VM controller，controller提供了inproc和docker 2中子controller，</span></span><br><span class="line"><span class="comment">// 即2中链码运行方式</span></span><br><span class="line">container.NewVMController(</span><br><span class="line"><span class="keyword">map</span>[<span class="keyword">string</span>]container.VMProvider&#123;</span><br><span class="line">dockercontroller.ContainerType: dockerProvider,</span><br><span class="line">inproccontroller.ContainerType: ipRegistry,</span><br><span class="line">&#125;,</span><br><span class="line">),</span><br><span class="line">sccp,</span><br><span class="line">pr,</span><br><span class="line">peer.DefaultSupport,</span><br><span class="line">ops.Provider,</span><br><span class="line">)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="VM处理操作虚拟机的请求"><a href="#VM处理操作虚拟机的请求" class="headerlink" title="VM处理操作虚拟机的请求"></a>VM处理操作虚拟机的请求</h4><p>core.container的请求，都实现了<code>VMCReq</code>接口，StartContainerReq、StopContainerReq、WaitContainerReq是实现VMCReq的3类请求。</p><p>启动实际是启动虚拟机接口，处理请求。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//VMCReq - all requests should implement this interface.</span></span><br><span class="line"><span class="comment">//The context should be passed and tested at each layer till we stop</span></span><br><span class="line"><span class="comment">//note that we'd stop on the first method on the stack that does not</span></span><br><span class="line"><span class="comment">//take context</span></span><br><span class="line"><span class="keyword">type</span> VMCReq <span class="keyword">interface</span> &#123;</span><br><span class="line">Do(v VM) error</span><br><span class="line">GetCCID() ccintf.CCID</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动容器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(si StartContainerReq)</span> <span class="title">Do</span><span class="params">(v VM)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> v.Start(si.CCID, si.Args, si.Env, si.FilesToUpload, si.Builder)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//VM is an abstract virtual image for supporting arbitrary virual machines</span></span><br><span class="line"><span class="keyword">type</span> VM <span class="keyword">interface</span> &#123;</span><br><span class="line">Start(ccid ccintf.CCID, args []<span class="keyword">string</span>, env []<span class="keyword">string</span>, filesToUpload <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">byte</span>, builder Builder) error</span><br><span class="line">Stop(ccid ccintf.CCID, timeout <span class="keyword">uint</span>, dontkill <span class="keyword">bool</span>, dontremove <span class="keyword">bool</span>) error</span><br><span class="line">Wait(ccid ccintf.CCID) (<span class="keyword">int</span>, error)</span><br><span class="line">HealthCheck(context.Context) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DockerVM和InprocVM都实现了VM接口，本文只关注InprocVM类型，即SCC的。</p><p>InprocVM会得到一个容器实例ipc，用它来运行SCC。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Start starts a previously registered system codechain</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(vm *InprocVM)</span> <span class="title">Start</span><span class="params">(ccid ccintf.CCID, args []<span class="keyword">string</span>, env []<span class="keyword">string</span>, filesToUpload <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">byte</span>, builder container.Builder)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">path := ccid.GetName()</span><br><span class="line"></span><br><span class="line">ipctemplate := vm.registry.getType(path)</span><br><span class="line"><span class="keyword">if</span> ipctemplate == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(fmt.Sprintf(<span class="string">"%s not registered"</span>, path))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 即ccid.Name</span></span><br><span class="line">instName := vm.GetVMName(ccid)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取容器实例</span></span><br><span class="line">ipc, err := vm.getInstance(ipctemplate, instName, args, env)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(fmt.Sprintf(<span class="string">"could not create instance for %s"</span>, instName))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 已经在运行了，还部署个啥！</span></span><br><span class="line"><span class="keyword">if</span> ipc.running &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(fmt.Sprintf(<span class="string">"chaincode running %s"</span>, path))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ipc.running = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">inprocLogger.Criticalf(<span class="string">"caught panic from chaincode  %s"</span>, instName)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="comment">// 启动进程级容器</span></span><br><span class="line">ipc.launchInProc(instName, args, env)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>inprocContainer</code>开启2个goroutine：</p><ol><li>第一个调用<code>shimStartInProc</code>，即利用core.chaincode.shim启动InProc类型的容器。</li><li>第二个调用<code>HandleChaincodeStream</code>，处理peer和Inproc容器间的通信数据，此处的stream是peer端的。</li></ol><p>这里可以看到创建了2个通道<code>peerRcvCCSend</code>和<code>ccRcvPeerSend</code>，它们表明了peer和scc的链码容器是通过通道直接通信的。peer和docker链码容器之间是走gRPC通信的，这个到普通链码的时候再介绍。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从进程启动链码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ipc *inprocContainer)</span> <span class="title">launchInProc</span><span class="params">(id <span class="keyword">string</span>, args []<span class="keyword">string</span>, env []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> ipc.ChaincodeSupport == <span class="literal">nil</span> &#123;</span><br><span class="line">inprocLogger.Panicf(<span class="string">"Chaincode support is nil, most likely you forgot to set it immediately after calling inproccontroller.NewRegsitry()"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和调用链码的上层通信的2个通道</span></span><br><span class="line">peerRcvCCSend := <span class="built_in">make</span>(<span class="keyword">chan</span> *pb.ChaincodeMessage)</span><br><span class="line">ccRcvPeerSend := <span class="built_in">make</span>(<span class="keyword">chan</span> *pb.ChaincodeMessage)</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line">ccchan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">ccsupportchan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">shimStartInProc := _shimStartInProc <span class="comment">// shadow to avoid race in test</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(ccchan)</span><br><span class="line"><span class="comment">// 启动链码</span></span><br><span class="line">inprocLogger.Debugf(<span class="string">"chaincode started for %s"</span>, id)</span><br><span class="line"><span class="keyword">if</span> args == <span class="literal">nil</span> &#123;</span><br><span class="line">args = ipc.args</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> env == <span class="literal">nil</span> &#123;</span><br><span class="line">env = ipc.env</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 利用shim启动</span></span><br><span class="line">err := shimStartInProc(env, args, ipc.chaincode, ccRcvPeerSend, peerRcvCCSend)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">err = fmt.Errorf(<span class="string">"chaincode-support ended with err: %s"</span>, err)</span><br><span class="line">_inprocLoggerErrorf(<span class="string">"%s"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">inprocLogger.Debugf(<span class="string">"chaincode ended for %s with err: %s"</span>, id, err)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// shadow function to avoid data race</span></span><br><span class="line">inprocLoggerErrorf := _inprocLoggerErrorf</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(ccsupportchan)</span><br><span class="line"><span class="comment">// 处理scc和外部通信的消息流</span></span><br><span class="line">inprocStream := newInProcStream(peerRcvCCSend, ccRcvPeerSend)</span><br><span class="line">inprocLogger.Debugf(<span class="string">"chaincode-support started for  %s"</span>, id)</span><br><span class="line">err := ipc.ChaincodeSupport.HandleChaincodeStream(inprocStream)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">err = fmt.Errorf(<span class="string">"chaincode ended with err: %s"</span>, err)</span><br><span class="line">inprocLoggerErrorf(<span class="string">"%s"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">inprocLogger.Debugf(<span class="string">"chaincode-support ended for %s with err: %s"</span>, id, err)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用shim启动Inproc链码容器中的程序"><a href="#利用shim启动Inproc链码容器中的程序" class="headerlink" title="利用shim启动Inproc链码容器中的程序"></a>利用shim启动Inproc链码容器中的程序</h4><p>shim是chaincode提供给容器，运行链码的工具，它运行在容器里。</p><p>利用shim启动InprocVM使用的函数是<code>StartInProc</code>，提取一些<strong>运行链码</strong>需要的数据，比如又一个stream，此处的stream是容器端的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动SCC的入口</span></span><br><span class="line"><span class="comment">// StartInProc is an entry point for system chaincodes bootstrap. It is not an</span></span><br><span class="line"><span class="comment">// API for chaincodes.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StartInProc</span><span class="params">(env []<span class="keyword">string</span>, args []<span class="keyword">string</span>, cc Chaincode, recv &lt;-<span class="keyword">chan</span> *pb.ChaincodeMessage, send <span class="keyword">chan</span>&lt;- *pb.ChaincodeMessage)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// 有点奇怪，这些日志都没有看到，因为已经在shim，不属于peer日志了</span></span><br><span class="line">chaincodeLogger.Debugf(<span class="string">"in proc %v"</span>, args)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从环境变量获取cc name</span></span><br><span class="line"><span class="keyword">var</span> chaincodename <span class="keyword">string</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> env &#123;</span><br><span class="line"><span class="keyword">if</span> strings.Index(v, <span class="string">"CORE_CHAINCODE_ID_NAME="</span>) == <span class="number">0</span> &#123;</span><br><span class="line">p := strings.SplitAfter(v, <span class="string">"CORE_CHAINCODE_ID_NAME="</span>)</span><br><span class="line">chaincodename = p[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> chaincodename == <span class="string">""</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">"error chaincode id not provided"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建peer和chaincode通信的通道</span></span><br><span class="line">stream := newInProcStream(recv, send)</span><br><span class="line">chaincodeLogger.Debugf(<span class="string">"starting chat with peer using name=%s"</span>, chaincodename)</span><br><span class="line"><span class="comment">// 与peer进行通信</span></span><br><span class="line">err := chatWithPeer(chaincodename, stream, cc)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>chatWithPeer</code>是通用的，普通的链码也调用这个程序。它创建了一个handler，用来处理消息（发送和接收），以及操作（调用）链码。</p><p>这个过程，它会向peer发送REGISTER消息，和peer先“握手”，也会从peer读消息，消息的处理函数就是里面的for循环，这样链码容器就运行起来了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用，SCC和CC都使用这个函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chatWithPeer</span><span class="params">(chaincodename <span class="keyword">string</span>, stream PeerChaincodeStream, cc Chaincode)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// 把stream和cc交给handler，handler可以发送和接收数据，即读写通道</span></span><br><span class="line"><span class="comment">// Create the shim handler responsible for all control logic</span></span><br><span class="line">handler := newChaincodeHandler(stream, cc)</span><br><span class="line"><span class="keyword">defer</span> stream.CloseSend()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Send the ChaincodeID during register.</span></span><br><span class="line">chaincodeID := &amp;pb.ChaincodeID&#123;Name: chaincodename&#125;</span><br><span class="line">payload, err := proto.Marshal(chaincodeID)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.Wrap(err, <span class="string">"error marshalling chaincodeID during chaincode registration"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在stream上向peer发送注册消息</span></span><br><span class="line"><span class="comment">// Register on the stream</span></span><br><span class="line">chaincodeLogger.Debugf(<span class="string">"Registering.. sending %s"</span>, pb.ChaincodeMessage_REGISTER)</span><br><span class="line"><span class="keyword">if</span> err = handler.serialSend(&amp;pb.ChaincodeMessage&#123;Type: pb.ChaincodeMessage_REGISTER, Payload: payload&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.WithMessage(err, <span class="string">"error sending chaincode REGISTER"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// holds return values from gRPC Recv below</span></span><br><span class="line"><span class="keyword">type</span> recvMsg <span class="keyword">struct</span> &#123;</span><br><span class="line">msg *pb.ChaincodeMessage</span><br><span class="line">err error</span><br><span class="line">&#125;</span><br><span class="line">msgAvail := <span class="built_in">make</span>(<span class="keyword">chan</span> *recvMsg, <span class="number">1</span>)</span><br><span class="line">errc := <span class="built_in">make</span>(<span class="keyword">chan</span> error)</span><br><span class="line"></span><br><span class="line">receiveMessage := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">in, err := stream.Recv()</span><br><span class="line">msgAvail &lt;- &amp;recvMsg&#123;in, err&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步读取1个消息</span></span><br><span class="line"><span class="keyword">go</span> receiveMessage()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环处理peer发送的消息</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> rmsg := &lt;-msgAvail:</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> rmsg.err == io.EOF:</span><br><span class="line">err = errors.Wrapf(rmsg.err, <span class="string">"received EOF, ending chaincode stream"</span>)</span><br><span class="line">chaincodeLogger.Debugf(<span class="string">"%+v"</span>, err)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line"><span class="keyword">case</span> rmsg.err != <span class="literal">nil</span>:</span><br><span class="line">err := errors.Wrap(rmsg.err, <span class="string">"receive failed"</span>)</span><br><span class="line">chaincodeLogger.Errorf(<span class="string">"Received error from server, ending chaincode stream: %+v"</span>, err)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line"><span class="keyword">case</span> rmsg.msg == <span class="literal">nil</span>:</span><br><span class="line">err := errors.New(<span class="string">"received nil message, ending chaincode stream"</span>)</span><br><span class="line">chaincodeLogger.Debugf(<span class="string">"%+v"</span>, err)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// 处理消息</span></span><br><span class="line">chaincodeLogger.Debugf(<span class="string">"[%s]Received message %s from peer"</span>, shorttxid(rmsg.msg.Txid), rmsg.msg.Type)</span><br><span class="line">err := handler.handleMessage(rmsg.msg, errc)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">err = errors.WithMessage(err, <span class="string">"error handling message"</span>)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取下一个消息</span></span><br><span class="line"><span class="keyword">go</span> receiveMessage()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> sendErr := &lt;-errc:</span><br><span class="line"><span class="keyword">if</span> sendErr != <span class="literal">nil</span> &#123;</span><br><span class="line">err := errors.Wrap(sendErr, <span class="string">"error sending"</span>)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的消息处理函数，先跳过，回过头来，关注scc容器和peer的通信。</p><h4 id="SCC和Peer的通信通道"><a href="#SCC和Peer的通信通道" class="headerlink" title="SCC和Peer的通信通道"></a>SCC和Peer的通信通道</h4><p>链码容器和Peer之间使用Stream进行通信，Stream有2种实现：</p><ol><li>使用channel封装的Stream</li><li>gRPC的Stream</li></ol><p><img src="http://img.lessisbetter.site/2019-09-peer-cc-communication.png" alt=""></p><p>链码容器和Peer通信的接口是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PeerChaincodeStream interface for stream between Peer and chaincode instance.</span></span><br><span class="line"><span class="keyword">type</span> PeerChaincodeStream <span class="keyword">interface</span> &#123;</span><br><span class="line">Send(*pb.ChaincodeMessage) error</span><br><span class="line">Recv() (*pb.ChaincodeMessage, error)</span><br><span class="line">CloseSend() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>普通链码使用gRPC：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> chaincodeSupportRegisterClient <span class="keyword">struct</span> &#123;</span><br><span class="line">grpc.ClientStream</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>系统链码直接使用通道通信，发送和接收消息都在下面了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// peer和chaincode之间通信的通道</span></span><br><span class="line"><span class="comment">// PeerChaincodeStream interface for stream between Peer and chaincode instance.</span></span><br><span class="line"><span class="keyword">type</span> inProcStream <span class="keyword">struct</span> &#123;</span><br><span class="line">recv &lt;-<span class="keyword">chan</span> *pb.ChaincodeMessage</span><br><span class="line">send <span class="keyword">chan</span>&lt;- *pb.ChaincodeMessage</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newInProcStream</span><span class="params">(recv &lt;-<span class="keyword">chan</span> *pb.ChaincodeMessage, send <span class="keyword">chan</span>&lt;- *pb.ChaincodeMessage)</span> *<span class="title">inProcStream</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;inProcStream&#123;recv, send&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送其实就是向send写数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *inProcStream)</span> <span class="title">Send</span><span class="params">(msg *pb.ChaincodeMessage)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">err = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//send may happen on a closed channel when the system is</span></span><br><span class="line"><span class="comment">//shutting down. Just catch the exception and return error</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">err = SendPanicFailure(fmt.Sprintf(<span class="string">"%s"</span>, r))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">s.send &lt;- msg</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收是从recv读数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *inProcStream)</span> <span class="title">Recv</span><span class="params">()</span> <span class="params">(*pb.ChaincodeMessage, error)</span></span> &#123;</span><br><span class="line">msg, ok := &lt;-s.recv</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"channel is closed"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> msg, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *inProcStream)</span> <span class="title">CloseSend</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// 实际啥也没做</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Peer和链码容器的交互，完成链码容器启动"><a href="#Peer和链码容器的交互，完成链码容器启动" class="headerlink" title="Peer和链码容器的交互，完成链码容器启动"></a>Peer和链码容器的交互，完成链码容器启动</h3><p>部署链码需要Peer和链码容器交互，不然Peer怎么知道链码容器已经启动。以下是一份peer的DEBUG日志，在下面标注了启动容器和链码Init过程中的消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">2019-09-09 07:52:09.915 UTC [chaincode] LaunchConfig -&gt; DEBU 098 launchConfig: executable:&quot;chaincode&quot;,Args:[chaincode,-peer.address=peer0.org1.example.com:7052],Envs:[CORE_CHAINCODE_LOGGING_LEVEL=info,CORE_CHAINCODE_LOGGING_SHIM=warning,CORE_CHAINCODE_LOGGING_FORMAT=%&#123;color&#125;%&#123;time:2006-01-02 15:04:05.000 MST&#125; [%&#123;module&#125;] %&#123;shortfunc&#125; -&gt; %&#123;level:.4s&#125; %&#123;id:03x&#125;%&#123;color:reset&#125; %&#123;message&#125;,CORE_CHAINCODE_ID_NAME=lscc:1.4.3,CORE_PEER_TLS_ENABLED=true,CORE_TLS_CLIENT_KEY_PATH=/etc/hyperledger/fabric/client.key,CORE_TLS_CLIENT_CERT_PATH=/etc/hyperledger/fabric/client.crt,CORE_PEER_TLS_ROOTCERT_FILE=/etc/hyperledger/fabric/peer.crt],Files:[/etc/hyperledger/fabric/client.crt /etc/hyperledger/fabric/client.key /etc/hyperledger/fabric/peer.crt]</span><br><span class="line">2019-09-09 07:52:09.915 UTC [chaincode] Start -&gt; DEBU 099 start container: lscc:1.4.3</span><br><span class="line">2019-09-09 07:52:09.915 UTC [chaincode] Start -&gt; DEBU 09a start container with args: chaincode -peer.address=peer0.org1.example.com:7052</span><br><span class="line">2019-09-09 07:52:09.915 UTC [chaincode] Start -&gt; DEBU 09b start container with env:</span><br><span class="line">CORE_CHAINCODE_LOGGING_LEVEL=info</span><br><span class="line">CORE_CHAINCODE_LOGGING_SHIM=warning</span><br><span class="line">CORE_CHAINCODE_LOGGING_FORMAT=%&#123;color&#125;%&#123;time:2006-01-02 15:04:05.000 MST&#125; [%&#123;module&#125;] %&#123;shortfunc&#125; -&gt; %&#123;level:.4s&#125; %&#123;id:03x&#125;%&#123;color:reset&#125; %&#123;message&#125;</span><br><span class="line">CORE_CHAINCODE_ID_NAME=lscc:1.4.3</span><br><span class="line">CORE_PEER_TLS_ENABLED=true</span><br><span class="line">CORE_TLS_CLIENT_KEY_PATH=/etc/hyperledger/fabric/client.key</span><br><span class="line">CORE_TLS_CLIENT_CERT_PATH=/etc/hyperledger/fabric/client.crt</span><br><span class="line">CORE_PEER_TLS_ROOTCERT_FILE=/etc/hyperledger/fabric/peer.crt</span><br><span class="line">2019-09-09 07:52:09.915 UTC [container] lockContainer -&gt; DEBU 09c waiting for container(lscc-1.4.3) lock</span><br><span class="line">2019-09-09 07:52:09.915 UTC [container] lockContainer -&gt; DEBU 09d got container (lscc-1.4.3) lock</span><br><span class="line">2019-09-09 07:52:09.915 UTC [inproccontroller] getInstance -&gt; DEBU 09e chaincode instance created for lscc-1.4.3</span><br><span class="line">2019-09-09 07:52:09.915 UTC [container] unlockContainer -&gt; DEBU 09f container lock deleted(lscc-1.4.3)</span><br><span class="line">2019-09-09 07:52:09.915 UTC [container] lockContainer -&gt; DEBU 0a0 waiting for container(lscc-1.4.3) lock</span><br><span class="line">2019-09-09 07:52:09.915 UTC [container] lockContainer -&gt; DEBU 0a1 got container (lscc-1.4.3) lock</span><br><span class="line">2019-09-09 07:52:09.915 UTC [container] unlockContainer -&gt; DEBU 0a2 container lock deleted(lscc-1.4.3)</span><br><span class="line">2019-09-09 07:52:09.915 UTC [inproccontroller] func2 -&gt; DEBU 0a3 chaincode-support started for  lscc-1.4.3</span><br><span class="line">2019-09-09 07:52:09.915 UTC [inproccontroller] func1 -&gt; DEBU 0a4 chaincode started for lscc-1.4.3</span><br><span class="line">// 以上日志对应的代码流程在上文都讲到了</span><br><span class="line"></span><br><span class="line">// 以下是交互过程peer日志</span><br><span class="line">// peer收到容器的注册消息</span><br><span class="line">2019-09-09 07:52:09.916 UTC [chaincode] handleMessage -&gt; DEBU 0a5 [] Fabric side handling ChaincodeMessage of type: REGISTER in state created</span><br><span class="line">2019-09-09 07:52:09.916 UTC [chaincode] HandleRegister -&gt; DEBU 0a6 Received REGISTER in state created</span><br><span class="line">2019-09-09 07:52:09.916 UTC [chaincode] Register -&gt; DEBU 0a7 registered handler complete for chaincode lscc:1.4.3</span><br><span class="line">2019-09-09 07:52:09.916 UTC [chaincode] HandleRegister -&gt; DEBU 0a8 Got REGISTER for chaincodeID = name:&quot;lscc:1.4.3&quot; , sending back REGISTERED</span><br><span class="line">2019-09-09 07:52:09.920 UTC [grpc] HandleSubConnStateChange -&gt; DEBU 0a9 pickfirstBalancer: HandleSubConnStateChange: 0xc0026318c0, READY</span><br><span class="line">2019-09-09 07:52:09.923 UTC [chaincode] HandleRegister -&gt; DEBU 0aa Changed state to established for name:&quot;lscc:1.4.3&quot;</span><br><span class="line"></span><br><span class="line">// peer发送ready消息</span><br><span class="line">2019-09-09 07:52:09.923 UTC [chaincode] sendReady -&gt; DEBU 0ab sending READY for chaincode name:&quot;lscc:1.4.3&quot;</span><br><span class="line">2019-09-09 07:52:09.923 UTC [chaincode] sendReady -&gt; DEBU 0ac Changed to state ready for chaincode name:&quot;lscc:1.4.3&quot;</span><br><span class="line"></span><br><span class="line">// 已经完成启动容器</span><br><span class="line">2019-09-09 07:52:09.923 UTC [chaincode] Launch -&gt; DEBU 0ad launch complete</span><br><span class="line">2019-09-09 07:52:09.924 UTC [chaincode] Execute -&gt; DEBU 0ae Entry</span><br><span class="line">// 收到容器COMPLETED消息</span><br><span class="line">2019-09-09 07:52:09.925 UTC [chaincode] handleMessage -&gt; DEBU 0af [01b03aae] Fabric side handling ChaincodeMessage of type: COMPLETED in state ready</span><br><span class="line"></span><br><span class="line">// 通知scc，部署已经完成</span><br><span class="line">2019-09-09 07:52:09.925 UTC [chaincode] Notify -&gt; DEBU 0b0 [01b03aae] notifying Txid:01b03aae-17a6-4b63-874e-dc20d6f5df0c, channelID:</span><br><span class="line">2019-09-09 07:52:09.925 UTC [chaincode] Execute -&gt; DEBU 0b1 Exit</span><br><span class="line">2019-09-09 07:52:09.925 UTC [sccapi] deploySysCC -&gt; INFO 0b2 system chaincode lscc/(github.com/hyperledger/fabric/core/scc/lscc) deployed</span><br></pre></td></tr></table></figure><p>可以到REGISTER、READY、COMPLETED等消息，以及状态的改变：created、ready。</p><p>但前面还没有介绍Peer和链码容器之间的通信，所以不展示代码了，展示一下Peer和链码容器的消息交互图：</p><p><img src="http://img.lessisbetter.site/2019-09-deploycc-msg.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;一份Peer节点启动的INFO级别日志如下，可以发现：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先注册了scc目录下的lscc, cscc, qscc，未
      
    
    </summary>
    
    
    
      <category term="区块链" scheme="http://lessisbetter.site/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Fabric" scheme="http://lessisbetter.site/tags/Fabric/"/>
    
  </entry>
  
  <entry>
    <title>Fabric 1.4源码解读 1：背书策略是怎么使用的</title>
    <link href="http://lessisbetter.site/2019/09/06/fabric-source-endorser-policy-flow/"/>
    <id>http://lessisbetter.site/2019/09/06/fabric-source-endorser-policy-flow/</id>
    <published>2019-09-06T08:39:45.000Z</published>
    <updated>2019-12-05T07:04:50.935Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.lessisbetter.site/2019-09-endorser-policy.png" alt="endorser policy"></p><p>背书策略是Fabric中的一个重要一环，想梳理一下背书策略的上链和使用流程。</p><p>背书策略是部署和升级链码时使用的，需要发送配置交易，所以尝试了从背书节点收到交易，然后处理交易的流程入手，找到背书策略的入口，结果毫无头绪。</p><p>换一种思路，从使用入手，向上追溯，这种就非常顺利了。</p><h2 id="从背书策略的使用入手"><a href="#从背书策略的使用入手" class="headerlink" title="从背书策略的使用入手"></a>从背书策略的使用入手</h2><p>VSCC会利用背书策略，并且背书策略不满足时会返回一个：背书策略不满足的错误，每一个上链的交易详细中都有这么一个Validation字段，为0代表有效交易，否则是无效交易，并用数字表示原因，背书策略不满足的序号就是10。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TxValidationCode <span class="keyword">int32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">...</span><br><span class="line">TxValidationCode_ENDORSEMENT_POLICY_FAILURE   TxValidationCode = <span class="number">10</span></span><br><span class="line">...</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>TxValidationCode_ENDORSEMENT_POLICY_FAILURE</code>被<code>VSCCValidateTx</code>使用，系统链码和普通链码都有背书策略需要满足，下面代码片是普通链码部分，可以发现调用<code>VSCCValidateTxForCC</code>验证交易。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// VSCCValidateTx executes vscc validation for transaction</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *VsccValidatorImpl)</span> <span class="title">VSCCValidateTx</span><span class="params">(seq <span class="keyword">int</span>, payload *common.Payload, envBytes []<span class="keyword">byte</span>, block *common.Block)</span> <span class="params">(error, peer.TxValidationCode)</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> err = v.VSCCValidateTxForCC(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> err.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> *commonerrors.VSCCEndorsementPolicyError:</span><br><span class="line">      <span class="keyword">return</span> err, peer.TxValidationCode_ENDORSEMENT_POLICY_FAILURE</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> err, peer.TxValidationCode_INVALID_OTHER_REASON</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个chaincode都会提供escc和vscc，现在都是默认的，也就是说escc和vscc都可以是具备可插拔的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode list -C mychannel --instantiated</span><br><span class="line">Get instantiated chaincodes on channel mychannel:</span><br><span class="line">Name: mycc, Version: 1.1, Path: github.com/chaincode/chaincode_example02/go/, Escc: escc, Vscc: vscc</span><br></pre></td></tr></table></figure><p><code>VSCCValidateTxForCC</code>会从交易的context中获取验证插件，然后利用插件验证交易。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *VsccValidatorImpl)</span> <span class="title">VSCCValidateTxForCC</span><span class="params">(ctx *Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">logger.Debug(<span class="string">"Validating"</span>, ctx, <span class="string">"with plugin"</span>)</span><br><span class="line">  <span class="comment">// 使用插件验证交易</span></span><br><span class="line">err := v.pluginValidator.ValidateWithPlugin(ctx)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// If the error is a pluggable validation execution error, cast it to the common errors ExecutionFailureError.</span></span><br><span class="line"><span class="keyword">if</span> e, isExecutionError := err.(*validation.ExecutionFailureError); isExecutionError &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;commonerrors.VSCCExecutionFailureError&#123;Err: e&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Else, treat it as an endorsement error.</span></span><br><span class="line"><span class="keyword">return</span> &amp;commonerrors.VSCCEndorsementPolicyError&#123;Err: err&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pv *PluginValidator)</span> <span class="title">ValidateWithPlugin</span><span class="params">(ctx *Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// 获取vscc插件</span></span><br><span class="line">plugin, err := pv.getOrCreatePlugin(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;validation.ExecutionFailureError&#123;</span><br><span class="line">Reason: fmt.Sprintf(<span class="string">"plugin with name %s couldn't be used: %v"</span>, ctx.VSCCName, err),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 利用插件验证</span></span><br><span class="line">err = plugin.Validate(ctx.Block, ctx.Namespace, ctx.Seq, <span class="number">0</span>, SerializedPolicy(ctx.Policy))</span><br><span class="line">validityStatus := <span class="string">"valid"</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">validityStatus = fmt.Sprintf(<span class="string">"invalid: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">logger.Debug(<span class="string">"Transaction"</span>, ctx.TxID, <span class="string">"appears to be"</span>, validityStatus)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Plugin validates transactions</span></span><br><span class="line"><span class="keyword">type</span> Plugin <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// Validate returns nil if the action at the given position inside the transaction</span></span><br><span class="line"><span class="comment">// at the given position in the given block is valid, or an error if not.</span></span><br><span class="line">Validate(block *common.Block, namespace <span class="keyword">string</span>, txPosition <span class="keyword">int</span>, actionPosition <span class="keyword">int</span>, contextData ...ContextDatum) error</span><br><span class="line"></span><br><span class="line"><span class="comment">// Init injects dependencies into the instance of the Plugin</span></span><br><span class="line">Init(dependencies ...Dependency) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前验证插件有2种实现，<code>TxValidatorV1_2</code>和<code>V1_3Validation</code>,<code>Validate</code>还从context取出了序列化的背书策略，vscc会调用PolicyEvalutor交易的背书是否满足背书策略。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *DefaultValidation)</span> <span class="title">Validate</span><span class="params">(block *common.Block, namespace <span class="keyword">string</span>, txPosition <span class="keyword">int</span>, actionPosition <span class="keyword">int</span>, contextData ...validation.ContextDatum)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(contextData) == <span class="number">0</span> &#123;</span><br><span class="line">logger.Panicf(<span class="string">"Expected to receive policy bytes in context data"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拿到序列化后的policy</span></span><br><span class="line">serializedPolicy, isSerializedPolicy := contextData[<span class="number">0</span>].(SerializedPolicy)</span><br><span class="line"><span class="keyword">if</span> !isSerializedPolicy &#123;</span><br><span class="line">logger.Panicf(<span class="string">"Expected to receive a serialized policy in the first context data"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> block == <span class="literal">nil</span> || block.Data == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">"empty block"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> txPosition &gt;= <span class="built_in">len</span>(block.Data.Data) &#123;</span><br><span class="line"><span class="keyword">return</span> errors.Errorf(<span class="string">"block has only %d transactions, but requested tx at position %d"</span>, <span class="built_in">len</span>(block.Data.Data), txPosition)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> block.Header == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.Errorf(<span class="string">"no block header"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用不同版本的validator进行验证</span></span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> v.Capabilities.V1_3Validation():</span><br><span class="line">err = v.TxValidatorV1_3.Validate(block, namespace, txPosition, actionPosition, serializedPolicy.Bytes())</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> v.Capabilities.V1_2Validation():</span><br><span class="line"><span class="keyword">fallthrough</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">err = v.TxValidatorV1_2.Validate(block, namespace, txPosition, actionPosition, serializedPolicy.Bytes())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logger.Debugf(<span class="string">"block %d, namespace: %s, tx %d validation results is: %v"</span>, block.Header.Number, namespace, txPosition, err)</span><br><span class="line"><span class="keyword">return</span> convertErrorTypeOrPanic(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证代码使用v2/validation_logic.go中的实现</span></span><br><span class="line"><span class="comment">// Validate validates the given envelope corresponding to a transaction with an endorsement</span></span><br><span class="line"><span class="comment">// policy as given in its serialized form</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(vscc *Validator)</span> <span class="title">Validate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">block *common.Block,</span></span></span><br><span class="line"><span class="function"><span class="params">namespace <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">txPosition <span class="keyword">int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">actionPosition <span class="keyword">int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">policyBytes []<span class="keyword">byte</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="title">commonerrors</span>.<span class="title">TxValidationError</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// evaluate the signature set against the policy</span></span><br><span class="line">  err = vscc.policyEvaluator.Evaluate(policyBytes, signatureSet)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    logger.Warningf(<span class="string">"Endorsement policy failure for transaction txid=%s, err: %s"</span>, chdr.GetTxId(), err.Error())</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(signatureSet) &lt; <span class="built_in">len</span>(<span class="built_in">cap</span>.Action.Endorsements) &#123;</span><br><span class="line">      <span class="comment">// Warning: duplicated identities exist, endorsement failure might be cause by this reason</span></span><br><span class="line">      <span class="keyword">return</span> policyErr(errors.New(DUPLICATED_IDENTITY_ERROR))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> policyErr(fmt.Errorf(<span class="string">"VSCC error: endorsement policy failure, err: %s"</span>, err))</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PolicyEvaluator evaluates policies</span></span><br><span class="line"><span class="keyword">type</span> PolicyEvaluator <span class="keyword">interface</span> &#123;</span><br><span class="line">validation.Dependency</span><br><span class="line"></span><br><span class="line"><span class="comment">// Evaluate takes a set of SignedData and evaluates whether this set of signatures satisfies</span></span><br><span class="line"><span class="comment">// the policy with the given bytes</span></span><br><span class="line">Evaluate(policyBytes []<span class="keyword">byte</span>, signatureSet []*common.SignedData) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Evaluate</code>会创建背书策略实例，然后利用背书策略验证背书签名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// Evaluate takes a set of SignedData and evaluates whether this set of signatures satisfies the policy</span><br><span class="line">func (id *PolicyEvaluator) Evaluate(policyBytes []byte, signatureSet []*common.SignedData) error &#123;</span><br><span class="line">pp := cauthdsl.NewPolicyProvider(id.IdentityDeserializer)</span><br><span class="line">policy, _, err := pp.NewPolicy(policyBytes)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return err</span><br><span class="line">&#125;</span><br><span class="line">return policy.Evaluate(signatureSet)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Policy is used to determine if a signature is valid</span><br><span class="line">type Policy interface &#123;</span><br><span class="line">// Evaluate takes a set of SignedData and evaluates whether this set of signatures satisfies the policy</span><br><span class="line">Evaluate(signatureSet []*cb.SignedData) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Evaluate takes a set of SignedData and evaluates whether this set of signatures satisfies the policy</span><br><span class="line">func (p *policy) Evaluate(signatureSet []*cb.SignedData) error &#123;</span><br><span class="line">if p == nil &#123;</span><br><span class="line">return fmt.Errorf(&quot;No such policy&quot;)</span><br><span class="line">&#125;</span><br><span class="line">idAndS := make([]IdentityAndSignature, len(signatureSet))</span><br><span class="line">for i, sd := range signatureSet &#123;</span><br><span class="line">idAndS[i] = &amp;deserializeAndVerify&#123;</span><br><span class="line">signedData:   sd,</span><br><span class="line">deserializer: p.deserializer,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ok := p.evaluator(deduplicate(idAndS), make([]bool, len(signatureSet)))</span><br><span class="line">if !ok &#123;</span><br><span class="line">return errors.New(&quot;signature set did not satisfy policy&quot;)</span><br><span class="line">&#125;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体背书验证签名的实现，当下就先不关心了。<strong>回过头来想一下，VSCC从哪拿到了背书策略？</strong></p><h2 id="VSCC的背书策略哪来的？"><a href="#VSCC的背书策略哪来的？" class="headerlink" title="VSCC的背书策略哪来的？"></a>VSCC的背书策略哪来的？</h2><p>回到上文第一次出现背书策略的地方：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func (pv *PluginValidator) ValidateWithPlugin(ctx *Context) error &#123;</span><br><span class="line">  err = plugin.Validate(ctx.Block, ctx.Namespace, ctx.Seq, 0, SerializedPolicy(ctx.Policy))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Context defines information about a transaction</span><br><span class="line">// that is being validated</span><br><span class="line">type Context struct &#123;</span><br><span class="line">Seq       int</span><br><span class="line">Envelope  []byte</span><br><span class="line">TxID      string</span><br><span class="line">Channel   string</span><br><span class="line">VSCCName  string</span><br><span class="line">Policy    []byte // 背书策略</span><br><span class="line">Namespace string</span><br><span class="line">Block     *common.Block</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>VSCCValidateTx</code>函数会创建Context，填写policy字段，其中policy是调用<code>GetInfoForValidate</code>获取的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *VsccValidatorImpl)</span> <span class="title">VSCCValidateTx</span><span class="params">(seq <span class="keyword">int</span>, payload *common.Payload, envBytes []<span class="keyword">byte</span>, block *common.Block)</span> <span class="params">(error, peer.TxValidationCode)</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 普通链码</span></span><br><span class="line">  <span class="keyword">if</span> !v.sccprovider.IsSysCC(ccID) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 获取policy、vscc等</span></span><br><span class="line">    <span class="comment">// Get latest chaincode version, vscc and validate policy</span></span><br><span class="line">    txcc, vscc, policy, err := v.GetInfoForValidate(chdr, ns)</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// do VSCC validation</span></span><br><span class="line">    ctx := &amp;Context&#123;</span><br><span class="line">      Seq:       seq,</span><br><span class="line">      Envelope:  envBytes,</span><br><span class="line">      Block:     block,</span><br><span class="line">      TxID:      chdr.TxId,</span><br><span class="line">      Channel:   chdr.ChannelId,</span><br><span class="line">      Namespace: ns,</span><br><span class="line">      Policy:    policy, <span class="comment">// Here</span></span><br><span class="line">      VSCCName:  vscc.ChaincodeName,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err = v.VSCCValidateTxForCC(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">switch</span> err.(<span class="keyword">type</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> *commonerrors.VSCCEndorsementPolicyError:</span><br><span class="line">        <span class="keyword">return</span> err, peer.TxValidationCode_ENDORSEMENT_POLICY_FAILURE</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> err, peer.TxValidationCode_INVALID_OTHER_REASON</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// SCC</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>GetInfoForValidate</code>先是获取了<code>ChaincodeDefinition</code>，它记录了peer对某个链码的proposal背书和验证的必要信息，然后利用<code>ChaincodeDefinition.Validation</code>获取了policy。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetInfoForValidate gets the ChaincodeInstance(with latest version) of tx, vscc and policy from lscc</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *VsccValidatorImpl)</span> <span class="title">GetInfoForValidate</span><span class="params">(chdr *common.ChannelHeader, ccID <span class="keyword">string</span>)</span> <span class="params">(*sysccprovider.ChaincodeInstance, *sysccprovider.ChaincodeInstance, []<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">cc := &amp;sysccprovider.ChaincodeInstance&#123;</span><br><span class="line">ChainID:          chdr.ChannelId,</span><br><span class="line">ChaincodeName:    ccID,</span><br><span class="line">ChaincodeVersion: coreUtil.GetSysCCVersion(),</span><br><span class="line">&#125;</span><br><span class="line">vscc := &amp;sysccprovider.ChaincodeInstance&#123;</span><br><span class="line">ChainID:          chdr.ChannelId,</span><br><span class="line">ChaincodeName:    <span class="string">"vscc"</span>,                     <span class="comment">// default vscc for system chaincodes</span></span><br><span class="line">ChaincodeVersion: coreUtil.GetSysCCVersion(), <span class="comment">// Get vscc version</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> policy []<span class="keyword">byte</span></span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="keyword">if</span> !v.sccprovider.IsSysCC(ccID) &#123;</span><br><span class="line"><span class="comment">// when we are validating a chaincode that is not a</span></span><br><span class="line"><span class="comment">// system CC, we need to ask the CC to give us the name</span></span><br><span class="line"><span class="comment">// of VSCC and of the policy that should be used</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// obtain name of the VSCC and the policy</span></span><br><span class="line"><span class="comment">// 获取cc 定义</span></span><br><span class="line">cd, err := v.getCDataForCC(chdr.ChannelId, ccID)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">msg := fmt.Sprintf(<span class="string">"Unable to get chaincode data from ledger for txid %s, due to %s"</span>, chdr.TxId, err)</span><br><span class="line">logger.Errorf(msg)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">cc.ChaincodeName = cd.CCName()</span><br><span class="line">cc.ChaincodeVersion = cd.CCVersion()</span><br><span class="line"><span class="comment">// 拿到policy</span></span><br><span class="line">vscc.ChaincodeName, policy = cd.Validation()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// when we are validating a system CC, we use the default</span></span><br><span class="line"><span class="comment">// VSCC and a default policy that requires one signature</span></span><br><span class="line"><span class="comment">// from any of the members of the channel</span></span><br><span class="line">p := cauthdsl.SignedByAnyMember(v.support.GetMSPIDs(chdr.ChannelId))</span><br><span class="line">policy, err = utils.Marshal(p)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> cc, vscc, policy, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------- ChaincodeDefinition - interface for ChaincodeData ------</span></span><br><span class="line"><span class="comment">// ChaincodeDefinition describes all of the necessary information for a peer to decide whether to endorse</span></span><br><span class="line"><span class="comment">// a proposal and whether to validate a transaction, for a particular chaincode.</span></span><br><span class="line"><span class="keyword">type</span> ChaincodeDefinition <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// CCName returns the name of this chaincode (the name it was put in the ChaincodeRegistry with).</span></span><br><span class="line">CCName() <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Hash returns the hash of the chaincode.</span></span><br><span class="line">Hash() []<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CCVersion returns the version of the chaincode.</span></span><br><span class="line">CCVersion() <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Validation returns how to validate transactions for this chaincode.</span></span><br><span class="line"><span class="comment">// The string returned is the name of the validation method (usually 'vscc')</span></span><br><span class="line"><span class="comment">// and the bytes returned are the argument to the validation (in the case of</span></span><br><span class="line"><span class="comment">// 'vscc', this is a marshaled pb.VSCCArgs message).</span></span><br><span class="line">Validation() (<span class="keyword">string</span>, []<span class="keyword">byte</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Endorsement returns how to endorse proposals for this chaincode.</span></span><br><span class="line"><span class="comment">// The string returns is the name of the endorsement method (usually 'escc').</span></span><br><span class="line">Endorsement() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ChaincodeData</code>实现了<code>ChaincodeDefinition</code>接口，<code>ChaincodeData</code>是LSCC保存的数据，它其中有1个字段就是Policy。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Validation returns how to validate transactions for this chaincode.</span></span><br><span class="line"><span class="comment">// The string returned is the name of the validation method (usually 'vscc')</span></span><br><span class="line"><span class="comment">// and the bytes returned are the argument to the validation (in the case of</span></span><br><span class="line"><span class="comment">// 'vscc', this is a marshaled pb.VSCCArgs message).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cd *ChaincodeData)</span> <span class="title">Validation</span><span class="params">()</span> <span class="params">(<span class="keyword">string</span>, []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> cd.Vscc, cd.Policy</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------- ChaincodeData is stored on the LSCC -------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ChaincodeData defines the datastructure for chaincodes to be serialized by proto</span></span><br><span class="line"><span class="comment">// Type provides an additional check by directing to use a specific package after instantiation</span></span><br><span class="line"><span class="comment">// Data is Type specifc (see CDSPackage and SignedCDSPackage)</span></span><br><span class="line"><span class="keyword">type</span> ChaincodeData <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Name of the chaincode</span></span><br><span class="line">Name <span class="keyword">string</span> <span class="string">`protobuf:"bytes,1,opt,name=name"`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Version of the chaincode</span></span><br><span class="line">Version <span class="keyword">string</span> <span class="string">`protobuf:"bytes,2,opt,name=version"`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Escc for the chaincode instance</span></span><br><span class="line">Escc <span class="keyword">string</span> <span class="string">`protobuf:"bytes,3,opt,name=escc"`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Vscc for the chaincode instance</span></span><br><span class="line">Vscc <span class="keyword">string</span> <span class="string">`protobuf:"bytes,4,opt,name=vscc"`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 背书策略</span></span><br><span class="line"><span class="comment">// Policy endorsement policy for the chaincode instance</span></span><br><span class="line">Policy []<span class="keyword">byte</span> <span class="string">`protobuf:"bytes,5,opt,name=policy,proto3"`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Data data specific to the package</span></span><br><span class="line">Data []<span class="keyword">byte</span> <span class="string">`protobuf:"bytes,6,opt,name=data,proto3"`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Id of the chaincode that's the unique fingerprint for the CC This is not</span></span><br><span class="line"><span class="comment">// currently used anywhere but serves as a good eyecatcher</span></span><br><span class="line">Id []<span class="keyword">byte</span> <span class="string">`protobuf:"bytes,7,opt,name=id,proto3"`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// InstantiationPolicy for the chaincode</span></span><br><span class="line">InstantiationPolicy []<span class="keyword">byte</span> <span class="string">`protobuf:"bytes,8,opt,name=instantiation_policy,proto3"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LSCC的Policy哪来的？"><a href="#LSCC的Policy哪来的？" class="headerlink" title="LSCC的Policy哪来的？"></a>LSCC的Policy哪来的？</h2><blockquote><p>提醒：链码实例化在代码里使用<strong>Deploy</strong>，而不是Instantiate，这样可以让代码更简洁，所以链码实例化也常称为链码部署。</p></blockquote><p><code>executeDeploy</code>为部署链码，也就是在部署链码的时候会保存背书策略。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// executeDeploy implements the "instantiate" Invoke transaction</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lscc *LifeCycleSysCC)</span> <span class="title">executeDeploy</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">stub shim.ChaincodeStubInterface,</span></span></span><br><span class="line"><span class="function"><span class="params">chainname <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">cds *pb.ChaincodeDeploymentSpec,</span></span></span><br><span class="line"><span class="function"><span class="params">policy []<span class="keyword">byte</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">escc []<span class="keyword">byte</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">vscc []<span class="keyword">byte</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">cdfs *ccprovider.ChaincodeData,</span></span></span><br><span class="line"><span class="function"><span class="params">ccpackfs ccprovider.CCPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">collectionConfigBytes []<span class="keyword">byte</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(*ccprovider.ChaincodeData, error)</span></span> &#123;</span><br><span class="line"><span class="comment">//just test for existence of the chaincode in the LSCC</span></span><br><span class="line">chaincodeName := cds.ChaincodeSpec.ChaincodeId.Name</span><br><span class="line">_, err := lscc.getCCInstance(stub, chaincodeName)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, ExistsErr(chaincodeName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//retain chaincode specific data and fill channel specific ones</span></span><br><span class="line">cdfs.Escc = <span class="keyword">string</span>(escc)</span><br><span class="line">cdfs.Vscc = <span class="keyword">string</span>(vscc)</span><br><span class="line"><span class="comment">// 保存背书策略</span></span><br><span class="line">cdfs.Policy = policy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>executeDeployOrUpgrade</code>是执行链码实例化和升级时调用，它会传递Policy，在链码部署和升级时都会保存背书策略。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// executeDeployOrUpgrade routes the code path either to executeDeploy or executeUpgrade</span></span><br><span class="line"><span class="comment">// depending on its function argument</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lscc *LifeCycleSysCC)</span> <span class="title">executeDeployOrUpgrade</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">stub shim.ChaincodeStubInterface,</span></span></span><br><span class="line"><span class="function"><span class="params">chainname <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">cds *pb.ChaincodeDeploymentSpec,</span></span></span><br><span class="line"><span class="function"><span class="params">policy, escc, vscc, collectionConfigBytes []<span class="keyword">byte</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">function <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(*ccprovider.ChaincodeData, error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">chaincodeName := cds.ChaincodeSpec.ChaincodeId.Name</span><br><span class="line">chaincodeVersion := cds.ChaincodeSpec.ChaincodeId.Version</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := lscc.isValidChaincodeName(chaincodeName); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := lscc.isValidChaincodeVersion(chaincodeName, chaincodeVersion); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ccpack, err := lscc.Support.GetChaincodeFromLocalStorage(chaincodeName, chaincodeVersion)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">retErrMsg := fmt.Sprintf(<span class="string">"cannot get package for chaincode (%s:%s)"</span>, chaincodeName, chaincodeVersion)</span><br><span class="line">logger.Errorf(<span class="string">"%s-err:%s"</span>, retErrMsg, err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"%s"</span>, retErrMsg)</span><br><span class="line">&#125;</span><br><span class="line">cd := ccpack.GetChaincodeData()</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> function &#123;</span><br><span class="line"><span class="keyword">case</span> DEPLOY:</span><br><span class="line"><span class="keyword">return</span> lscc.executeDeploy(stub, chainname, cds, policy, escc, vscc, cd, ccpack, collectionConfigBytes)</span><br><span class="line"><span class="keyword">case</span> UPGRADE:</span><br><span class="line"><span class="keyword">return</span> lscc.executeUpgrade(stub, chainname, cds, policy, escc, vscc, cd, ccpack, collectionConfigBytes)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">logger.Panicf(<span class="string">"Programming error, unexpected function '%s'"</span>, function)</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">""</span>) <span class="comment">// unreachable code</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LSCC也实现了ChainCode接口，与普通链码的实现并没有区别，只不过LSCC并不运行在容器中。<code>LifeCycleSysCC.Invoke</code>会根据参数调用不同的函数，而部署和升级时，会调用<code>executeDeployOrUpgrade</code>部署链码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Invoke implements lifecycle functions "deploy", "start", "stop", "upgrade".</span></span><br><span class="line"><span class="comment">// Deploy's arguments -  &#123;[]byte("deploy"), []byte(&lt;chainname&gt;), &lt;unmarshalled pb.ChaincodeDeploymentSpec&gt;&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Invoke also implements some query-like functions</span></span><br><span class="line"><span class="comment">// Get chaincode arguments -  &#123;[]byte("getid"), []byte(&lt;chainname&gt;), []byte(&lt;chaincodename&gt;)&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lscc *LifeCycleSysCC)</span> <span class="title">Invoke</span><span class="params">(stub shim.ChaincodeStubInterface)</span> <span class="title">pb</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">switch</span> function &#123;</span><br><span class="line">    <span class="keyword">case</span> INSTALL:</span><br><span class="line">      ...</span><br><span class="line">    <span class="keyword">case</span> DEPLOY, UPGRADE:</span><br><span class="line">      <span class="comment">// 提取背书策略</span></span><br><span class="line">      <span class="comment">// optional arguments here (they can each be nil and may or may not be present)</span></span><br><span class="line">      <span class="comment">// args[3] is a marshalled SignaturePolicyEnvelope representing the endorsement policy</span></span><br><span class="line">      <span class="comment">// args[4] is the name of escc</span></span><br><span class="line">      <span class="comment">// args[5] is the name of vscc</span></span><br><span class="line">      <span class="comment">// args[6] is a marshalled CollectionConfigPackage struct</span></span><br><span class="line">      <span class="keyword">var</span> EP []<span class="keyword">byte</span></span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">len</span>(args) &gt; <span class="number">3</span> &amp;&amp; <span class="built_in">len</span>(args[<span class="number">3</span>]) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        EP = args[<span class="number">3</span>]</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p := cauthdsl.SignedByAnyMember(peer.GetMSPIDs(channel))</span><br><span class="line">        EP, err = utils.Marshal(p)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> shim.Error(err.Error())</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">      cd, err := lscc.executeDeployOrUpgrade(stub, channel, cds, EP, escc, vscc, collectionsConfig, function)</span><br><span class="line">      ...</span><br><span class="line">    <span class="keyword">case</span> ...:</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们终于知道Policy是哪来的，又是如何被使用的了。管理和查看链码信息，本质是创建一个调用LSCC的Proposal或者交易，链码的信息会保存在LSCC，当VSCC验证链码的交易时，会从LSCC获取信息，包括背书策略、vscc插件等，以验证交易。</p><p>最后，ESCC、VSCC也是进行了可插拔设计的。</p><p><img src="http://img.lessisbetter.site/2019-09-endorser-policy.png" alt="endorser policy"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://img.lessisbetter.site/2019-09-endorser-policy.png&quot; alt=&quot;endorser policy&quot;&gt;&lt;/p&gt;
&lt;p&gt;背书策略是Fabric中的一个重要一环，想梳理一下背书策略的上链和使用流程。&lt;
      
    
    </summary>
    
    
    
      <category term="区块链" scheme="http://lessisbetter.site/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Fabric" scheme="http://lessisbetter.site/tags/Fabric/"/>
    
  </entry>
  
</feed>
