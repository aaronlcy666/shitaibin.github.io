<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.4.2" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.4.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.4.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.4.2">


  <link rel="mask-icon" href="/images/logo.svg?v=6.4.2" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.4.2',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="前言这篇文章从区块传播策略入手，介绍新区块是如何传播到远端节点，以及新区块加入到远端节点本地链的过程，同时会介绍fetcher模块，fetcher的功能是处理Peer通知的区块信息。在介绍过程中，还会涉及到p2p，eth等模块，不会专门介绍，而是专注区块的传播和加入区块链的过程。 当前代码是以太坊Release 1.8，如果版本不同，代码上可能存在差异。">
<meta name="keywords" content="以太坊">
<meta property="og:type" content="article">
<meta property="og:title" content="以太坊源码分析：fetcher模块和区块传播">
<meta property="og:url" content="http://shitaibin.github.io/2018/08/30/ethereum-fetcher-module-and-block-propagate/index.html">
<meta property="og:site_name" content="随风">
<meta property="og:description" content="前言这篇文章从区块传播策略入手，介绍新区块是如何传播到远端节点，以及新区块加入到远端节点本地链的过程，同时会介绍fetcher模块，fetcher的功能是处理Peer通知的区块信息。在介绍过程中，还会涉及到p2p，eth等模块，不会专门介绍，而是专注区块的传播和加入区块链的过程。 当前代码是以太坊Release 1.8，如果版本不同，代码上可能存在差异。">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://7xixtr.com1.z0.glb.clouddn.com/image-20180821115214521.png-own">
<meta property="og:image" content="http://7xixtr.com1.z0.glb.clouddn.com/image-20180821114210114.png-own">
<meta property="og:image" content="http://7xixtr.com1.z0.glb.clouddn.com/image-20180821114756055.png-own">
<meta property="og:image" content="http://7xixtr.com1.z0.glb.clouddn.com/image-20180821175330370.png-own">
<meta property="og:image" content="http://7xixtr.com1.z0.glb.clouddn.com/image-20180821115537184.png-own">
<meta property="og:image" content="http://7xixtr.com1.z0.glb.clouddn.com/image-20180821143403650.png-own">
<meta property="og:image" content="http://7xixtr.com1.z0.glb.clouddn.com/image-20180822103401508.png-own">
<meta property="og:image" content="http://7xixtr.com1.z0.glb.clouddn.com/image-20180822103701006.png-own">
<meta property="og:updated_time" content="2018-09-01T07:49:38.441Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="以太坊源码分析：fetcher模块和区块传播">
<meta name="twitter:description" content="前言这篇文章从区块传播策略入手，介绍新区块是如何传播到远端节点，以及新区块加入到远端节点本地链的过程，同时会介绍fetcher模块，fetcher的功能是处理Peer通知的区块信息。在介绍过程中，还会涉及到p2p，eth等模块，不会专门介绍，而是专注区块的传播和加入区块链的过程。 当前代码是以太坊Release 1.8，如果版本不同，代码上可能存在差异。">
<meta name="twitter:image" content="http://7xixtr.com1.z0.glb.clouddn.com/image-20180821115214521.png-own">






  <link rel="canonical" href="http://shitaibin.github.io/2018/08/30/ethereum-fetcher-module-and-block-propagate/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>以太坊源码分析：fetcher模块和区块传播 | 随风</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">随风</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">云象区块链招区块链工程师，内推请邮件shitb[@]yunphant.com</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Home</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />About</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />Tags</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />Archives</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://shitaibin.github.io/2018/08/30/ethereum-fetcher-module-and-block-propagate/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="专注区块链技术，深耕区块链发展，关注Go语言发展">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="随风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">以太坊源码分析：fetcher模块和区块传播
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-08-30 16:49:47" itemprop="dateCreated datePublished" datetime="2018-08-30T16:49:47+08:00">2018-08-30</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-09-01 15:49:38" itemprop="dateModified" datetime="2018-09-01T15:49:38+08:00">2018-09-01</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1><span id="前言">前言</span></h1><p>这篇文章从区块传播策略入手，介绍新区块是如何传播到远端节点，以及新区块加入到远端节点本地链的过程，同时会介绍fetcher模块，fetcher的功能是处理Peer通知的区块信息。在介绍过程中，还会涉及到p2p，eth等模块，不会专门介绍，而是专注区块的传播和加入区块链的过程。</p>
<p>当前代码是以太坊Release 1.8，如果版本不同，代码上可能存在差异。</p>
<a id="more"></a>
<h1><span id="总体过程和传播策略">总体过程和传播策略</span></h1><p>本节从宏观角度介绍，节点产生区块后，为了传播给远端节点做了啥，远端节点收到区块后又做了什么，每个节点都连接了很多Peer，它传播的策略是什么样的？</p>
<p>总体流程和策略可以总结为，传播给远端Peer节点，Peer验证区块无误后，加入到本地区块链，继续传播新区块信息。具体过程如下。</p>
<p>先看总体过程。产生区块后，<code>miner</code>模块会发布一个事件<code>NewMinedBlockEvent</code>，订阅事件的协程收到事件后，就会把新区块的消息，广播给它所有的peer，peer收到消息后，会交给自己的fetcher模块处理，fetcher进行基本的验证后，区块没问题，发现这个区块就是本地链需要的下一个区块，则交给<code>blockChain</code>进一步进行完整的验证，这个过程会执行区块所有的交易，无误后把区块加入到本地链，写入数据库，这个过程就是下面的流程图，图1。</p>
<p><img src="http://7xixtr.com1.z0.glb.clouddn.com/image-20180821115214521.png-own" alt="图1：新区块传播总体流程图"></p>
<p>总体流程图，能看到有个分叉，是因为节点传播新区块是有策略的。它的传播策略为：</p>
<ol>
<li>假如节点连接了<code>N</code>个Peer，它只向Peer列表的<code>sqrt(N)</code>个Peer广播<strong>完整的区块</strong>消息。</li>
<li>向所有的Peer广播<strong>只包含区块Hash</strong>的消息。</li>
</ol>
<p>策略图的效果如图2，红色节点将区块传播给黄色节点：<img src="http://7xixtr.com1.z0.glb.clouddn.com/image-20180821114210114.png-own" alt="图2：产生区块后传播给相邻节点"></p>
<p>收到区块Hash的节点，需要从发送给它消息的Peer那里获取对应的完整区块，获取区块后就会按照图1的流程，加入到fetcher队列，最终插入本地区块链后，<strong>将区块的Hash值广播给和它相连，但还不知道这个区块的Peer</strong>。非产生区块节点的策略图，如图3，黄色节点将区块Hash传播给青色节点：<img src="http://7xixtr.com1.z0.glb.clouddn.com/image-20180821114756055.png-own" alt="图3：非产块节点传播新区块"></p>
<p>至此，可以看出<strong>以太坊采用以石击水的方式，像水纹一样，层层扩散新产生的区块</strong>。</p>
<h1><span id="fetcher模块是干啥的">Fetcher模块是干啥的</span></h1><p>fetcher模块的功能，就是收集其他Peer通知它的区块信息：1）完整的区块2）区块Hash消息。根据通知的消息，获取完整的区块，然后传递给<code>eth</code>模块把区块插入区块链。</p>
<p>如果是完整区块，就可以传递给eth插入区块，如果只有区块Hash，则需要从其他的Peer获取此完整的区块，然后再传递给eth插入区块。</p>
<p><img src="http://7xixtr.com1.z0.glb.clouddn.com/image-20180821175330370.png-own" alt="fetcher功能抽象"></p>
<h1><span id="源码解读">源码解读</span></h1><p>本节介绍区块传播和处理的细节东西，方式仍然是先用图解释流程，再是代码流程。</p>
<h2><span id="产块节点的传播新区块">产块节点的传播新区块</span></h2><p>节点产生区块后，广播的流程可以表示为图4：</p>
<ol>
<li>发布事件</li>
<li>事件处理函数选择要广播完整的Peer，然后将区块加入到它们的队列</li>
<li>事件处理函数把区块Hash添加到所有Peer的另外一个通知队列</li>
<li>每个Peer的广播处理函数，会遍历它的待广播区块队列和通知队列，把数据封装成消息，调用P2P接口发送出去</li>
</ol>
<p><img src="http://7xixtr.com1.z0.glb.clouddn.com/image-20180821115537184.png-own" alt="图4：产块节点的传播图"></p>
<p>再看下代码上的细节。</p>
<ol>
<li><code>worker.wait()</code>函数发布事件<code>NewMinedBlockEvent</code>。</li>
<li><code>ProtocolManager.minedBroadcastLoop()</code>是事件处理函数。它调用了2次<code>pm.BroadcastBlock()</code>。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mined broadcast loop</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *ProtocolManager)</span> <span class="title">minedBroadcastLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// automatically stops if unsubscribe</span></span><br><span class="line">	<span class="keyword">for</span> obj := <span class="keyword">range</span> pm.minedBlockSub.Chan() &#123;</span><br><span class="line">		<span class="keyword">switch</span> ev := obj.Data.(<span class="keyword">type</span>) &#123;</span><br><span class="line">		<span class="keyword">case</span> core.NewMinedBlockEvent:</span><br><span class="line">			pm.BroadcastBlock(ev.Block, <span class="literal">true</span>)  <span class="comment">// First propagate block to peers</span></span><br><span class="line">			pm.BroadcastBlock(ev.Block, <span class="literal">false</span>) <span class="comment">// Only then announce to the rest</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>pm.BroadcastBlock()</code>的入参<code>propagate</code>为真时，向部分Peer广播完整的区块，调用<code>peer.AsyncSendNewBlock()</code>，否则向所有Peer广播区块头，调用<code>peer.AsyncSendNewBlockHash()</code>，这2个函数就是把数据放入队列，此处不再放代码。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BroadcastBlock will either propagate a block to a subset of it's peers, or</span></span><br><span class="line"><span class="comment">// will only announce it's availability (depending what's requested).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *ProtocolManager)</span> <span class="title">BroadcastBlock</span><span class="params">(block *types.Block, propagate <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	hash := block.Hash()</span><br><span class="line">	peers := pm.peers.PeersWithoutBlock(hash)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If propagation is requested, send to a subset of the peer</span></span><br><span class="line">	<span class="comment">// 这种情况，要把区块广播给部分peer</span></span><br><span class="line">	<span class="keyword">if</span> propagate &#123;</span><br><span class="line">		<span class="comment">// Calculate the TD of the block (it's not imported yet, so block.Td is not valid)</span></span><br><span class="line">		<span class="comment">// 计算新的总难度</span></span><br><span class="line">		<span class="keyword">var</span> td *big.Int</span><br><span class="line">		<span class="keyword">if</span> parent := pm.blockchain.GetBlock(block.ParentHash(), block.NumberU64()<span class="number">-1</span>); parent != <span class="literal">nil</span> &#123;</span><br><span class="line">			td = <span class="built_in">new</span>(big.Int).Add(block.Difficulty(), pm.blockchain.GetTd(block.ParentHash(), block.NumberU64()<span class="number">-1</span>))</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			log.Error(<span class="string">"Propagating dangling block"</span>, <span class="string">"number"</span>, block.Number(), <span class="string">"hash"</span>, hash)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Send the block to a subset of our peers</span></span><br><span class="line">		<span class="comment">// 广播区块给部分peer</span></span><br><span class="line">		transfer := peers[:<span class="keyword">int</span>(math.Sqrt(<span class="keyword">float64</span>(<span class="built_in">len</span>(peers))))]</span><br><span class="line">		<span class="keyword">for</span> _, peer := <span class="keyword">range</span> transfer &#123;</span><br><span class="line">			peer.AsyncSendNewBlock(block, td)</span><br><span class="line">		&#125;</span><br><span class="line">		log.Trace(<span class="string">"Propagated block"</span>, <span class="string">"hash"</span>, hash, <span class="string">"recipients"</span>, <span class="built_in">len</span>(transfer), <span class="string">"duration"</span>, common.PrettyDuration(time.Since(block.ReceivedAt)))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Otherwise if the block is indeed in out own chain, announce it</span></span><br><span class="line">	<span class="comment">// 把区块hash值广播给所有peer</span></span><br><span class="line">	<span class="keyword">if</span> pm.blockchain.HasBlock(hash, block.NumberU64()) &#123;</span><br><span class="line">		<span class="keyword">for</span> _, peer := <span class="keyword">range</span> peers &#123;</span><br><span class="line">			peer.AsyncSendNewBlockHash(block)</span><br><span class="line">		&#125;</span><br><span class="line">		log.Trace(<span class="string">"Announced block"</span>, <span class="string">"hash"</span>, hash, <span class="string">"recipients"</span>, <span class="built_in">len</span>(peers), <span class="string">"duration"</span>, common.PrettyDuration(time.Since(block.ReceivedAt)))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p><code>peer.broadcase()</code>是每个Peer连接的广播函数，它只广播3种消息：交易、完整的区块、区块的Hash，这样表明了节点只会主动广播这3中类型的数据，剩余的数据同步，都是通过<strong>请求-响应</strong>的方式。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// broadcast is a write loop that multiplexes block propagations, announcements</span></span><br><span class="line"><span class="comment">// and transaction broadcasts into the remote peer. The goal is to have an async</span></span><br><span class="line"><span class="comment">// writer that does not lock up node internals.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *peer)</span> <span class="title">broadcast</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="comment">// 广播交易</span></span><br><span class="line">		<span class="keyword">case</span> txs := &lt;-p.queuedTxs:</span><br><span class="line">			<span class="keyword">if</span> err := p.SendTransactions(txs); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			p.Log().Trace(<span class="string">"Broadcast transactions"</span>, <span class="string">"count"</span>, <span class="built_in">len</span>(txs))</span><br><span class="line">		<span class="comment">// 广播完整的新区块</span></span><br><span class="line">		<span class="keyword">case</span> prop := &lt;-p.queuedProps:</span><br><span class="line">			<span class="keyword">if</span> err := p.SendNewBlock(prop.block, prop.td); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			p.Log().Trace(<span class="string">"Propagated block"</span>, <span class="string">"number"</span>, prop.block.Number(), <span class="string">"hash"</span>, prop.block.Hash(), <span class="string">"td"</span>, prop.td)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 广播区块Hash</span></span><br><span class="line">		<span class="keyword">case</span> block := &lt;-p.queuedAnns:</span><br><span class="line">			<span class="keyword">if</span> err := p.SendNewBlockHashes([]common.Hash&#123;block.Hash()&#125;, []<span class="keyword">uint64</span>&#123;block.NumberU64()&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			p.Log().Trace(<span class="string">"Announced block"</span>, <span class="string">"number"</span>, block.Number(), <span class="string">"hash"</span>, block.Hash())</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> &lt;-p.term:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2><span id="peer节点处理新区块">Peer节点处理新区块</span></h2><p>本节介绍远端节点收到2种区块同步消息的处理，其中<code>NewBlockMsg</code>的处理流程比较清晰，也简洁。<code>NewBlockHashesMsg</code>消息的处理就绕了2绕，从总体流程图1上能看出来，它需要先从给他发送消息Peer那里获取到完整的区块，剩下的流程和<code>NewBlockMsg</code>又一致了。</p>
<p>这部分涉及的模块多，画出来有种眼花缭乱的感觉，但只要抓住上面的主线，代码看起来还是很清晰的。通过图5先看下整体流程。</p>
<p>消息处理的起点是<code>ProtocolManager.handleMsg</code>，<code>NewBlockMsg</code>的处理流程是蓝色标记的区域，红色区域是单独的协程，是fetcher处理队列中区块的流程，如果从队列中取出的区块是当前链需要的，校验后，调用<code>blockchian.InsertChain()</code>把区块插入到区块链，最后写入数据库，这是黄色部分。最后，绿色部分是<code>NewBlockHashesMsg</code>的处理流程，代码流程上是比较复杂的，为了能通过图描述整体流程，我把它简化掉了。</p>
<p><img src="http://7xixtr.com1.z0.glb.clouddn.com/image-20180821143403650.png-own" alt="图5：远端节点处理新区块"></p>
<p>仔细看看这幅图，掌握整体的流程后，接下来看每个步骤的细节。</p>
<h3><span id="newblockmsg的处理">NewBlockMsg的处理</span></h3><p>本节介绍节点收到完整区块的处理，流程如下：</p>
<ol>
<li>首先进行RLP编解码，然后标记发送消息的Peer已经知道这个区块，这样本节点最后广播这个区块的Hash时，不会再发送给该Peer。</li>
<li>将区块存入到fetcher的队列，<code>调用fetcher.Enqueue</code>。</li>
<li>更新Peer的Head位置，然后判断本地链是否落后于Peer的链，如果是，则通过Peer更新本地链。</li>
</ol>
<p>只看<code>handle.Msg()</code>的<code>NewBlockMsg</code>相关的部分。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> msg.Code == NewBlockMsg:</span><br><span class="line">	<span class="comment">// Retrieve and decode the propagated block</span></span><br><span class="line">	<span class="comment">// 收到新区块，解码，赋值接收数据</span></span><br><span class="line">	<span class="keyword">var</span> request newBlockData</span><br><span class="line">	<span class="keyword">if</span> err := msg.Decode(&amp;request); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errResp(ErrDecode, <span class="string">"%v: %v"</span>, msg, err)</span><br><span class="line">	&#125;</span><br><span class="line">	request.Block.ReceivedAt = msg.ReceivedAt</span><br><span class="line">	request.Block.ReceivedFrom = p</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Mark the peer as owning the block and schedule it for import</span></span><br><span class="line">	<span class="comment">// 标记peer知道这个区块</span></span><br><span class="line">	p.MarkBlock(request.Block.Hash())</span><br><span class="line">	<span class="comment">// 为啥要如队列？已经得到完整的区块了</span></span><br><span class="line">	<span class="comment">// 答：存入fetcher的优先级队列，fetcher会从队列中选取当前高度需要的块</span></span><br><span class="line">	pm.fetcher.Enqueue(p.id, request.Block)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Assuming the block is importable by the peer, but possibly not yet done so,</span></span><br><span class="line">	<span class="comment">// calculate the head hash and TD that the peer truly must have.</span></span><br><span class="line">	<span class="comment">// 截止到parent区块的头和难度</span></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		trueHead = request.Block.ParentHash()</span><br><span class="line">		trueTD   = <span class="built_in">new</span>(big.Int).Sub(request.TD, request.Block.Difficulty())</span><br><span class="line">	)</span><br><span class="line">	<span class="comment">// Update the peers total difficulty if better than the previous</span></span><br><span class="line">	<span class="comment">// 如果收到的块的难度大于peer之前的，以及自己本地的，就去和这个peer同步</span></span><br><span class="line">	<span class="comment">// 问题：就只用了一下块里的hash指，为啥不直接使用这个块呢，如果这个块不能用，干嘛不少发送些数据，减少网络负载呢。</span></span><br><span class="line">	<span class="comment">// 答案：实际上，这个块加入到了优先级队列中，当fetcher的loop检查到当前下一个区块的高度，正是队列中有的，则不再向peer请求</span></span><br><span class="line">	<span class="comment">// 该区块，而是直接使用该区块，检查无误后交给block chain执行insertChain</span></span><br><span class="line">	<span class="keyword">if</span> _, td := p.Head(); trueTD.Cmp(td) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		p.SetHead(trueHead, trueTD)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Schedule a sync if above ours. Note, this will not fire a sync for a gap of</span></span><br><span class="line">		<span class="comment">// a singe block (as the true TD is below the propagated block), however this</span></span><br><span class="line">		<span class="comment">// scenario should easily be covered by the fetcher.</span></span><br><span class="line">		currentBlock := pm.blockchain.CurrentBlock()</span><br><span class="line">		<span class="keyword">if</span> trueTD.Cmp(pm.blockchain.GetTd(currentBlock.Hash(), currentBlock.NumberU64())) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">go</span> pm.synchronise(p)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//------------------------ 以上 handleMsg</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Enqueue tries to fill gaps the the fetcher's future import queue.</span></span><br><span class="line"><span class="comment">// 发给inject通道，当前协程在handleMsg，通过通道发送给fetcher的协程处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Fetcher)</span> <span class="title">Enqueue</span><span class="params">(peer <span class="keyword">string</span>, block *types.Block)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	op := &amp;inject&#123;</span><br><span class="line">		origin: peer,</span><br><span class="line">		block:  block,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> f.inject &lt;- op:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-f.quit:</span><br><span class="line">		<span class="keyword">return</span> errTerminated</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------ 以下 fetcher.loop处理inject部分</span></span><br><span class="line"><span class="keyword">case</span> op := &lt;-f.inject:</span><br><span class="line">	<span class="comment">// A direct block insertion was requested, try and fill any pending gaps</span></span><br><span class="line">	<span class="comment">// 区块加入队列，首先也填入未决的间距</span></span><br><span class="line">	propBroadcastInMeter.Mark(<span class="number">1</span>)</span><br><span class="line">	f.enqueue(op.origin, op.block)</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------  如队列函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// enqueue schedules a new future import operation, if the block to be imported</span></span><br><span class="line"><span class="comment">// has not yet been seen.</span></span><br><span class="line"><span class="comment">// 把导入的新区块放进来</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Fetcher)</span> <span class="title">enqueue</span><span class="params">(peer <span class="keyword">string</span>, block *types.Block)</span></span> &#123;</span><br><span class="line">	hash := block.Hash()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Ensure the peer isn't DOSing us</span></span><br><span class="line">	<span class="comment">// 防止peer的DOS攻击</span></span><br><span class="line">	count := f.queues[peer] + <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> count &gt; blockLimit &#123;</span><br><span class="line">		log.Debug(<span class="string">"Discarded propagated block, exceeded allowance"</span>, <span class="string">"peer"</span>, peer, <span class="string">"number"</span>, block.Number(), <span class="string">"hash"</span>, hash, <span class="string">"limit"</span>, blockLimit)</span><br><span class="line">		propBroadcastDOSMeter.Mark(<span class="number">1</span>)</span><br><span class="line">		f.forgetHash(hash)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Discard any past or too distant blocks</span></span><br><span class="line">	<span class="comment">// 高度检查：未来太远的块丢弃</span></span><br><span class="line">	<span class="keyword">if</span> dist := <span class="keyword">int64</span>(block.NumberU64()) - <span class="keyword">int64</span>(f.chainHeight()); dist &lt; -maxUncleDist || dist &gt; maxQueueDist &#123;</span><br><span class="line">		log.Debug(<span class="string">"Discarded propagated block, too far away"</span>, <span class="string">"peer"</span>, peer, <span class="string">"number"</span>, block.Number(), <span class="string">"hash"</span>, hash, <span class="string">"distance"</span>, dist)</span><br><span class="line">		propBroadcastDropMeter.Mark(<span class="number">1</span>)</span><br><span class="line">		f.forgetHash(hash)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Schedule the block for future importing</span></span><br><span class="line">	<span class="comment">// 块先加入优先级队列，加入链之前，还有很多要做</span></span><br><span class="line">	<span class="keyword">if</span> _, ok := f.queued[hash]; !ok &#123;</span><br><span class="line">		op := &amp;inject&#123;</span><br><span class="line">			origin: peer,</span><br><span class="line">			block:  block,</span><br><span class="line">		&#125;</span><br><span class="line">		f.queues[peer] = count</span><br><span class="line">		f.queued[hash] = op</span><br><span class="line">		f.queue.Push(op, -<span class="keyword">float32</span>(block.NumberU64()))</span><br><span class="line">		<span class="keyword">if</span> f.queueChangeHook != <span class="literal">nil</span> &#123;</span><br><span class="line">			f.queueChangeHook(op.block.Hash(), <span class="literal">true</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		log.Debug(<span class="string">"Queued propagated block"</span>, <span class="string">"peer"</span>, peer, <span class="string">"number"</span>, block.Number(), <span class="string">"hash"</span>, hash, <span class="string">"queued"</span>, f.queue.Size())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="fetcher队列处理">fetcher队列处理</span></h3><p>本节我们看看，区块加入队列后，fetcher如何处理区块，为何不直接校验区块，插入到本地链？</p>
<p>由于以太坊又Uncle的机制，节点可能收到老一点的一些区块。另外，节点可能由于网络原因，落后了几个区块，所以可能收到“未来”的一些区块，这些区块都不能直接插入到本地链。</p>
<p>区块入的队列是一个优先级队列，高度低的区块会被优先取出来。<code>fetcher.loop</code>是单独协程，不断运转，清理fecther中的事务和事件。首先会清理正在<code>fetching</code>的区块，但已经超时。然后处理优先级队列中的区块，判断高度是否是下一个区块，如果是则调用<code>f.insert()</code>函数，校验后调用<code>BlockChain.InsertChain()</code>，成功插入后，<strong>广播新区块的Hash</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Loop is the main fetcher loop, checking and processing various notification</span></span><br><span class="line"><span class="comment">// events.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Fetcher)</span> <span class="title">loop</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Iterate the block fetching until a quit is requested</span></span><br><span class="line">	fetchTimer := time.NewTimer(<span class="number">0</span>)</span><br><span class="line">	completeTimer := time.NewTimer(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// Clean up any expired block fetches</span></span><br><span class="line">		<span class="comment">// 清理过期的区块</span></span><br><span class="line">		<span class="keyword">for</span> hash, announce := <span class="keyword">range</span> f.fetching &#123;</span><br><span class="line">			<span class="keyword">if</span> time.Since(announce.time) &gt; fetchTimeout &#123;</span><br><span class="line">				f.forgetHash(hash)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Import any queued blocks that could potentially fit</span></span><br><span class="line">		<span class="comment">// 导入队列中合适的块</span></span><br><span class="line">		height := f.chainHeight()</span><br><span class="line">		<span class="keyword">for</span> !f.queue.Empty() &#123;</span><br><span class="line">			op := f.queue.PopItem().(*inject)</span><br><span class="line">			hash := op.block.Hash()</span><br><span class="line">			<span class="keyword">if</span> f.queueChangeHook != <span class="literal">nil</span> &#123;</span><br><span class="line">				f.queueChangeHook(hash, <span class="literal">false</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// If too high up the chain or phase, continue later</span></span><br><span class="line">			<span class="comment">// 块不是链需要的下一个块，再入优先级队列，停止循环</span></span><br><span class="line">			number := op.block.NumberU64()</span><br><span class="line">			<span class="keyword">if</span> number &gt; height+<span class="number">1</span> &#123;</span><br><span class="line">				f.queue.Push(op, -<span class="keyword">float32</span>(number))</span><br><span class="line">				<span class="keyword">if</span> f.queueChangeHook != <span class="literal">nil</span> &#123;</span><br><span class="line">					f.queueChangeHook(hash, <span class="literal">true</span>)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Otherwise if fresh and still unknown, try and import</span></span><br><span class="line">			<span class="comment">// 高度正好是我们想要的，并且链上也没有这个块</span></span><br><span class="line">			<span class="keyword">if</span> number+maxUncleDist &lt; height || f.getBlock(hash) != <span class="literal">nil</span> &#123;</span><br><span class="line">				f.forgetBlock(hash)</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 那么，块插入链</span></span><br><span class="line">			f.insert(op.origin, op.block)</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//省略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Fetcher)</span> <span class="title">insert</span><span class="params">(peer <span class="keyword">string</span>, block *types.Block)</span></span> &#123;</span><br><span class="line">	hash := block.Hash()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Run the import on a new thread</span></span><br><span class="line">	log.Debug(<span class="string">"Importing propagated block"</span>, <span class="string">"peer"</span>, peer, <span class="string">"number"</span>, block.Number(), <span class="string">"hash"</span>, hash)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; f.done &lt;- hash &#125;()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// If the parent's unknown, abort insertion</span></span><br><span class="line">		parent := f.getBlock(block.ParentHash())</span><br><span class="line">		<span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Debug(<span class="string">"Unknown parent of propagated block"</span>, <span class="string">"peer"</span>, peer, <span class="string">"number"</span>, block.Number(), <span class="string">"hash"</span>, hash, <span class="string">"parent"</span>, block.ParentHash())</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Quickly validate the header and propagate the block if it passes</span></span><br><span class="line">		<span class="comment">// 验证区块头，成功后广播区块</span></span><br><span class="line">		<span class="keyword">switch</span> err := f.verifyHeader(block.Header()); err &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">			<span class="comment">// All ok, quickly propagate to our peers</span></span><br><span class="line">			propBroadcastOutTimer.UpdateSince(block.ReceivedAt)</span><br><span class="line">			<span class="keyword">go</span> f.broadcastBlock(block, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> consensus.ErrFutureBlock:</span><br><span class="line">			<span class="comment">// Weird future block, don't fail, but neither propagate</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="comment">// Something went very wrong, drop the peer</span></span><br><span class="line">			log.Debug(<span class="string">"Propagated block verification failed"</span>, <span class="string">"peer"</span>, peer, <span class="string">"number"</span>, block.Number(), <span class="string">"hash"</span>, hash, <span class="string">"err"</span>, err)</span><br><span class="line">			f.dropPeer(peer)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Run the actual import and log any issues</span></span><br><span class="line">		<span class="comment">// 调用回调函数，实际是blockChain.insertChain</span></span><br><span class="line">		<span class="keyword">if</span> _, err := f.insertChain(types.Blocks&#123;block&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Debug(<span class="string">"Propagated block import failed"</span>, <span class="string">"peer"</span>, peer, <span class="string">"number"</span>, block.Number(), <span class="string">"hash"</span>, hash, <span class="string">"err"</span>, err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// If import succeeded, broadcast the block</span></span><br><span class="line">		propAnnounceOutTimer.UpdateSince(block.ReceivedAt)</span><br><span class="line">		<span class="keyword">go</span> f.broadcastBlock(block, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Invoke the testing hook if needed</span></span><br><span class="line">		<span class="keyword">if</span> f.importedHook != <span class="literal">nil</span> &#123;</span><br><span class="line">			f.importedHook(block)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="newblockhashesmsg的处理">NewBlockHashesMsg的处理</span></h3><p>本节介绍NewBlockHashesMsg的处理，其实，消息处理是简单的，而复杂一点的是从Peer哪获取完整的区块，下节再看。</p>
<p>流程如下:</p>
<ol>
<li>对消息进行RLP解码，然后标记Peer已经知道此区块。</li>
<li>寻找出本地区块链不存在的区块Hash值，把这些未知的Hash通知给fetcher。</li>
<li><code>fetcher.Notify</code>记录好通知信息，塞入<code>notify</code>通道，以便交给fetcher的协程。</li>
<li><code>fetcher.loop()</code>会对<code>notify</code>中的消息进行处理，确认区块并非DOS攻击，然后检查区块的高度，判断该区块是否已经在<code>fetching</code>或者<code>comleting(代表已经下载区块头，在下载body)</code>，如果都没有，则加入到<code>announced</code>中，触发0s定时器，进行处理。</li>
</ol>
<p>关于<code>announced</code>下节再介绍。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// handleMsg()部分</span></span><br><span class="line"><span class="keyword">case</span> msg.Code == NewBlockHashesMsg:</span><br><span class="line">	<span class="keyword">var</span> announces newBlockHashesData</span><br><span class="line">	<span class="keyword">if</span> err := msg.Decode(&amp;announces); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errResp(ErrDecode, <span class="string">"%v: %v"</span>, msg, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Mark the hashes as present at the remote node</span></span><br><span class="line">	<span class="keyword">for</span> _, block := <span class="keyword">range</span> announces &#123;</span><br><span class="line">		p.MarkBlock(block.Hash)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Schedule all the unknown hashes for retrieval</span></span><br><span class="line">	<span class="comment">// 把本地链没有的块hash找出来，交给fetcher去下载</span></span><br><span class="line">	unknown := <span class="built_in">make</span>(newBlockHashesData, <span class="number">0</span>, <span class="built_in">len</span>(announces))</span><br><span class="line">	<span class="keyword">for</span> _, block := <span class="keyword">range</span> announces &#123;</span><br><span class="line">		<span class="keyword">if</span> !pm.blockchain.HasBlock(block.Hash, block.Number) &#123;</span><br><span class="line">			unknown = <span class="built_in">append</span>(unknown, block)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, block := <span class="keyword">range</span> unknown &#123;</span><br><span class="line">		pm.fetcher.Notify(p.id, block.Hash, block.Number, time.Now(), p.RequestOneHeader, p.RequestBodies)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Notify announces the fetcher of the potential availability of a new block in</span></span><br><span class="line"><span class="comment">// the network.</span></span><br><span class="line"><span class="comment">// 通知fetcher（自己）有新块产生，没有块实体，有hash、高度等信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Fetcher)</span> <span class="title">Notify</span><span class="params">(peer <span class="keyword">string</span>, hash common.Hash, number <span class="keyword">uint64</span>, time time.Time,</span></span></span><br><span class="line"><span class="function"><span class="params">	headerFetcher headerRequesterFn, bodyFetcher bodyRequesterFn)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	block := &amp;announce&#123;</span><br><span class="line">		hash:        hash,</span><br><span class="line">		number:      number,</span><br><span class="line">		time:        time,</span><br><span class="line">		origin:      peer,</span><br><span class="line">		fetchHeader: headerFetcher,</span><br><span class="line">		fetchBodies: bodyFetcher,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> f.notify &lt;- block:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-f.quit:</span><br><span class="line">		<span class="keyword">return</span> errTerminated</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fetcher.loop()的notify通道消息处理</span></span><br><span class="line"><span class="keyword">case</span> notification := &lt;-f.notify:</span><br><span class="line">	<span class="comment">// A block was announced, make sure the peer isn't DOSing us</span></span><br><span class="line">	propAnnounceInMeter.Mark(<span class="number">1</span>)</span><br><span class="line">	count := f.announces[notification.origin] + <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> count &gt; hashLimit &#123;</span><br><span class="line">		log.Debug(<span class="string">"Peer exceeded outstanding announces"</span>, <span class="string">"peer"</span>, notification.origin, <span class="string">"limit"</span>, hashLimit)</span><br><span class="line">		propAnnounceDOSMeter.Mark(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If we have a valid block number, check that it's potentially useful</span></span><br><span class="line">	<span class="comment">// 高度检查</span></span><br><span class="line">	<span class="keyword">if</span> notification.number &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> dist := <span class="keyword">int64</span>(notification.number) - <span class="keyword">int64</span>(f.chainHeight()); dist &lt; -maxUncleDist || dist &gt; maxQueueDist &#123;</span><br><span class="line">			log.Debug(<span class="string">"Peer discarded announcement"</span>, <span class="string">"peer"</span>, notification.origin, <span class="string">"number"</span>, notification.number, <span class="string">"hash"</span>, notification.hash, <span class="string">"distance"</span>, dist)</span><br><span class="line">			propAnnounceDropMeter.Mark(<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// All is well, schedule the announce if block's not yet downloading</span></span><br><span class="line">	<span class="comment">// 检查是否已经在下载，已下载则忽略</span></span><br><span class="line">	<span class="keyword">if</span> _, ok := f.fetching[notification.hash]; ok &#123;</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> _, ok := f.completing[notification.hash]; ok &#123;</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 更新peer已经通知给我们的区块数量</span></span><br><span class="line">	f.announces[notification.origin] = count</span><br><span class="line">	<span class="comment">// 把通知信息加入到announced，供调度</span></span><br><span class="line">	f.announced[notification.hash] = <span class="built_in">append</span>(f.announced[notification.hash], notification)</span><br><span class="line">	<span class="keyword">if</span> f.announceChangeHook != <span class="literal">nil</span> &amp;&amp; <span class="built_in">len</span>(f.announced[notification.hash]) == <span class="number">1</span> &#123;</span><br><span class="line">		f.announceChangeHook(notification.hash, <span class="literal">true</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(f.announced) == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="comment">// 有通知放入到announced，则重设0s定时器，loop的另外一个分支会处理这些通知</span></span><br><span class="line">		f.rescheduleFetch(fetchTimer)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="fetcher获取完整区块">fetcher获取完整区块</span></h3><p>本节介绍fetcher获取完整区块的过程，这也是fetcher最重要的功能，会涉及到fetcher至少80%的代码。单独拉放一大节吧。</p>
<h2><span id="fetcher的大头">Fetcher的大头</span></h2><p>Fetcher最主要的功能就是获取完整的区块，然后在合适的实际交给InsertChain去验证和插入到本地区块链。我们还是从宏观入手，看Fetcher是如何工作的，一定要先掌握好宏观，因为代码层面上没有这么清晰。</p>
<h3><span id="宏观">宏观</span></h3><p>首先，看两个节点是如何交互，获取完整区块，使用时序图的方式看一下，见图6，流程很清晰不再文字介绍。</p>
<p><img src="http://7xixtr.com1.z0.glb.clouddn.com/image-20180822103401508.png-own" alt="图6：节点获取完整区块的时序图"></p>
<p>再看下获取区块过程中，fetcher内部的状态转移，它使用状态来记录，要获取的区块在什么阶段，见图7。我稍微解释一下：</p>
<ol>
<li>收到<code>NewBlockHashesMsg</code>后，相关信息会记录到<code>announced</code>，进入<code>announced</code>状态，代表了本节点接收了消息。</li>
<li><code>announced</code>由fetcher协程处理，经过校验后，会向给他发送消息的Peer发送请求，请求该区块的区块头，然后进入<code>fetching</code>状态。</li>
<li>获取区块头后，如果区块头表示没有交易和uncle，则转移到<code>completing</code>状态，并且使用区块头合成完整的区块，加入到<code>queued</code>优先级队列。</li>
<li>获取区块头后，如果区块头表示该区块有交易和uncle，则转移到<code>fetched</code>状态，然后发送请求，请求交易和uncle，然后转移到<code>completing</code>状态。</li>
<li>收到交易和uncle后，使用头、交易、uncle这3个信息，生成完整的区块，加入到队列<code>queued</code>。</li>
</ol>
<p><img src="http://7xixtr.com1.z0.glb.clouddn.com/image-20180822103701006.png-own" alt="图7：获取区块状态转移图"></p>
<h3><span id="微观">微观</span></h3><p>接下来就是从代码角度看如何获取完整区块的流程了，有点多，看不懂的时候，再回顾下上面宏观的介绍图。</p>
<p>首先看Fetcher的定义，它存放了通信数据和状态管理，捡加注释的看，上文提到的状态，里面都有。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fetcher is responsible for accumulating block announcements from various peers</span></span><br><span class="line"><span class="comment">// and scheduling them for retrieval.</span></span><br><span class="line"><span class="comment">// 积累块通知，然后调度获取这些块</span></span><br><span class="line"><span class="keyword">type</span> Fetcher <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Various event channels</span></span><br><span class="line">    <span class="comment">// 收到区块hash值的通道</span></span><br><span class="line">	notify <span class="keyword">chan</span> *announce</span><br><span class="line">    <span class="comment">// 收到完整区块的通道</span></span><br><span class="line">	inject <span class="keyword">chan</span> *inject</span><br><span class="line"></span><br><span class="line">	blockFilter <span class="keyword">chan</span> <span class="keyword">chan</span> []*types.Block</span><br><span class="line">	<span class="comment">// 过滤header的通道的通道</span></span><br><span class="line">	headerFilter <span class="keyword">chan</span> <span class="keyword">chan</span> *headerFilterTask</span><br><span class="line">	<span class="comment">// 过滤body的通道的通道</span></span><br><span class="line">	bodyFilter <span class="keyword">chan</span> <span class="keyword">chan</span> *bodyFilterTask</span><br><span class="line"></span><br><span class="line">	done <span class="keyword">chan</span> common.Hash</span><br><span class="line">	quit <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Announce states</span></span><br><span class="line">	<span class="comment">// Peer已经给了本节点多少区块头通知</span></span><br><span class="line">	announces <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span> <span class="comment">// Per peer announce counts to prevent memory exhaustion</span></span><br><span class="line">	<span class="comment">// 已经announced的区块列表</span></span><br><span class="line">	announced <span class="keyword">map</span>[common.Hash][]*announce <span class="comment">// Announced blocks, scheduled for fetching</span></span><br><span class="line">	<span class="comment">// 正在fetching区块头的请求</span></span><br><span class="line">	fetching <span class="keyword">map</span>[common.Hash]*announce <span class="comment">// Announced blocks, currently fetching</span></span><br><span class="line">	<span class="comment">// 已经fetch到区块头，还差body的请求，用来获取body</span></span><br><span class="line">	fetched <span class="keyword">map</span>[common.Hash][]*announce <span class="comment">// Blocks with headers fetched, scheduled for body retrieval</span></span><br><span class="line">	<span class="comment">// 已经得到区块头的</span></span><br><span class="line">	completing <span class="keyword">map</span>[common.Hash]*announce <span class="comment">// Blocks with headers, currently body-completing</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Block cache</span></span><br><span class="line">	<span class="comment">// queue，优先级队列，高度做优先级</span></span><br><span class="line">	<span class="comment">// queues，统计peer通告了多少块</span></span><br><span class="line">	<span class="comment">// queued，代表这个块如队列了，</span></span><br><span class="line">	queue  *prque.Prque            <span class="comment">// Queue containing the import operations (block number sorted)</span></span><br><span class="line">	queues <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>          <span class="comment">// Per peer block counts to prevent memory exhaustion</span></span><br><span class="line">	queued <span class="keyword">map</span>[common.Hash]*inject <span class="comment">// Set of already queued blocks (to dedupe imports)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Callbacks</span></span><br><span class="line">	getBlock       blockRetrievalFn   <span class="comment">// Retrieves a block from the local chain</span></span><br><span class="line">	verifyHeader   headerVerifierFn   <span class="comment">// Checks if a block's headers have a valid proof of work，验证区块头，包含了PoW验证</span></span><br><span class="line">	broadcastBlock blockBroadcasterFn <span class="comment">// Broadcasts a block to connected peers，广播给peer</span></span><br><span class="line">	chainHeight    chainHeightFn      <span class="comment">// Retrieves the current chain's height</span></span><br><span class="line">	insertChain    chainInsertFn      <span class="comment">// Injects a batch of blocks into the chain，插入区块到链的函数</span></span><br><span class="line">	dropPeer       peerDropFn         <span class="comment">// Drops a peer for misbehaving</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Testing hooks</span></span><br><span class="line">	announceChangeHook <span class="function"><span class="keyword">func</span><span class="params">(common.Hash, <span class="keyword">bool</span>)</span> // <span class="title">Method</span> <span class="title">to</span> <span class="title">call</span> <span class="title">upon</span> <span class="title">adding</span> <span class="title">or</span> <span class="title">deleting</span> <span class="title">a</span> <span class="title">hash</span> <span class="title">from</span> <span class="title">the</span> <span class="title">announce</span> <span class="title">list</span></span></span><br><span class="line"><span class="function">	<span class="title">queueChangeHook</span>    <span class="title">func</span><span class="params">(common.Hash, <span class="keyword">bool</span>)</span> // <span class="title">Method</span> <span class="title">to</span> <span class="title">call</span> <span class="title">upon</span> <span class="title">adding</span> <span class="title">or</span> <span class="title">deleting</span> <span class="title">a</span> <span class="title">block</span> <span class="title">from</span> <span class="title">the</span> <span class="title">import</span> <span class="title">queue</span></span></span><br><span class="line"><span class="function">	<span class="title">fetchingHook</span>       <span class="title">func</span><span class="params">([]common.Hash)</span>     // <span class="title">Method</span> <span class="title">to</span> <span class="title">call</span> <span class="title">upon</span> <span class="title">starting</span> <span class="title">a</span> <span class="title">block</span> <span class="params">(eth/61)</span> <span class="title">or</span> <span class="title">header</span> <span class="params">(eth/62)</span> <span class="title">fetch</span></span></span><br><span class="line"><span class="function">	<span class="title">completingHook</span>     <span class="title">func</span><span class="params">([]common.Hash)</span>     // <span class="title">Method</span> <span class="title">to</span> <span class="title">call</span> <span class="title">upon</span> <span class="title">starting</span> <span class="title">a</span> <span class="title">block</span> <span class="title">body</span> <span class="title">fetch</span> <span class="params">(eth/62)</span></span></span><br><span class="line"><span class="function">	<span class="title">importedHook</span>       <span class="title">func</span><span class="params">(*types.Block)</span>      // <span class="title">Method</span> <span class="title">to</span> <span class="title">call</span> <span class="title">upon</span> <span class="title">successful</span> <span class="title">block</span> <span class="title">import</span> <span class="params">(both eth/61 and eth/62)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p><code>NewBlockHashesMsg</code>消息的处理<a href="#NewBlockHashesMsg的处理">前面的小节已经讲过了</a>，不记得可向前翻看。这里从<code>announced</code>的状态处理说起。<code>loop()</code>中，<code>fetchTimer</code>超时后，代表了收到了消息通知，需要处理，会从<code>announced</code>中选择出需要处理的通知，然后创建请求，请求区块头，由于可能有很多节点都通知了它某个区块的Hash，所以随机的从这些发送消息的Peer中选择一个Peer，发送请求的时候，为每个Peer都创建了单独的协程。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> &lt;-fetchTimer.C:</span><br><span class="line">	<span class="comment">// At least one block's timer ran out, check for needing retrieval</span></span><br><span class="line">	<span class="comment">// 有区块通知，去处理</span></span><br><span class="line">	request := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]common.Hash)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> hash, announces := <span class="keyword">range</span> f.announced &#123;</span><br><span class="line">		<span class="keyword">if</span> time.Since(announces[<span class="number">0</span>].time) &gt; arriveTimeout-gatherSlack &#123;</span><br><span class="line">			<span class="comment">// Pick a random peer to retrieve from, reset all others</span></span><br><span class="line">			<span class="comment">// 可能有很多peer都发送了这个区块的hash值，随机选择一个peer</span></span><br><span class="line">			announce := announces[rand.Intn(<span class="built_in">len</span>(announces))]</span><br><span class="line">			f.forgetHash(hash)</span><br><span class="line"></span><br><span class="line">			<span class="comment">// If the block still didn't arrive, queue for fetching</span></span><br><span class="line">			<span class="comment">// 本地还没有这个区块，创建获取区块的请求</span></span><br><span class="line">			<span class="keyword">if</span> f.getBlock(hash) == <span class="literal">nil</span> &#123;</span><br><span class="line">				request[announce.origin] = <span class="built_in">append</span>(request[announce.origin], hash)</span><br><span class="line">				f.fetching[hash] = announce</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Send out all block header requests</span></span><br><span class="line">	<span class="comment">// 把所有的request发送出去</span></span><br><span class="line">	<span class="comment">// 为每一个peer都创建一个协程，然后请求所有需要从该peer获取的请求</span></span><br><span class="line">	<span class="keyword">for</span> peer, hashes := <span class="keyword">range</span> request &#123;</span><br><span class="line">		log.Trace(<span class="string">"Fetching scheduled headers"</span>, <span class="string">"peer"</span>, peer, <span class="string">"list"</span>, hashes)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Create a closure of the fetch and schedule in on a new thread</span></span><br><span class="line">		fetchHeader, hashes := f.fetching[hashes[<span class="number">0</span>]].fetchHeader, hashes</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">if</span> f.fetchingHook != <span class="literal">nil</span> &#123;</span><br><span class="line">				f.fetchingHook(hashes)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> _, hash := <span class="keyword">range</span> hashes &#123;</span><br><span class="line">				headerFetchMeter.Mark(<span class="number">1</span>)</span><br><span class="line">				fetchHeader(hash) <span class="comment">// Suboptimal, but protocol doesn't allow batch header retrievals</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Schedule the next fetch if blocks are still pending</span></span><br><span class="line">	f.rescheduleFetch(fetchTimer)</span><br></pre></td></tr></table></figure>
<p>从<code>Notify</code>的调用中，可以看出，<code>fetcherHeader()</code>的实际函数是<code>RequestOneHeader()</code>，该函数使用的消息是<code>GetBlockHeadersMsg</code>，可以用来请求多个区块头，不过fetcher只请求一个。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pm.fetcher.Notify(p.id, block.Hash, block.Number, time.Now(), p.RequestOneHeader, p.RequestBodies)</span><br><span class="line"></span><br><span class="line"><span class="comment">// RequestOneHeader is a wrapper around the header query functions to fetch a</span></span><br><span class="line"><span class="comment">// single header. It is used solely by the fetcher.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *peer)</span> <span class="title">RequestOneHeader</span><span class="params">(hash common.Hash)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	p.Log().Debug(<span class="string">"Fetching single header"</span>, <span class="string">"hash"</span>, hash)</span><br><span class="line">	<span class="keyword">return</span> p2p.Send(p.rw, GetBlockHeadersMsg, &amp;getBlockHeadersData&#123;Origin: hashOrNumber&#123;Hash: hash&#125;, Amount: <span class="keyword">uint64</span>(<span class="number">1</span>), Skip: <span class="keyword">uint64</span>(<span class="number">0</span>), Reverse: <span class="literal">false</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>GetBlockHeadersMsg</code>的处理如下：因为它是获取多个区块头的，所以处理起来比较“麻烦”，还好，fetcher只获取一个区块头，其处理在20行~33行，获取下一个区块头的处理逻辑，这里就不看了，最后调用<code>SendBlockHeaders()</code>将区块头发送给请求的节点，消息是<code>BlockHeadersMsg</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// handleMsg()</span></span><br><span class="line"><span class="comment">// Block header query, collect the requested headers and reply</span></span><br><span class="line"><span class="keyword">case</span> msg.Code == GetBlockHeadersMsg:</span><br><span class="line">	<span class="comment">// Decode the complex header query</span></span><br><span class="line">	<span class="keyword">var</span> query getBlockHeadersData</span><br><span class="line">	<span class="keyword">if</span> err := msg.Decode(&amp;query); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errResp(ErrDecode, <span class="string">"%v: %v"</span>, msg, err)</span><br><span class="line">	&#125;</span><br><span class="line">	hashMode := query.Origin.Hash != (common.Hash&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Gather headers until the fetch or network limits is reached</span></span><br><span class="line">	<span class="comment">// 收集区块头，直到达到限制</span></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		bytes   common.StorageSize</span><br><span class="line">		headers []*types.Header</span><br><span class="line">		unknown <span class="keyword">bool</span></span><br><span class="line">	)</span><br><span class="line">	<span class="comment">// 自己已知区块 &amp;&amp; 少于查询的数量 &amp;&amp; 大小小于2MB &amp;&amp; 小于能下载的最大数量</span></span><br><span class="line">	<span class="keyword">for</span> !unknown &amp;&amp; <span class="built_in">len</span>(headers) &lt; <span class="keyword">int</span>(query.Amount) &amp;&amp; bytes &lt; softResponseLimit &amp;&amp; <span class="built_in">len</span>(headers) &lt; downloader.MaxHeaderFetch &#123;</span><br><span class="line">		<span class="comment">// Retrieve the next header satisfying the query</span></span><br><span class="line">		<span class="comment">// 获取区块头</span></span><br><span class="line">		<span class="keyword">var</span> origin *types.Header</span><br><span class="line">		<span class="keyword">if</span> hashMode &#123;</span><br><span class="line">            <span class="comment">// fetcher 使用的模式</span></span><br><span class="line">			origin = pm.blockchain.GetHeaderByHash(query.Origin.Hash)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			origin = pm.blockchain.GetHeaderByNumber(query.Origin.Number)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> origin == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		number := origin.Number.Uint64()</span><br><span class="line">		headers = <span class="built_in">append</span>(headers, origin)</span><br><span class="line">		bytes += estHeaderRlpSize</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Advance to the next header of the query</span></span><br><span class="line">		<span class="comment">// 下一个区块头的获取，不同策略，方式不同</span></span><br><span class="line">		<span class="keyword">switch</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> query.Origin.Hash != (common.Hash&#123;&#125;) &amp;&amp; query.Reverse:</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> p.SendBlockHeaders(headers)</span><br></pre></td></tr></table></figure>
<p><code>BlockHeadersMsg</code>的处理很有意思，因为<code>GetBlockHeadersMsg</code>并不是fetcher独占的消息，downloader也可以调用，所以，响应消息的处理需要分辨出是fetcher请求的，还是downloader请求的。它的处理逻辑是：fetcher先过滤收到的区块头，如果fetcher不要的，那就是downloader的，在调用<code>fetcher.FilterHeaders</code>的时候，fetcher就将自己要的区块头拿走了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// handleMsg()</span></span><br><span class="line"><span class="keyword">case</span> msg.Code == BlockHeadersMsg:</span><br><span class="line">	<span class="comment">// A batch of headers arrived to one of our previous requests</span></span><br><span class="line">	<span class="keyword">var</span> headers []*types.Header</span><br><span class="line">	<span class="keyword">if</span> err := msg.Decode(&amp;headers); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errResp(ErrDecode, <span class="string">"msg %v: %v"</span>, msg, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// If no headers were received, but we're expending a DAO fork check, maybe it's that</span></span><br><span class="line">	<span class="comment">// 检查是不是当前DAO的硬分叉</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(headers) == <span class="number">0</span> &amp;&amp; p.forkDrop != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Possibly an empty reply to the fork header checks, sanity check TDs</span></span><br><span class="line">		verifyDAO := <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// If we already have a DAO header, we can check the peer's TD against it. If</span></span><br><span class="line">		<span class="comment">// the peer's ahead of this, it too must have a reply to the DAO check</span></span><br><span class="line">		<span class="keyword">if</span> daoHeader := pm.blockchain.GetHeaderByNumber(pm.chainconfig.DAOForkBlock.Uint64()); daoHeader != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> _, td := p.Head(); td.Cmp(pm.blockchain.GetTd(daoHeader.Hash(), daoHeader.Number.Uint64())) &gt;= <span class="number">0</span> &#123;</span><br><span class="line">				verifyDAO = <span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// If we're seemingly on the same chain, disable the drop timer</span></span><br><span class="line">		<span class="keyword">if</span> verifyDAO &#123;</span><br><span class="line">			p.Log().Debug(<span class="string">"Seems to be on the same side of the DAO fork"</span>)</span><br><span class="line">			p.forkDrop.Stop()</span><br><span class="line">			p.forkDrop = <span class="literal">nil</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Filter out any explicitly requested headers, deliver the rest to the downloader</span></span><br><span class="line">	<span class="comment">// 过滤是不是fetcher请求的区块头，去掉fetcher请求的区块头再交给downloader</span></span><br><span class="line">	filter := <span class="built_in">len</span>(headers) == <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> filter &#123;</span><br><span class="line">		<span class="comment">// If it's a potential DAO fork check, validate against the rules</span></span><br><span class="line">		<span class="comment">// 检查是否硬分叉</span></span><br><span class="line">		<span class="keyword">if</span> p.forkDrop != <span class="literal">nil</span> &amp;&amp; pm.chainconfig.DAOForkBlock.Cmp(headers[<span class="number">0</span>].Number) == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// Disable the fork drop timer</span></span><br><span class="line">			p.forkDrop.Stop()</span><br><span class="line">			p.forkDrop = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// Validate the header and either drop the peer or continue</span></span><br><span class="line">			<span class="keyword">if</span> err := misc.VerifyDAOHeaderExtraData(pm.chainconfig, headers[<span class="number">0</span>]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				p.Log().Debug(<span class="string">"Verified to be on the other side of the DAO fork, dropping"</span>)</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">			p.Log().Debug(<span class="string">"Verified to be on the same side of the DAO fork"</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Irrelevant of the fork checks, send the header to the fetcher just in case</span></span><br><span class="line">		<span class="comment">// 使用fetcher过滤区块头</span></span><br><span class="line">		headers = pm.fetcher.FilterHeaders(p.id, headers, time.Now())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 剩下的区块头交给downloader</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(headers) &gt; <span class="number">0</span> || !filter &#123;</span><br><span class="line">		err := pm.downloader.DeliverHeaders(p.id, headers)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Debug(<span class="string">"Failed to deliver headers"</span>, <span class="string">"err"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><code>FilterHeaders()</code>是一个很有大智慧的函数，看起来耐人寻味，但实在妙。它要把所有的区块头，都传递给fetcher协程，还要获取fetcher协程处理后的结果。<code>fetcher.headerFilter</code>是存放通道的通道，而<code>filter</code>是存放包含区块头过滤任务的通道。它先把<code>filter</code>传递给了<code>headerFilter</code>，这样<code>fetcher</code>协程就在另外一段等待了，而后将<code>headerFilterTask</code>传入<code>filter</code>，fetcher就能读到数据了，处理后，再将数据写回<code>filter</code>而刚好被<code>FilterHeaders</code>函数处理了，该函数实际运行在<code>handleMsg()</code>的协程中。</p>
<p>每个Peer都会分配一个ProtocolManager然后处理该Peer的消息，但<code>fetcher</code>只有一个事件处理协程，如果不创建一个<code>filter</code>，fetcher哪知道是谁发给它的区块头呢？过滤之后，该如何发回去呢？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FilterHeaders extracts all the headers that were explicitly requested by the fetcher,</span></span><br><span class="line"><span class="comment">// returning those that should be handled differently.</span></span><br><span class="line"><span class="comment">// 寻找出fetcher请求的区块头</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Fetcher)</span> <span class="title">FilterHeaders</span><span class="params">(peer <span class="keyword">string</span>, headers []*types.Header, time time.Time)</span> []*<span class="title">types</span>.<span class="title">Header</span></span> &#123;</span><br><span class="line">	log.Trace(<span class="string">"Filtering headers"</span>, <span class="string">"peer"</span>, peer, <span class="string">"headers"</span>, <span class="built_in">len</span>(headers))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Send the filter channel to the fetcher</span></span><br><span class="line">	<span class="comment">// 任务通道</span></span><br><span class="line">	filter := <span class="built_in">make</span>(<span class="keyword">chan</span> *headerFilterTask)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="comment">// 任务通道发送到这个通道</span></span><br><span class="line">	<span class="keyword">case</span> f.headerFilter &lt;- filter:</span><br><span class="line">	<span class="keyword">case</span> &lt;-f.quit:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Request the filtering of the header list</span></span><br><span class="line">	<span class="comment">// 创建过滤任务，发送到任务通道</span></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> filter &lt;- &amp;headerFilterTask&#123;peer: peer, headers: headers, time: time&#125;:</span><br><span class="line">	<span class="keyword">case</span> &lt;-f.quit:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Retrieve the headers remaining after filtering</span></span><br><span class="line">	<span class="comment">// 从任务通道，获取过滤的结果并返回</span></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> task := &lt;-filter:</span><br><span class="line">		<span class="keyword">return</span> task.headers</span><br><span class="line">	<span class="keyword">case</span> &lt;-f.quit:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来要看<code>f.headerFilter</code>的处理，这段代码有90行，它做了一下几件事：</p>
<ol>
<li>从<code>f.headerFilter</code>取出<code>filter</code>，然后取出过滤任务<code>task</code>。</li>
<li>它把区块头分成3类：<code>unknown</code>这不是分是要返回给调用者的，即<code>handleMsg()</code>, <code>incomplete</code>存放还需要获取body的区块头，<code>complete</code>存放只包含区块头的区块。遍历所有的区块头，填到到对应的分类中，具体的判断可看18行的注释，记住宏观中将的状态转移图。</li>
<li>把<code>unknonw</code>中的区块返回给<code>handleMsg()</code>。</li>
<li>把 <code>incomplete</code>的区块头获取状态移动到<code>fetched</code>状态，然后触发定时器，以便去处理<code>complete</code>的区块。</li>
<li>把<code>compelete</code>的区块加入到<code>queued</code>。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fetcher.loop()</span></span><br><span class="line"><span class="keyword">case</span> filter := &lt;-f.headerFilter:</span><br><span class="line">	<span class="comment">// Headers arrived from a remote peer. Extract those that were explicitly</span></span><br><span class="line">	<span class="comment">// requested by the fetcher, and return everything else so it's delivered</span></span><br><span class="line">	<span class="comment">// to other parts of the system.</span></span><br><span class="line">	<span class="comment">// 收到从远端节点发送的区块头，过滤出fetcher请求的</span></span><br><span class="line">	<span class="comment">// 从任务通道获取过滤任务</span></span><br><span class="line">	<span class="keyword">var</span> task *headerFilterTask</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> task = &lt;-filter:</span><br><span class="line">	<span class="keyword">case</span> &lt;-f.quit:</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	headerFilterInMeter.Mark(<span class="keyword">int64</span>(<span class="built_in">len</span>(task.headers)))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Split the batch of headers into unknown ones (to return to the caller),</span></span><br><span class="line">	<span class="comment">// known incomplete ones (requiring body retrievals) and completed blocks.</span></span><br><span class="line">	<span class="comment">// unknown的不是fetcher请求的，complete放没有交易和uncle的区块，有头就够了，incomplete放</span></span><br><span class="line">	<span class="comment">// 还需要获取uncle和交易的区块</span></span><br><span class="line">	unknown, incomplete, complete := []*types.Header&#123;&#125;, []*announce&#123;&#125;, []*types.Block&#123;&#125;</span><br><span class="line">	<span class="comment">// 遍历所有收到的header</span></span><br><span class="line">	<span class="keyword">for</span> _, header := <span class="keyword">range</span> task.headers &#123;</span><br><span class="line">		hash := header.Hash()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Filter fetcher-requested headers from other synchronisation algorithms</span></span><br><span class="line">		<span class="comment">// 是正在获取的hash，并且对应请求的peer，并且未fetched，未completing，未queued</span></span><br><span class="line">		<span class="keyword">if</span> announce := f.fetching[hash]; announce != <span class="literal">nil</span> &amp;&amp; announce.origin == task.peer &amp;&amp; f.fetched[hash] == <span class="literal">nil</span> &amp;&amp; f.completing[hash] == <span class="literal">nil</span> &amp;&amp; f.queued[hash] == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// If the delivered header does not match the promised number, drop the announcer</span></span><br><span class="line">			<span class="comment">// 高度校验，竟然不匹配，扰乱秩序，peer肯定是坏蛋。</span></span><br><span class="line">			<span class="keyword">if</span> header.Number.Uint64() != announce.number &#123;</span><br><span class="line">				log.Trace(<span class="string">"Invalid block number fetched"</span>, <span class="string">"peer"</span>, announce.origin, <span class="string">"hash"</span>, header.Hash(), <span class="string">"announced"</span>, announce.number, <span class="string">"provided"</span>, header.Number)</span><br><span class="line">				f.dropPeer(announce.origin)</span><br><span class="line">				f.forgetHash(hash)</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Only keep if not imported by other means</span></span><br><span class="line">			<span class="comment">// 本地链没有当前区块</span></span><br><span class="line">			<span class="keyword">if</span> f.getBlock(hash) == <span class="literal">nil</span> &#123;</span><br><span class="line">				announce.header = header</span><br><span class="line">				announce.time = task.time</span><br><span class="line"></span><br><span class="line">				<span class="comment">// If the block is empty (header only), short circuit into the final import queue</span></span><br><span class="line">				<span class="comment">// 如果区块没有交易和uncle，加入到complete</span></span><br><span class="line">				<span class="keyword">if</span> header.TxHash == types.DeriveSha(types.Transactions&#123;&#125;) &amp;&amp; header.UncleHash == types.CalcUncleHash([]*types.Header&#123;&#125;) &#123;</span><br><span class="line">					log.Trace(<span class="string">"Block empty, skipping body retrieval"</span>, <span class="string">"peer"</span>, announce.origin, <span class="string">"number"</span>, header.Number, <span class="string">"hash"</span>, header.Hash())</span><br><span class="line"></span><br><span class="line">					block := types.NewBlockWithHeader(header)</span><br><span class="line">					block.ReceivedAt = task.time</span><br><span class="line"></span><br><span class="line">					complete = <span class="built_in">append</span>(complete, block)</span><br><span class="line">					f.completing[hash] = announce</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// Otherwise add to the list of blocks needing completion</span></span><br><span class="line">				<span class="comment">// 否则就是不完整的区块</span></span><br><span class="line">				incomplete = <span class="built_in">append</span>(incomplete, announce)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				log.Trace(<span class="string">"Block already imported, discarding header"</span>, <span class="string">"peer"</span>, announce.origin, <span class="string">"number"</span>, header.Number, <span class="string">"hash"</span>, header.Hash())</span><br><span class="line">				f.forgetHash(hash)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Fetcher doesn't know about it, add to the return list</span></span><br><span class="line">			<span class="comment">// 没请求过的header</span></span><br><span class="line">			unknown = <span class="built_in">append</span>(unknown, header)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 把未知的区块头，再传递会filter</span></span><br><span class="line">	headerFilterOutMeter.Mark(<span class="keyword">int64</span>(<span class="built_in">len</span>(unknown)))</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> filter &lt;- &amp;headerFilterTask&#123;headers: unknown, time: task.time&#125;:</span><br><span class="line">	<span class="keyword">case</span> &lt;-f.quit:</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Schedule the retrieved headers for body completion</span></span><br><span class="line">	<span class="comment">// 把未完整的区块加入到fetched，跳过已经在completeing中的，然后触发completeTimer定时器</span></span><br><span class="line">	<span class="keyword">for</span> _, announce := <span class="keyword">range</span> incomplete &#123;</span><br><span class="line">		hash := announce.header.Hash()</span><br><span class="line">		<span class="keyword">if</span> _, ok := f.completing[hash]; ok &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		f.fetched[hash] = <span class="built_in">append</span>(f.fetched[hash], announce)</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(f.fetched) == <span class="number">1</span> &#123;</span><br><span class="line">			f.rescheduleComplete(completeTimer)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Schedule the header-only blocks for import</span></span><br><span class="line">	<span class="comment">// 把只有头的区块入队列</span></span><br><span class="line">	<span class="keyword">for</span> _, block := <span class="keyword">range</span> complete &#123;</span><br><span class="line">		<span class="keyword">if</span> announce := f.completing[block.Hash()]; announce != <span class="literal">nil</span> &#123;</span><br><span class="line">			f.enqueue(announce.origin, block)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>跟随状态图的转义，剩下的工作是<code>fetched</code>转移到<code>completing</code>，上面的流程已经触发了<code>completeTimer</code>定时器，超时后就会处理，流程与请求Header类似，不再赘述，此时发送的请求消息是<code>GetBlockBodiesMsg</code>，实际调的函数是<code>RequestBodies</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fetcher.loop()</span></span><br><span class="line"><span class="keyword">case</span> &lt;-completeTimer.C:</span><br><span class="line">	<span class="comment">// At least one header's timer ran out, retrieve everything</span></span><br><span class="line">	<span class="comment">// 至少有1个header已经获取完了</span></span><br><span class="line">	request := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]common.Hash)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历所有待获取body的announce</span></span><br><span class="line">	<span class="keyword">for</span> hash, announces := <span class="keyword">range</span> f.fetched &#123;</span><br><span class="line">		<span class="comment">// Pick a random peer to retrieve from, reset all others</span></span><br><span class="line">		<span class="comment">// 随机选一个Peer发送请求，因为可能已经有很多Peer通知它这个区块了</span></span><br><span class="line">		announce := announces[rand.Intn(<span class="built_in">len</span>(announces))]</span><br><span class="line">		f.forgetHash(hash)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// If the block still didn't arrive, queue for completion</span></span><br><span class="line">		<span class="comment">// 如果本地没有这个区块，则放入到completing，创建请求</span></span><br><span class="line">		<span class="keyword">if</span> f.getBlock(hash) == <span class="literal">nil</span> &#123;</span><br><span class="line">			request[announce.origin] = <span class="built_in">append</span>(request[announce.origin], hash)</span><br><span class="line">			f.completing[hash] = announce</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Send out all block body requests</span></span><br><span class="line">	<span class="comment">// 发送所有的请求，获取body，依然是每个peer一个单独协程</span></span><br><span class="line">	<span class="keyword">for</span> peer, hashes := <span class="keyword">range</span> request &#123;</span><br><span class="line">		log.Trace(<span class="string">"Fetching scheduled bodies"</span>, <span class="string">"peer"</span>, peer, <span class="string">"list"</span>, hashes)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Create a closure of the fetch and schedule in on a new thread</span></span><br><span class="line">		<span class="keyword">if</span> f.completingHook != <span class="literal">nil</span> &#123;</span><br><span class="line">			f.completingHook(hashes)</span><br><span class="line">		&#125;</span><br><span class="line">		bodyFetchMeter.Mark(<span class="keyword">int64</span>(<span class="built_in">len</span>(hashes)))</span><br><span class="line">		<span class="keyword">go</span> f.completing[hashes[<span class="number">0</span>]].fetchBodies(hashes)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Schedule the next fetch if blocks are still pending</span></span><br><span class="line">	f.rescheduleComplete(completeTimer)</span><br></pre></td></tr></table></figure>
<p><code>handleMsg()</code>处理该消息也是干净利落，直接获取RLP格式的body，然后发送响应消息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// handleMsg()</span></span><br><span class="line"><span class="keyword">case</span> msg.Code == GetBlockBodiesMsg:</span><br><span class="line">	<span class="comment">// Decode the retrieval message</span></span><br><span class="line">	msgStream := rlp.NewStream(msg.Payload, <span class="keyword">uint64</span>(msg.Size))</span><br><span class="line">	<span class="keyword">if</span> _, err := msgStream.List(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Gather blocks until the fetch or network limits is reached</span></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		hash   common.Hash</span><br><span class="line">		bytes  <span class="keyword">int</span></span><br><span class="line">		bodies []rlp.RawValue</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历所有请求</span></span><br><span class="line">	<span class="keyword">for</span> bytes &lt; softResponseLimit &amp;&amp; <span class="built_in">len</span>(bodies) &lt; downloader.MaxBlockFetch &#123;</span><br><span class="line">		<span class="comment">// Retrieve the hash of the next block</span></span><br><span class="line">		<span class="keyword">if</span> err := msgStream.Decode(&amp;hash); err == rlp.EOL &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> errResp(ErrDecode, <span class="string">"msg %v: %v"</span>, msg, err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Retrieve the requested block body, stopping if enough was found</span></span><br><span class="line">		<span class="comment">// 获取body，RLP格式</span></span><br><span class="line">		<span class="keyword">if</span> data := pm.blockchain.GetBodyRLP(hash); <span class="built_in">len</span>(data) != <span class="number">0</span> &#123;</span><br><span class="line">			bodies = <span class="built_in">append</span>(bodies, data)</span><br><span class="line">			bytes += <span class="built_in">len</span>(data)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p.SendBlockBodiesRLP(bodies)</span><br></pre></td></tr></table></figure>
<p>响应消息<code>BlockBodiesMsg</code>的处理与处理获取header的处理原理相同，先交给fetcher过滤，然后剩下的才是downloader的。需要注意一点，响应消息里只包含交易列表和叔块列表。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// handleMsg()</span></span><br><span class="line"><span class="keyword">case</span> msg.Code == BlockBodiesMsg:</span><br><span class="line">	<span class="comment">// A batch of block bodies arrived to one of our previous requests</span></span><br><span class="line">	<span class="keyword">var</span> request blockBodiesData</span><br><span class="line">	<span class="keyword">if</span> err := msg.Decode(&amp;request); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errResp(ErrDecode, <span class="string">"msg %v: %v"</span>, msg, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Deliver them all to the downloader for queuing</span></span><br><span class="line">	<span class="comment">// 传递给downloader去处理</span></span><br><span class="line">	transactions := <span class="built_in">make</span>([][]*types.Transaction, <span class="built_in">len</span>(request))</span><br><span class="line">	uncles := <span class="built_in">make</span>([][]*types.Header, <span class="built_in">len</span>(request))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i, body := <span class="keyword">range</span> request &#123;</span><br><span class="line">		transactions[i] = body.Transactions</span><br><span class="line">		uncles[i] = body.Uncles</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Filter out any explicitly requested bodies, deliver the rest to the downloader</span></span><br><span class="line">	<span class="comment">// 先让fetcher过滤去fetcher请求的body，剩下的给downloader</span></span><br><span class="line">	filter := <span class="built_in">len</span>(transactions) &gt; <span class="number">0</span> || <span class="built_in">len</span>(uncles) &gt; <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> filter &#123;</span><br><span class="line">		transactions, uncles = pm.fetcher.FilterBodies(p.id, transactions, uncles, time.Now())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 剩下的body交给downloader</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(transactions) &gt; <span class="number">0</span> || <span class="built_in">len</span>(uncles) &gt; <span class="number">0</span> || !filter &#123;</span><br><span class="line">		err := pm.downloader.DeliverBodies(p.id, transactions, uncles)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Debug(<span class="string">"Failed to deliver bodies"</span>, <span class="string">"err"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>过滤函数的原理也与Header相同。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FilterBodies extracts all the block bodies that were explicitly requested by</span></span><br><span class="line"><span class="comment">// the fetcher, returning those that should be handled differently.</span></span><br><span class="line"><span class="comment">// 过去出fetcher请求的body，返回它没有处理的，过程类型header的处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Fetcher)</span> <span class="title">FilterBodies</span><span class="params">(peer <span class="keyword">string</span>, transactions [][]*types.Transaction, uncles [][]*types.Header, time time.Time)</span> <span class="params">([][]*types.Transaction, [][]*types.Header)</span></span> &#123;</span><br><span class="line">	log.Trace(<span class="string">"Filtering bodies"</span>, <span class="string">"peer"</span>, peer, <span class="string">"txs"</span>, <span class="built_in">len</span>(transactions), <span class="string">"uncles"</span>, <span class="built_in">len</span>(uncles))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Send the filter channel to the fetcher</span></span><br><span class="line">	filter := <span class="built_in">make</span>(<span class="keyword">chan</span> *bodyFilterTask)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> f.bodyFilter &lt;- filter:</span><br><span class="line">	<span class="keyword">case</span> &lt;-f.quit:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Request the filtering of the body list</span></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> filter &lt;- &amp;bodyFilterTask&#123;peer: peer, transactions: transactions, uncles: uncles, time: time&#125;:</span><br><span class="line">	<span class="keyword">case</span> &lt;-f.quit:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Retrieve the bodies remaining after filtering</span></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> task := &lt;-filter:</span><br><span class="line">		<span class="keyword">return</span> task.transactions, task.uncles</span><br><span class="line">	<span class="keyword">case</span> &lt;-f.quit:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际过滤body的处理瞧一下，这和Header的处理是不同的。直接看不点：</p>
<ol>
<li>它要的区块，单独取出来存到<code>blocks</code>中，它不要的继续留在<code>task</code>中。</li>
<li>判断是不是fetcher请求的方法：如果交易列表和叔块列表计算出的hash值与区块头中的一样，并且消息来自请求的Peer，则就是fetcher请求的。</li>
<li>将<code>blocks</code>中的区块加入到<code>queued</code>，终结。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> filter := &lt;-f.bodyFilter:</span><br><span class="line">	<span class="comment">// Block bodies arrived, extract any explicitly requested blocks, return the rest</span></span><br><span class="line">	<span class="keyword">var</span> task *bodyFilterTask</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> task = &lt;-filter:</span><br><span class="line">	<span class="keyword">case</span> &lt;-f.quit:</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	bodyFilterInMeter.Mark(<span class="keyword">int64</span>(<span class="built_in">len</span>(task.transactions)))</span><br><span class="line"></span><br><span class="line">	blocks := []*types.Block&#123;&#125;</span><br><span class="line">	<span class="comment">// 获取的每个body的txs列表和uncle列表</span></span><br><span class="line">	<span class="comment">// 遍历每个区块的txs列表和uncle列表，计算hash后判断是否是当前fetcher请求的body</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(task.transactions) &amp;&amp; i &lt; <span class="built_in">len</span>(task.uncles); i++ &#123;</span><br><span class="line">		<span class="comment">// Match up a body to any possible completion request</span></span><br><span class="line">		matched := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 遍历所有保存的请求，因为tx和uncle，不知道它是属于哪个区块的，只能去遍历所有的请求，通常量不大，所以遍历没有性能影响</span></span><br><span class="line">		<span class="keyword">for</span> hash, announce := <span class="keyword">range</span> f.completing &#123;</span><br><span class="line">			<span class="keyword">if</span> f.queued[hash] == <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="comment">// 把传入的每个块的hash和unclehash和它请求出去的记录进行对比，匹配则说明是fetcher请求的区块body</span></span><br><span class="line">				txnHash := types.DeriveSha(types.Transactions(task.transactions[i]))</span><br><span class="line">				uncleHash := types.CalcUncleHash(task.uncles[i])</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> txnHash == announce.header.TxHash &amp;&amp; uncleHash == announce.header.UncleHash &amp;&amp; announce.origin == task.peer &#123;</span><br><span class="line">					<span class="comment">// Mark the body matched, reassemble if still unknown</span></span><br><span class="line">					matched = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">					<span class="comment">// 如果当前链还没有这个区块，则收集这个区块，合并成新区块</span></span><br><span class="line">					<span class="keyword">if</span> f.getBlock(hash) == <span class="literal">nil</span> &#123;</span><br><span class="line">						block := types.NewBlockWithHeader(announce.header).WithBody(task.transactions[i], task.uncles[i])</span><br><span class="line">						block.ReceivedAt = task.time</span><br><span class="line"></span><br><span class="line">						blocks = <span class="built_in">append</span>(blocks, block)</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						f.forgetHash(hash)</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 从task中移除fetcher请求的数据</span></span><br><span class="line">		<span class="keyword">if</span> matched &#123;</span><br><span class="line">			task.transactions = <span class="built_in">append</span>(task.transactions[:i], task.transactions[i+<span class="number">1</span>:]...)</span><br><span class="line">			task.uncles = <span class="built_in">append</span>(task.uncles[:i], task.uncles[i+<span class="number">1</span>:]...)</span><br><span class="line">			i--</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将剩余的数据返回</span></span><br><span class="line">	bodyFilterOutMeter.Mark(<span class="keyword">int64</span>(<span class="built_in">len</span>(task.transactions)))</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> filter &lt;- task:</span><br><span class="line">	<span class="keyword">case</span> &lt;-f.quit:</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Schedule the retrieved blocks for ordered import</span></span><br><span class="line">	<span class="comment">// 把收集的区块加入到队列</span></span><br><span class="line">	<span class="keyword">for</span> _, block := <span class="keyword">range</span> blocks &#123;</span><br><span class="line">		<span class="keyword">if</span> announce := f.completing[block.Hash()]; announce != <span class="literal">nil</span> &#123;</span><br><span class="line">			f.enqueue(announce.origin, block)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，fetcher获取完整区块的流程讲完了，fetcher模块中80%的代码也都贴出来了，还有2个值得看看的函数：</p>
<ol>
<li><code>forgetHash(hash common.Hash)</code>：用于清空指定hash指的记/状态录信息。</li>
<li><code>forgetBlock(hash common.Hash)</code>：用于从队列中移除一个区块。</li>
</ol>
<p>最后了，再回到开始看看fetcher模块和新区块的传播流程，有没有豁然开朗。</p>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/以太坊/" rel="tag"># 以太坊</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/06/22/ethereum-code-consensus-3/" rel="next" title="以太坊源码分析：共识（3）">
                <i class="fa fa-chevron-left"></i> 以太坊源码分析：共识（3）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/09/04/explore-golang-timer/" rel="prev" title="探索Golang定时器的陷阱">
                探索Golang定时器的陷阱 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">大彬</p>
              <p class="site-description motion-element" itemprop="description">专注区块链技术，深耕区块链发展，关注Go语言发展</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">51</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">49</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">2.</span> <span class="nav-text">总体过程和传播策略</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">3.</span> <span class="nav-text">Fetcher模块是干啥的</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">4.</span> <span class="nav-text">源码解读</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">4.1.</span> <span class="nav-text">产块节点的传播新区块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">4.2.</span> <span class="nav-text">Peer节点处理新区块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">4.2.1.</span> <span class="nav-text">NewBlockMsg的处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">4.2.2.</span> <span class="nav-text">fetcher队列处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">4.2.3.</span> <span class="nav-text">NewBlockHashesMsg的处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">4.2.4.</span> <span class="nav-text">fetcher获取完整区块</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">4.3.</span> <span class="nav-text">Fetcher的大头</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">4.3.1.</span> <span class="nav-text">宏观</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">4.3.2.</span> <span class="nav-text">微观</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">大彬</span>

  

  
</div>




  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Muse</a> v6.4.2</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.4.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.4.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.2"></script>



  



  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
