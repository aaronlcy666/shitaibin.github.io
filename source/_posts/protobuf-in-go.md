---
title: Go是如何实现protobuf的编解码的，从原理到源码
date: 2019-08-26 20:52:58
tags: ['Go', 'RPC']
---


## Protocol Buffers介绍

Protocol buffers缩写为protobuf，是由Google创造的一种用于序列化的标记语言，项目Github仓库：https://github.com/protocolbuffers/protobuf。

Protobuf主要用于不同的编程语言的协作RPC场景下，定义需要序列化的数据格式。Protobuf本质上仅仅是**一种用于交互的结构式定义**，从功能上**和XML、JSON**等各种其他的交互形式都**并无本质不同，只负责定义不负责数据编解码**。

其官方介绍如下：

> Protocol buffers are Google's language-neutral, platform-neutral, extensible **mechanism for serializing structured data** – think XML, but smaller, faster, and simpler. You **define how you want your data to be structured** once, then you can use special generated source code to easily write and read your structured data to and from a variety of data streams and using a variety of languages.

## Protocol buffers的多语言支持


protobuf是支持多种编程语言的，即多种编程语言的类型数据可以转换成protobuf定义的类型数据，各种语言的类型对应可以看此[介绍](https://developers.google.com/protocol-buffers/docs/proto3#scalar)。

我们介绍一下protobuf对多语言的支持原理。protobuf有个程序叫**protoc**，它是一个编译程序，**负责把proto文件编译成对应语言的文件**，它已经支持了C++、C#、Java、Python，而对于Go和Dart需要安装插件才能配合生成对于语言的文件。

对于C++，protoc可以把`a.proto`，编译成`a.pb.h`和`a.pb.cc`。

对于Go，protoc需要使用插件**protoc-gen-go**，把`a.proto`，编译成`a.pb.go`，其中包含了定义的数据类型，它的序列化和反序列化函数等。

![](http://img.lessisbetter.site/2019-09-protoc.png)

敲黑板，对Go语言，protoc只负责利用protoc-gen-go把proto文件编译成Go语言文件，并不负责序列化和反序列化，生成的Go语言文件中的序列化和反序列化操作都是只是wrapper。

那Go语言对protobuf的序列化和反序列化，是由谁完成的？

由`github.com/golang/protobuf/proto`完成，它负责把结构体等序列化成proto数据(`[]byte`)，把proto数据反序列化成Go结构体。

![](http://img.lessisbetter.site/2019-09-marshal-unmarshal.png)

OK，原理部分就铺垫这些，看一个简单样例，了解protoc和protoc-gen-go的使用，以及进行序列化和反序列化操作。

## 一个Hello World样例

根据上面的介绍，Go语言使用protobuf我们要先安装2个工具：protoc和protoc-gen-go。

### 安装protoc和protoc-gen-go

首先去[下载页](https://github.com/protocolbuffers/protobuf/releases/tag/v3.9.1)下载符合你系统的protoc，本文示例版本如下：

```
➜  protoc-3.9.0-osx-x86_64 tree .
.
├── bin
│   └── protoc
├── include
│   └── google
│       └── protobuf
│           ├── any.proto
│           ├── api.proto
│           ├── compiler
│           │   └── plugin.proto
│           ├── descriptor.proto
│           ├── duration.proto
│           ├── empty.proto
│           ├── field_mask.proto
│           ├── source_context.proto
│           ├── struct.proto
│           ├── timestamp.proto
│           ├── type.proto
│           └── wrappers.proto
└── readme.txt

5 directories, 14 files
```

**protoc的安装**步骤都卸载readme.txt中了：

> To install, simply place this binary somewhere in your PATH.

把`protoc-3.9.0-osx-x86_64/bin`加入到PATH。


> If you intend to use the included well known types then don't forget to
> copy the contents of the 'include' directory somewhere as well, for example
> into '/usr/local/include/'.

如果使用已经定义好的类型，即上面include目录`*.proto`文件中的类型，把include目录下文件，拷贝到`/usr/local/include/`，按照煎鱼的建议，这个`google`目录最好直接放在项目目录，所有相关的项目都使用相同版本的proto文件。

**安装protoc-gen-go：**

```
go get –u github.com/golang/protobuf/protoc-gen-go
```

检查安装，应该能查到这2个程序的位置：

```
➜  fabric git:(release-1.4) which protoc
/usr/local/bin/protoc
➜  fabric git:(release-1.4) which protoc-gen-go
/Users/shitaibin/go/bin/protoc-gen-go
```


### Hello world

创建了一个使用protoc的小玩具，它的目录结构如下，这里简单各文件过一下：

```bash
➜  protobuf git:(master) tree helloworld1
helloworld1
├── main.go
├── request.proto
└── types
    └── request.pb.go
```

#### 定义proto文件

使用proto3，定义一个Request，`request.proto`内容如下：

```protobuf
// file: request.proto
syntax = "proto3";
package helloworld;
option go_package="./types";

message Request {
    string data = 1;
}
```

- syntax：protobuf版本，现在是proto3
- package：不完全等价于Go的package，最好另行设定`go_package`，指定根据protoc文件生成的go语言文件的package名称。
- message：会编译成Go的`struct`。
	- `string data = 1`：代表request的成员data是string类型，该成员的id是1，protoc给每个成员都定义一个编号，编解码的时候使用编号代替使用成员名称，压缩数据量。


#### 编译proto文件

```bash
$ protoc --go_out=. ./request.proto
```

`--go_out`指明了要把`./request.proto`编译成Go语言文件，生成的是`./types/request.pb.go`，注意观察一下为Request结构体生产的2个方法`XXX_Unmarshal`和`XXX_Marshal`，文件内容如下：

```go
// file: ./types/request.pb.go
// Code generated by protoc-gen-go. DO NOT EDIT.
// source: request.proto

package types

import (
	fmt "fmt"
	math "math"

	proto "github.com/golang/protobuf/proto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type Request struct {
	Data                 string   `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	// 以下是protobuf自动填充的字段，protobuf需要使用
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Request) Reset()         { *m = Request{} }
func (m *Request) String() string { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()    {}
func (*Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_7f73548e33e655fe, []int{0}
}

// 反序列化函数
func (m *Request) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Request.Unmarshal(m, b)
}
// 序列化函数
func (m *Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Request.Marshal(b, m, deterministic)
}
func (m *Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request.Merge(m, src)
}
func (m *Request) XXX_Size() int {
	return xxx_messageInfo_Request.Size(m)
}
func (m *Request) XXX_DiscardUnknown() {
	xxx_messageInfo_Request.DiscardUnknown(m)
}

var xxx_messageInfo_Request proto.InternalMessageInfo

// 获取字段
func (m *Request) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

func init() {
	proto.RegisterType((*Request)(nil), "helloworld.Request")
}

func init() { proto.RegisterFile("request.proto", fileDescriptor_7f73548e33e655fe) }

var fileDescriptor_7f73548e33e655fe = []byte{
	// 91 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0xe2, 0x2d, 0x4a, 0x2d, 0x2c,
	0x4d, 0x2d, 0x2e, 0xd1, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0xe2, 0xca, 0x48, 0xcd, 0xc9, 0xc9,
	0x2f, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x92, 0xe5, 0x62, 0x0f, 0x82, 0x48, 0x0a, 0x09, 0x71, 0xb1,
	0xa4, 0x24, 0x96, 0x24, 0x4a, 0x30, 0x2a, 0x30, 0x6a, 0x70, 0x06, 0x81, 0xd9, 0x4e, 0x9c, 0x51,
	0xec, 0x7a, 0xfa, 0x25, 0x95, 0x05, 0xa9, 0xc5, 0x49, 0x6c, 0x60, 0xcd, 0xc6, 0x80, 0x00, 0x00,
	0x00, 0xff, 0xff, 0x2e, 0x52, 0x69, 0xb5, 0x4d, 0x00, 0x00, 0x00,
}
```

#### 编写Go语言程序

下面这段测试程序就是创建了一个请求，序列化又反序列化的过程。

```go
// file: main.go
package main

import (
	"fmt"

	"./types"
	"github.com/golang/protobuf/proto"
)

func main() {
	req := &types.Request{Data: "Hello LIB"}

	// Marshal
	encoded, err := proto.Marshal(req)
	if err != nil {
		fmt.Printf("Encode to protobuf data error: %v", err)
	}

	// Unmarshal
	var unmarshaledReq types.Request
	err = proto.Unmarshal(encoded, &unmarshaledReq)
	if err != nil {
		fmt.Printf("Unmarshal to struct error: %v", err)
	}

	fmt.Printf("req: %v\n", req.String())
	fmt.Printf("unmarshaledReq: %v\n", unmarshaledReq.String())
}
```

运行结果：

```
➜  helloworld1 git:(master) go run main.go
req: data:"Hello LIB"
unmarshaledReq: data:"Hello LIB"
```

以上都是铺垫，下一节的proto包怎么实现编解码才是重点，protobuf用法可以去翻：

1. 官方介绍：[protoc3介绍](https://developers.google.com/protocol-buffers/docs/proto3)，[编码介绍](https://developers.google.com/protocol-buffers/docs/encoding)，[Go教程](https://developers.google.com/protocol-buffers/docs/gotutorial)
2. 煎鱼[grpc系列文章](https://eddycjy.gitbook.io/golang/di-4-ke-grpc/install)



## proto包源码分析


### 编解码原理

编解码包都会列出支持的编解码类型，我们暂且把这些类型成为底层类型，编解码的本质是：

1. 为每一个底层类型编写编解码函数
1. 把一个结构体的字段，递归的拆解成底层类型，然后选择合适的函数进行编码或解码操作

![](http://img.lessisbetter.site/2019-09-protobuf-marshal.png)

**Go语言proto消息的编解码是由`"github.com/golang/protobuf/proto`包（后面简称proto包）完成的**，接下来先看编码，再看解码。

### 编码

> 约定：以下所有的代码片，如果是request.pb.go或main.go中的代码，会在第一行标记文件名，否则都是proto包的源码。

```go
// main.go
package main

import (
	"fmt"

	"./types"
	"github.com/golang/protobuf/proto"
)

func main() {
	req := &types.Request{Data: "Hello Dabin"}

	// Marshal
	encoded, err := proto.Marshal(req)
	if err != nil {
		fmt.Printf("Encode to protobuf data error: %v", err)
	}
	...
}
```

编码调用的是`proto.Marshal`函数，它可以完成对proto文件中定义的Message数据进行序列化，返回序列化结果或错误。

它有3种序列化方式：

1. pb满足`newMarshaler`接口，则调用`XXX_Marshal()`进行序列化。
1. pb满足`Marshaler`接口，则调用`Marshal()`进行序列化，这种方式适合某类型自定义序列化规则的情况。
1. 否则，使用默认的序列化方式，创建一个Warpper，利用wrapper对pb进行序列化。后面会介绍方式1实际就是使用方式3。

```go
// Marshal takes a protocol buffer message
// and encodes it into the wire format, returning the data.
// This is the main entry point.
func Marshal(pb Message) ([]byte, error) {
	if m, ok := pb.(newMarshaler); ok {
		siz := m.XXX_Size()
		b := make([]byte, 0, siz)
		return m.XXX_Marshal(b, false)
	}
	if m, ok := pb.(Marshaler); ok {
		// If the message can marshal itself, let it do it, for compatibility.
		// NOTE: This is not efficient.
		return m.Marshal()
	}
	// in case somehow we didn't generate the wrapper
	if pb == nil {
		return nil, ErrNil
	}
	var info InternalMessageInfo
	siz := info.Size(pb)
	b := make([]byte, 0, siz)
	return info.Marshal(b, pb, false)
}
```

`newMarshaler`和`Marshaler`如下，对比示例中的`Request`定义可以发现，`Request`实现了newMarshaler接口，没有实现`Marshaler`接口。

```go
// newMarshaler is the interface representing objects that can marshal themselves.
//
// This exists to support protoc-gen-go generated messages.
// The proto package will stop type-asserting to this interface in the future.
//
// DO NOT DEPEND ON THIS.
type newMarshaler interface {
	XXX_Size() int
	XXX_Marshal(b []byte, deterministic bool) ([]byte, error)
}

// Marshaler is the interface representing objects that can marshal themselves.
type Marshaler interface {
	Marshal() ([]byte, error)
}
```

`Request`的`XXX_Marshal`实现如下，它实际是调用了`xxx_messageInfo_Request.Marshal`，`xxx_messageInfo_Request`是定义在`request.pb.go`中的一个全局变量，类型就是`InternalMessageInfo`，实际就是前文提到的wrapper。

```go
// request.pb.go
func (m *Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	print("Called xxx marshal\n")
	panic("I want see stack trace")
	return xxx_messageInfo_Request.Marshal(b, m, deterministic)
}

var xxx_messageInfo_Request proto.InternalMessageInfo
```

本质上，以上都是在wrap，后面才是真正序列化的主体函数。

`InternalMessageInfo`主要是用来缓存序列化和反序列化用到的信息。

```go
// InternalMessageInfo is a type used internally by generated .pb.go files.
// This type is not intended to be used by non-generated code.
// This type is not subject to any compatibility guarantee.
type InternalMessageInfo struct {
	marshal   *marshalInfo // marshal信息
	unmarshal *unmarshalInfo
	merge     *mergeInfo
	discard   *discardInfo
}
```

`InternalMessageInfo.Marshal`首先是获取待序列化类型的序列化信息u，然后利用序列化信息u进行序列化。

```go
// Marshal is the entry point from generated code,
// and should be ONLY called by generated code.
// It marshals msg to the end of b.
// a is a pointer to a place to store cached marshal info.
func (a *InternalMessageInfo) Marshal(b []byte, msg Message, deterministic bool) ([]byte, error) {
	// 获取该message类型的MarshalInfo，这些信息都缓存起来了
	// 大量并发时无需重复创建
	u := getMessageMarshalInfo(msg, a)
	// 入参校验
	ptr := toPointer(&msg)
	if ptr.isNil() {
		// We get here if msg is a typed nil ((*SomeMessage)(nil)),
		// so it satisfies the interface, and msg == nil wouldn't
		// catch it. We don't want crash in this case.
		return b, ErrNil
	}
	// 根据MarshalInfo对数据进行marshal
	return u.marshal(b, ptr, deterministic)
}
```

由于每种类型的序列化信息是一致的，所以`getMessageMarshalInfo`对序列化信息进行了缓存，缓存在`a.marshal`，如果a中不存在marshal信息，才去生成，但不进行初始化，然后保存到a中。

```go
func getMessageMarshalInfo(msg interface{}, a *InternalMessageInfo) *marshalInfo {
	// u := a.marshal, but atomically.
	// We use an atomic here to ensure memory consistency.
	// 从InternalMessageInfo中读取
	u := atomicLoadMarshalInfo(&a.marshal)
	// 读取不到代表未保存过
	if u == nil {
		// Get marshal information from type of message.
		t := reflect.ValueOf(msg).Type()
		if t.Kind() != reflect.Ptr {
			panic(fmt.Sprintf("cannot handle non-pointer message type %v", t))
		}
		u = getMarshalInfo(t.Elem())
		// Store it in the cache for later users.
		// a.marshal = u, but atomically.
		atomicStoreMarshalInfo(&a.marshal, u)
	}
	return u
}
```

`getMarshalInfo`只是创建了一个`marshalInfo`对象，填充了字段`typ`，剩余的字段未填充。

```
// getMarshalInfo returns the information to marshal a given type of message.
// The info it returns may not necessarily initialized.
// t is the type of the message (NOT the pointer to it).
// 获取MarshalInfo结构体，如果不存在则使用message类型t创建1个
func getMarshalInfo(t reflect.Type) *marshalInfo {
	marshalInfoLock.Lock()
	u, ok := marshalInfoMap[t]
	if !ok {
		u = &marshalInfo{typ: t}
		marshalInfoMap[t] = u
	}
	marshalInfoLock.Unlock()
	return u
}

// marshalInfo is the information used for marshaling a message.
type marshalInfo struct {
	typ          reflect.Type
	fields       []*marshalFieldInfo
	unrecognized field                      // offset of XXX_unrecognized
	extensions   field                      // offset of XXX_InternalExtensions
	v1extensions field                      // offset of XXX_extensions
	sizecache    field                      // offset of XXX_sizecache
	initialized  int32                      // 0 -- only typ is set, 1 -- fully initialized
	messageset   bool                       // uses message set wire format
	hasmarshaler bool                       // has custom marshaler
	sync.RWMutex                            // protect extElems map, also for initialization
	extElems     map[int32]*marshalElemInfo // info of extension elements
}
```

`marshalInfo.marshal`是Marshal真实主体，会判断u是否已经初始化，如果未初始化调用`computeMarshalInfo`计算Marshal需要的信息，实际就是填充`marshalInfo`中的各种字段。

`u.hasmarshaler`代表当前类型是否实现了`Marshaler`接口，直接调用Marshal函数进行序列化。可以确定Marshal函数的序列化方式2，即实现`Marshaler`接口的方法，最后肯定也会调用`marshalInfo.marshal`。

该函数的主体是一个for循环，依次遍历该类型的每一个字段，对required属性进行校验，然后按字段类型，调用`f.marshaler`对该字段类型进行序列化。这个`f.marshaler`哪来的呢？

```go
// marshal is the main function to marshal a message. It takes a byte slice and appends
// the encoded data to the end of the slice, returns the slice and error (if any).
// ptr is the pointer to the message.
// If deterministic is true, map is marshaled in deterministic order.
// 该函数是Marshal的主体函数，把消息编码为数据后，追加到b之后，最后返回b。
// deterministic为true代表map会以确定的顺序进行编码。
func (u *marshalInfo) marshal(b []byte, ptr pointer, deterministic bool) ([]byte, error) {
	// 初始化marshalInfo的基础信息
	// 主要是根据已有信息填充该结构体的一些字段
	if atomic.LoadInt32(&u.initialized) == 0 {
		u.computeMarshalInfo()
	}

	// If the message can marshal itself, let it do it, for compatibility.
	// NOTE: This is not efficient.
	// 如果该类型实现了Marshaler接口，即能够对自己Marshal，则自行Marshal
	// 结果追加到b
	if u.hasmarshaler {
		m := ptr.asPointerTo(u.typ).Interface().(Marshaler)
		b1, err := m.Marshal()
		b = append(b, b1...)
		return b, err
	}

	var err, errLater error
	// The old marshaler encodes extensions at beginning.
	// 检查扩展字段，把message的扩展字段追加到b
	if u.extensions.IsValid() {
		// offset函数用来根据指针偏移量获取message的指定字段
		e := ptr.offset(u.extensions).toExtensions()
		if u.messageset {
			b, err = u.appendMessageSet(b, e, deterministic)
		} else {
			b, err = u.appendExtensions(b, e, deterministic)
		}
		if err != nil {
			return b, err
		}
	}
	if u.v1extensions.IsValid() {
		m := *ptr.offset(u.v1extensions).toOldExtensions()
		b, err = u.appendV1Extensions(b, m, deterministic)
		if err != nil {
			return b, err
		}
	}

	// 遍历message的每一个字段，检查并做编码，然后追加到b
	for _, f := range u.fields {
		if f.required {
			// 如果required的字段未设置，则记录错误，所有的marshal工作完成后再处理
			if ptr.offset(f.field).getPointer().isNil() {
				// Required field is not set.
				// We record the error but keep going, to give a complete marshaling.
				if errLater == nil {
					errLater = &RequiredNotSetError{f.name}
				}
				continue
			}
		}
		// 字段为指针类型，并且为nil，代表未设置，该字段无需编码
		if f.isPointer && ptr.offset(f.field).getPointer().isNil() {
			// nil pointer always marshals to nothing
			continue
		}
		// 利用这个字段的marshaler进行编码
		b, err = f.marshaler(b, ptr.offset(f.field), f.wiretag, deterministic)
		if err != nil {
			if err1, ok := err.(*RequiredNotSetError); ok {
				// required字段但未设置错误
				// Required field in submessage is not set.
				// We record the error but keep going, to give a complete marshaling.
				if errLater == nil {
					errLater = &RequiredNotSetError{f.name + "." + err1.field}
				}
				continue
			}
			// “动态数组”中包含nil元素
			if err == errRepeatedHasNil {
				err = errors.New("proto: repeated field " + f.name + " has nil element")
			}
			if err == errInvalidUTF8 {
				if errLater == nil {
					fullName := revProtoTypes[reflect.PtrTo(u.typ)] + "." + f.name
					errLater = &invalidUTF8Error{fullName}
				}
				continue
			}
			return b, err
		}
	}
	// 为识别的类型字段，直接转为bytes，追加到b
	// computeMarshalInfo中已经收集这些字段
	if u.unrecognized.IsValid() {
		s := *ptr.offset(u.unrecognized).toBytes()
		b = append(b, s...)
	}
	return b, errLater
}
```

`computeMarshalInfo`实际上就是对要序列化的类型，进行一次全面检查，设置好序列化要使用的数据，这其中就包含了各字段的序列化函数`f.marshaler`。我们就重点关注下这部分，struct的每一个字段都会分配一个`marshalFieldInfo`，代表这个字段序列化需要的信息，会调用`computeMarshalFieldInfo`会填充这个对象。

```go
// computeMarshalInfo initializes the marshal info.
func (u *marshalInfo) computeMarshalInfo() {
	// 加锁，代表了不能同时计算marshal信息
	u.Lock()
	defer u.Unlock()
	// 计算1次即可
	if u.initialized != 0 { // non-atomic read is ok as it is protected by the lock
		return
	}

	// 获取要marshal的message类型
	t := u.typ
	u.unrecognized = invalidField
	u.extensions = invalidField
	u.v1extensions = invalidField
	u.sizecache = invalidField

	// If the message can marshal itself, let it do it, for compatibility.
	// 判断当前类型是否实现了Marshal接口，如果实现标记为类型自有marshaler
	// 没用类型断言是因为t是Type类型，不是保存在某个接口的变量
	// NOTE: This is not efficient.
	if reflect.PtrTo(t).Implements(marshalerType) {
		u.hasmarshaler = true
		atomic.StoreInt32(&u.initialized, 1)
		// 可以直接返回了，后面使用自有的marshaler编码
		return
	}

	// get oneof implementers
	// 看*t实现了以下哪个接口，oneof特性
	var oneofImplementers []interface{}
	switch m := reflect.Zero(reflect.PtrTo(t)).Interface().(type) {
	case oneofFuncsIface:
		_, _, _, oneofImplementers = m.XXX_OneofFuncs()
	case oneofWrappersIface:
		oneofImplementers = m.XXX_OneofWrappers()
	}

	n := t.NumField()

	// deal with XXX fields first
	// 遍历t的每一个XXX字段
	for i := 0; i < t.NumField(); i++ {
		f := t.Field(i)
		// 跳过非XXX开头的字段
		if !strings.HasPrefix(f.Name, "XXX_") {
			continue
		}
		// 处理以下几个protobuf自带的字段
		switch f.Name {
		case "XXX_sizecache":
			u.sizecache = toField(&f)
		case "XXX_unrecognized":
			u.unrecognized = toField(&f)
		case "XXX_InternalExtensions":
			u.extensions = toField(&f)
			u.messageset = f.Tag.Get("protobuf_messageset") == "1"
		case "XXX_extensions":
			u.v1extensions = toField(&f)
		case "XXX_NoUnkeyedLiteral":
			// nothing to do
		default:
			panic("unknown XXX field: " + f.Name)
		}
		n--
	}

	// normal fields
	// 处理message的普通字段
	fields := make([]marshalFieldInfo, n) // batch allocation
	u.fields = make([]*marshalFieldInfo, 0, n)
	for i, j := 0, 0; i < t.NumField(); i++ {
		f := t.Field(i)

		// 跳过XXX字段
		if strings.HasPrefix(f.Name, "XXX_") {
			continue
		}

		// 取fields的下一个有效字段，指针类型
		// j代表了fields有效字段数量，n是包含了XXX字段的总字段数量
		field := &fields[j]
		j++
		field.name = f.Name
		// 填充到u.fields
		u.fields = append(u.fields, field)
		// 字段的tag里包含“protobuf_oneof”特殊处理
		if f.Tag.Get("protobuf_oneof") != "" {
			field.computeOneofFieldInfo(&f, oneofImplementers)
			continue
		}
		// 字段里不包含“protobuf”，代表不是protoc自动生成的字段
		if f.Tag.Get("protobuf") == "" {
			// field has no tag (not in generated message), ignore it
			// 删除刚刚保存的字段信息
			u.fields = u.fields[:len(u.fields)-1]
			j--
			continue
		}
		// 填充字段的marshal信息
		field.computeMarshalFieldInfo(&f)
	}

	// fields are marshaled in tag order on the wire.
	// 字段排序
	sort.Sort(byTag(u.fields))

	// 初始化完成
	atomic.StoreInt32(&u.initialized, 1)
}
```

回顾一下`Request`的定义，它包含1个字段Data，后面`protobuf:...`描述了protobuf要使用的信息，`"bytes,..."`这段被称为tags，用逗号进行分割后，其中：

- tags[0]: bytes，代表Data类型的数据要被转换为bytes
- tags[1]: 1，代表了字段的ID
- tags[2]: opt，代表可行，非必须
- tags[3]: name=data，proto文件中的名称
- tags[4]: proto3，代表使用的protobuf版本

```go
// request.pb.go
type Request struct{
	Data                 string   `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	...
}
```

`computeMarshalFieldInfo`首先要获取字段ID和要转换的类型，填充到marshalFieldInfo，然后调用`setMarshaler`利用字段f和tags获取该字段类型的序列化函数。

```go
// computeMarshalFieldInfo fills up the information to marshal a field.
func (fi *marshalFieldInfo) computeMarshalFieldInfo(f *reflect.StructField) {
	// parse protobuf tag of the field.
	// tag has format of "bytes,49,opt,name=foo,def=hello!"
	// 获取"protobuf"的完整tag，然后使用，分割，得到上面的格式
	tags := strings.Split(f.Tag.Get("protobuf"), ",")
	if tags[0] == "" {
		return
	}
	// tag的编号，即message中设置的string name = x，则x就是这个字段的tag id
	tag, err := strconv.Atoi(tags[1])
	if err != nil {
		panic("tag is not an integer")
	}
	// 要转换成的类型，bytes，varint等等
	wt := wiretype(tags[0])
	// 设置字段是required还是opt
	if tags[2] == "req" {
		fi.required = true
	}
	// 设置field和tag信息到marshalFieldInfo
	fi.setTag(f, tag, wt)
	// 根据当前的tag信息（类型等），选择marshaler函数
	fi.setMarshaler(f, tags)
}
```

`setMarshaler`的重点是`typeMarshaler`，`typeMarshaler`这个函数非常长，其实就是根据类型设置返回对于的序列化函数，比如Bool、Int32、Uint32...，如果是结构体、切片等复合类型，就可以形成递归了。

```go
// setMarshaler fills up the sizer and marshaler in the info of a field.
func (fi *marshalFieldInfo) setMarshaler(f *reflect.StructField, tags []string) {
	// map类型字段特殊处理
	switch f.Type.Kind() {
	case reflect.Map:
		// map field
		fi.isPointer = true
		fi.sizer, fi.marshaler = makeMapMarshaler(f)
		return
	case reflect.Ptr, reflect.Slice:
		// 指针字段和切片字段标记指针类型
		fi.isPointer = true
	}

	// 根据字段类型和tag选择marshaler
	fi.sizer, fi.marshaler = typeMarshaler(f.Type, tags, true, false)
}

// typeMarshaler returns the sizer and marshaler of a given field.
// t is the type of the field.
// tags is the generated "protobuf" tag of the field.
// If nozero is true, zero value is not marshaled to the wire.
// If oneof is true, it is a oneof field.
// 函数非常长，省略内容
func typeMarshaler(t reflect.Type, tags []string, nozero, oneof bool) (sizer, marshaler) {
	...
	switch t.Kind() {
	case reflect.Bool:
		if pointer {
			return sizeBoolPtr, appendBoolPtr
		}
		if slice {
			if packed {
				return sizeBoolPackedSlice, appendBoolPackedSlice
			}
			return sizeBoolSlice, appendBoolSlice
		}
		if nozero {
			return sizeBoolValueNoZero, appendBoolValueNoZero
		}
		return sizeBoolValue, appendBoolValue
	case reflect.Uint32:
	...
	case reflect.Int32:
	....
	case reflect.Struct:
	...
}
```

以下是Bool和String类型的2个序列化函数示例：

```go
func appendBoolValue(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {
	v := *ptr.toBool()
	b = appendVarint(b, wiretag)
	if v {
		b = append(b, 1)
	} else {
		b = append(b, 0)
	}
	return b, nil
}
```

```go
func appendStringValue(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {
	v := *ptr.toString()
	b = appendVarint(b, wiretag)
	b = appendVarint(b, uint64(len(v)))
	b = append(b, v...)
	return b, nil
}
```

所以序列化后的`[]byte`，应当是符合这种模式：

```
| wiretag | data | wiretag | data | ... | data |
```

### 解码

```go
// Unmarshaler is the interface representing objects that can
// unmarshal themselves.  The argument points to data that may be
// overwritten, so implementations should not keep references to the
// buffer.
// Unmarshal implementations should not clear the receiver.
// Any unmarshaled data should be merged into the receiver.
// Callers of Unmarshal that do not want to retain existing data
// should Reset the receiver before calling Unmarshal.
type Unmarshaler interface {
	Unmarshal([]byte) error
}

// newUnmarshaler is the interface representing objects that can
// unmarshal themselves. The semantics are identical to Unmarshaler.
//
// This exists to support protoc-gen-go generated messages.
// The proto package will stop type-asserting to this interface in the future.
//
// DO NOT DEPEND ON THIS.
type newUnmarshaler interface {
	// 实现了XXX_Unmarshal
	XXX_Unmarshal([]byte) error
}

// Unmarshal parses the protocol buffer representation in buf and places the
// decoded result in pb.  If the struct underlying pb does not match
// the data in buf, the results can be unpredictable.
//
// Unmarshal resets pb before starting to unmarshal, so any
// existing data in pb is always removed. Use UnmarshalMerge
// to preserve and append to existing data.
func Unmarshal(buf []byte, pb Message) error {
	pb.Reset()
	// pb自己有unmarshal函数，实现了newUnmarshaler接口
	if u, ok := pb.(newUnmarshaler); ok {
		return u.XXX_Unmarshal(buf)
	}
	// pb自己有unmarshal函数，实现了Unmarshaler接口
	if u, ok := pb.(Unmarshaler); ok {
		return u.Unmarshal(buf)
	}
	// 使用默认的Unmarshal
	return NewBuffer(buf).Unmarshal(pb)
}

func (m *Request) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Request.Unmarshal(m, b)
}

// Unmarshal is the entry point from the generated .pb.go files.
// This function is not intended to be used by non-generated code.
// This function is not subject to any compatibility guarantee.
// msg contains a pointer to a protocol buffer struct.
// b is the data to be unmarshaled into the protocol buffer.
// a is a pointer to a place to store cached unmarshal information.
func (a *InternalMessageInfo) Unmarshal(msg Message, b []byte) error {
	// Load the unmarshal information for this message type.
	// The atomic load ensures memory consistency.
	// 获取保存在a中的unmarshal信息
	u := atomicLoadUnmarshalInfo(&a.unmarshal)
	if u == nil {
		// Slow path: find unmarshal info for msg, update a with it.
		u = getUnmarshalInfo(reflect.TypeOf(msg).Elem())
		atomicStoreUnmarshalInfo(&a.unmarshal, u)
	}
	// Then do the unmarshaling.
	// 执行unmarshal
	err := u.unmarshal(toPointer(&msg), b)
	return err
}

```



```go
// unmarshal does the main work of unmarshaling a message.
// u provides type information used to unmarshal the message.
// m is a pointer to a protocol buffer message.
// b is a byte stream to unmarshal into m.
// This is top routine used when recursively unmarshaling submessages.
func (u *unmarshalInfo) unmarshal(m pointer, b []byte) error {
	if atomic.LoadInt32(&u.initialized) == 0 {
		// 为u填充unmarshal信息，以及设置每个字段类型的unmarshaler函数
		u.computeUnmarshalInfo()
	}
	if u.isMessageSet {
		return unmarshalMessageSet(b, m.offset(u.extensions).toExtensions())
	}
	var reqMask uint64 // bitmask of required fields we've seen.
	var errLater error
	for len(b) > 0 {
		// Read tag and wire type.
		// Special case 1 and 2 byte varints.
		var x uint64
		if b[0] < 128 {
			x = uint64(b[0])
			b = b[1:]
		} else if len(b) >= 2 && b[1] < 128 {
			x = uint64(b[0]&0x7f) + uint64(b[1])<<7
			b = b[2:]
		} else {
			var n int
			x, n = decodeVarint(b)
			if n == 0 {
				return io.ErrUnexpectedEOF
			}
			b = b[n:]
		}
		// 获取tag和wire标记
		tag := x >> 3
		wire := int(x) & 7

		// Dispatch on the tag to one of the unmarshal* functions below.
		// 根据tag选择该类型的unmarshalFieldInfo：f
		var f unmarshalFieldInfo
		if tag < uint64(len(u.dense)) {
			f = u.dense[tag]
		} else {
			f = u.sparse[tag]
		}
		// 如果该类型有unmarshaler函数，则执行解码和错误处理
		if fn := f.unmarshal; fn != nil {
			var err error
			// 从b解析，然后填充到f的对应字段
			b, err = fn(b, m.offset(f.field), wire)
			if err == nil {
				reqMask |= f.reqMask
				continue
			}
			if r, ok := err.(*RequiredNotSetError); ok {
				// Remember this error, but keep parsing. We need to produce
				// a full parse even if a required field is missing.
				if errLater == nil {
					errLater = r
				}
				reqMask |= f.reqMask
				continue
			}
			if err != errInternalBadWireType {
				if err == errInvalidUTF8 {
					if errLater == nil {
						fullName := revProtoTypes[reflect.PtrTo(u.typ)] + "." + f.name
						errLater = &invalidUTF8Error{fullName}
					}
					continue
				}
				return err
			}
			// Fragments with bad wire type are treated as unknown fields.
		}

		// Unknown tag.
		// 跳过未知tag，可能是proto中的message定义升级了，增加了一些字段，使用老版本的，就不识别新的字段
		if !u.unrecognized.IsValid() {
			// Don't keep unrecognized data; just skip it.
			var err error
			b, err = skipField(b, wire)
			if err != nil {
				return err
			}
			continue
		}
		// 检查未识别字段是不是extension
		// Keep unrecognized data around.
		// maybe in extensions, maybe in the unrecognized field.
		z := m.offset(u.unrecognized).toBytes()
		var emap map[int32]Extension
		var e Extension
		for _, r := range u.extensionRanges {
			if uint64(r.Start) <= tag && tag <= uint64(r.End) {
				if u.extensions.IsValid() {
					mp := m.offset(u.extensions).toExtensions()
					emap = mp.extensionsWrite()
					e = emap[int32(tag)]
					z = &e.enc
					break
				}
				if u.oldExtensions.IsValid() {
					p := m.offset(u.oldExtensions).toOldExtensions()
					emap = *p
					if emap == nil {
						emap = map[int32]Extension{}
						*p = emap
					}
					e = emap[int32(tag)]
					z = &e.enc
					break
				}
				panic("no extensions field available")
			}
		}

		// Use wire type to skip data.
		var err error
		b0 := b
		b, err = skipField(b, wire)
		if err != nil {
			return err
		}
		*z = encodeVarint(*z, tag<<3|uint64(wire))
		*z = append(*z, b0[:len(b0)-len(b)]...)

		if emap != nil {
			emap[int32(tag)] = e
		}
	}
	// 校验解析到的required字段的数量，如果与u中记录的不匹配，则报错
	if reqMask != u.reqMask && errLater == nil {
		// A required field of this message is missing.
		for _, n := range u.reqFields {
			if reqMask&1 == 0 {
				errLater = &RequiredNotSetError{n}
			}
			reqMask >>= 1
		}
	}
	return errLater
}
```



## 参考文章

- https://tech.meituan.com/2015/02/26/serialization-vs-deserialization.html
  《序列化和反序列化》出自美团技术团队，值得一读。
- https://github.com/golang/protobuf
  Go支持protocol buffer的仓库，Readme，值得详读。
- https://developers.google.com/protocol-buffers/docs/gotutorial
  Google Protocol Buffers的Go语言tutorial，值得详细阅读和实操。
- https://developers.google.com/protocol-buffers/docs/overview
  Google Protocol Buffers的Overview，介绍了什么是Protocol Buffers，它的原理、历史（起源），以及和XML的对比，必读。
- https://developers.google.com/protocol-buffers/docs/proto3
  《Language Guide (proto3)》这篇文章介绍了proto3的定义，也可以理解为`.proto`文件的语法，就如同Go语言的语法，不懂语法怎么编写`.proto`文件？读这篇文章会了解很多原理，以及可以少踩坑，必读。
- https://developers.google.com/protocol-buffers/docs/reference/go-generated
  《Go Generated Code》这篇文章详细介绍了protoc是怎么用`.protoc`生成`.pb.go`的，可选。
- https://developers.google.com/protocol-buffers/docs/encoding#
  《Protocol Buffers Encoding》这篇介绍编码原理，可选。
- https://godoc.org/github.com/golang/protobuf/proto
  《package proto文档》可以把proto包当做Go语言操作protobuf数据的SDK，它实现了结构体和protobuf数据的转换，它和`.pb.go`文件配合使用。
