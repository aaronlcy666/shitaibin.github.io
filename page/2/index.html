<!DOCTYPE html>













<html class="theme-next pisces" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">
































<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=6.6.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.6.0" color="#222">









<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.6.0',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="区块链、Go语言">
<meta name="keywords" content="区块链 Go语言 后端 技术 人生 编程">
<meta property="og:type" content="website">
<meta property="og:title" content="Go语言充电站">
<meta property="og:url" content="http://lessisbetter.site/page/2/index.html">
<meta property="og:site_name" content="Go语言充电站">
<meta property="og:description" content="区块链、Go语言">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Go语言充电站">
<meta name="twitter:description" content="区块链、Go语言">



  <link rel="alternate" href="/atom.xml" title="Go语言充电站" type="application/atom+xml" />




  <link rel="canonical" href="http://lessisbetter.site/page/2/"/>



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Go语言充电站 – 大彬 less is better</title>
  












  <noscript>
  <style>
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion .logo-line-before i { left: initial; }
    .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Go语言充电站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">大彬 less is better</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-主页">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br />主页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-标签云">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签云</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-专题文章">

    
    
    
      
    

    

    <a href="/subject/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br />专题文章</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-文章列表">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br />文章列表</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-关于">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-大牛博客">

    
    
    
      
    

    

    <a href="/blogs/" rel="section"><i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />大牛博客</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    
  
  
  
  

  

    <a href="https://github.com/Shitaibin" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" style="fill: #222; color: #fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2019/10/29/fabric-transaction-endorser-source/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="区块链、Go语言">
      <meta itemprop="image" content="http://img.lessisbetter.site/gzh-qrcode-logo-small.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Go语言充电站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/10/29/fabric-transaction-endorser-source/" class="post-title-link" itemprop="url">Fabric 1.4源码解读 4：交易背书流程解读</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-10-29 18:05:43" itemprop="dateCreated datePublished" datetime="2019-10-29T18:05:43+08:00">2019-10-29</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-26 14:23:23" itemprop="dateModified" datetime="2019-12-26T14:23:23+08:00">2019-12-26</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>在 <a href="http://lessisbetter.site/2019/07/17/fabric-concepts-notes/">快速入门Fabric核心概念和框架</a> 这篇文章中，介绍了 Fabric 的很多概念，其中也包含了交易、提案（Proposal）和链码。同时也介绍了，交易的执行流程，链码的调用流程等。</p>
<p>本文聚焦介绍交易流程的一个环节：交易背书，以下的3幅图，在<a href="http://lessisbetter.site/2019/07/17/fabric-concepts-notes/">快速入门Fabric核心概念和框架</a> 中都有介绍，有必要的话，去读一下上下文信息。</p>
<h3 id="交易宏观流程"><a href="#交易宏观流程" class="headerlink" title="交易宏观流程"></a>交易宏观流程</h3><p><img src="http://img.lessisbetter.site/2019-07-tx-flow.png" alt=""></p>
<p>交易的详细流程请阅读 <a href="http://lessisbetter.site/2019/07/17/fabric-concepts-notes/#%E4%BA%A4%E6%98%93">交易流程</a>，了解交易流程的几大环节。</p>
<h3 id="链码调用流程"><a href="#链码调用流程" class="headerlink" title="链码调用流程"></a>链码调用流程</h3><p><img src="http://img.lessisbetter.site/2019-07-fabric-invoke-chaincode.png" alt=""></p>
<p>上图，展示了客户端、Peer，以及链码容器 3大主体在交易流程中的背书过程，请关注一下Peer中的 Handler，它负责和链码容器交互。</p>
<h3 id="提案背书流程"><a href="#提案背书流程" class="headerlink" title="提案背书流程"></a>提案背书流程</h3><p><img src="http://img.lessisbetter.site/2019-07-chaincode_swimlane.png" alt=""></p>
<p>上图，从接近源码的层面，展示了交易背书过程。其中Fabric、Shim 是 Peer 中的模块，ChainCode 代表链码容器，Endorser Chaincode 代表 Peer 对交易提案和模拟执行结果进行背书。</p>
<p>如果了解过Chaincode，你会知道 Shim 是链码容器和 Peer 交互所依赖的模块。</p>
<p>最后推荐一份保华大佬整理的 <a href="https://github.com/yeasy/hyperledger_code_fabric/blob/master/process/peer_endorse.md" target="_blank" rel="noopener">Peer 提案背书过程</a>，是读源码前，必读的资料。虽然精简，但把重要的核心流程都串联起来了。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="Proposal定义"><a href="#Proposal定义" class="headerlink" title="Proposal定义"></a>Proposal定义</h3><p>客户端发送被背书节点的是 <code>SignedProposal</code> ，它包含了签名和Proposal，这是它在<code>proposal.proto</code>中的组成简介，：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SignedProposal</span><br><span class="line">|\_ Signature                                    (signature on the Proposal message by the creator specified in the header)</span><br><span class="line"> \_ Proposal</span><br><span class="line">    |\_ Header                                   (the header for this proposal)</span><br><span class="line">     \_ Payload                                  (the payload for this proposal)</span><br></pre></td></tr></table></figure>
<p><code>proposal.proto</code>这个文件还简要介绍了Client和背书节点之间通信的消息类型和过程。</p>
<h4 id="Proposal"><a href="#Proposal" class="headerlink" title="Proposal"></a>Proposal</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SignedProposal <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// The bytes of Proposal</span></span><br><span class="line">	ProposalBytes []<span class="keyword">byte</span> <span class="string">`protobuf:"bytes,1,opt,name=proposal_bytes,json=proposalBytes,proto3" json:"proposal_bytes,omitempty"`</span></span><br><span class="line">	<span class="comment">// Signaure over proposalBytes; this signature is to be verified against</span></span><br><span class="line">	<span class="comment">// the creator identity contained in the header of the Proposal message</span></span><br><span class="line">	<span class="comment">// marshaled as proposalBytes</span></span><br><span class="line">	Signature            []<span class="keyword">byte</span>   <span class="string">`protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Proposal <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// The header of the proposal. It is the bytes of the Header</span></span><br><span class="line">	Header []<span class="keyword">byte</span> <span class="string">`protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`</span></span><br><span class="line">	<span class="comment">// The payload of the proposal as defined by the type in the proposal</span></span><br><span class="line">	<span class="comment">// header.</span></span><br><span class="line">	Payload []<span class="keyword">byte</span> <span class="string">`protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`</span></span><br><span class="line">	<span class="comment">// Optional extensions to the proposal. Its content depends on the Header's</span></span><br><span class="line">	<span class="comment">// type field.  For the type CHAINCODE, it might be the bytes of a</span></span><br><span class="line">	<span class="comment">// ChaincodeAction message.</span></span><br><span class="line">	Extension            []<span class="keyword">byte</span>   <span class="string">`protobuf:"bytes,3,opt,name=extension,proto3" json:"extension,omitempty"`</span></span><br><span class="line">	XXX_NoUnkeyedLiteral <span class="keyword">struct</span>&#123;&#125; <span class="string">`json:"-"`</span></span><br><span class="line">	XXX_unrecognized     []<span class="keyword">byte</span>   <span class="string">`json:"-"`</span></span><br><span class="line">	XXX_sizecache        <span class="keyword">int32</span>    <span class="string">`json:"-"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Header <span class="keyword">struct</span> &#123;</span><br><span class="line">	ChannelHeader        []<span class="keyword">byte</span>   <span class="string">`protobuf:"bytes,1,opt,name=channel_header,json=channelHeader,proto3" json:"channel_header,omitempty"`</span></span><br><span class="line">	SignatureHeader      []<span class="keyword">byte</span>   <span class="string">`protobuf:"bytes,2,opt,name=signature_header,json=signatureHeader,proto3" json:"signature_header,omitempty"`</span></span><br><span class="line">	XXX_NoUnkeyedLiteral <span class="keyword">struct</span>&#123;&#125; <span class="string">`json:"-"`</span></span><br><span class="line">	XXX_unrecognized     []<span class="keyword">byte</span>   <span class="string">`json:"-"`</span></span><br><span class="line">	XXX_sizecache        <span class="keyword">int32</span>    <span class="string">`json:"-"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Header is a generic replay prevention and identity message to include in a signed payload</span></span><br><span class="line"><span class="keyword">type</span> ChannelHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">	Type <span class="keyword">int32</span> <span class="string">`protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`</span></span><br><span class="line">	<span class="comment">// Version indicates message protocol version</span></span><br><span class="line">	Version <span class="keyword">int32</span> <span class="string">`protobuf:"varint,2,opt,name=version,proto3" json:"version,omitempty"`</span></span><br><span class="line">	<span class="comment">// Timestamp is the local time when the message was created</span></span><br><span class="line">	<span class="comment">// by the sender</span></span><br><span class="line">	Timestamp *timestamp.Timestamp <span class="string">`protobuf:"bytes,3,opt,name=timestamp,proto3" json:"timestamp,omitempty"`</span></span><br><span class="line">	<span class="comment">// Identifier of the channel this message is bound for</span></span><br><span class="line">	ChannelId <span class="keyword">string</span> <span class="string">`protobuf:"bytes,4,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty"`</span></span><br><span class="line">	<span class="comment">// An unique identifier that is used end-to-end.</span></span><br><span class="line">	<span class="comment">//  -  set by higher layers such as end user or SDK</span></span><br><span class="line">	<span class="comment">//  -  passed to the endorser (which will check for uniqueness)</span></span><br><span class="line">	<span class="comment">//  -  as the header is passed along unchanged, it will be</span></span><br><span class="line">	<span class="comment">//     be retrieved by the committer (uniqueness check here as well)</span></span><br><span class="line">	<span class="comment">//  -  to be stored in the ledger</span></span><br><span class="line">	TxId <span class="keyword">string</span> <span class="string">`protobuf:"bytes,5,opt,name=tx_id,json=txId,proto3" json:"tx_id,omitempty"`</span></span><br><span class="line">	<span class="comment">// The epoch in which this header was generated, where epoch is defined based on block height</span></span><br><span class="line">	<span class="comment">// Epoch in which the response has been generated. This field identifies a</span></span><br><span class="line">	<span class="comment">// logical window of time. A proposal response is accepted by a peer only if</span></span><br><span class="line">	<span class="comment">// two conditions hold:</span></span><br><span class="line">	<span class="comment">// 1. the epoch specified in the message is the current epoch</span></span><br><span class="line">	<span class="comment">// 2. this message has been only seen once during this epoch (i.e. it hasn't</span></span><br><span class="line">	<span class="comment">//    been replayed)</span></span><br><span class="line">	Epoch <span class="keyword">uint64</span> <span class="string">`protobuf:"varint,6,opt,name=epoch,proto3" json:"epoch,omitempty"`</span></span><br><span class="line">	<span class="comment">// Extension that may be attached based on the header type</span></span><br><span class="line">	Extension []<span class="keyword">byte</span> <span class="string">`protobuf:"bytes,7,opt,name=extension,proto3" json:"extension,omitempty"`</span></span><br><span class="line">	<span class="comment">// If mutual TLS is employed, this represents</span></span><br><span class="line">	<span class="comment">// the hash of the client's TLS certificate</span></span><br><span class="line">	TlsCertHash          []<span class="keyword">byte</span>   <span class="string">`protobuf:"bytes,8,opt,name=tls_cert_hash,json=tlsCertHash,proto3" json:"tls_cert_hash,omitempty"`</span></span><br><span class="line">	XXX_NoUnkeyedLiteral <span class="keyword">struct</span>&#123;&#125; <span class="string">`json:"-"`</span></span><br><span class="line">	XXX_unrecognized     []<span class="keyword">byte</span>   <span class="string">`json:"-"`</span></span><br><span class="line">	XXX_sizecache        <span class="keyword">int32</span>    <span class="string">`json:"-"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SignatureHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Creator of the message, a marshaled msp.SerializedIdentity</span></span><br><span class="line">	Creator []<span class="keyword">byte</span> <span class="string">`protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`</span></span><br><span class="line">	<span class="comment">// Arbitrary number that may only be used once. Can be used to detect replay attacks.</span></span><br><span class="line">	Nonce                []<span class="keyword">byte</span>   <span class="string">`protobuf:"bytes,2,opt,name=nonce,proto3" json:"nonce,omitempty"`</span></span><br><span class="line">	XXX_NoUnkeyedLiteral <span class="keyword">struct</span>&#123;&#125; <span class="string">`json:"-"`</span></span><br><span class="line">	XXX_unrecognized     []<span class="keyword">byte</span>   <span class="string">`json:"-"`</span></span><br><span class="line">	XXX_sizecache        <span class="keyword">int32</span>    <span class="string">`json:"-"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="gRPC定义"><a href="#gRPC定义" class="headerlink" title="gRPC定义"></a>gRPC定义</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EndorserClient is the client API for Endorser service.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.</span></span><br><span class="line"><span class="keyword">type</span> EndorserClient <span class="keyword">interface</span> &#123;</span><br><span class="line">	ProcessProposal(ctx context.Context, in *SignedProposal, opts ...grpc.CallOption) (*ProposalResponse, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// EndorserServer is the server API for Endorser service.</span></span><br><span class="line"><span class="keyword">type</span> EndorserServer <span class="keyword">interface</span> &#123;</span><br><span class="line">	ProcessProposal(context.Context, *SignedProposal) (*ProposalResponse, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SDK发送Proposal"><a href="#SDK发送Proposal" class="headerlink" title="SDK发送Proposal"></a>SDK发送Proposal</h3><h3 id="Peer接收Proposal"><a href="#Peer接收Proposal" class="headerlink" title="Peer接收Proposal"></a>Peer接收Proposal</h3><h3 id="Peer处理Proposal主流程"><a href="#Peer处理Proposal主流程" class="headerlink" title="Peer处理Proposal主流程"></a>Peer处理Proposal主流程</h3><p>主要是把背书节点的背书工作聚合一下：</p>
<ol>
<li>Proposal预处理</li>
<li>获取交易执行模拟器，模拟执行Proposal</li>
<li>如果模拟执行成功，调用ESCC对Proposal和结果进行背书，如果模拟执行失败直接返回背书失败的响应</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Endorser)</span> <span class="title">ProcessProposal</span><span class="params">(ctx context.Context, signedProp *pb.SignedProposal)</span> <span class="params">(*pb.ProposalResponse, error)</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 0 -- check and validate</span></span><br><span class="line">	<span class="comment">// 这里有相当多的工作量</span></span><br><span class="line">	vr, err := e.preProcess(signedProp)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		resp := vr.resp</span><br><span class="line">		<span class="keyword">return</span> resp, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	prop, hdrExt, chainID, txid := vr.prop, vr.hdrExt, vr.chainID, vr.txid</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取指定账本模拟器</span></span><br><span class="line">	<span class="comment">// obtaining once the tx simulator for this proposal. This will be nil</span></span><br><span class="line">	<span class="comment">// for chainless proposals</span></span><br><span class="line">	<span class="comment">// Also obtain a history query executor for history queries, since tx simulator does not cover history</span></span><br><span class="line">	<span class="keyword">var</span> txsim ledger.TxSimulator</span><br><span class="line">	<span class="keyword">var</span> historyQueryExecutor ledger.HistoryQueryExecutor</span><br><span class="line">	<span class="keyword">if</span> acquireTxSimulator(chainID, vr.hdrExt.ChaincodeId) &#123;</span><br><span class="line">		<span class="keyword">if</span> txsim, err = e.s.GetTxSimulator(chainID, txid); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> &amp;pb.ProposalResponse&#123;Response: &amp;pb.Response&#123;Status: <span class="number">500</span>, Message: err.Error()&#125;&#125;, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">defer</span> txsim.Done()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> historyQueryExecutor, err = e.s.GetHistoryQueryExecutor(chainID); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> &amp;pb.ProposalResponse&#123;Response: &amp;pb.Response&#123;Status: <span class="number">500</span>, Message: err.Error()&#125;&#125;, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	txParams := &amp;ccprovider.TransactionParams&#123;</span><br><span class="line">		ChannelID:            chainID,</span><br><span class="line">		TxID:                 txid,</span><br><span class="line">		SignedProp:           signedProp,</span><br><span class="line">		Proposal:             prop,</span><br><span class="line">		TXSimulator:          txsim,</span><br><span class="line">		HistoryQueryExecutor: historyQueryExecutor,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// this could be a request to a chainless SysCC</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 模拟执行交易，失败则返回背书失败的响应</span></span><br><span class="line">	<span class="comment">// 1 -- simulate</span></span><br><span class="line">	cd, res, simulationResult, ccevent, err := e.SimulateProposal(txParams, hdrExt.ChaincodeId)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;pb.ProposalResponse&#123;Response: &amp;pb.Response&#123;Status: <span class="number">500</span>, Message: err.Error()&#125;&#125;, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> res != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> res.Status &gt;= shim.ERROR &#123;</span><br><span class="line">			endorserLogger.Errorf(<span class="string">"[%s][%s] simulateProposal() resulted in chaincode %s response status %d for txid: %s"</span>, chainID, shorttxid(txid), hdrExt.ChaincodeId, res.Status, txid)</span><br><span class="line">			<span class="keyword">var</span> cceventBytes []<span class="keyword">byte</span></span><br><span class="line">			<span class="keyword">if</span> ccevent != <span class="literal">nil</span> &#123;</span><br><span class="line">				cceventBytes, err = putils.GetBytesChaincodeEvent(ccevent)</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">"failed to marshal event bytes"</span>)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			pResp, err := putils.CreateProposalResponseFailure(prop.Header, prop.Payload, res, simulationResult, cceventBytes, hdrExt.ChaincodeId, hdrExt.PayloadVisibility)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> &amp;pb.ProposalResponse&#123;Response: &amp;pb.Response&#123;Status: <span class="number">500</span>, Message: err.Error()&#125;&#125;, <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> pResp, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对模拟执行的结果进行签名背书</span></span><br><span class="line">	<span class="comment">// 2 -- endorse and get a marshalled ProposalResponse message</span></span><br><span class="line">	<span class="keyword">var</span> pResp *pb.ProposalResponse</span><br><span class="line"></span><br><span class="line">	<span class="comment">// TODO till we implement global ESCC, CSCC for system chaincodes</span></span><br><span class="line">	<span class="comment">// chainless proposals (such as CSCC) don't have to be endorsed</span></span><br><span class="line">	<span class="keyword">if</span> chainID == <span class="string">""</span> &#123;</span><br><span class="line">		pResp = &amp;pb.ProposalResponse&#123;Response: res&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Note: To endorseProposal(), we pass the released txsim. Hence, an error would occur if we try to use this txsim</span></span><br><span class="line">		pResp, err = e.endorseProposal(ctx, chainID, txid, signedProp, prop, res, simulationResult, ccevent, hdrExt.PayloadVisibility, hdrExt.ChaincodeId, txsim, cd)</span><br><span class="line"></span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set the proposal response payload - it</span></span><br><span class="line">	<span class="comment">// contains the "return value" from the</span></span><br><span class="line">	<span class="comment">// chaincode invocation</span></span><br><span class="line">	pResp.Response = res</span><br><span class="line"></span><br><span class="line">	<span class="comment">// total failed proposals = ProposalsReceived-SuccessfulProposals</span></span><br><span class="line">	e.Metrics.SuccessfulProposals.Add(<span class="number">1</span>)</span><br><span class="line">	success = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pResp, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="preProcess-检查和获取信息"><a href="#preProcess-检查和获取信息" class="headerlink" title="preProcess 检查和获取信息"></a>preProcess 检查和获取信息</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// preProcess checks the tx proposal headers, uniqueness and ACL</span></span><br><span class="line"><span class="comment">// 检查proposal、ACL</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Endorser)</span> <span class="title">preProcess</span><span class="params">(signedProp *pb.SignedProposal)</span> <span class="params">(*validateResult, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 包含proposal、header、chainID、txid等信息</span></span><br><span class="line">	vr := &amp;validateResult&#123;&#125;</span><br><span class="line">	<span class="comment">// at first, we check whether the message is valid</span></span><br><span class="line">	<span class="comment">// 检查proposal，并获取各种需要的信息</span></span><br><span class="line">	prop, hdr, hdrExt, err := validation.ValidateProposalMessage(signedProp)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		e.Metrics.ProposalValidationFailed.Add(<span class="number">1</span>)</span><br><span class="line">		vr.resp = &amp;pb.ProposalResponse&#123;Response: &amp;pb.Response&#123;Status: <span class="number">500</span>, Message: err.Error()&#125;&#125;</span><br><span class="line">		<span class="keyword">return</span> vr, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取Header中的2个Header</span></span><br><span class="line">	chdr, err := putils.UnmarshalChannelHeader(hdr.ChannelHeader)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		vr.resp = &amp;pb.ProposalResponse&#123;Response: &amp;pb.Response&#123;Status: <span class="number">500</span>, Message: err.Error()&#125;&#125;</span><br><span class="line">		<span class="keyword">return</span> vr, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	shdr, err := putils.GetSignatureHeader(hdr.SignatureHeader)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		vr.resp = &amp;pb.ProposalResponse&#123;Response: &amp;pb.Response&#123;Status: <span class="number">500</span>, Message: err.Error()&#125;&#125;</span><br><span class="line">		<span class="keyword">return</span> vr, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查是否调用了不可外部（用户）的系统链码</span></span><br><span class="line">	<span class="comment">// 先找到链码实例，然后调用链码的方法判断本身是否可调用</span></span><br><span class="line">	<span class="comment">// block invocations to security-sensitive system chaincodes</span></span><br><span class="line">	<span class="keyword">if</span> e.s.IsSysCCAndNotInvokableExternal(hdrExt.ChaincodeId.Name) &#123;</span><br><span class="line">		endorserLogger.Errorf(<span class="string">"Error: an attempt was made by %#v to invoke system chaincode %s"</span>, shdr.Creator, hdrExt.ChaincodeId.Name)</span><br><span class="line">		err = errors.Errorf(<span class="string">"chaincode %s cannot be invoked through a proposal"</span>, hdrExt.ChaincodeId.Name)</span><br><span class="line">		vr.resp = &amp;pb.ProposalResponse&#123;Response: &amp;pb.Response&#123;Status: <span class="number">500</span>, Message: err.Error()&#125;&#125;</span><br><span class="line">		<span class="keyword">return</span> vr, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	chainID := chdr.ChannelId</span><br><span class="line">	txid := chdr.TxId</span><br><span class="line">	endorserLogger.Debugf(<span class="string">"[%s][%s] processing txid: %s"</span>, chainID, shorttxid(txid), txid)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> chainID != <span class="string">""</span> &#123;</span><br><span class="line">		<span class="comment">// labels that provide context for failure metrics</span></span><br><span class="line">		meterLabels := []<span class="keyword">string</span>&#123;</span><br><span class="line">			<span class="string">"channel"</span>, chainID,</span><br><span class="line">			<span class="string">"chaincode"</span>, hdrExt.ChaincodeId.Name + <span class="string">":"</span> + hdrExt.ChaincodeId.Version,</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 检查交易是否已上链</span></span><br><span class="line">		<span class="comment">// Here we handle uniqueness check and ACLs for proposals targeting a chain</span></span><br><span class="line">		<span class="comment">// Notice that ValidateProposalMessage has already verified that TxID is computed properly</span></span><br><span class="line">		<span class="keyword">if</span> _, err = e.s.GetTransactionByID(chainID, txid); err == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// increment failure due to duplicate transactions. Useful for catching replay attacks in</span></span><br><span class="line">			<span class="comment">// addition to benign retries</span></span><br><span class="line">			e.Metrics.DuplicateTxsFailure.With(meterLabels...).Add(<span class="number">1</span>)</span><br><span class="line">			err = errors.Errorf(<span class="string">"duplicate transaction found [%s]. Creator [%x]"</span>, txid, shdr.Creator)</span><br><span class="line">			vr.resp = &amp;pb.ProposalResponse&#123;Response: &amp;pb.Response&#123;Status: <span class="number">500</span>, Message: err.Error()&#125;&#125;</span><br><span class="line">			<span class="keyword">return</span> vr, err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 用户链码检查ACL</span></span><br><span class="line">		<span class="comment">// check ACL only for application chaincodes; ACLs</span></span><br><span class="line">		<span class="comment">// for system chaincodes are checked elsewhere</span></span><br><span class="line">		<span class="keyword">if</span> !e.s.IsSysCC(hdrExt.ChaincodeId.Name) &#123;</span><br><span class="line">			<span class="comment">// check that the proposal complies with the Channel's writers</span></span><br><span class="line">			<span class="keyword">if</span> err = e.s.CheckACL(signedProp, chdr, shdr, hdrExt); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				e.Metrics.ProposalACLCheckFailed.With(meterLabels...).Add(<span class="number">1</span>)</span><br><span class="line">				vr.resp = &amp;pb.ProposalResponse&#123;Response: &amp;pb.Response&#123;Status: <span class="number">500</span>, Message: err.Error()&#125;&#125;</span><br><span class="line">				<span class="keyword">return</span> vr, err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// chainless proposals do not/cannot affect ledger and cannot be submitted as transactions</span></span><br><span class="line">		<span class="comment">// ignore uniqueness checks; also, chainless proposals are not validated using the policies</span></span><br><span class="line">		<span class="comment">// of the chain since by definition there is no chain; they are validated against the local</span></span><br><span class="line">		<span class="comment">// MSP of the peer instead by the call to ValidateProposalMessage above</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 保存提取的各信息</span></span><br><span class="line">	vr.prop, vr.hdrExt, vr.chainID, vr.txid = prop, hdrExt, chainID, txid</span><br><span class="line">	<span class="keyword">return</span> vr, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ValidateProposalMessage checks the validity of a SignedProposal message</span></span><br><span class="line"><span class="comment">// this function returns Header and ChaincodeHeaderExtension messages since they</span></span><br><span class="line"><span class="comment">// have been unmarshalled and validated</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValidateProposalMessage</span><span class="params">(signedProp *pb.SignedProposal)</span> <span class="params">(*pb.Proposal, *common.Header, *pb.ChaincodeHeaderExtension, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> signedProp == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, errors.New(<span class="string">"nil arguments"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	putilsLogger.Debugf(<span class="string">"ValidateProposalMessage starts for signed proposal %p"</span>, signedProp)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// extract the Proposal message from signedProp</span></span><br><span class="line">	prop, err := utils.GetProposal(signedProp.ProposalBytes)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1) look at the ProposalHeader</span></span><br><span class="line">	hdr, err := utils.GetHeader(prop.Header)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// validate the header</span></span><br><span class="line">	chdr, shdr, err := validateCommonHeader(hdr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从SignatureHeader交易客户端的签名</span></span><br><span class="line">	<span class="comment">// validate the signature</span></span><br><span class="line">	err = checkSignatureFromCreator(shdr.Creator, signedProp.Signature, signedProp.ProposalBytes, chdr.ChannelId)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// log the exact message on the peer but return a generic error message to</span></span><br><span class="line">		<span class="comment">// avoid malicious users scanning for channels</span></span><br><span class="line">		putilsLogger.Warningf(<span class="string">"channel [%s]: %s"</span>, chdr.ChannelId, err)</span><br><span class="line">		sId := &amp;msp.SerializedIdentity&#123;&#125;</span><br><span class="line">		err := proto.Unmarshal(shdr.Creator, sId)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// log the error here as well but still only return the generic error</span></span><br><span class="line">			err = errors.Wrap(err, <span class="string">"could not deserialize a SerializedIdentity"</span>)</span><br><span class="line">			putilsLogger.Warningf(<span class="string">"channel [%s]: %s"</span>, chdr.ChannelId, err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, errors.Errorf(<span class="string">"access denied: channel [%s] creator org [%s]"</span>, chdr.ChannelId, sId.Mspid)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查txid的计算是否符合规则</span></span><br><span class="line">	<span class="comment">// Verify that the transaction ID has been computed properly.</span></span><br><span class="line">	<span class="comment">// This check is needed to ensure that the lookup into the ledger</span></span><br><span class="line">	<span class="comment">// for the same TxID catches duplicates.</span></span><br><span class="line">	err = utils.CheckTxID(</span><br><span class="line">		chdr.TxId,</span><br><span class="line">		shdr.Nonce,</span><br><span class="line">		shdr.Creator)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 依据不同的proposal类型对proposal分别进行检查</span></span><br><span class="line">	<span class="comment">// continue the validation in a way that depends on the type specified in the header</span></span><br><span class="line">	<span class="keyword">switch</span> common.HeaderType(chdr.Type) &#123;</span><br><span class="line">	<span class="keyword">case</span> common.HeaderType_CONFIG:</span><br><span class="line">		<span class="comment">//which the types are different the validation is the same</span></span><br><span class="line">		<span class="comment">//viz, validate a proposal to a chaincode. If we need other</span></span><br><span class="line">		<span class="comment">//special validation for confguration, we would have to implement</span></span><br><span class="line">		<span class="comment">//special validation</span></span><br><span class="line">		<span class="keyword">fallthrough</span></span><br><span class="line">	<span class="keyword">case</span> common.HeaderType_ENDORSER_TRANSACTION:</span><br><span class="line">		<span class="comment">// 主要是提取ChaincodeHeaderExtension</span></span><br><span class="line">		<span class="comment">// validation of the proposal message knowing it's of type CHAINCODE</span></span><br><span class="line">		chaincodeHdrExt, err := validateChaincodeProposalMessage(prop, hdr)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> prop, hdr, chaincodeHdrExt, err</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="comment">//NOTE : we proably need a case</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, errors.Errorf(<span class="string">"unsupported proposal type %d"</span>, common.HeaderType(chdr.Type))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="背书节点模拟执行交易"><a href="#背书节点模拟执行交易" class="headerlink" title="背书节点模拟执行交易"></a>背书节点模拟执行交易</h3><h4 id="获取模拟器"><a href="#获取模拟器" class="headerlink" title="获取模拟器"></a>获取模拟器</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Support contains functions that the endorser requires to execute its tasks</span></span><br><span class="line"><span class="keyword">type</span> Support <span class="keyword">interface</span> &#123;</span><br><span class="line">	crypto.SignerSupport</span><br><span class="line">	<span class="comment">// IsSysCCAndNotInvokableExternal returns true if the supplied chaincode is</span></span><br><span class="line">	<span class="comment">// ia system chaincode and it NOT invokable</span></span><br><span class="line">	IsSysCCAndNotInvokableExternal(name <span class="keyword">string</span>) <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// GetTxSimulator returns the transaction simulator for the specified ledger</span></span><br><span class="line">	<span class="comment">// a client may obtain more than one such simulator; they are made unique</span></span><br><span class="line">	<span class="comment">// by way of the supplied txid</span></span><br><span class="line">	GetTxSimulator(ledgername <span class="keyword">string</span>, txid <span class="keyword">string</span>) (ledger.TxSimulator, error)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetTxSimulator returns the transaction simulator for the specified ledger</span></span><br><span class="line"><span class="comment">// a client may obtain more than one such simulator; they are made unique</span></span><br><span class="line"><span class="comment">// by way of the supplied txid</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SupportImpl)</span> <span class="title">GetTxSimulator</span><span class="params">(ledgername <span class="keyword">string</span>, txid <span class="keyword">string</span>)</span> <span class="params">(ledger.TxSimulator, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 使用账本和txid创建模拟器，每个交易有单独的模拟器</span></span><br><span class="line">	lgr := s.Peer.GetLedger(ledgername)</span><br><span class="line">	<span class="keyword">if</span> lgr == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.Errorf(<span class="string">"Channel does not exist: %s"</span>, ledgername)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> lgr.NewTxSimulator(txid)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewTxSimulator returns new `ledger.TxSimulator`</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *kvLedger)</span> <span class="title">NewTxSimulator</span><span class="params">(txid <span class="keyword">string</span>)</span> <span class="params">(ledger.TxSimulator, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> l.txtmgmt.NewTxSimulator(txid)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewTxSimulator implements method in interface `txmgmt.TxMgr`</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(txmgr *LockBasedTxMgr)</span> <span class="title">NewTxSimulator</span><span class="params">(txid <span class="keyword">string</span>)</span> <span class="params">(ledger.TxSimulator, error)</span></span> &#123;</span><br><span class="line">	logger.Debugf(<span class="string">"constructing new tx simulator"</span>)</span><br><span class="line">	s, err := newLockBasedTxSimulator(txmgr, txid)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	txmgr.commitRWLock.RLock()</span><br><span class="line">	<span class="keyword">return</span> s, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 就2项重要的：查询执行器、读写集构建器</span></span><br><span class="line"><span class="comment">// LockBasedTxSimulator is a transaction simulator used in `LockBasedTxMgr`</span></span><br><span class="line"><span class="keyword">type</span> lockBasedTxSimulator <span class="keyword">struct</span> &#123;</span><br><span class="line">	lockBasedQueryExecutor</span><br><span class="line">	rwsetBuilder              *rwsetutil.RWSetBuilder</span><br><span class="line">	writePerformed            <span class="keyword">bool</span></span><br><span class="line">	pvtdataQueriesPerformed   <span class="keyword">bool</span></span><br><span class="line">	simulationResultsComputed <span class="keyword">bool</span></span><br><span class="line">	paginatedQueriesPerformed <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newLockBasedTxSimulator</span><span class="params">(txmgr *LockBasedTxMgr, txid <span class="keyword">string</span>)</span> <span class="params">(*lockBasedTxSimulator, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建读写集构建器，能帮助构建读写集</span></span><br><span class="line">	rwsetBuilder := rwsetutil.NewRWSetBuilder()</span><br><span class="line">	helper := newQueryHelper(txmgr, rwsetBuilder)</span><br><span class="line">	logger.Debugf(<span class="string">"constructing new tx simulator txid = [%s]"</span>, txid)</span><br><span class="line">	<span class="keyword">return</span> &amp;lockBasedTxSimulator&#123;lockBasedQueryExecutor&#123;helper, txid&#125;, rwsetBuilder, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LockBasedQueryExecutor is a query executor used in `LockBasedTxMgr`</span></span><br><span class="line"><span class="comment">// "只读"，不包含写相关的操作</span></span><br><span class="line"><span class="keyword">type</span> lockBasedQueryExecutor <span class="keyword">struct</span> &#123;</span><br><span class="line">	helper *queryHelper</span><br><span class="line">	txid   <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="模拟执行"><a href="#模拟执行" class="headerlink" title="模拟执行"></a>模拟执行</h4><h5 id="endorser部分"><a href="#endorser部分" class="headerlink" title="endorser部分"></a>endorser部分</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> acquireTxSimulator(chainID, vr.hdrExt.ChaincodeId) &#123;</span><br><span class="line">	<span class="keyword">if</span> txsim, err = e.s.GetTxSimulator(chainID, txid); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;pb.ProposalResponse&#123;Response: &amp;pb.Response&#123;Status: <span class="number">500</span>, Message: err.Error()&#125;&#125;, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> txsim.Done()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 历史查询器</span></span><br><span class="line">	<span class="keyword">if</span> historyQueryExecutor, err = e.s.GetHistoryQueryExecutor(chainID); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;pb.ProposalResponse&#123;Response: &amp;pb.Response&#123;Status: <span class="number">500</span>, Message: err.Error()&#125;&#125;, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">txParams := &amp;ccprovider.TransactionParams&#123;</span><br><span class="line">	ChannelID:            chainID,</span><br><span class="line">	TxID:                 txid,</span><br><span class="line">	SignedProp:           signedProp,</span><br><span class="line">	Proposal:             prop,</span><br><span class="line">	TXSimulator:          txsim,	<span class="comment">// 模拟器在此</span></span><br><span class="line">	HistoryQueryExecutor: historyQueryExecutor,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// this could be a request to a chainless SysCC</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> if the proposal has an extension, it will be of type ChaincodeAction;</span></span><br><span class="line"><span class="comment">//       if it's present it means that no simulation is to be performed because</span></span><br><span class="line"><span class="comment">//       we're trying to emulate a submitting peer. On the other hand, we need</span></span><br><span class="line"><span class="comment">//       to validate the supplied action before endorsing it</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟执行交易，失败则返回背书失败的响应</span></span><br><span class="line"><span class="comment">// 1 -- simulate</span></span><br><span class="line">cd, res, simulationResult, ccevent, err := e.SimulateProposal(txParams, hdrExt.ChaincodeId)</span><br></pre></td></tr></table></figure>
<p>调用chaincode模块模拟执行交易，获取交易执行的公开和私密数据读写集，以及交易执行产生的事件，并把结果返回给上层进行背书。</p>
<p>其中还包含了私密数据的处理，会把它取出来，然后通过Gossip传播给在私密数据中的Peer节点。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SimulateProposal simulates the proposal by calling the chaincode</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Endorser)</span> <span class="title">SimulateProposal</span><span class="params">(txParams *ccprovider.TransactionParams, cid *pb.ChaincodeID)</span> <span class="params">(ccprovider.ChaincodeDefinition, *pb.Response, []<span class="keyword">byte</span>, *pb.ChaincodeEvent, error)</span></span> &#123;</span><br><span class="line">	endorserLogger.Debugf(<span class="string">"[%s][%s] Entry chaincode: %s"</span>, txParams.ChannelID, shorttxid(txParams.TxID), cid)</span><br><span class="line">	<span class="keyword">defer</span> endorserLogger.Debugf(<span class="string">"[%s][%s] Exit"</span>, txParams.ChannelID, shorttxid(txParams.TxID))</span><br><span class="line">	<span class="comment">// we do expect the payload to be a ChaincodeInvocationSpec</span></span><br><span class="line">	<span class="comment">// if we are supporting other payloads in future, this be glaringly point</span></span><br><span class="line">	<span class="comment">// as something that should change</span></span><br><span class="line">	<span class="comment">// 根据Proposal生成Invoke需要的信息</span></span><br><span class="line">	cis, err := putils.GetChaincodeInvocationSpec(txParams.Proposal)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 链码的元数据</span></span><br><span class="line">	<span class="keyword">var</span> cdLedger ccprovider.ChaincodeDefinition</span><br><span class="line">	<span class="keyword">var</span> version <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置version</span></span><br><span class="line">	<span class="keyword">if</span> !e.s.IsSysCC(cid.Name) &#123;</span><br><span class="line">		<span class="comment">// 根据要调用的链码名称，从lscc获取链码的元数据</span></span><br><span class="line">		cdLedger, err = e.s.GetChaincodeDefinition(cid.Name, txParams.TXSimulator)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, errors.WithMessage(err, fmt.Sprintf(<span class="string">"make sure the chaincode %s has been successfully instantiated and try again"</span>, cid.Name))</span><br><span class="line">		&#125;</span><br><span class="line">		version = cdLedger.CCVersion()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 实际被打桩了，无实现</span></span><br><span class="line">		err = e.s.CheckInstantiationPolicy(cid.Name, version, cdLedger)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// scc版本是固定的"latest"</span></span><br><span class="line">		version = util.GetSysCCVersion()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ---3. execute the proposal and get simulation results</span></span><br><span class="line">	<span class="keyword">var</span> simResult *ledger.TxSimulationResults</span><br><span class="line">	<span class="keyword">var</span> pubSimResBytes []<span class="keyword">byte</span></span><br><span class="line">	<span class="keyword">var</span> res *pb.Response</span><br><span class="line">	<span class="keyword">var</span> ccevent *pb.ChaincodeEvent</span><br><span class="line">	<span class="comment">// 模拟执行，执行结果保存在模拟器</span></span><br><span class="line">	res, ccevent, err = e.callChaincode(txParams, version, cis.ChaincodeSpec.Input, cid)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		endorserLogger.Errorf(<span class="string">"[%s][%s] failed to invoke chaincode %s, error: %+v"</span>, txParams.ChannelID, shorttxid(txParams.TxID), cid, err)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> txParams.TXSimulator != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 通过模拟器获取模拟执行结果，包含公开和私密数据2份读写集</span></span><br><span class="line">		<span class="keyword">if</span> simResult, err = txParams.TXSimulator.GetTxSimulationResults(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			txParams.TXSimulator.Done()</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 存在私密数据</span></span><br><span class="line">		<span class="keyword">if</span> simResult.PvtSimulationResults != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> cid.Name == <span class="string">"lscc"</span> &#123;</span><br><span class="line">				<span class="comment">// <span class="doctag">TODO:</span> remove once we can store collection configuration outside of LSCC</span></span><br><span class="line">				txParams.TXSimulator.Done()</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, errors.New(<span class="string">"Private data is forbidden to be used in instantiate"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 获取要通过Gossip传播的私密数据</span></span><br><span class="line">			pvtDataWithConfig, err := e.AssemblePvtRWSet(simResult.PvtSimulationResults, txParams.TXSimulator)</span><br><span class="line">			<span class="comment">// To read collection config need to read collection updates before</span></span><br><span class="line">			<span class="comment">// releasing the lock, hence txParams.TXSimulator.Done()  moved down here</span></span><br><span class="line">			txParams.TXSimulator.Done()</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, errors.WithMessage(err, <span class="string">"failed to obtain collections config"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			endorsedAt, err := e.s.GetLedgerHeight(txParams.ChannelID)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, errors.WithMessage(err, fmt.Sprint(<span class="string">"failed to obtain ledger height for channel"</span>, txParams.ChannelID))</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Add ledger height at which transaction was endorsed,</span></span><br><span class="line">			<span class="comment">// `endorsedAt` is obtained from the block storage and at times this could be 'endorsement Height + 1'.</span></span><br><span class="line">			<span class="comment">// However, since we use this height only to select the configuration (3rd parameter in distributePrivateData) and</span></span><br><span class="line">			<span class="comment">// manage transient store purge for orphaned private writesets (4th parameter in distributePrivateData), this works for now.</span></span><br><span class="line">			<span class="comment">// Ideally, ledger should add support in the simulator as a first class function `GetHeight()`.</span></span><br><span class="line">			pvtDataWithConfig.EndorsedAt = endorsedAt</span><br><span class="line">			<span class="comment">// 把私密数据同通道id、交易id和区块高度发出去，代表私密数据所属的区块和交易</span></span><br><span class="line">			<span class="keyword">if</span> err := e.distributePrivateData(txParams.ChannelID, txParams.TxID, pvtDataWithConfig, endorsedAt); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 交易模拟完成，释放模拟器占用的资源</span></span><br><span class="line">		txParams.TXSimulator.Done()</span><br><span class="line">		<span class="comment">// 获取模拟执行的公开结果</span></span><br><span class="line">		<span class="keyword">if</span> pubSimResBytes, err = simResult.GetPubSimulationBytes(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 返回链码元数据、模拟执行结果、交易执行产生的事件</span></span><br><span class="line">	<span class="keyword">return</span> cdLedger, res, pubSimResBytes, ccevent, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>callChaincode</code> 调用chaincode模块执行链码。在前面的流程中，还没有区分系统链码SCC和用户链码UCC，SCC和UCC都会通过<code>Execute</code>函数被传递给chaincode模块而执行。</p>
<p>如果是调用<code>lscc</code>部署或升级UCC，会调用<code>ExecuteLegacyInit</code>执行链码容器的初始化。</p>
<p>最后返回链码模拟执行结果和事件。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// call specified chaincode (system or user)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Endorser)</span> <span class="title">callChaincode</span><span class="params">(txParams *ccprovider.TransactionParams, version <span class="keyword">string</span>, input *pb.ChaincodeInput, cid *pb.ChaincodeID)</span> <span class="params">(*pb.Response, *pb.ChaincodeEvent, error)</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// scc也在这执行</span></span><br><span class="line">	<span class="comment">// is this a system chaincode</span></span><br><span class="line">	res, ccevent, err = e.s.Execute(txParams, txParams.ChannelID, cid.Name, version, txParams.TxID, txParams.SignedProp, txParams.Proposal, input)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果是调用lscc部署或升级链码，会走这段流程</span></span><br><span class="line">	<span class="keyword">if</span> cid.Name == <span class="string">"lscc"</span> &amp;&amp; <span class="built_in">len</span>(input.Args) &gt;= <span class="number">3</span> &amp;&amp; (<span class="keyword">string</span>(input.Args[<span class="number">0</span>]) == <span class="string">"deploy"</span> || <span class="keyword">string</span>(input.Args[<span class="number">0</span>]) == <span class="string">"upgrade"</span>) &#123;</span><br><span class="line">		userCDS, err := putils.GetChaincodeDeploymentSpec(input.Args[<span class="number">2</span>], e.PlatformRegistry)</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// 进行链码容器初始化，最后会调用链码的Init的函数</span></span><br><span class="line">		_, _, err = e.s.ExecuteLegacyInit(txParams, txParams.ChannelID, cds.ChaincodeSpec.ChaincodeId.Name, cds.ChaincodeSpec.ChaincodeId.Version, txParams.TxID, txParams.SignedProp, txParams.Proposal, cds)</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ----- END -------</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res, ccevent, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Support</code> 接口实际集合了众多背书节点需要的外部模块功能，比如链码、系统链码、ACL等。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Support contains functions that the endorser requires to execute its tasks</span></span><br><span class="line"><span class="keyword">type</span> Support <span class="keyword">interface</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// SupportImpl provides an implementation of the endorser.Support interface</span></span><br><span class="line"><span class="comment">// issuing calls to various static methods of the peer</span></span><br><span class="line"><span class="keyword">type</span> SupportImpl <span class="keyword">struct</span> &#123;</span><br><span class="line">	*PluginEndorser</span><br><span class="line">	crypto.SignerSupport</span><br><span class="line">	Peer             peer.Operations</span><br><span class="line">	PeerSupport      peer.Support</span><br><span class="line">	ChaincodeSupport *chaincode.ChaincodeSupport</span><br><span class="line">	SysCCProvider    *scc.Provider</span><br><span class="line">	ACLProvider      aclmgmt.ACLProvider</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Execute</code>就是调用<code>ChaincodeSupport.Execute</code>实现的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Execute a proposal and return the chaincode response</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SupportImpl)</span> <span class="title">Execute</span><span class="params">(txParams *ccprovider.TransactionParams, cid, name, version, txid <span class="keyword">string</span>, signedProp *pb.SignedProposal, prop *pb.Proposal, input *pb.ChaincodeInput)</span> <span class="params">(*pb.Response, *pb.ChaincodeEvent, error)</span></span> &#123;</span><br><span class="line">	cccid := &amp;ccprovider.CCContext&#123;</span><br><span class="line">		Name:    name,</span><br><span class="line">		Version: version,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// decorate the chaincode input</span></span><br><span class="line">	decorators := library.InitRegistry(library.Config&#123;&#125;).Lookup(library.Decoration).([]decoration.Decorator)</span><br><span class="line">	input.Decorations = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">byte</span>)</span><br><span class="line">	input = decoration.Apply(prop, input, decorators...)</span><br><span class="line">	txParams.ProposalDecorations = input.Decorations</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> s.ChaincodeSupport.Execute(txParams, cccid, input)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="chaincode部分"><a href="#chaincode部分" class="headerlink" title="chaincode部分"></a>chaincode部分</h5><p>通过上面的接口，跨入chaincode模块的大门。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *ChaincodeSupport)</span> <span class="title">Execute</span><span class="params">(txParams *ccprovider.TransactionParams, cccid *ccprovider.CCContext, input *pb.ChaincodeInput)</span> <span class="params">(*pb.Response, *pb.ChaincodeEvent, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Invoke得到ChaincodeMessage</span></span><br><span class="line">	resp, err := cs.Invoke(txParams, cccid, input)</span><br><span class="line">	<span class="comment">// 根据ChaincodeMessage得到Response和事件</span></span><br><span class="line">	<span class="keyword">return</span> processChaincodeExecutionResult(txParams.TxID, cccid.Name, resp, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *ChaincodeSupport)</span> <span class="title">Invoke</span><span class="params">(txParams *ccprovider.TransactionParams, cccid *ccprovider.CCContext, input *pb.ChaincodeInput)</span> <span class="params">(*pb.ChaincodeMessage, error)</span></span> &#123;</span><br><span class="line">	h, err := cs.Launch(txParams.ChannelID, cccid.Name, cccid.Version, txParams.TXSimulator)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行调用链码的交易（和链码之间的消息为ChaincodeMessage_TRANSACTION）</span></span><br><span class="line">	cctype := pb.ChaincodeMessage_TRANSACTION</span><br><span class="line">	<span class="keyword">return</span> cs.execute(cctype, txParams, cccid, input, h)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="获取链码执行环境"><a href="#获取链码执行环境" class="headerlink" title="获取链码执行环境"></a>获取链码执行环境</h5><p><code>Launch</code> 可以获取链码执行环境，即用户链码容器，如果已实例化的链码，在当前背书节点上，链码容器未启动，则启动链码容器，<code>Launch</code>会返回一个跟链码容器交互Handler。</p>
<p>某个 Peer 上可以部署多个链码容器，Peer 为了和这些链码容器交互/通信，给每个链码容器都创建了一个 Handler，Handler 携带了 Peer 和链码容器交互的资源。</p>
<p><img src="http://img.lessisbetter.site/2019-10-peer-cc-handler.png" alt=""></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Launch starts executing chaincode if it is not already running. This method</span></span><br><span class="line"><span class="comment">// blocks until the peer side handler gets into ready state or encounters a fatal</span></span><br><span class="line"><span class="comment">// error. If the chaincode is already running, it simply returns.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *ChaincodeSupport)</span> <span class="title">Launch</span><span class="params">(chainID, chaincodeName, chaincodeVersion <span class="keyword">string</span>, qe ledger.QueryExecutor)</span> <span class="params">(*Handler, error)</span></span> &#123;</span><br><span class="line">	cname := chaincodeName + <span class="string">":"</span> + chaincodeVersion</span><br><span class="line">	<span class="keyword">if</span> h := cs.HandlerRegistry.Handler(cname); h != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> h, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动链码容器 ...</span></span><br><span class="line"></span><br><span class="line">	h := cs.HandlerRegistry.Handler(cname)</span><br><span class="line">	<span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrapf(err, <span class="string">"[channel %s] claimed to start chaincode container for %s but could not find handler"</span>, chainID, cname)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> h, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>链码容器的启动过程，不是本文的重点，所以不继续深入Launch的调用细节。</p>
<h5 id="模拟执行交易"><a href="#模拟执行交易" class="headerlink" title="模拟执行交易"></a>模拟执行交易</h5><p><code>execute</code>封装出执行交易的消息，然后使用 Handler 执行交易。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// execute executes a transaction and waits for it to complete until a timeout value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *ChaincodeSupport)</span> <span class="title">execute</span><span class="params">(cctyp pb.ChaincodeMessage_Type, txParams *ccprovider.TransactionParams, cccid *ccprovider.CCContext, input *pb.ChaincodeInput, h *Handler)</span> <span class="params">(*pb.ChaincodeMessage, error)</span></span> &#123;</span><br><span class="line">	input.Decorations = txParams.ProposalDecorations</span><br><span class="line">	<span class="comment">// 创建消息</span></span><br><span class="line">	ccMsg, err := createCCMessage(cctyp, txParams.ChannelID, txParams.TxID, input)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.WithMessage(err, <span class="string">"failed to create chaincode message"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行交易</span></span><br><span class="line">	ccresp, err := h.Execute(txParams, cccid, ccMsg, cs.ExecuteTimeout)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.WithMessage(err, fmt.Sprintf(<span class="string">"error sending"</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ccresp, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意以下这个参数 <code>txParams *ccprovider.TransactionParams</code> 其类型定义如下，它包含了一条交易执行过程中的信息和资源，所以交易传递的过程中，一直有这个参数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TransactionParams are parameters which are tied to a particular transaction</span></span><br><span class="line"><span class="comment">// and which are required for invoking chaincode.</span></span><br><span class="line"><span class="keyword">type</span> TransactionParams <span class="keyword">struct</span> &#123;</span><br><span class="line">	TxID                 <span class="keyword">string</span></span><br><span class="line">	ChannelID            <span class="keyword">string</span></span><br><span class="line">	SignedProp           *pb.SignedProposal</span><br><span class="line">	Proposal             *pb.Proposal</span><br><span class="line">	TXSimulator          ledger.TxSimulator</span><br><span class="line">	HistoryQueryExecutor ledger.HistoryQueryExecutor</span><br><span class="line">	CollectionStore      privdata.CollectionStore</span><br><span class="line">	IsInitTransaction    <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// this is additional data passed to the chaincode</span></span><br><span class="line">	ProposalDecorations <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Handler 执行交易的过程如下，创建交易执行的上下文 Context，因为链码容器在执行交易的时候，会和 Peer 之间进行多次通信，进行数据的读写，上下文可以让数据读写获取到正确的信息。</p>
<p>之后 Handler 把消息发送给链码容器，并等待链码容器发来包含执行结果的消息，或者执行超时，默认执行时间是 30s。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Handler)</span> <span class="title">Execute</span><span class="params">(txParams *ccprovider.TransactionParams, cccid *ccprovider.CCContext, msg *pb.ChaincodeMessage, timeout time.Duration)</span> <span class="params">(*pb.ChaincodeMessage, error)</span></span> &#123;</span><br><span class="line">	chaincodeLogger.Debugf(<span class="string">"Entry"</span>)</span><br><span class="line">	<span class="keyword">defer</span> chaincodeLogger.Debugf(<span class="string">"Exit"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 私密数据</span></span><br><span class="line">	txParams.CollectionStore = h.getCollectionStore(msg.ChannelId)</span><br><span class="line">	<span class="comment">// 是否是执行链码初始化</span></span><br><span class="line">	txParams.IsInitTransaction = (msg.Type == pb.ChaincodeMessage_INIT)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建交易context</span></span><br><span class="line">	txctx, err := h.TXContexts.Create(txParams)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 退出时（执行交易完毕），释放交易上下文资源</span></span><br><span class="line">	<span class="keyword">defer</span> h.TXContexts.Delete(msg.ChannelId, msg.Txid)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// proposal保存到msg</span></span><br><span class="line">	<span class="keyword">if</span> err := h.setChaincodeProposal(txParams.SignedProp, txParams.Proposal, msg); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 向链码容器发送msg</span></span><br><span class="line">	h.serialSendAsync(msg)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待链码容器响应，或者超时</span></span><br><span class="line">	<span class="keyword">var</span> ccresp *pb.ChaincodeMessage</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> ccresp = &lt;-txctx.ResponseNotifier:</span><br><span class="line">		<span class="comment">// response is sent to user or calling chaincode. ChaincodeMessage_ERROR</span></span><br><span class="line">		<span class="comment">// are typically treated as error</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(timeout):</span><br><span class="line">		err = errors.New(<span class="string">"timeout expired while executing transaction"</span>)</span><br><span class="line">		ccName := cccid.Name + <span class="string">":"</span> + cccid.Version</span><br><span class="line">		h.Metrics.ExecuteTimeouts.With(</span><br><span class="line">			<span class="string">"chaincode"</span>, ccName,</span><br><span class="line">		).Add(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ccresp, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="处理链码容器模拟响应"><a href="#处理链码容器模拟响应" class="headerlink" title="处理链码容器模拟响应"></a>处理链码容器模拟响应</h5><p>链码容器执行的响应会向上传递，直到 <code>ChaincodeSupport.Execute</code>，它调用 <code>processChaincodeExecutionResult</code> 把链码容器返回的响应，转化为交易模拟执行的 Response，而 Response 最终会返回给Endorser，大家可去调用流程上翻。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processChaincodeExecutionResult</span><span class="params">(txid, ccName <span class="keyword">string</span>, resp *pb.ChaincodeMessage, err error)</span> <span class="params">(*pb.Response, *pb.ChaincodeEvent, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, errors.Wrapf(err, <span class="string">"failed to execute transaction %s"</span>, txid)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> resp == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, errors.Errorf(<span class="string">"nil response from transaction %s"</span>, txid)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> resp.ChaincodeEvent != <span class="literal">nil</span> &#123;</span><br><span class="line">		resp.ChaincodeEvent.ChaincodeId = ccName</span><br><span class="line">		resp.ChaincodeEvent.TxId = txid</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> resp.Type &#123;</span><br><span class="line">	<span class="comment">// 交易执行成功则提取Payload中保存的Response</span></span><br><span class="line">	<span class="keyword">case</span> pb.ChaincodeMessage_COMPLETED:</span><br><span class="line">		res := &amp;pb.Response&#123;&#125;</span><br><span class="line">		err := proto.Unmarshal(resp.Payload, res)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, errors.Wrapf(err, <span class="string">"failed to unmarshal response for transaction %s"</span>, txid)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res, resp.ChaincodeEvent, <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 	失败，则提取Payload中保存的错误信息</span></span><br><span class="line">	<span class="keyword">case</span> pb.ChaincodeMessage_ERROR:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, resp.ChaincodeEvent, errors.Errorf(<span class="string">"transaction returned with failure: %s"</span>, resp.Payload)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, errors.Errorf(<span class="string">"unexpected response type %d for transaction %s"</span>, resp.Type, txid)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="释放模拟器资源"><a href="#释放模拟器资源" class="headerlink" title="释放模拟器资源"></a>释放模拟器资源</h4><p>回想一下，在 <code>Endorser.SimulateProposal</code> 中，它获取了 交易模拟执行器 <code>TXSimulator</code>，这里面可是有很多资源的，如果不及时释放，在高 TPS 下，Peer压力上大，资源泄露，性能低下等问题会爆发出来。</p>
<p><code>txParams.TXSimulator.Done()</code> 用来释放资源，上文提到 <code>TxSimulator</code> 包含了 <code>QueryExecutor</code>, <code>lockBasedQueryExecutor</code> 实现了 <code>QueryExecutor</code>，也就是说，主要是释放查询操作相关的资源。</p>
<p>从源码可以看到会释放读写锁以及迭代器资源，如果不及时释放，后果果然不堪。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Done implements method in interface `ledger.QueryExecutor`</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *lockBasedQueryExecutor)</span> <span class="title">Done</span><span class="params">()</span></span> &#123;</span><br><span class="line">	logger.Debugf(<span class="string">"Done with transaction simulation / query execution [%s]"</span>, q.txid)</span><br><span class="line">	q.helper.done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *queryHelper)</span> <span class="title">done</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> h.doneInvoked &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">// 释放锁</span></span><br><span class="line">		h.txmgr.commitRWLock.RUnlock()</span><br><span class="line">		h.doneInvoked = <span class="literal">true</span></span><br><span class="line">		<span class="comment">// 释放迭代器</span></span><br><span class="line">		<span class="keyword">for</span> _, itr := <span class="keyword">range</span> h.itrs &#123;</span><br><span class="line">			itr.Close()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ESCC处理模拟执行结果"><a href="#ESCC处理模拟执行结果" class="headerlink" title="ESCC处理模拟执行结果"></a>ESCC处理模拟执行结果</h3><p>上文提到，模拟执行的 Response 会最终回到 Endorser，Endorser 会调用 ESCC 对结果进行背书，最终生成 <code>ProposalResponse</code>，我们看一下这个过程。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Endorser)</span> <span class="title">ProcessProposal</span><span class="params">(ctx context.Context, signedProp *pb.SignedProposal)</span> <span class="params">(*pb.ProposalResponse, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Pre-process, simulate</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> chainID == <span class="string">""</span> &#123;</span><br><span class="line">		pResp = &amp;pb.ProposalResponse&#123;Response: res&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Note: To endorseProposal(), we pass the released txsim. Hence, an error would occur if we try to use this txsim</span></span><br><span class="line">		pResp, err = e.endorseProposal(ctx, chainID, txid, signedProp, prop, res, simulationResult, ccevent, hdrExt.PayloadVisibility, hdrExt.ChaincodeId, txsim, cd)</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Endorser-endorseProposal"><a href="#Endorser-endorseProposal" class="headerlink" title="Endorser.endorseProposal"></a>Endorser.endorseProposal</h5><p>背书链码实现了可插拔，可以使用不同的ESCC，系统链码和用户链码的背书过程是不同的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// endorse the proposal by calling the ESCC</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Endorser)</span> <span class="title">endorseProposal</span><span class="params">(_ context.Context, chainID <span class="keyword">string</span>, txid <span class="keyword">string</span>, signedProp *pb.SignedProposal, proposal *pb.Proposal, response *pb.Response, simRes []<span class="keyword">byte</span>, event *pb.ChaincodeEvent, visibility []<span class="keyword">byte</span>, ccid *pb.ChaincodeID, txsim ledger.TxSimulator, cd ccprovider.ChaincodeDefinition)</span> <span class="params">(*pb.ProposalResponse, error)</span></span> &#123;</span><br><span class="line">	endorserLogger.Debugf(<span class="string">"[%s][%s] Entry chaincode: %s"</span>, chainID, shorttxid(txid), ccid)</span><br><span class="line">	<span class="keyword">defer</span> endorserLogger.Debugf(<span class="string">"[%s][%s] Exit"</span>, chainID, shorttxid(txid))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 系统链码和用户链码使用不同的ESCC</span></span><br><span class="line">	isSysCC := cd == <span class="literal">nil</span></span><br><span class="line">	<span class="comment">// 1) extract the name of the escc that is requested to endorse this chaincode</span></span><br><span class="line">	<span class="keyword">var</span> escc <span class="keyword">string</span></span><br><span class="line">	<span class="comment">// ie, "lscc" or system chaincodes</span></span><br><span class="line">	<span class="keyword">if</span> isSysCC &#123;</span><br><span class="line">		escc = <span class="string">"escc"</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		escc = cd.Endorsement()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	endorserLogger.Debugf(<span class="string">"[%s][%s] escc for chaincode %s is %s"</span>, chainID, shorttxid(txid), ccid, escc)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// marshalling event bytes</span></span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	<span class="keyword">var</span> eventBytes []<span class="keyword">byte</span></span><br><span class="line">	<span class="keyword">if</span> event != <span class="literal">nil</span> &#123;</span><br><span class="line">		eventBytes, err = putils.GetBytesChaincodeEvent(event)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">"failed to marshal event bytes"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// set version of executing chaincode</span></span><br><span class="line">	<span class="keyword">if</span> isSysCC &#123;</span><br><span class="line">		<span class="comment">// if we want to allow mixed fabric levels we should</span></span><br><span class="line">		<span class="comment">// set syscc version to ""</span></span><br><span class="line">		ccid.Version = util.GetSysCCVersion()</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		ccid.Version = cd.CCVersion()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建背书上下文信息</span></span><br><span class="line">	ctx := Context&#123;</span><br><span class="line">		PluginName:     escc, <span class="comment">// 插件名称</span></span><br><span class="line">		Channel:        chainID,</span><br><span class="line">		SignedProposal: signedProp,</span><br><span class="line">		ChaincodeID:    ccid,</span><br><span class="line">		Event:          eventBytes,</span><br><span class="line">		SimRes:         simRes,</span><br><span class="line">		Response:       response,</span><br><span class="line">		Visibility:     visibility,</span><br><span class="line">		Proposal:       proposal,</span><br><span class="line">		TxID:           txid,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用插件背书</span></span><br><span class="line">	<span class="keyword">return</span> e.s.EndorseWithPlugin(ctx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>背书插件实现下面的接口即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Plugin endorses a proposal response</span></span><br><span class="line"><span class="keyword">type</span> Plugin <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Endorse signs the given payload(ProposalResponsePayload bytes), and optionally mutates it.</span></span><br><span class="line">	<span class="comment">// Returns:</span></span><br><span class="line">	<span class="comment">// The Endorsement: A signature over the payload, and an identity that is used to verify the signature</span></span><br><span class="line">	<span class="comment">// The payload that was given as input (could be modified within this function)</span></span><br><span class="line">	<span class="comment">// Or error on failure</span></span><br><span class="line">	Endorse(payload []<span class="keyword">byte</span>, sp *peer.SignedProposal) (*peer.Endorsement, []<span class="keyword">byte</span>, error)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Init injects dependencies into the instance of the Plugin</span></span><br><span class="line">	Init(dependencies ...Dependency) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用插件背书，需获取插件实例，然后组装响应Payload，它包含了交易执行的多种结果，然后对Payload以及签名的Proposal背书。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EndorseWithPlugin endorses the response with a plugin</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pe *PluginEndorser)</span> <span class="title">EndorseWithPlugin</span><span class="params">(ctx Context)</span> <span class="params">(*pb.ProposalResponse, error)</span></span> &#123;</span><br><span class="line">	endorserLogger.Debug(<span class="string">"Entering endorsement for"</span>, ctx)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ctx.Response == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"response is nil"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ctx.Response.Status &gt;= shim.ERRORTHRESHOLD &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;pb.ProposalResponse&#123;Response: ctx.Response&#125;, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取插件</span></span><br><span class="line">	plugin, err := pe.getOrCreatePlugin(PluginName(ctx.PluginName), ctx.Channel)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		endorserLogger.Warning(<span class="string">"Endorsement with plugin for"</span>, ctx, <span class="string">" failed:"</span>, err)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.Errorf(<span class="string">"plugin with name %s could not be used: %v"</span>, ctx.PluginName, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 把模拟执行的信息组成生成背书响应Payload</span></span><br><span class="line">	prpBytes, err := proposalResponsePayloadFromContext(ctx)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		endorserLogger.Warning(<span class="string">"Endorsement with plugin for"</span>, ctx, <span class="string">" failed:"</span>, err)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">"failed assembling proposal response payload"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对Payload和签名的Proposal进行背书</span></span><br><span class="line">	endorsement, prpBytes, err := plugin.Endorse(prpBytes, ctx.SignedProposal)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		endorserLogger.Warning(<span class="string">"Endorsement with plugin for"</span>, ctx, <span class="string">" failed:"</span>, err)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.WithStack(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	resp := &amp;pb.ProposalResponse&#123;</span><br><span class="line">		Version:     <span class="number">1</span>,</span><br><span class="line">		Endorsement: endorsement,</span><br><span class="line">		Payload:     prpBytes,</span><br><span class="line">		Response:    ctx.Response,</span><br><span class="line">	&#125;</span><br><span class="line">	endorserLogger.Debug(<span class="string">"Exiting"</span>, ctx)</span><br><span class="line">	<span class="keyword">return</span> resp, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>系统提供的默认背书插件如下，<strong>本质是对交易执行结果和Proposal签名人信息进行签名。</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Endorse signs the given payload(ProposalResponsePayload bytes), and optionally mutates it.</span></span><br><span class="line"><span class="comment">// Returns:</span></span><br><span class="line"><span class="comment">// The Endorsement: A signature over the payload, and an identity that is used to verify the signature</span></span><br><span class="line"><span class="comment">// The payload that was given as input (could be modified within this function)</span></span><br><span class="line"><span class="comment">// Or error on failure</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *DefaultEndorsement)</span> <span class="title">Endorse</span><span class="params">(prpBytes []<span class="keyword">byte</span>, sp *peer.SignedProposal)</span> <span class="params">(*peer.Endorsement, []<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 提取Proposal的签名人</span></span><br><span class="line">	signer, err := e.SigningIdentityForRequest(sp)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, errors.New(fmt.Sprintf(<span class="string">"failed fetching signing identity: %v"</span>, err))</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 得到签名人身份</span></span><br><span class="line">	<span class="comment">// serialize the signing identity</span></span><br><span class="line">	identityBytes, err := signer.Serialize()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, errors.New(fmt.Sprintf(<span class="string">"could not serialize the signing identity: %v"</span>, err))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对Payload和身份进行签名</span></span><br><span class="line">	<span class="comment">// sign the concatenation of the proposal response and the serialized endorser identity with this endorser's key</span></span><br><span class="line">	signature, err := signer.Sign(<span class="built_in">append</span>(prpBytes, identityBytes...))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, errors.New(fmt.Sprintf(<span class="string">"could not sign the proposal response payload: %v"</span>, err))</span><br><span class="line">	&#125;</span><br><span class="line">	endorsement := &amp;peer.Endorsement&#123;Signature: signature, Endorser: identityBytes&#125;</span><br><span class="line">	<span class="keyword">return</span> endorsement, prpBytes, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="发送Response"><a href="#发送Response" class="headerlink" title="发送Response"></a>发送Response</h3><p><code>ProcessProposal</code> 会把 ProposalResponse 作为返回值，剩下的就交给 gRPC，发送给请求方了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文从宏观和源码层面，解读了交易提案背书涉及的数据结构，以及其主要背书流程，核心可以主要包含以下几步：</p>
<ol>
<li>检查Proposal</li>
<li>为交易创建模拟器，并调用模拟器模拟执行交易，生成执行结果</li>
<li>背书模块对执行结果和Proposal身份信息背书（签名），然后生成背书响应发送给客户端</li>
</ol>
<p>关于背书流程，本文未涉及的环节有：</p>
<ol>
<li>Proposal中各字段，层层递进的含义</li>
<li>模拟执行交易，是链码执行函数，并和Peer交互的过程，以及模拟执行的各种资源</li>
<li>2种插件化ESCC的实现</li>
</ol>
<p>后面的章节，会对相关源码实现做进一步分析。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2019/10/20/go-gc-1-history-and-priciple/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="区块链、Go语言">
      <meta itemprop="image" content="http://img.lessisbetter.site/gzh-qrcode-logo-small.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Go语言充电站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/10/20/go-gc-1-history-and-priciple/" class="post-title-link" itemprop="url">Go垃圾回收 1：历史和原理</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-10-20 11:13:11" itemprop="dateCreated datePublished" datetime="2019-10-20T11:13:11+08:00">2019-10-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-02-04 17:31:33" itemprop="dateModified" datetime="2020-02-04T17:31:33+08:00">2020-02-04</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>新老朋友好久不见，我是大彬。今天为大家带来的分享是Go语言垃圾回收，这篇文章筹划的了很久，因为GC也是很强大的一个话题，关于GC已经有很多篇论文还有书籍，想通过一篇文章来介绍Go语言的垃圾回收是困难的，所以决定分几篇文章来完成Go语言垃圾回收的相关话题：</p>
<ol>
<li>Go垃圾回收 1: 历史和原理</li>
<li>Go垃圾回收 2: GC主要流程</li>
<li>Go垃圾回收 3: 源码分析</li>
<li>Go垃圾回收 4: GC对性能的影响与优化</li>
</ol>
<p>虽然划分成了3部分，但每个子话题依然很大，依然难写，依然大而不全，每一篇文章都会有宏观与细节，这样的大而不全对于不了解GC的朋友是好事，即可以有宏观上的认识，又可以有重要细节的感知。</p>
<p>这篇文章就是第一个话题：Go垃圾回收历史和原理，希望各位有所收获。</p>
<h2 id="Go语言垃圾回收简介"><a href="#Go语言垃圾回收简介" class="headerlink" title="Go语言垃圾回收简介"></a>Go语言垃圾回收简介</h2><p><strong>垃圾</strong>指内存中不再使用的内存区域，自动发现与释放这种内存区域的过程就是垃圾回收。</p>
<p>内存资源是有限的，而垃圾回收可以让内存重复使用，并且减轻开发者对内存管理的负担，减少程序中的内存问题。</p>
<p>以下是从网上对垃圾回收的2个定义：</p>
<blockquote>
<ol>
<li>Garbage consists of objects that are dead.</li>
<li>In tracing garbage collection, the term is sometimes used to mean objects that are known to be dead; that is, objects that are unreachable.</li>
</ol>
</blockquote>
<h3 id="Go垃圾回收发展史"><a href="#Go垃圾回收发展史" class="headerlink" title="Go垃圾回收发展史"></a>Go垃圾回收发展史</h3><ul>
<li><a href="https://golang.org/doc/go1.1#performance" target="_blank" rel="noopener">go1.1</a>，提高效率和垃圾回收精确度。</li>
<li><a href="https://golang.org/doc/go1.3#garbage_collector" target="_blank" rel="noopener">go1.3</a>，提高了垃圾回收的精确度。</li>
<li><p><a href="https://golang.org/doc/go1.4#runtime" target="_blank" rel="noopener">go1.4</a>，之前版本的runtime大部分是使用C写的，这个版本大量使用Go进行了重写，让GC有了扫描stack的能力，进一步提高了垃圾回收的精确度。</p>
</li>
<li><p><a href="https://golang.org/doc/go1.5#gc" target="_blank" rel="noopener">go1.5</a>，目标是降低GC延迟，采用了<strong>并发标记和并发清除，三色标记</strong>，<strong>write barrier</strong>，以及实现了更好的<strong>回收器调度</strong>，设计<a href="https://docs.google.com/document/d/16Y4IsnNRCN43Mx0NZc5YXZLovrHvvLhK_h0KN8woTO4/edit" target="_blank" rel="noopener">文档1</a>，<a href="https://golang.org/s/go15gcpacing" target="_blank" rel="noopener">文档2</a>，以及这个版本的<a href="https://talks.golang.org/2015/go-gc.pdf" title="Go talk: go1.5" target="_blank" rel="noopener">Go talk</a>。</p>
</li>
<li><a href="https://golang.org/doc/go1.6" target="_blank" rel="noopener">go1.6</a>，小优化，当程序使用大量内存时，GC暂停时间有所降低。</li>
<li><a href="https://golang.org/doc/go1.7" target="_blank" rel="noopener">go1.7</a>，小优化，当程序有大量空闲goroutine，stack大小波动比较大时，GC暂停时间有显著降低。</li>
<li><a href="https://golang.org/doc/go1.8" target="_blank" rel="noopener">go1.8</a>，<strong>write barrier切换到hybrid write barrier</strong>，以消除STW中的re-scan，把STW的最差情况降低到<strong>50us</strong>，设计<a href="https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md" target="_blank" rel="noopener">文档</a>。</li>
<li><a href="https://golang.org/doc/go1.9#gc" target="_blank" rel="noopener">go1.9</a>，提升指标比较多，1）过去 <a href="https://golang.org/pkg/runtime/#GC" target="_blank" rel="noopener"><code>runtime.GC</code></a>, <a href="https://golang.org/pkg/runtime/debug/#SetGCPercent" target="_blank" rel="noopener"><code>debug.SetGCPercent</code></a>, 和 <a href="https://golang.org/pkg/runtime/debug/#FreeOSMemory" target="_blank" rel="noopener"><code>debug.FreeOSMemory</code></a>都不能触发<strong>并发GC</strong>，他们触发的GC都是阻塞的，go1.9可以了，变成了在垃圾回收之前只阻塞调用GC的goroutine。2）<a href="https://golang.org/pkg/runtime/debug/#SetGCPercent" target="_blank" rel="noopener"><code>debug.SetGCPercent</code></a>只在有必要的情况下才会触发GC。</li>
<li><a href="https://golang.org/doc/go1.10#performance" target="_blank" rel="noopener">go.1.10</a>，小优化，加速了GC，程序应当运行更快<em>一点点</em>。</li>
<li><a href="https://golang.org/doc/go1.12" target="_blank" rel="noopener">go1.12</a>，显著提高了堆内存存在大碎片情况下的sweeping性能，能够降低GC后立即分配内存的延迟。</li>
</ul>
<p>以上的历史版本信息都来自<a href="https://golang.org/doc/devel/release.html" target="_blank" rel="noopener">Go release归档</a>，有兴趣可以去翻阅一下。</p>
<h3 id="Go垃圾回收主要流程"><a href="#Go垃圾回收主要流程" class="headerlink" title="Go垃圾回收主要流程"></a>Go垃圾回收主要流程</h3><p>下面这幅图来自Go1.5的<a href="https://talks.golang.org/2015/go-gc.pdf" title="Go talk: go1.5" target="_blank" rel="noopener">go talk</a>，虽然go1.12的GC与go1.5有了许多改变，但总体的流程没有较大改变，并且也找不到官方更新的图了，所有就用这幅图介绍GC主流程。</p>
<p><img src="http://img.lessisbetter.site/2019-10-gc-go1.7.png" alt="Go GC"></p>
<p>Go 垃圾回收是分<strong>轮次</strong>的，每一轮GC都是从 Off 状态开始，如果不是 Off 状态，则代表上一轮GC还未完成，如果这时修改指针的值，是直接修改的。</p>
<p>Go 垃圾回收的主要分2部分，第1部分是扫描所有对象进行三色标记，标记为黑色、灰色和白色，标记完成后只有黑色和白色对象，黑色代表使用中对象，白色对象代表垃圾，灰色是白色过渡到黑色的中间临时状态，第2部分是清扫垃圾，即清理白色对象。</p>
<p>第1部分包含了栈扫描、标记和标记结束3个阶段。在栈扫描之前有2个重要的准备：STW（Stop The World）和开启<strong>写屏障</strong>（WB，Write Barrier）。</p>
<p>STW是为了暂停当前所有运行中的goroutine，进行一些准备工作，比如开启WB，把全局变量，以及每个goroutine中的 <strong>Root对象</strong> 收集起来，Root对象是标记扫描的源头，可以从Root对象依次索引到使用中的对象。</p>
<p><img src="http://img.lessisbetter.site/2019-10-obj-tree.png" alt="Objects Reference Tree"></p>
<blockquote>
<p>假设内存中的对象用圆圈表示，那根据对象的指向关系，所有的对象可以组成若干依赖树，每一个 Root对象 都是树根，按图索骥能找到每一个使用中的对象。但树根不一定是Root对象，也有可能是垃圾，使用灰色树根代表Root对象，白色树根代表垃圾。</p>
</blockquote>
<p>每个P都有一个 <code>mcache</code> ，每个 <code>mcache</code> 都有1个Span用来存放 TinyObject，TinyObject 都是不包含指针的对象，所以这些对象可以直接标记为黑色，然后关闭 STW。</p>
<blockquote>
<p>如果不了解mcache和Tiny对象，赶紧翻一下这篇文章<a href="https://mp.weixin.qq.com/s/3gGbJaeuvx4klqcv34hmmw" title="Go内存分配那些事，就这么简单!" target="_blank" rel="noopener">Go内存分配那些事</a>。</p>
</blockquote>
<p>每个P都有1个进行扫描标记的 goroutine，可以进行并发标记，关闭STW后，这些 goroutine 就变成可运行状态，接收 Go Scheduler 的调度，被调度时执行1轮标记，它负责第1部分任务：栈扫描、标记和标记结束。</p>
<p><strong>栈扫描阶段</strong>就是把前面搜集的Root对象找出来，标记为黑色，然后把它们引用的对象也找出来，标记为灰色，并且加入到<strong>gcWork队列</strong>，gcWork队列保存了灰色的对象，每个灰色的对象都是一个Work。</p>
<p>后面可以进入<strong>标记阶段</strong>，它是一个循环，不断的从gcWork队列中取出work，所指向的对象标记为黑色，该对象指向的对象标记为灰色，然后加入队列，直到队列为空。</p>
<p>然后进入<strong>标记结束阶段</strong>，再次开启STW，不同的版本处理方式是不同的。</p>
<p>在Go1.7的版本是<strong>Dijkstra写屏障</strong>，这个写屏障只监控堆上指针数据的变动，由于成本原因，没有监控栈上指针的变动，由于应用goroutine和GC的标记goroutine都在运行，当栈上的指针指向的对象变更为白色对象时，这个白色对象应当标记为黑色，需要再次扫描全局变量和栈，以免释放这类不该释放的对象。</p>
<p>在Go1.8及以后的版本引入了<strong>混合写屏障</strong>，这个写屏障依然不监控栈上指针的变动，但是它的策略，使得无需再次扫描栈和全局变量，但依然需要STW然后进行一些检查。</p>
<p>标记结束阶段的最后会关闭写屏障，然后关闭STW，唤醒熟睡已久的负责清扫垃圾的goroutine。</p>
<p><strong>清扫goroutine是应用启动后立即创建的一个后台goroutine</strong>，它会立刻进入睡眠，等待被唤醒，然后执行垃圾清理：把白色对象挨个清理掉，清扫goroutine和应用goroutine是并发进行的。清扫完成之后，它再次进入睡眠状态，等待下次被唤醒。</p>
<p>最后执行一些数据统计和状态修改的工作，并且设置好触发下一轮GC的阈值，把GC状态设置为Off。</p>
<p><strong>以上就是Go垃圾回收的主要流程，但和go1.12的源码稍微有一些不同</strong>，比如标记结束后，就开始设置各种状态数据以及把GC状态成了Off，在开启一轮GC时，会自动检测当前是否处于Off，如果不是Off，则当前goroutine会调用清扫函数，帮助清扫goroutine一起清扫span，实际的Go垃圾回收流程以源码为准。</p>
<p>主要流程是宏观一点的角度，接下去会扩散一下，介绍主要流程中提到的各种概念，比如三色标记、并发标记清理、STW、写屏障、辅助GC、GC persent。</p>
<h2 id="几类垃圾回收思想"><a href="#几类垃圾回收思想" class="headerlink" title="几类垃圾回收思想"></a>几类垃圾回收思想</h2><p>垃圾回收的研究已经存在了几十年，远在Go诞生之前，就存在了多种垃圾回收的思想，我们这里看几个跟Go垃圾回收相关的几个。</p>
<h3 id="Tracing-GC"><a href="#Tracing-GC" class="headerlink" title="Tracing GC"></a>Tracing GC</h3><p>WIKI介绍：<a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Tracing_garbage_collection</a></p>
<p>Tracing GC 是垃圾回收的一个大类，另外一个大类是<strong>引用计数</strong>，关于各种垃圾回收的类别可以看下这个系列文章<a href="https://liujiacai.net/blog/2018/08/04/incremental-gc/" target="_blank" rel="noopener">深入浅出垃圾回收</a>。</p>
<p>本文主要介绍Tracing GC的简要原理，我们首先看一下引用树的概念。把内存中所有的对象，都作为一个节点，对象A中的指针，指向了对象B，就存在从对象A指向对象B的一条边，对象B也可能指向了其他对象，那么根据指向关系就能生成一颗对象引用树。</p>
<p><img src="http://img.lessisbetter.site/2019-10-obj-ref-tree.png" alt="Objects Reference Tree"></p>
<p>把内存中所有的对象引用树组合起来，就组成了一幅图。</p>
<p><img src="http://img.lessisbetter.site/2019-10-mem-obj.png" alt="Memory Objects"></p>
<p>Tracing GC中有2类对象：</p>
<ol>
<li>可到达对象，即使用中对象</li>
<li>不可到达对象，即垃圾</li>
</ol>
<p>Tracing GC使用对象引用树找到所有可到达的对象，找到可到达对象有2个原则。</p>
<p><strong>原则1：被程序中调用栈，或者全局变量指向的对象是可到达对象。</strong></p>
<p><img src="http://img.lessisbetter.site/2019-10-obj-root.png" alt="Root Objects"></p>
<p><strong>原则2：被可到达对象指向的对象也是可到达对象。</strong></p>
<p>A是可到达的，并且B被A引用，所以B也是可到达的。</p>
<p><img src="http://img.lessisbetter.site/2019-10-obj-reachable.png" alt="Reachable Objects"></p>
<p>Tracing GC使用任何一种图论的遍历算法，都可以从<strong>Root对象</strong>，根据引用关系找到所有的可到达对象，并把他们做标记。Tracing GC扫描后，<strong>黑色</strong>对象为可到达对象，剩下的<strong>白色</strong>对象为不可到达对象。</p>
<blockquote>
<p>原生的 Tracing GC 只有黑色和白色2种颜色。</p>
</blockquote>
<p><img src="http://img.lessisbetter.site/2019-10-obj-traced.png" alt="Tracing GC"></p>
<h3 id="增量式垃圾回收思想"><a href="#增量式垃圾回收思想" class="headerlink" title="增量式垃圾回收思想"></a>增量式垃圾回收思想</h3><p>垃圾回收离不开STW，STW是Stop The World，指会暂停所有正在执行的用户线程/协程，进行垃圾回收的操作，STW为垃圾对象的扫描和标记提供了必要的条件。</p>
<p><strong>非增量式垃圾</strong>回收需要STW，在STW期间完成<strong>所有</strong>垃圾对象的标记，STW结束后慢慢的执行垃圾对象的清理。</p>
<p><strong>增量式垃圾回收</strong>也需要STW，在STW期间完成<strong>部分</strong>垃圾对象的标记，然后结束STW继续执行用户线程，一段时间后再次执行STW再标记<strong>部分</strong>垃圾对象，这个过程会多次重复执行，直到<strong>所有</strong>垃圾对象标记完成。</p>
<p><img src="http://img.lessisbetter.site/2019-10-increment-gc.png" alt="Increment GC"></p>
<p>GC算法有3大性能指标：吞吐量、最大暂停时间（最大的STW占时）、内存占用率。<strong>增量式垃圾回收不能提高吞吐量，但和非增量式垃圾回收相比，每次STW的时间更短，能够降低最大暂停时间</strong>，就是Go每个版本Release Note中提到的GC延迟、GC暂停时间。</p>
<p>下图是非增量式GC和增量式GC的对比：</p>
<p><img src="http://img.lessisbetter.site/2019-10-normal-vs-incremnt.png" alt="Normal V.S. Increment GC"></p>
<blockquote>
<p>以上图片来自 <a href="https://blog.heroku.com/incremental-gc" target="_blank" rel="noopener">Incremental Garbage Collection in Ruby 2.2</a> ，它也很好的介绍了增量式垃圾回收的思想。</p>
</blockquote>
<h3 id="并发垃圾回收"><a href="#并发垃圾回收" class="headerlink" title="并发垃圾回收"></a>并发垃圾回收</h3><p>减少最大暂停时间还有一种思路：并发垃圾回收，注意不是并行垃圾回收。</p>
<p><strong>并行垃圾回收</strong>是每个核上都跑垃圾回收的线程，同时进行垃圾回收，这期间为STW，会暂停用户线程的执行。</p>
<p><strong>并发垃圾回收</strong>是先STW找到所有的Root对象，然后结束STW，让垃圾标记线程和用户线程并发执行，垃圾标记完成后，再次开启STW，再次扫描和标记，以免释放使用中的内存。</p>
<p>并发垃圾回收和并行垃圾回收的重要区别就是不会持续暂停用户线程，并发垃圾回收也降低了STW的时间，达到了减少最大暂停时间的目的。</p>
<p><img src="https://dt-cdn.net/images/the-different-gc-algorithms-510-ed7afde0fb.png" alt=""></p>
<blockquote>
<p>图片来自 <a href="https://www.dynatrace.com/resources/ebooks/javabook/reduce-garbage-collection-pause-time/" target="_blank" rel="noopener">Reducing Garbage-Collection Pause Time</a> ，橙色线条为垃圾回收线程的运行，蓝色线条为用户线程。</p>
</blockquote>
<h2 id="Go垃圾回收主要原理"><a href="#Go垃圾回收主要原理" class="headerlink" title="Go垃圾回收主要原理"></a>Go垃圾回收主要原理</h2><h3 id="三色标记"><a href="#三色标记" class="headerlink" title="三色标记"></a>三色标记</h3><p><strong>为什么需要三色标记？</strong></p>
<p>三色标记的目的，主要是利用Tracing GC做增量式垃圾回收，降低最大暂停时间。原生Tracing GC只有黑色和白色，没有中间的状态，这就要求GC扫描过程必须一次性完成，得到最后的黑色和白色对象。在前面增量式GC中介绍到了，这种方式会存在较大的暂停时间。</p>
<p>三色标记增加了中间状态灰色，增量式GC运行过程中，应用线程的运行可能改变了对象引用树，只要让黑色对象不直接引用白色对象，GC就可以增量式的运行，减少停顿时间。</p>
<p><strong>什么是三色标记？</strong></p>
<p>三色标记，望文生义可以知道它由3种颜色组成：</p>
<ol>
<li>黑色 Black：表示对象是<strong>可达的</strong>，即使用中的对象，黑色是已经被扫描的对象。</li>
<li>灰色 Gary：表示<strong>被黑色对象直接引用的对象</strong>，但还没对它进行扫描。</li>
<li>白色 White：白色是对象的初始颜色，如果扫描完成后，对象依然还是白色的，说明此对象是垃圾对象。</li>
</ol>
<p>三色标记规则：黑色不能指向白色对象。即黑色可以指向灰色，灰色可以指向白色。</p>
<p>三色标记主要流程：</p>
<ol>
<li>初始所有对象被标记为白色。</li>
<li>寻找所有Root对象，比如被线程直接引用的对象，把Root对象标记为灰色。</li>
<li>把灰色对象标记为黑色，并它们引用的对象标记为灰色。</li>
<li>持续遍历每一个灰色对象，直到没有灰色对象。</li>
<li>剩余白色对象为垃圾对象。</li>
</ol>
<p>推荐一篇结合Go代码展示了三色标记的过程的优秀文章：<br><a href="https://making.pusher.com/golangs-real-time-gc-in-theory-and-practice/" target="_blank" rel="noopener">Golang’s Real-time GC in Theory and Practice</a> 。</p>
<p><strong>记录三色的方法简介</strong></p>
<p>Go1.12 使用位图和队列结合表示三种颜色状态：</p>
<ol>
<li>白色：位图没有标记被扫描。</li>
<li>灰色：位图被标记已扫描，并且对象在队列。</li>
<li>黑色：位图被标记已扫描，并且对象已从队列弹出。</li>
</ol>
<p>位图是全局的，表示了Heap中内存块是否被扫描，是否包含指针等。</p>
<p>队列有全局的一个和每个P有一个本地队列，扫描对象进行标记的过程，优先处理本P的队列，其思想与P的g本地队列和全局队列类似，减少资源竞争，提高并行化。</p>
<h3 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h3><p>我们结合一段用户代码介绍写屏障：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A.Next = B</span><br><span class="line">A.Next = &amp;C&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>三色标记的扫描线程是跟用户线程并发执行的，考虑这种情况：</p>
<p>用户线程执行完 <code>A.Next = B</code> 后，扫描线程把A标记为黑色，B标记为灰色，用户线程执行 <code>A.Next = &amp;C{}</code> ，C是新对象，被标记为白色，由于A已经被扫描，不会重复扫描，所以C不会被标记为灰色，造成了黑色对象指向白色对象的情况，这种三色标记中是不允许的，结果是C被认为是垃圾对象，最终被清扫掉，当访问C时会造成非法内存访问而Panic。</p>
<p>写屏障可以解决这个问题，当对象引用树发生改变时，即对象指向关系发生变化时，将被指向的对象标记为灰色，维护了三色标记的约束：黑色对象不能直接引用白色对象，这避免了使用中的对象被释放。</p>
<p>有写屏障后，用户线程执行 <code>A.Next = &amp;C{}</code> 后，写屏障把C标记为灰色。</p>
<h3 id="并发标记"><a href="#并发标记" class="headerlink" title="并发标记"></a>并发标记</h3><p>并发垃圾回收的主要思想上文已经介绍，Go的垃圾回收为每个P都分配了一个gcMarker协程，用于并发标记对象，这样有些P在标记对象，而有些P上继续运行用户协程。</p>
<p>Go的并发标记有4种运行模式，还没深入研究，这里举一个并发标记的场景：在goroutine的调度过程中，如果当前P上已经没有g可以执行，也偷不到g时，P就空闲下来了，这时候可以运行当前P的gcMarker协程。</p>
<h3 id="触发GC"><a href="#触发GC" class="headerlink" title="触发GC"></a>触发GC</h3><p>GC有3种触发方式：</p>
<ul>
<li><p>辅助GC</p>
<p>在分配内存时，会判断当前的Heap内存分配量是否达到了触发一轮GC的阈值（每轮GC完成后，该阈值会被动态设置），如果超过阈值，则启动一轮GC。</p>
</li>
<li><p>调用<code>runtime.GC()</code>强制启动一轮GC。</p>
</li>
<li><p><strong>sysmon</strong>是运行时的守护进程，当超过 <code>forcegcperiod</code> (2分钟)没有运行GC会启动一轮GC。</p>
</li>
</ul>
<h3 id="GC调节参数"><a href="#GC调节参数" class="headerlink" title="GC调节参数"></a>GC调节参数</h3><p>Go垃圾回收不像Java垃圾回收那样，有很多参数可供调节，Go为了保证使用GC的简洁性，只提供了一个参数<code>GOGC</code>。</p>
<p><code>GOGC</code>代表了占用中的内存增长比率，达到该比率时应当触发1次GC，该参数可以通过环境变量设置。</p>
<p>它的单位是百分比，取值范围并不是 [0, 100]，可以是1000，甚至2000，2000时代表2000%，即20倍。</p>
<p>假如当前heap占用内存为4MB，<code>GOGC = 75</code>，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 * (1+75%) = 7MB</span><br></pre></td></tr></table></figure>
<p>等heap占用内存大小达到7MB时会触发1轮GC。</p>
<p><code>GOGC</code>还有2个特殊值：</p>
<ol>
<li><code>&quot;off&quot;</code> : 代表关闭GC</li>
<li><code>0</code> : 代表持续进行垃圾回收，只用于调试 </li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了Go垃圾回收的发展史，以及Go垃圾回收的一些主要概念，是为掌握Go垃圾回收提供一个基础。下期文章将把本文提到的概念串起来，介绍Go垃圾回收的主要流程，下期见。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><p><a href="https://cloud.tencent.com/developer/article/1186944" target="_blank" rel="noopener">一个专家眼中的Go与Java垃圾回收算法大对比</a></p>
<p>这篇文章介绍了一些垃圾回收的标准，比如GC吞吐量、分配性能、暂停时间等等。</p>
</li>
<li><p><a href="https://www.infoq.cn/article/2017/03/garbage-collection-algorithm" target="_blank" rel="noopener">理解垃圾回收算法</a></p>
<p>这篇文章介绍了几种常见的垃圾机制，并使用gif展示回收过程。</p>
</li>
</ul>
<ul>
<li><p><a href="https://liujiacai.net/blog/2018/06/15/garbage-collection-intro/" target="_blank" rel="noopener">深入浅出垃圾回收（一）简介篇</a>，<a href="https://liujiacai.net/blog/2018/08/04/incremental-gc/" target="_blank" rel="noopener">深入浅出垃圾回收（三）增量式 GC</a>，<a href="https://liujiacai.net/blog/2018/08/18/generational-gc/" target="_blank" rel="noopener">深入浅出垃圾回收（四）分代式 GC</a></p>
<p>这个系列文章介绍了垃圾回收的概念、策略，以及三色标记等增量回收，以及分代收集。</p>
</li>
<li><p><a href="https://engineering.linecorp.com/en/blog/go-gc/" target="_blank" rel="noopener">Go gc</a></p>
<p>这篇文章做了Go和Java GC的简单对比表。看起来Go Gc比JVM GC少很多东西，但这其中解释了一些理由。</p>
<p>Go没有使用compaction来解决碎片问题，而是使用了TCMalloc来减缓碎片和优化分配。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>JAVA (JAVA8 HOTSPOT VM)</th>
<th>GO</th>
</tr>
</thead>
<tbody>
<tr>
<td>Collector</td>
<td>Several collectors (Serial, Parallel, CMS, G1)</td>
<td>CMS</td>
</tr>
<tr>
<td>Compaction</td>
<td>Compacts</td>
<td>Does not compact</td>
</tr>
<tr>
<td>Generational GC</td>
<td>Generational GC</td>
<td>Non-generational GC</td>
</tr>
<tr>
<td>Tuning parameters</td>
<td>Depends on the collector.Multiple parameters available.</td>
<td>Go垃圾回收 only</td>
</tr>
</tbody>
</table>
<ul>
<li><p><a href="https://juejin.im/post/5d2825bff265da1b6836e8d4" target="_blank" rel="noopener">【译】 Golang 中的垃圾回收（一）</a></p>
<p>这篇文章是William Kennedy垃圾回收系列文章的第一篇的译文，这个文章从宏观的角度介绍了垃圾回收的原理，把垃圾回收跟调度结合起来介绍，分析了Go GC是如何实现低延时的。并且详细介绍了并发标记、STW、并发清除等。</p>
</li>
<li><p><a href="https://i6448038.github.io/2019/03/04/golang-garbage-collector/" target="_blank" rel="noopener">图解Golang的GC算法</a></p>
<p>RyuGou用图的方式简述了三色标记法的标记清除过程以及写屏障。</p>
</li>
<li><p><a href="https://making.pusher.com/golangs-real-time-gc-in-theory-and-practice/" target="_blank" rel="noopener">Golang’s Real-time GC in Theory and Practice</a></p>
<p>这篇文章有一个非常棒的GC动画。</p>
</li>
<li><p><a href="https://blog.wangriyu.wang/2019/04-Golang-GC.html" target="_blank" rel="noopener">学习 Golang GC</a></p>
<p>这篇文章对GC的历史、原理、goroutine栈，Go GC历史，基础原理，触发时间都有介绍，是一篇大而全的文章，但每个部分确实也都不详细，值得再参考。</p>
</li>
<li><p><a href="http://legendtkl.com/2017/04/28/golang-gc/" target="_blank" rel="noopener">Golang 垃圾回收剖析</a></p>
</li>
</ul>
<ul>
<li><p><a href="https://www.cnblogs.com/zkweb/p/7880099.html" target="_blank" rel="noopener">Golang源码探索(三) GC的实现原理</a></p>
<p>Go垃圾回收的绝佳源码文章，图文并茂，从内存分配，讲到垃圾回收。</p>
</li>
</ul>
<ul>
<li><p><a href="https://talks.golang.org/2015/go-gc.pdf" target="_blank" rel="noopener">Go talk 2015: Go Gc: Latency Problem Solved</a></p>
<p>go1.5降低GC延迟的PPT介绍。</p>
</li>
<li><p><a href="https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md" target="_blank" rel="noopener">Proposal: Eliminate STW stack re-scanning</a></p>
<p>消除Go垃圾回收中第二次STW的re-scanning的提案。</p>
</li>
</ul>
<blockquote>
<ol>
<li>如果这篇文章对你有帮助，不妨关注下我的Github，有文章会收到通知。</li>
<li>本文作者：<a href="http://lessisbetter.site/about/">大彬</a></li>
<li>如果喜欢本文，随意转载，但请保留此原文链接：<a href="http://lessisbetter.site/2019/10/20/go-gc-1-history-and-priciple/">http://lessisbetter.site/2019/10/20/go-gc-1-history-and-priciple/</a></li>
</ol>
</blockquote>
<p><div style="color:#0096FF; text-align:center">关注公众号，获取最新Golang文章</div><br><img src="http://img.lessisbetter.site/blog-gzh.png" style="border:0" align="center"></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2019/09/20/fabric-event-source/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="区块链、Go语言">
      <meta itemprop="image" content="http://img.lessisbetter.site/gzh-qrcode-logo-small.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Go语言充电站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/20/fabric-event-source/" class="post-title-link" itemprop="url">Fabric 1.4源码解读 3：事件(Event)原理解读</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-09-20 19:46:41" itemprop="dateCreated datePublished" datetime="2019-09-20T19:46:41+08:00">2019-09-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-01-07 14:22:24" itemprop="dateModified" datetime="2020-01-07T14:22:24+08:00">2020-01-07</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Event是应用和Fabric网络交互的一种方式，应用可以通过<strong>SDK</strong>向<strong>Peer</strong>订阅某种类型的事件，当Peer发现事件发生时，可以把Event发送给应用，应用获取到通知信息。</p>
<h2 id="Event功能介绍"><a href="#Event功能介绍" class="headerlink" title="Event功能介绍"></a>Event功能介绍</h2><p>Event从来源上可以分为2类：</p>
<ol>
<li>链码容器发出的Event</li>
<li>Peer上账本变更发出的Event</li>
</ol>
<p><img src="http://img.lessisbetter.site/2019-09-sdk-event.png" alt="fabric event"></p>
<p><em>图源自<a href="https://medium.com/coinmonks/tutorial-chaincode-event-listener-on-hyperledger-fabric-java-sdk-557304f1fe28" target="_blank" rel="noopener">Tutorial Chaincode Event Listener on Hyperledger Fabric Java SDK</a></em></p>
<p>翻阅Node SDK和Go SDK的文档，发现SDK提供了4类事件：</p>
<ol>
<li>BlockEvent，可以用来监控被添加到账本上的区块。客户端需要Admin权限，这样才能读取完整的区块，每产生一个区块，它都会接收到通知。区块中有交易，交易中有chaincode event，所以可以通过BlockEvent获取其他事件。</li>
<li>FilteredBlockEvent，可以用来监控简要的区块信息，当不只关心区块包含了哪些交易，交易是否成功时，它非常实用，还可以降低网络负载。它包含区块的部分信息，所以被称为filtered，信息有channel ID，区块号，交易的validation code。</li>
<li>TransactionStatusEvent，可以用来监控某个交易在当前组织的peer何时完成。可以得到交易的validation code和交易所在区块。</li>
<li>ChaincodeEvent，用来监听Chaincode发出的事件，不同的链码可以自定义自己的事件，所以这个更具有个性化。包含了交易id、区块号、链码id、事件名称，事件内容。如果想要查看事件内容，客户端所使用的账号，必须是Admin权限。</li>
</ol>
<p>另外，订阅事件时可以指定开启和结束的区块号范围，如果开始的区块号已经产生，即区块已经写入账本，可以重放事件，更多信息可以看下面的文档。</p>
<p>关于Event的2篇重要文档，深深感觉Node SDK的文档，比Go SDK的文档丰富。</p>
<ul>
<li><a href="https://fabric-sdk-node.github.io/tutorial-channel-events.html" target="_blank" rel="noopener">Hyperledger Fabric SDK for node.js Tutorial: How to use the channel-based event service</a></li>
<li><a href="https://hyperledger-fabric-cn.readthedocs.io/zh/latest/peer_event_services.html" target="_blank" rel="noopener">Peer channel-based event services — hyperledger-fabricdocs master 文档</a></li>
</ul>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>上一节的介绍能够知道有哪些Event，各有什么作用，这一节介绍SDK和Peer是如何进行事件交互的。</p>
<p>SDK和Peer之间是通过gRPC通信的，gRPC的<a href="https://github.com/hyperledger/fabric/blob/release-1.4/protos/peer/events.proto" target="_blank" rel="noopener">protos的定义文件</a>4种message：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FilteredBlock，给FilteredBlockEvent使用</span><br><span class="line">FilteredTransaction，结合下一个，给FilteredTransactionEvent使用</span><br><span class="line">FilteredTransactionActions</span><br><span class="line">FilteredChaincodeAction，给ChaincodeEvent使用</span><br></pre></td></tr></table></figure>
<p>和1个Response，其中使用了oneof。</p>
<ul>
<li>status，指http status，成功的时候无需使用，错误的时候可以使用指明错误。</li>
<li>block，给BlockEvent使用</li>
<li>FilteredBlock，给另外3种事件使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// DeliverResponse</span><br><span class="line">message DeliverResponse &#123;</span><br><span class="line">    oneof Type &#123;</span><br><span class="line">        common.Status status = 1;</span><br><span class="line">        common.Block block = 2;</span><br><span class="line">        FilteredBlock filtered_block = 3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以及2个gRPC通信接口:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">service Deliver &#123;</span><br><span class="line">    // deliver first requires an Envelope of type ab.DELIVER_SEEK_INFO with</span><br><span class="line">    // Payload data as a marshaled orderer.SeekInfo message,</span><br><span class="line">    // then a stream of block replies is received</span><br><span class="line">    rpc Deliver (stream common.Envelope) returns (stream DeliverResponse) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    // deliver first requires an Envelope of type ab.DELIVER_SEEK_INFO with</span><br><span class="line">    // Payload data as a marshaled orderer.SeekInfo message,</span><br><span class="line">    // then a stream of **filtered** block replies is received</span><br><span class="line">    rpc DeliverFiltered (stream common.Envelope) returns (stream DeliverResponse) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>咦，4个Event，怎么只有2个接口？</p>
<p>配合下图，我们做一番讲解。</p>
<p><img src="http://img.lessisbetter.site/2019-11-fabric-events.png" alt="fabric sdk go event"></p>
<p>对于Peer而言，只有2中类型的订阅：</p>
<ol>
<li>BlockEvent，即完整的区块</li>
<li>FilteredBlockEvent，即不完整的区块，可以根据FilteredBlockEvent中的信息，生成FilteredTransactionEvent信息和ChainCodeEvent信息</li>
</ol>
<p>图中深蓝色和绿色的线分别代表BlockEvent和FilteredBlockEvent相关的数据流，BlockEvent使用的是Deliver函数，FilteredBlockEvent使用的是DeliverFiltered函数。</p>
<p>每一个事件订阅，都是一个gRPC连接，Peer会不断的从账本读区块，然后根据区块生成事件，发送给客户端。</p>
<p>Go SDK中实现了一个Dispatcher，就是提供这么一个中转的功能，对上层应用提供4中类型的事件，把4种事件注册请求转换为2种，调用DeliverClient把事件订阅请求发送给Peer，又把Peer发来的2种事件，转换为应用订阅的事件响应。</p>
<p>Peer启动时，启动gRPC服务后，会注册好DeliverServer接收事件订阅，然后调用deliverBlocks进入循环，在新区块产生后，会生成订阅的BlockEvent或FilteredBlockEvent，利用ResponseSender把事件发送给SDK。</p>
<h2 id="event-pb-go源码"><a href="#event-pb-go源码" class="headerlink" title="event.pb.go源码"></a>event.pb.go源码</h2><p>这就是根据<code>events.proto</code>生成的Go文件，负责创建gRPC通信的客户端和服务端，以及两边的消息发送。</p>
<p>主要关注下2个接口：</p>
<p><code>deliverClient</code>实现了<code>DeliverClient</code>，已经在该源文件实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DeliverClient is the client API for Deliver service.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.</span></span><br><span class="line"><span class="keyword">type</span> DeliverClient <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// deliver first requires an Envelope of type ab.DELIVER_SEEK_INFO with</span></span><br><span class="line">	<span class="comment">// Payload data as a marshaled orderer.SeekInfo message,</span></span><br><span class="line">	<span class="comment">// then a stream of block replies is received</span></span><br><span class="line">	Deliver(ctx context.Context, opts ...grpc.CallOption) (Deliver_DeliverClient, error)</span><br><span class="line">	<span class="comment">// deliver first requires an Envelope of type ab.DELIVER_SEEK_INFO with</span></span><br><span class="line">	<span class="comment">// Payload data as a marshaled orderer.SeekInfo message,</span></span><br><span class="line">	<span class="comment">// then a stream of **filtered** block replies is received</span></span><br><span class="line">	DeliverFiltered(ctx context.Context, opts ...grpc.CallOption) (Deliver_DeliverFilteredClient, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>DeliverServer</code>是服务端的接口，需要Peer实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DeliverServer is the server API for Deliver service.</span></span><br><span class="line"><span class="keyword">type</span> DeliverServer <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// deliver first requires an Envelope of type ab.DELIVER_SEEK_INFO with</span></span><br><span class="line">	<span class="comment">// Payload data as a marshaled orderer.SeekInfo message,</span></span><br><span class="line">	<span class="comment">// then a stream of block replies is received</span></span><br><span class="line">	Deliver(Deliver_DeliverServer) error</span><br><span class="line">	<span class="comment">// deliver first requires an Envelope of type ab.DELIVER_SEEK_INFO with</span></span><br><span class="line">	<span class="comment">// Payload data as a marshaled orderer.SeekInfo message,</span></span><br><span class="line">	<span class="comment">// then a stream of **filtered** block replies is received</span></span><br><span class="line">	DeliverFiltered(Deliver_DeliverFilteredServer) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Peer-event源码"><a href="#Peer-event源码" class="headerlink" title="Peer event源码"></a>Peer event源码</h2><p>Peer干了这么几件事：</p>
<ol>
<li>注册gRPC服务，即注册接受客户端发来的事件订阅的函数</li>
<li>gRPC收到消息，订阅相应事件注册处理函数</li>
<li>处理函数持续向客户端发送区块事件，直到结束</li>
</ol>
<h3 id="添加Deliver服务"><a href="#添加Deliver服务" class="headerlink" title="添加Deliver服务"></a>添加Deliver服务</h3><p><code>serve</code>是Peer启动后的运行的主函数，它会创建gRPC server，以及创建DeliverEvent server，并把它绑定到gRPC server上。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// peer/node/start.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serve</span><span class="params">(args []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 创建peer的gRPC server</span></span><br><span class="line">    peerServer, err := peer.NewPeerServer(listenAddr, serverConfig)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        logger.Fatalf(<span class="string">"Failed to create peer server (%s)"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 创建和启动基于gRPC的event deliver server</span></span><br><span class="line">    abServer := peer.NewDeliverEventsServer(mutualTLS, policyCheckerProvider, &amp;peer.DeliverChainManager&#123;&#125;, metricsProvider)</span><br><span class="line">    pb.RegisterDeliverServer(peerServer.Server(), abServer)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建DeliverEventsServer，实际是创建好处理事件订阅的handler。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core/peer/deliverevents.go</span></span><br><span class="line"><span class="comment">// NewDeliverEventsServer creates a peer.Deliver server to deliver block and</span></span><br><span class="line"><span class="comment">// filtered block events</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDeliverEventsServer</span><span class="params">(mutualTLS <span class="keyword">bool</span>, policyCheckerProvider PolicyCheckerProvider, chainManager deliver.ChainManager, metricsProvider metrics.Provider)</span> <span class="title">peer</span>.<span class="title">DeliverServer</span></span> &#123;</span><br><span class="line">	timeWindow := viper.GetDuration(<span class="string">"peer.authentication.timewindow"</span>)</span><br><span class="line">	<span class="keyword">if</span> timeWindow == <span class="number">0</span> &#123;</span><br><span class="line">		defaultTimeWindow := <span class="number">15</span> * time.Minute</span><br><span class="line">		logger.Warningf(<span class="string">"`peer.authentication.timewindow` not set; defaulting to %s"</span>, defaultTimeWindow)</span><br><span class="line">		timeWindow = defaultTimeWindow</span><br><span class="line">	&#125;</span><br><span class="line">	metrics := deliver.NewMetrics(metricsProvider)</span><br><span class="line">	<span class="keyword">return</span> &amp;server&#123;</span><br><span class="line">		<span class="comment">// 创建handler</span></span><br><span class="line">		dh:                    deliver.NewHandler(chainManager, timeWindow, mutualTLS, metrics),</span><br><span class="line">		policyCheckerProvider: policyCheckerProvider,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewHandler creates an implementation of the Handler interface.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewHandler</span><span class="params">(cm ChainManager, timeWindow time.Duration, mutualTLS <span class="keyword">bool</span>, metrics *Metrics)</span> *<span class="title">Handler</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Handler&#123;</span><br><span class="line">		ChainManager:     cm,</span><br><span class="line">		TimeWindow:       timeWindow,</span><br><span class="line">		BindingInspector: InspectorFunc(comm.NewBindingInspector(mutualTLS, ExtractChannelHeaderCertHash)),</span><br><span class="line">		Metrics:          metrics,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>server</code>实现了<code>DeliverServer</code>接口，当gRPC接收到事件注册时，就可以调用Deliver或者FilteredDeliver被调用时，就调用server的<code>DeliverFiltered</code>或者<code>Deliver</code>函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// server holds the dependencies necessary to create a deliver server</span><br><span class="line">type server struct &#123;</span><br><span class="line">	dh                    *deliver.Handler</span><br><span class="line">	policyCheckerProvider PolicyCheckerProvider</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接收事件订阅"><a href="#接收事件订阅" class="headerlink" title="接收事件订阅"></a>接收事件订阅</h3><p>BlockEvent的注册和事件处理主要流程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server.Deliver -&gt; Handler.Handle -&gt;</span><br><span class="line">deliverBlocks -&gt; SendBlockResponse -&gt; blockResponseSender.SendBlockResponse -&gt; gRPC生成的server Send函数</span><br></pre></td></tr></table></figure>
<p>FilteredBlockEvent的注册和事件处理主要流程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server.DeliverFiltered -&gt; Handler.Handle -&gt;</span><br><span class="line">deliverBlocks -&gt; SendBlockResponse -&gt; filteredBlockResponseSender.SendBlockResponseg -&gt; RPC生成的server Send函数</span><br></pre></td></tr></table></figure>
<p>它们2个流程是类似的，下面就以BlockEvent的流程介绍。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Deliver sends a stream of blocks to a client after commitment</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span> <span class="title">Deliver</span><span class="params">(srv peer.Deliver_DeliverServer)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	logger.Debugf(<span class="string">"Starting new Deliver handler"</span>)</span><br><span class="line">	<span class="keyword">defer</span> dumpStacktraceOnPanic()</span><br><span class="line">	<span class="comment">// getting policy checker based on resources.Event_Block resource name</span></span><br><span class="line">	deliverServer := &amp;deliver.Server&#123;</span><br><span class="line">		PolicyChecker: s.policyCheckerProvider(resources.Event_Block),</span><br><span class="line">		Receiver:      srv,</span><br><span class="line">		<span class="comment">// 创建了sender</span></span><br><span class="line">		ResponseSender: &amp;blockResponseSender&#123;</span><br><span class="line">			Deliver_DeliverServer: srv,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s.dh.Handle(srv.Context(), deliverServer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handle receives incoming deliver requests.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Handler)</span> <span class="title">Handle</span><span class="params">(ctx context.Context, srv *Server)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	addr := util.ExtractRemoteAddress(ctx)</span><br><span class="line">	logger.Debugf(<span class="string">"Starting new deliver loop for %s"</span>, addr)</span><br><span class="line">	h.Metrics.StreamsOpened.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">defer</span> h.Metrics.StreamsClosed.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		logger.Debugf(<span class="string">"Attempting to read seek info message from %s"</span>, addr)</span><br><span class="line">		envelope, err := srv.Recv()</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			logger.Debugf(<span class="string">"Received EOF from %s, hangup"</span>, addr)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			logger.Warningf(<span class="string">"Error reading from %s: %s"</span>, addr, err)</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 主体</span></span><br><span class="line">		status, err := h.deliverBlocks(ctx, srv, envelope)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		err = srv.SendStatusResponse(status)</span><br><span class="line">		<span class="keyword">if</span> status != cb.Status_SUCCESS &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			logger.Warningf(<span class="string">"Error sending to %s: %s"</span>, addr, err)</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		logger.Debugf(<span class="string">"Waiting for new SeekInfo from %s"</span>, addr)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>deliverBlocks</code>的主要作用就是不停的获取区块，然后调用sender发送事件，其中还包含了事件订阅信息的获取，错误处理等。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Handler)</span> <span class="title">deliverBlocks</span><span class="params">(ctx context.Context, srv *Server, envelope *cb.Envelope)</span> <span class="params">(status cb.Status, err error)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">var</span> block *cb.Block</span><br><span class="line">		<span class="keyword">var</span> status cb.Status</span><br><span class="line"></span><br><span class="line">		iterCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="comment">// 获取下一个区块，当账本Append Block时，就可以拿到要写入到账本的区块</span></span><br><span class="line">			block, status = cursor.Next()</span><br><span class="line">			<span class="built_in">close</span>(iterCh)</span><br><span class="line">		&#125;()</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// 发送区块</span></span><br><span class="line">		<span class="keyword">if</span> err := srv.SendBlockResponse(block); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			logger.Warningf(<span class="string">"[channel: %s] Error sending to %s: %s"</span>, chdr.ChannelId, addr, err)</span><br><span class="line">			<span class="keyword">return</span> cb.Status_INTERNAL_SERVER_ERROR, err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		h.Metrics.BlocksSent.With(labels...).Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 停止判断</span></span><br><span class="line">		<span class="keyword">if</span> stopNum == block.Header.Number &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Iterator</code>接口用来获取区块.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Iterator is useful for a chain Reader to stream blocks as they are created</span></span><br><span class="line"><span class="keyword">type</span> Iterator <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Next blocks until there is a new block available, or returns an error if</span></span><br><span class="line">	<span class="comment">// the next block is no longer retrievable</span></span><br><span class="line">	Next() (*cb.Block, cb.Status)</span><br><span class="line">	<span class="comment">// Close releases resources acquired by the Iterator</span></span><br><span class="line">	Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Fabric有3种类型的账本：ram、json和file，它们都实现了这个接口，这里主要是为了辅助解释事件机制，我们看一个最简单的：ram的实现。</p>
<p><code>Next()</code>拿到的区块是从<code>simpleList.SetNext()</code>存进去的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Next blocks until there is a new block available, or returns an error if the</span></span><br><span class="line"><span class="comment">// next block is no longer retrievable</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cu *cursor)</span> <span class="title">Next</span><span class="params">()</span> <span class="params">(*cb.Block, cb.Status)</span></span> &#123;</span><br><span class="line">	<span class="comment">// This only loops once, as signal reading indicates non-nil next</span></span><br><span class="line">	<span class="comment">// 实际只执行1次</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 拿到区块</span></span><br><span class="line">		next := cu.list.getNext()</span><br><span class="line">		<span class="keyword">if</span> next != <span class="literal">nil</span> &#123;</span><br><span class="line">			cu.list = next</span><br><span class="line">			<span class="keyword">return</span> cu.list.block, cb.Status_SUCCESS</span><br><span class="line">		&#125;</span><br><span class="line">		&lt;-cu.list.signal</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *simpleList)</span> <span class="title">getNext</span><span class="params">()</span> *<span class="title">simpleList</span></span> &#123;</span><br><span class="line">	s.lock.RLock()</span><br><span class="line">	<span class="keyword">defer</span> s.lock.RUnlock()</span><br><span class="line">	<span class="keyword">return</span> s.next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *simpleList)</span> <span class="title">setNext</span><span class="params">(n *simpleList)</span></span> &#123;</span><br><span class="line">	s.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> s.lock.Unlock()</span><br><span class="line">	s.next = n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Append()</code>是账本对外提供的接口，当要把区块追加到账本时，会调用此函数，该函数会调用<code>setNext()</code>设置待追加的区块。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Append appends a new block to the ledger</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rl *ramLedger)</span> <span class="title">Append</span><span class="params">(block *cb.Block)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	rl.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> rl.lock.Unlock()</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	rl.appendBlock(block)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rl *ramLedger)</span> <span class="title">appendBlock</span><span class="params">(block *cb.Block)</span></span> &#123;</span><br><span class="line">	next := &amp;simpleList&#123;</span><br><span class="line">		signal: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">		block:  block,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 设置最新的区块</span></span><br><span class="line">	rl.newest.setNext(next)</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="发送事件消息"><a href="#发送事件消息" class="headerlink" title="发送事件消息"></a>发送事件消息</h3><p><code>blockResponseSender.SendBlockResponse</code>是BlockEvent的事件发送函数，实际就是调用gRPC生成的函数。</p>
<p><code>blockResponseSender</code>是在<code>server.Deliver</code>中创建的，它实际就是<code>peer.Deliver_DeliverServer</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// blockResponseSender structure used to send block responses</span></span><br><span class="line"><span class="keyword">type</span> blockResponseSender <span class="keyword">struct</span> &#123;</span><br><span class="line">	peer.Deliver_DeliverServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SendBlockResponse generates deliver response with block message</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(brs *blockResponseSender)</span> <span class="title">SendBlockResponse</span><span class="params">(block *common.Block)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	response := &amp;peer.DeliverResponse&#123;</span><br><span class="line">		Type: &amp;peer.DeliverResponse_Block&#123;Block: block&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> brs.Send(response)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Go-SDK源码"><a href="#Go-SDK源码" class="headerlink" title="Go SDK源码"></a>Go SDK源码</h2><p>社区正在重构fabric-sdk-go，所以这里不着重介绍sdk的源码了，提醒几个重要的点，可能以后还有。</p>
<p><code>Deliver</code>和<code>DeliverFiltered</code>被封装成了2个全局函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">	// Deliver creates a Deliver stream</span><br><span class="line">	Deliver = func(client pb.DeliverClient) (deliverStream, error) &#123;</span><br><span class="line">		return client.Deliver(context.Background())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// DeliverFiltered creates a DeliverFiltered stream</span><br><span class="line">	DeliverFiltered = func(client pb.DeliverClient) (deliverStream, error) &#123;</span><br><span class="line">		return client.DeliverFiltered(context.Background())</span><br><span class="line">	&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>它们会被调用，进一步封装成provider，provider会为dispatch服务：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// deliverProvider is the connection provider used for connecting to the Deliver service</span></span><br><span class="line"><span class="keyword">var</span> deliverProvider = <span class="function"><span class="keyword">func</span><span class="params">(context fabcontext.Client, chConfig fab.ChannelCfg, peer fab.Peer)</span> <span class="params">(api.Connection, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> peer == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"Peer is nil"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	eventEndpoint, ok := peer.(api.EventEndpoint)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"peer is not an EventEndpoint"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> deliverconn.New(context, chConfig, deliverconn.Deliver, peer.URL(), eventEndpoint.Opts()...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h3><p><code>Dispatcher</code>会保存BlockEvent和FilteredBlockEvent的注册，以及用2个map<code>txRegistrations</code>和<code>ccRegistrations</code>保存交易和Chaincode Event的注册，<code>handlers</code>是各种注册事件的处理函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dispatcher is responsible for handling all events, including connection and registration events originating from the client,</span></span><br><span class="line"><span class="comment">// and events originating from the channel event service. All events are processed in a single Go routine</span></span><br><span class="line"><span class="comment">// in order to avoid any race conditions and to ensure that events are processed in the order in which they are received.</span></span><br><span class="line"><span class="comment">// This also avoids the need for synchronization.</span></span><br><span class="line"><span class="comment">// The lastBlockNum member MUST be first to ensure it stays 64-bit aligned on 32-bit machines.</span></span><br><span class="line"><span class="keyword">type</span> Dispatcher <span class="keyword">struct</span> &#123;</span><br><span class="line">	lastBlockNum <span class="keyword">uint64</span> <span class="comment">// Must be first, do not move</span></span><br><span class="line">	params</span><br><span class="line">	updateLastBlockInfoOnly    <span class="keyword">bool</span></span><br><span class="line">	state                      <span class="keyword">int32</span></span><br><span class="line">	eventch                    <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	blockRegistrations         []*BlockReg</span><br><span class="line">	filteredBlockRegistrations []*FilteredBlockReg</span><br><span class="line">	handlers                   <span class="keyword">map</span>[reflect.Type]Handler</span><br><span class="line">	txRegistrations            <span class="keyword">map</span>[<span class="keyword">string</span>]*TxStatusReg</span><br><span class="line">	ccRegistrations            <span class="keyword">map</span>[<span class="keyword">string</span>]*ChaincodeReg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注册事件"><a href="#注册事件" class="headerlink" title="注册事件"></a>注册事件</h3><p>这是Dispatcher的事件注册函数，在它眼里，不止有4个事件：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RegisterHandler registers an event handler</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ed *Dispatcher)</span> <span class="title">RegisterHandler</span><span class="params">(t <span class="keyword">interface</span>&#123;&#125;, h Handler)</span></span> &#123;</span><br><span class="line">	htype := reflect.TypeOf(t)</span><br><span class="line">	<span class="keyword">if</span> _, ok := ed.handlers[htype]; !ok &#123;</span><br><span class="line">		logger.Debugf(<span class="string">"Registering handler for %s on dispatcher %T"</span>, htype, ed)</span><br><span class="line">		ed.handlers[htype] = h</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		logger.Debugf(<span class="string">"Cannot register handler %s on dispatcher %T since it's already registered"</span>, htype, ed)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注册各注册事件的处理函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RegisterHandlers registers all of the handlers by event type</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ed *Dispatcher)</span> <span class="title">RegisterHandlers</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ed.RegisterHandler(&amp;RegisterChaincodeEvent&#123;&#125;, ed.handleRegisterCCEvent)</span><br><span class="line">	ed.RegisterHandler(&amp;RegisterTxStatusEvent&#123;&#125;, ed.handleRegisterTxStatusEvent)</span><br><span class="line">	ed.RegisterHandler(&amp;RegisterBlockEvent&#123;&#125;, ed.handleRegisterBlockEvent)</span><br><span class="line">	ed.RegisterHandler(&amp;RegisterFilteredBlockEvent&#123;&#125;, ed.handleRegisterFilteredBlockEvent)</span><br><span class="line">	ed.RegisterHandler(&amp;UnregisterEvent&#123;&#125;, ed.handleUnregisterEvent)</span><br><span class="line">	ed.RegisterHandler(&amp;StopEvent&#123;&#125;, ed.HandleStopEvent)</span><br><span class="line">	ed.RegisterHandler(&amp;TransferEvent&#123;&#125;, ed.HandleTransferEvent)</span><br><span class="line">	ed.RegisterHandler(&amp;StopAndTransferEvent&#123;&#125;, ed.HandleStopAndTransferEvent)</span><br><span class="line">	ed.RegisterHandler(&amp;RegistrationInfoEvent&#123;&#125;, ed.handleRegistrationInfoEvent)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The following events are used for testing only</span></span><br><span class="line">	ed.RegisterHandler(&amp;fab.BlockEvent&#123;&#125;, ed.handleBlockEvent)</span><br><span class="line">	ed.RegisterHandler(&amp;fab.FilteredBlockEvent&#123;&#125;, ed.handleFilteredBlockEvent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接收Peer事件"><a href="#接收Peer事件" class="headerlink" title="接收Peer事件"></a>接收Peer事件</h3><p><code>handleEvent</code>用来处理来自Peer的事件，不同的类型调用不同的handler。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ed *Dispatcher)</span> <span class="title">handleEvent</span><span class="params">(e esdispatcher.Event)</span></span> &#123;</span><br><span class="line">	delevent := e.(*connection.Event)</span><br><span class="line">	evt := delevent.Event.(*pb.DeliverResponse)</span><br><span class="line">	<span class="keyword">switch</span> response := evt.Type.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> *pb.DeliverResponse_Status:</span><br><span class="line">		ed.handleDeliverResponseStatus(response)</span><br><span class="line">	<span class="keyword">case</span> *pb.DeliverResponse_Block:</span><br><span class="line">		ed.HandleBlock(response.Block, delevent.SourceURL)</span><br><span class="line">	<span class="keyword">case</span> *pb.DeliverResponse_FilteredBlock:</span><br><span class="line">		ed.HandleFilteredBlock(response.FilteredBlock, delevent.SourceURL)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		logger.Errorf(<span class="string">"handler not found for deliver response type %T"</span>, response)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>HandleBlock</code>把Event封装是BlockEvent退给应用。可以看到BlockEvent也会发布FilteredBlockEvent。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HandleBlock handles a block event</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ed *Dispatcher)</span> <span class="title">HandleBlock</span><span class="params">(block *cb.Block, sourceURL <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	logger.Debugf(<span class="string">"Handling block event - Block #%d"</span>, block.Header.Number)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := ed.updateLastBlockNum(block.Header.Number); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		logger.Error(err.Error())</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ed.updateLastBlockInfoOnly &#123;</span><br><span class="line">		ed.updateLastBlockInfoOnly = <span class="literal">false</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	logger.Debug(<span class="string">"Publishing block event..."</span>)</span><br><span class="line">	ed.publishBlockEvents(block, sourceURL)</span><br><span class="line">	ed.publishFilteredBlockEvents(toFilteredBlock(block), sourceURL)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ed *Dispatcher)</span> <span class="title">publishBlockEvents</span><span class="params">(block *cb.Block, sourceURL <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, reg := <span class="keyword">range</span> ed.blockRegistrations &#123;</span><br><span class="line">		<span class="keyword">if</span> !reg.Filter(block) &#123;</span><br><span class="line">			logger.Debugf(<span class="string">"Not sending block event for block #%d since it was filtered out."</span>, block.Header.Number)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ed.eventConsumerTimeout &lt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> reg.Eventch &lt;- NewBlockEvent(block, sourceURL):</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				logger.Warn(<span class="string">"Unable to send to block event channel."</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> ed.eventConsumerTimeout == <span class="number">0</span> &#123;</span><br><span class="line">			reg.Eventch &lt;- NewBlockEvent(block, sourceURL)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> reg.Eventch &lt;- NewBlockEvent(block, sourceURL):</span><br><span class="line">			<span class="keyword">case</span> &lt;-time.After(ed.eventConsumerTimeout):</span><br><span class="line">				logger.Warn(<span class="string">"Timed out sending block event."</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FilteredBlockEvent能解析出TransactionEvent和ChaincodeEvent：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ed *Dispatcher)</span> <span class="title">publishFilteredBlockEvents</span><span class="params">(fblock *pb.FilteredBlock, sourceURL <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> fblock == <span class="literal">nil</span> &#123;</span><br><span class="line">		logger.Warn(<span class="string">"Filtered block is nil. Event will not be published"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	logger.Debugf(<span class="string">"Publishing filtered block event: %#v"</span>, fblock)</span><br><span class="line"></span><br><span class="line">	checkFilteredBlockRegistrations(ed, fblock, sourceURL)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, tx := <span class="keyword">range</span> fblock.FilteredTransactions &#123;</span><br><span class="line">		<span class="comment">// 发布交易订阅</span></span><br><span class="line">		ed.publishTxStatusEvents(tx, fblock.Number, sourceURL)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Only send a chaincode event if the transaction has committed</span></span><br><span class="line">		<span class="keyword">if</span> tx.TxValidationCode == pb.TxValidationCode_VALID &#123;</span><br><span class="line">			txActions := tx.GetTransactionActions()</span><br><span class="line">			<span class="keyword">if</span> txActions == <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(txActions.ChaincodeActions) == <span class="number">0</span> &#123;</span><br><span class="line">				logger.Debugf(<span class="string">"No chaincode action found for TxID[%s], block[%d], source URL[%s]"</span>, tx.Txid, fblock.Number, sourceURL)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> _, action := <span class="keyword">range</span> txActions.ChaincodeActions &#123;</span><br><span class="line">				<span class="keyword">if</span> action.ChaincodeEvent != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="comment">// 发布chaincode event订阅</span></span><br><span class="line">					ed.publishCCEvents(action.ChaincodeEvent, fblock.Number, sourceURL)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			logger.Debugf(<span class="string">"Cannot publish CCEvents for block[%d] and source URL[%s] since Tx Validation Code[%d] is not valid"</span>, fblock.Number, sourceURL, tx.TxValidationCode)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ed *Dispatcher)</span> <span class="title">publishTxStatusEvents</span><span class="params">(tx *pb.FilteredTransaction, blockNum <span class="keyword">uint64</span>, sourceURL <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	logger.Debugf(<span class="string">"Publishing Tx Status event for TxID [%s]..."</span>, tx.Txid)</span><br><span class="line">	<span class="keyword">if</span> reg, ok := ed.txRegistrations[tx.Txid]; ok &#123;</span><br><span class="line">		logger.Debugf(<span class="string">"Sending Tx Status event for TxID [%s] to registrant..."</span>, tx.Txid)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ed.eventConsumerTimeout &lt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> reg.Eventch &lt;- NewTxStatusEvent(tx.Txid, tx.TxValidationCode, blockNum, sourceURL):</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				logger.Warn(<span class="string">"Unable to send to Tx Status event channel."</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> ed.eventConsumerTimeout == <span class="number">0</span> &#123;</span><br><span class="line">			reg.Eventch &lt;- NewTxStatusEvent(tx.Txid, tx.TxValidationCode, blockNum, sourceURL)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> reg.Eventch &lt;- NewTxStatusEvent(tx.Txid, tx.TxValidationCode, blockNum, sourceURL):</span><br><span class="line">			<span class="keyword">case</span> &lt;-time.After(ed.eventConsumerTimeout):</span><br><span class="line">				logger.Warn(<span class="string">"Timed out sending Tx Status event."</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ed *Dispatcher)</span> <span class="title">publishCCEvents</span><span class="params">(ccEvent *pb.ChaincodeEvent, blockNum <span class="keyword">uint64</span>, sourceURL <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, reg := <span class="keyword">range</span> ed.ccRegistrations &#123;</span><br><span class="line">		logger.Debugf(<span class="string">"Matching CCEvent[%s,%s] against Reg[%s,%s] ..."</span>, ccEvent.ChaincodeId, ccEvent.EventName, reg.ChaincodeID, reg.EventFilter)</span><br><span class="line">		<span class="keyword">if</span> reg.ChaincodeID == ccEvent.ChaincodeId &amp;&amp; reg.EventRegExp.MatchString(ccEvent.EventName) &#123;</span><br><span class="line">			logger.Debugf(<span class="string">"... matched CCEvent[%s,%s] against Reg[%s,%s]"</span>, ccEvent.ChaincodeId, ccEvent.EventName, reg.ChaincodeID, reg.EventFilter)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> ed.eventConsumerTimeout &lt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> reg.Eventch &lt;- NewChaincodeEvent(ccEvent.ChaincodeId, ccEvent.EventName, ccEvent.TxId, ccEvent.Payload, blockNum, sourceURL):</span><br><span class="line">				<span class="keyword">default</span>:</span><br><span class="line">					logger.Warn(<span class="string">"Unable to send to CC event channel."</span>)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> ed.eventConsumerTimeout == <span class="number">0</span> &#123;</span><br><span class="line">				reg.Eventch &lt;- NewChaincodeEvent(ccEvent.ChaincodeId, ccEvent.EventName, ccEvent.TxId, ccEvent.Payload, blockNum, sourceURL)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> reg.Eventch &lt;- NewChaincodeEvent(ccEvent.ChaincodeId, ccEvent.EventName, ccEvent.TxId, ccEvent.Payload, blockNum, sourceURL):</span><br><span class="line">				<span class="keyword">case</span> &lt;-time.After(ed.eventConsumerTimeout):</span><br><span class="line">					logger.Warn(<span class="string">"Timed out sending CC event."</span>)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了：</p>
<ol>
<li>Peer支持的2类Even，</li>
<li>Peer是如何支持事件订阅，和发送事件的，</li>
<li>SDK支持的4类Event，这4类Event和Peer的2类Event的关系</li>
<li>SDK和Peer之间的gRPC通信</li>
</ol>
<p>更多SDK事件的使用，请参考<a href="https://godoc.org/github.com/hyperledger/fabric-sdk-go/pkg/client/event#New" target="_blank" rel="noopener">文档</a>。</p>
<p>Fabric事件介绍的[官方文档(<a href="https://stone-fabric.readthedocs.io/zh/latest/peer_event_services.html)。" target="_blank" rel="noopener">https://stone-fabric.readthedocs.io/zh/latest/peer_event_services.html)。</a></p>
<p>Fabric在examples中还提供了一个<a href="https://github.com/hyperledger/fabric/tree/release-1.4/examples/events/eventsclient" target="_blank" rel="noopener">eventclient</a>样例，看这个样例更有助于理解Fabric event的原理，以及是如何交互的。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2019/09/11/fabric-deploy-scc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="区块链、Go语言">
      <meta itemprop="image" content="http://img.lessisbetter.site/gzh-qrcode-logo-small.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Go语言充电站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/11/fabric-deploy-scc/" class="post-title-link" itemprop="url">Fabric 1.4源码解读 2：系统链码SCC是如何部署的</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-09-11 11:37:27 / 修改时间：14:28:37" itemprop="dateCreated datePublished" datetime="2019-09-11T11:37:27+08:00">2019-09-11</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一份Peer节点启动的INFO级别日志如下，可以发现：</p>
<ol>
<li>先注册了scc目录下的lscc, cscc, qscc，未注册chaincode目录下的lifecycle</li>
<li>然后又依次部署了上述scc。</li>
</ol>
<p>本文的目的就是梳理出，系统链码的部署流程，这是peer节点提供背书、链码管理、配置、查询等功能的基础。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">2019-09-09 07:52:09.409 UTC [gossip.gossip] start -&gt; INFO 013 Gossip instance peer1.org1.example.com:8051 started</span><br><span class="line">2019-09-09 07:52:09.418 UTC [sccapi] deploySysCC -&gt; INFO 014 system chaincode lscc/(github.com/hyperledger/fabric/core/scc/lscc) deployed</span><br><span class="line">2019-09-09 07:52:09.420 UTC [cscc] Init -&gt; INFO 015 Init CSCC</span><br><span class="line">2019-09-09 07:52:09.422 UTC [sccapi] deploySysCC -&gt; INFO 016 system chaincode cscc/(github.com/hyperledger/fabric/core/scc/cscc) deployed</span><br><span class="line">2019-09-09 07:52:09.424 UTC [qscc] Init -&gt; INFO 017 Init QSCC</span><br><span class="line">2019-09-09 07:52:09.424 UTC [sccapi] deploySysCC -&gt; INFO 018 system chaincode qscc/(github.com/hyperledger/fabric/core/scc/qscc) deployed</span><br><span class="line">2019-09-09 07:52:09.425 UTC [sccapi] deploySysCC -&gt; INFO 019 system chaincode (+lifecycle,github.com/hyperledger/fabric/core/chaincode/lifecycle) disabled</span><br><span class="line">...</span><br><span class="line">2019-09-09 07:52:14.386 UTC [sccapi] deploySysCC -&gt; INFO 031 system chaincode lscc/mychannel(github.com/hyperledger/fabric/core/scc/lscc) deployed</span><br><span class="line">2019-09-09 07:52:14.386 UTC [cscc] Init -&gt; INFO 032 Init CSCC</span><br><span class="line">2019-09-09 07:52:14.386 UTC [sccapi] deploySysCC -&gt; INFO 033 system chaincode cscc/mychannel(github.com/hyperledger/fabric/core/scc/cscc) deployed</span><br><span class="line">2019-09-09 07:52:14.387 UTC [qscc] Init -&gt; INFO 034 Init QSCC</span><br><span class="line">2019-09-09 07:52:14.387 UTC [sccapi] deploySysCC -&gt; INFO 035 system chaincode qscc/mychannel(github.com/hyperledger/fabric/core/scc/qscc) deployed</span><br><span class="line">2019-09-09 07:52:14.387 UTC [sccapi] deploySysCC -&gt; INFO 036 system chaincode (+lifecycle,github.com/hyperledger/fabric/core/chaincode/lifecycle) disabled</span><br></pre></td></tr></table></figure>
<h2 id="宏观流程"><a href="#宏观流程" class="headerlink" title="宏观流程"></a>宏观流程</h2><blockquote>
<p>提醒，本文使用<strong>SCC代指系统链码</strong>，使用scc代指core.scc模块。</p>
</blockquote>
<p>在介绍源码之前，先给出总体流程，以便看源码的时候不会迷失。</p>
<p>部署SCC会涉及到4个模块：</p>
<ol>
<li>peer.node，它是peer的主程序，可以调用core.scc进行注册和部署SCC</li>
<li>core.scc，它包含了lscc、qscc、cscc这3个scc，以及SCC的注册和部署</li>
<li>core.chaincode，它是链码管理，普通链码和SCC都会走该模块，去部署和调用链码，和链码容器交互，并且它还提供了1个链码容器的工具shim</li>
<li>core.container，它是实现链码容器，有2种链码容器，SCC使用的InprocVM，和普通链码使用的DockerVM</li>
</ol>
<p>注册和部署的简要流程如下：</p>
<p><img src="http://img.lessisbetter.site/2019-09-deploy-scc-flow.png" alt=""></p>
<ol>
<li>peer运行启动程序</li>
<li>注册scc<ol>
<li>peer.node创建好lscc、cscc、qscc等scc实例，以及从配置文件读取的scc</li>
<li>peer.node调用core.scc依次注册每一个scc实例</li>
<li>core.scc调用core.container把scc实例信息注册到container</li>
</ol>
</li>
<li>部署scc<ol>
<li>peer.node调用core.scc依次部署每一个注册的scc</li>
<li>core.scc部署scc的流程复用普通链码部署流程，调用core.chaincode</li>
<li>core.chaincode执行启动链码容器，scc也有链码容器是Inproc类型，不是Docker类型</li>
<li>core.chaincode会调用core.container建立scc的Inproc容器实例</li>
<li>core.container调用core.chaincode.shim启动容器内的程序，并负责和peer通信</li>
<li>启动完成后，core.chaincode向容器发送Init消息，让容器初始化，容器初始化完成会发送响应消息给core.chaincode，core.chaincode部署scc完成</li>
</ol>
</li>
</ol>
<h2 id="总流程"><a href="#总流程" class="headerlink" title="总流程"></a>总流程</h2><blockquote>
<p>列出源码的过程，会省略大量不相关代码，用<code>...</code>代替。</p>
</blockquote>
<p>peer启动过程中，会调用<code>node.serve</code>，其中包含了为系统链码注册SCC和部署SCC。之后，还会为应用通道部署SCC，说明每个通道有各自的SCC，这里省略掉这部分。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serve</span><span class="params">(args []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 获取support，会注册SCC</span></span><br><span class="line">    <span class="comment">// Initialize chaincode service</span></span><br><span class="line">    chaincodeSupport, ccp, sccp, packageProvider := startChaincodeServer(peerHost, aclProvider, pr, opsSystem)</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 为系统通道部署已经注册的SCC</span></span><br><span class="line">    <span class="comment">// deploy system chaincodes</span></span><br><span class="line">	sccp.DeploySysCCs(<span class="string">""</span>, ccp)</span><br><span class="line">	logger.Infof(<span class="string">"Deployed system chaincodes"</span>)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注册SCC"><a href="#注册SCC" class="headerlink" title="注册SCC"></a>注册SCC</h2><p>注册SCC的流程：</p>
<p>peer.node -&gt; core.scc -&gt; core.container</p>
<h3 id="peer-node"><a href="#peer-node" class="headerlink" title="peer.node"></a>peer.node</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// startChaincodeServer will finish chaincode related initialization, including:</span></span><br><span class="line"><span class="comment">// 1) setup local chaincode install path</span></span><br><span class="line"><span class="comment">// 2) create chaincode specific tls CA</span></span><br><span class="line"><span class="comment">// 3) start the chaincode specific gRPC listening service</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startChaincodeServer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	peerHost <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	aclProvider aclmgmt.ACLProvider,</span></span></span><br><span class="line"><span class="function"><span class="params">	pr *platforms.Registry,</span></span></span><br><span class="line"><span class="function"><span class="params">	ops *operations.System,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(*chaincode.ChaincodeSupport, ccprovider.ChaincodeProvider, *scc.Provider, *persistence.PackageProvider)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="comment">// 会注册SCC</span></span><br><span class="line">	chaincodeSupport, ccp, sccp := registerChaincodeSupport(</span><br><span class="line">		ccSrv,</span><br><span class="line">		ccEndpoint,</span><br><span class="line">		ca,</span><br><span class="line">		packageProvider,</span><br><span class="line">		aclProvider,</span><br><span class="line">		pr,</span><br><span class="line">		lifecycleSCC,</span><br><span class="line">		ops,</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">go</span> ccSrv.Start()</span><br><span class="line">	<span class="keyword">return</span> chaincodeSupport, ccp, sccp, packageProvider</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">registerChaincodeSupport</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	grpcServer *comm.GRPCServer,</span></span></span><br><span class="line"><span class="function"><span class="params">	ccEndpoint <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	ca tlsgen.CA,</span></span></span><br><span class="line"><span class="function"><span class="params">	packageProvider *persistence.PackageProvider,</span></span></span><br><span class="line"><span class="function"><span class="params">	aclProvider aclmgmt.ACLProvider,</span></span></span><br><span class="line"><span class="function"><span class="params">	pr *platforms.Registry,</span></span></span><br><span class="line"><span class="function"><span class="params">	lifecycleSCC *lifecycle.SCC,</span></span></span><br><span class="line"><span class="function"><span class="params">	ops *operations.System,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(*chaincode.ChaincodeSupport, ccprovider.ChaincodeProvider, *scc.Provider)</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// SCC的VM provider</span></span><br><span class="line">	ipRegistry := inproccontroller.NewRegistry()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建SCC provider</span></span><br><span class="line">	sccp := scc.NewProvider(peer.Default, peer.DefaultSupport, ipRegistry)</span><br><span class="line">	<span class="comment">// 创建lscc实例</span></span><br><span class="line">    lsccInst := lscc.New(sccp, aclProvider, pr)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 普通链码，docker容器类型的VM provider</span></span><br><span class="line">	dockerProvider := dockercontroller.NewProvider(</span><br><span class="line">		viper.GetString(<span class="string">"peer.id"</span>),</span><br><span class="line">		viper.GetString(<span class="string">"peer.networkId"</span>),</span><br><span class="line">		ops.Provider,</span><br><span class="line">	)</span><br><span class="line">	dockerVM := dockercontroller.NewDockerVM(</span><br><span class="line">		dockerProvider.PeerID,</span><br><span class="line">		dockerProvider.NetworkID,</span><br><span class="line">		dockerProvider.BuildMetrics,</span><br><span class="line">	)</span><br><span class="line">    ...</span><br><span class="line">    chaincodeSupport := chaincode.NewChaincodeSupport(</span><br><span class="line">		chaincode.GlobalConfig(),</span><br><span class="line">		ccEndpoint,</span><br><span class="line">		userRunsCC,</span><br><span class="line">		ca.CertBytes(),</span><br><span class="line">		authenticator,</span><br><span class="line">		packageProvider,</span><br><span class="line">		lsccInst, <span class="comment">// chaincodeSupport的声明周期管理使用了lscc，而不是lifecycle</span></span><br><span class="line">		aclProvider,</span><br><span class="line">		container.NewVMController(</span><br><span class="line">			<span class="keyword">map</span>[<span class="keyword">string</span>]container.VMProvider&#123;</span><br><span class="line">				dockercontroller.ContainerType: dockerProvider,</span><br><span class="line">				inproccontroller.ContainerType: ipRegistry,</span><br><span class="line">			&#125;,</span><br><span class="line">		),</span><br><span class="line">		sccp,</span><br><span class="line">		pr,</span><br><span class="line">		peer.DefaultSupport,</span><br><span class="line">		ops.Provider,</span><br><span class="line">	)</span><br><span class="line">	ipRegistry.ChaincodeSupport = chaincodeSupport</span><br><span class="line">	<span class="comment">// chaincode provider，可以用来创建cscc</span></span><br><span class="line">	ccp := chaincode.NewProvider(chaincodeSupport)</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 创建cscc、qscc</span></span><br><span class="line">	csccInst := cscc.New(ccp, sccp, aclProvider)</span><br><span class="line">	qsccInst := qscc.New(aclProvider)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Now that chaincode is initialized, register all system chaincodes.</span></span><br><span class="line">	sccs := scc.CreatePluginSysCCs(sccp)</span><br><span class="line">	<span class="comment">// 加入lscc、cscc、qscc</span></span><br><span class="line">	<span class="comment">// lifecycleSCC在1.4中disable了</span></span><br><span class="line">	<span class="comment">// sccs是用户自定义的系统链码</span></span><br><span class="line">	<span class="keyword">for</span> _, cc := <span class="keyword">range</span> <span class="built_in">append</span>([]scc.SelfDescribingSysCC&#123;lsccInst, csccInst, qsccInst, lifecycleSCC&#125;, sccs...) &#123;</span><br><span class="line">		<span class="comment">// 注册每一个SCC</span></span><br><span class="line">		sccp.RegisterSysCC(cc)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">return</span> chaincodeSupport, ccp, sccp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="core-scc"><a href="#core-scc" class="headerlink" title="core.scc"></a>core.scc</h3><p>注册某1个系统合约。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Provider implements sysccprovider.SystemChaincodeProvider</span></span><br><span class="line"><span class="keyword">type</span> Provider <span class="keyword">struct</span> &#123;</span><br><span class="line">	Peer        peer.Operations</span><br><span class="line">	PeerSupport peer.Support</span><br><span class="line">	Registrar   Registrar             <span class="comment">// 注册</span></span><br><span class="line">	SysCCs      []SelfDescribingSysCC <span class="comment">// 注册的scc，包含失败的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RegisterSysCC registers a system chaincode with the syscc provider.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Provider)</span> <span class="title">RegisterSysCC</span><span class="params">(scc SelfDescribingSysCC)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 收集/注册scc到scc provider</span></span><br><span class="line">	p.SysCCs = <span class="built_in">append</span>(p.SysCCs, scc)</span><br><span class="line">	_, err := p.registerSysCC(scc)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		sysccLogger.Panicf(<span class="string">"Could not register system chaincode: %s"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// registerSysCC registers the given system chaincode with the peer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Provider)</span> <span class="title">registerSysCC</span><span class="params">(syscc SelfDescribingSysCC)</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 检测该scc是否开启或不在白名单</span></span><br><span class="line">	<span class="keyword">if</span> !syscc.Enabled() || !isWhitelisted(syscc) &#123;</span><br><span class="line">		sysccLogger.Info(fmt.Sprintf(<span class="string">"system chaincode (%s,%s,%t) disabled"</span>, syscc.Name(), syscc.Path(), syscc.Enabled()))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// XXX This is an ugly hack, version should be tied to the chaincode instance, not he peer binary</span></span><br><span class="line">	version := util.GetSysCCVersion()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// cc的描述信息</span></span><br><span class="line">	ccid := &amp;ccintf.CCID&#123;</span><br><span class="line">		Name:    syscc.Name(),</span><br><span class="line">		Version: version,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 注册scc的chaincode</span></span><br><span class="line">	err := p.Registrar.Register(ccid, syscc.Chaincode())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">//if the type is registered, the instance may not be... keep going</span></span><br><span class="line">		<span class="keyword">if</span> _, ok := err.(inproccontroller.SysCCRegisteredErr); !ok &#123;</span><br><span class="line">			errStr := fmt.Sprintf(<span class="string">"could not register (%s,%v): %s"</span>, syscc.Path(), syscc, err)</span><br><span class="line">			sysccLogger.Error(errStr)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>, fmt.Errorf(errStr)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sysccLogger.Infof(<span class="string">"system chaincode %s(%s) registered"</span>, syscc.Name(), syscc.Path())</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Registrar provides a way for system chaincodes to be registered</span></span><br><span class="line"><span class="keyword">type</span> Registrar <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Register registers a system chaincode</span></span><br><span class="line">	Register(ccid *ccintf.CCID, cc shim.Chaincode) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="core-container"><a href="#core-container" class="headerlink" title="core.container"></a>core.container</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Register registers system chaincode with given path. The deploy should be called to initialize</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Registry)</span> <span class="title">Register</span><span class="params">(ccid *ccintf.CCID, cc shim.Chaincode)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	r.mutex.Lock()</span><br><span class="line">	<span class="keyword">defer</span> r.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 注册系统链码</span></span><br><span class="line">	name := ccid.GetName()</span><br><span class="line">	inprocLogger.Debugf(<span class="string">"Registering chaincode instance: %s"</span>, name)</span><br><span class="line">	tmp := r.typeRegistry[name]</span><br><span class="line">	<span class="keyword">if</span> tmp != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> SysCCRegisteredErr(name)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	r.typeRegistry[name] = &amp;inprocContainer&#123;chaincode: cc&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Registry stores registered system chaincodes.</span></span><br><span class="line"><span class="comment">// It implements container.VMProvider and scc.Registrar</span></span><br><span class="line"><span class="keyword">type</span> Registry <span class="keyword">struct</span> &#123;</span><br><span class="line">	mutex        sync.Mutex</span><br><span class="line">	typeRegistry <span class="keyword">map</span>[<span class="keyword">string</span>]*inprocContainer <span class="comment">// 已注册链码映射</span></span><br><span class="line">	instRegistry <span class="keyword">map</span>[<span class="keyword">string</span>]*inprocContainer <span class="comment">// 链码示例映射</span></span><br><span class="line"></span><br><span class="line">	ChaincodeSupport ccintf.CCSupport</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="部署SCC"><a href="#部署SCC" class="headerlink" title="部署SCC"></a>部署SCC</h2><p>部署SCC的流程：</p>
<p>peer.node -&gt; core.scc -&gt; core.chaincode -&gt; core.container</p>
<h3 id="peer-node-1"><a href="#peer-node-1" class="headerlink" title="peer.node"></a>peer.node</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serve</span><span class="params">(args []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="comment">// 为系统通道部署已经注册的SCC</span></span><br><span class="line">	<span class="comment">// deploy system chaincodes</span></span><br><span class="line">	sccp.DeploySysCCs(<span class="string">""</span>, ccp)</span><br><span class="line">    logger.Infof(<span class="string">"Deployed system chaincodes"</span>)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="core-scc-1"><a href="#core-scc-1" class="headerlink" title="core.scc"></a>core.scc</h3><p><code>DeploySysCCs</code>会为chainID对应的channel，部署注册过程中收集的每一个SCC，它们在<code>p.SysCCs</code>中。</p>
<p>部署链码实际是一笔交易，为了复用普通链码的部署流程，core.scc使用<code>deploySysCC</code>封装部署链码需要的参数，链码是实际部署，走core.chaincode流程。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DeploySysCCs is the hook for system chaincodes where system chaincodes are registered with the fabric</span></span><br><span class="line"><span class="comment">//note the chaincode must still be deployed and launched like a user chaincode will be</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Provider)</span> <span class="title">DeploySysCCs</span><span class="params">(chainID <span class="keyword">string</span>, ccp ccprovider.ChaincodeProvider)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 部署每一个scc</span></span><br><span class="line">	<span class="keyword">for</span> _, sysCC := <span class="keyword">range</span> p.SysCCs &#123;</span><br><span class="line">		deploySysCC(chainID, ccp, sysCC)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// deploySysCC deploys the given system chaincode on a chain</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deploySysCC</span><span class="params">(chainID <span class="keyword">string</span>, ccprov ccprovider.ChaincodeProvider, syscc SelfDescribingSysCC)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// disable或不在白名单的scc不执行部署</span></span><br><span class="line">	<span class="keyword">if</span> !syscc.Enabled() || !isWhitelisted(syscc) &#123;</span><br><span class="line">		sysccLogger.Info(fmt.Sprintf(<span class="string">"system chaincode (%s,%s) disabled"</span>, syscc.Name(), syscc.Path()))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为scc生成txid，因为部署链码的过程需要txParams，与普通链码的流程相同</span></span><br><span class="line">	txid := util.GenerateUUID()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Note, this structure is barely initialized,</span></span><br><span class="line">	<span class="comment">// we omit the history query executor, the proposal</span></span><br><span class="line">	<span class="comment">// and the signed proposal</span></span><br><span class="line">	txParams := &amp;ccprovider.TransactionParams&#123;</span><br><span class="line">		TxID:      txid,</span><br><span class="line">		ChannelID: chainID,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置交易执行模拟器，系统通道chainID为""，所以系统通道的scc没有模拟器</span></span><br><span class="line">	<span class="keyword">if</span> chainID != <span class="string">""</span> &#123;</span><br><span class="line">		<span class="comment">// 获取链/通道的账本</span></span><br><span class="line">		lgr := peer.GetLedger(chainID)</span><br><span class="line">		<span class="keyword">if</span> lgr == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"syschain %s start up failure - unexpected nil ledger for channel %s"</span>, syscc.Name(), chainID))</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 根据交易id创建链码模拟器</span></span><br><span class="line">		txsim, err := lgr.NewTxSimulator(txid)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 指定链码执行模拟器</span></span><br><span class="line">		txParams.TXSimulator = txsim</span><br><span class="line">		<span class="keyword">defer</span> txsim.Done()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	chaincodeID := &amp;pb.ChaincodeID&#123;Path: syscc.Path(), Name: syscc.Name()&#125;</span><br><span class="line">	spec := &amp;pb.ChaincodeSpec&#123;Type: pb.ChaincodeSpec_Type(pb.ChaincodeSpec_Type_value[<span class="string">"GOLANG"</span>]), ChaincodeId: chaincodeID, Input: &amp;pb.ChaincodeInput&#123;Args: syscc.InitArgs()&#125;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ChaincodeDeploymentSpec_SYSTEM标明：部署SCC</span></span><br><span class="line">	chaincodeDeploymentSpec := &amp;pb.ChaincodeDeploymentSpec&#123;ExecEnv: pb.ChaincodeDeploymentSpec_SYSTEM, ChaincodeSpec: spec&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// XXX This is an ugly hack, version should be tied to the chaincode instance, not he peer binary</span></span><br><span class="line">	version := util.GetSysCCVersion()</span><br><span class="line"></span><br><span class="line">	cccid := &amp;ccprovider.CCContext&#123;</span><br><span class="line">		Name:    chaincodeDeploymentSpec.ChaincodeSpec.ChaincodeId.Name,</span><br><span class="line">		Version: version,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 部署SCC</span></span><br><span class="line">	resp, _, err := ccprov.ExecuteLegacyInit(txParams, cccid, chaincodeDeploymentSpec)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; resp.Status != shim.OK &#123;</span><br><span class="line">		err = errors.New(resp.Message)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sysccLogger.Infof(<span class="string">"system chaincode %s/%s(%s) deployed"</span>, syscc.Name(), chainID, syscc.Path())</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ChaincodeProvider provides an abstraction layer that is</span></span><br><span class="line"><span class="comment">// used for different packages to interact with code in the</span></span><br><span class="line"><span class="comment">// chaincode package without importing it; more methods</span></span><br><span class="line"><span class="comment">// should be added below if necessary</span></span><br><span class="line"><span class="keyword">type</span> ChaincodeProvider <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Execute executes a standard chaincode invocation for a chaincode and an input</span></span><br><span class="line">	Execute(txParams *TransactionParams, cccid *CCContext, input *pb.ChaincodeInput) (*pb.Response, *pb.ChaincodeEvent, error)</span><br><span class="line">	<span class="comment">// ExecuteLegacyInit is a special case for executing chaincode deployment specs,</span></span><br><span class="line">	<span class="comment">// which are not already in the LSCC, needed for old lifecycle</span></span><br><span class="line">	ExecuteLegacyInit(txParams *TransactionParams, cccid *CCContext, spec *pb.ChaincodeDeploymentSpec) (*pb.Response, *pb.ChaincodeEvent, error)</span><br><span class="line">	<span class="comment">// Stop stops the chaincode give</span></span><br><span class="line">	Stop(ccci *ChaincodeContainerInfo) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="core-chaincode"><a href="#core-chaincode" class="headerlink" title="core.chaincode"></a>core.chaincode</h3><p><code>CCProviderImpl</code>实现了<code>ChaincodeProvider</code>接口，可以用来部署链码，<code>ExecuteLegacyInit</code>会执行2项：</p>
<ol>
<li>启动链码容器</li>
<li>执行链码Init函数，链码容器启动后，peer和链码容器通过消息通信，<code>ChaincodeMessage_INIT</code>是执行链码容器的Init函数</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExecuteLegacyInit executes a chaincode which is not in the LSCC table</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CCProviderImpl)</span> <span class="title">ExecuteLegacyInit</span><span class="params">(txParams *ccprovider.TransactionParams, cccid *ccprovider.CCContext, spec *pb.ChaincodeDeploymentSpec)</span> <span class="params">(*pb.Response, *pb.ChaincodeEvent, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.cs.ExecuteLegacyInit(txParams, cccid, spec)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ExecuteLegacyInit is a temporary method which should be removed once the old style lifecycle</span></span><br><span class="line"><span class="comment">// is entirely deprecated.  Ideally one release after the introduction of the new lifecycle.</span></span><br><span class="line"><span class="comment">// It does not attempt to start the chaincode based on the information from lifecycle, but instead</span></span><br><span class="line"><span class="comment">// accepts the container information directly in the form of a ChaincodeDeploymentSpec.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *ChaincodeSupport)</span> <span class="title">ExecuteLegacyInit</span><span class="params">(txParams *ccprovider.TransactionParams, cccid *ccprovider.CCContext, spec *pb.ChaincodeDeploymentSpec)</span> <span class="params">(*pb.Response, *pb.ChaincodeEvent, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 部署链码需要的信息</span></span><br><span class="line">    ccci := ccprovider.DeploymentSpecToChaincodeContainerInfo(spec)</span><br><span class="line">	ccci.Version = cccid.Version</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动容器</span></span><br><span class="line">	err := cs.LaunchInit(ccci)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cname := ccci.Name + <span class="string">":"</span> + ccci.Version</span><br><span class="line">	h := cs.HandlerRegistry.Handler(cname)</span><br><span class="line">	<span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, errors.Wrapf(err, <span class="string">"[channel %s] claimed to start chaincode container for %s but could not find handler"</span>, txParams.ChannelID, cname)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用链码Init</span></span><br><span class="line">	resp, err := cs.execute(pb.ChaincodeMessage_INIT, txParams, cccid, spec.GetChaincodeSpec().Input, h)</span><br><span class="line">	<span class="keyword">return</span> processChaincodeExecutionResult(txParams.TxID, cccid.Name, resp, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>LaunchInit</code>是启动容器的一层检查，实际启动由<code>Launcher.Launch</code>完成。启动链码容器是异步的，会创建单独的goroutine去执行。</p>
<p>core.chaincode使用<code>Runtime</code>接口操控链码容器的启停。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LaunchInit bypasses getting the chaincode spec from the LSCC table</span></span><br><span class="line"><span class="comment">// as in the case of v1.0-v1.2 lifecycle, the chaincode will not yet be</span></span><br><span class="line"><span class="comment">// defined in the LSCC table</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *ChaincodeSupport)</span> <span class="title">LaunchInit</span><span class="params">(ccci *ccprovider.ChaincodeContainerInfo)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	cname := ccci.Name + <span class="string">":"</span> + ccci.Version</span><br><span class="line">	<span class="comment">// 已经有handler，即容器已经启动。调用链码的时候，也会获取handler</span></span><br><span class="line">	<span class="keyword">if</span> cs.HandlerRegistry.Handler(cname) != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 否则启动容器，设置handler</span></span><br><span class="line">	<span class="keyword">return</span> cs.Launcher.Launch(ccci)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RuntimeLauncher)</span> <span class="title">Launch</span><span class="params">(ccci *ccprovider.ChaincodeContainerInfo)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> startFailCh <span class="keyword">chan</span> error</span><br><span class="line">	<span class="keyword">var</span> timeoutCh &lt;-<span class="keyword">chan</span> time.Time</span><br><span class="line"></span><br><span class="line">	startTime := time.Now()</span><br><span class="line">	cname := ccci.Name + <span class="string">":"</span> + ccci.Version</span><br><span class="line">	launchState, alreadyStarted := r.Registry.Launching(cname)</span><br><span class="line">	<span class="comment">// 链码容器未启动，启动容器</span></span><br><span class="line">	<span class="keyword">if</span> !alreadyStarted &#123;</span><br><span class="line">		startFailCh = <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="number">1</span>)</span><br><span class="line">		timeoutCh = time.NewTimer(r.StartupTimeout).C</span><br><span class="line"></span><br><span class="line">		codePackage, err := r.getCodePackage(ccci)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="comment">// 启动容器</span></span><br><span class="line">			<span class="keyword">if</span> err := r.Runtime.Start(ccci, codePackage); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				startFailCh &lt;- errors.WithMessage(err, <span class="string">"error starting container"</span>)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			exitCode, err := r.Runtime.Wait(ccci)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				launchState.Notify(errors.Wrap(err, <span class="string">"failed to wait on container exit"</span>))</span><br><span class="line">			&#125;</span><br><span class="line">			launchState.Notify(errors.Errorf(<span class="string">"container exited with %d"</span>, exitCode))</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Runtime is used to manage chaincode runtime instances.</span></span><br><span class="line"><span class="keyword">type</span> Runtime <span class="keyword">interface</span> &#123;</span><br><span class="line">	Start(ccci *ccprovider.ChaincodeContainerInfo, codePackage []<span class="keyword">byte</span>) error</span><br><span class="line">	Stop(ccci *ccprovider.ChaincodeContainerInfo) error</span><br><span class="line">	Wait(ccci *ccprovider.ChaincodeContainerInfo) (<span class="keyword">int</span>, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ContainerRuntime</code>是core.chaincode封装出来和core.container交互的，在这里它会创建启动链码请求，交给container。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start launches chaincode in a runtime environment.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ContainerRuntime)</span> <span class="title">Start</span><span class="params">(ccci *ccprovider.ChaincodeContainerInfo, codePackage []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	cname := ccci.Name + <span class="string">":"</span> + ccci.Version</span><br><span class="line"></span><br><span class="line">	lc, err := c.LaunchConfig(cname, ccci.Type)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	chaincodeLogger.Debugf(<span class="string">"start container: %s"</span>, cname)</span><br><span class="line">	chaincodeLogger.Debugf(<span class="string">"start container with args: %s"</span>, strings.Join(lc.Args, <span class="string">" "</span>))</span><br><span class="line">	chaincodeLogger.Debugf(<span class="string">"start container with env:\n\t%s"</span>, strings.Join(lc.Envs, <span class="string">"\n\t"</span>))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动链码的请求</span></span><br><span class="line">	scr := container.StartContainerReq&#123;</span><br><span class="line">		Builder: &amp;container.PlatformBuilder&#123;</span><br><span class="line">			Type:             ccci.Type,</span><br><span class="line">			Name:             ccci.Name,</span><br><span class="line">			Version:          ccci.Version,</span><br><span class="line">			Path:             ccci.Path,</span><br><span class="line">			CodePackage:      codePackage,</span><br><span class="line">			PlatformRegistry: c.PlatformRegistry,</span><br><span class="line">		&#125;,</span><br><span class="line">		Args:          lc.Args,</span><br><span class="line">		Env:           lc.Envs,</span><br><span class="line">		FilesToUpload: lc.Files,</span><br><span class="line">		CCID: ccintf.CCID&#123;</span><br><span class="line">			Name:    ccci.Name,</span><br><span class="line">			Version: ccci.Version,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 处理容器操作请求</span></span><br><span class="line">	<span class="keyword">if</span> err := c.Processor.Process(ccci.ContainerType, scr); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.WithMessage(err, <span class="string">"error starting container"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Processor processes vm and container requests.</span></span><br><span class="line"><span class="keyword">type</span> Processor <span class="keyword">interface</span> &#123;</span><br><span class="line">	Process(vmtype <span class="keyword">string</span>, req container.VMCReq) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="core-container-1"><a href="#core-container-1" class="headerlink" title="core.container"></a>core.container</h3><p><code>VMController</code>实现了Processor，它会按指定的类型建立虚拟机，明明就是容器，为啥内部又叫VM，VM有2种：</p>
<ol>
<li>InprocVM，意思是运行在单独进程中的虚拟机，但不是指操作系统的进程，而是指一个隔离的环境，SCC是这类。</li>
<li>DockerVM，指利用Docker启动的容器，普通链码就是这类。</li>
</ol>
<p>类型是存在<code>ccci.ContainerType</code>中的，<code>ccci</code>包含了部署链码所需要的信息，这个信息在core.chaincode很早就获取到了，可以往前翻。</p>
<p><code>Process</code>就是创建VM，然后利用VM处理请求的过程。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据请求对VM进行某种操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(vmc *VMController)</span> <span class="title">Process</span><span class="params">(vmtype <span class="keyword">string</span>, req VMCReq)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建vm</span></span><br><span class="line">	v := vmc.newVM(vmtype)</span><br><span class="line">	ccid := req.GetCCID()</span><br><span class="line">	id := ccid.GetName()</span><br><span class="line"></span><br><span class="line">	vmc.lockContainer(id)</span><br><span class="line">	<span class="keyword">defer</span> vmc.unlockContainer(id)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 把vm传递给请求，即用该vm执行请求内容</span></span><br><span class="line">	<span class="keyword">return</span> req.Do(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="虚拟机创建"><a href="#虚拟机创建" class="headerlink" title="虚拟机创建"></a>虚拟机创建</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用指定类型的vm provider创建vm</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(vmc *VMController)</span> <span class="title">newVM</span><span class="params">(typ <span class="keyword">string</span>)</span> <span class="title">VM</span></span> &#123;</span><br><span class="line">	v, ok := vmc.vmProviders[typ]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		vmLogger.Panicf(<span class="string">"Programming error: unsupported VM type: %s"</span>, typ)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> v.NewVM()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewVMController creates a new instance of VMController</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewVMController</span><span class="params">(vmProviders <span class="keyword">map</span>[<span class="keyword">string</span>]VMProvider)</span> *<span class="title">VMController</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;VMController&#123;</span><br><span class="line">		containerLocks: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*refCountedLock),</span><br><span class="line">		vmProviders:    vmProviders,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建VM需要使用<code>NewVMController</code>，回过去找它的创建地方。</p>
<p>在注册SCC的过程中，调用<code>registerChaincodeSupport</code>创建了<code>chaincodeSupport</code>，其中一个字段为创建<code>NewVMController</code>，就包含了2类Vm provider：</p>
<ol>
<li>ipRegistry，SCC的</li>
<li>dockerProvider，普通链码的</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">registerChaincodeSupport</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	grpcServer *comm.GRPCServer,</span></span></span><br><span class="line"><span class="function"><span class="params">	ccEndpoint <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	ca tlsgen.CA,</span></span></span><br><span class="line"><span class="function"><span class="params">	packageProvider *persistence.PackageProvider,</span></span></span><br><span class="line"><span class="function"><span class="params">	aclProvider aclmgmt.ACLProvider,</span></span></span><br><span class="line"><span class="function"><span class="params">	pr *platforms.Registry,</span></span></span><br><span class="line"><span class="function"><span class="params">	lifecycleSCC *lifecycle.SCC,</span></span></span><br><span class="line"><span class="function"><span class="params">	ops *operations.System,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(*chaincode.ChaincodeSupport, ccprovider.ChaincodeProvider, *scc.Provider)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// SCC的VM provider</span></span><br><span class="line">	ipRegistry := inproccontroller.NewRegistry()</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 普通链码，docker容器类型的VM provider</span></span><br><span class="line">	dockerProvider := dockercontroller.NewProvider(</span><br><span class="line">		viper.GetString(<span class="string">"peer.id"</span>),</span><br><span class="line">		viper.GetString(<span class="string">"peer.networkId"</span>),</span><br><span class="line">		ops.Provider,</span><br><span class="line">	)</span><br><span class="line">    ...</span><br><span class="line">    chaincodeSupport := chaincode.NewChaincodeSupport(</span><br><span class="line">		chaincode.GlobalConfig(),</span><br><span class="line">		ccEndpoint,</span><br><span class="line">		userRunsCC,</span><br><span class="line">		ca.CertBytes(),</span><br><span class="line">		authenticator,</span><br><span class="line">		packageProvider,</span><br><span class="line">		lsccInst, <span class="comment">// chaincodeSupport的声明周期管理使用了lscc，而不是lifecycle</span></span><br><span class="line">		aclProvider,</span><br><span class="line">        <span class="comment">// 创建了VM controller，controller提供了inproc和docker 2中子controller，</span></span><br><span class="line">		<span class="comment">// 即2中链码运行方式</span></span><br><span class="line">		container.NewVMController(</span><br><span class="line">			<span class="keyword">map</span>[<span class="keyword">string</span>]container.VMProvider&#123;</span><br><span class="line">				dockercontroller.ContainerType: dockerProvider,</span><br><span class="line">				inproccontroller.ContainerType: ipRegistry,</span><br><span class="line">			&#125;,</span><br><span class="line">		),</span><br><span class="line">		sccp,</span><br><span class="line">		pr,</span><br><span class="line">		peer.DefaultSupport,</span><br><span class="line">		ops.Provider,</span><br><span class="line">	)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="VM处理操作虚拟机的请求"><a href="#VM处理操作虚拟机的请求" class="headerlink" title="VM处理操作虚拟机的请求"></a>VM处理操作虚拟机的请求</h4><p>core.container的请求，都实现了<code>VMCReq</code>接口，StartContainerReq、StopContainerReq、WaitContainerReq是实现VMCReq的3类请求。</p>
<p>启动实际是启动虚拟机接口，处理请求。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//VMCReq - all requests should implement this interface.</span></span><br><span class="line"><span class="comment">//The context should be passed and tested at each layer till we stop</span></span><br><span class="line"><span class="comment">//note that we'd stop on the first method on the stack that does not</span></span><br><span class="line"><span class="comment">//take context</span></span><br><span class="line"><span class="keyword">type</span> VMCReq <span class="keyword">interface</span> &#123;</span><br><span class="line">	Do(v VM) error</span><br><span class="line">	GetCCID() ccintf.CCID</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动容器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(si StartContainerReq)</span> <span class="title">Do</span><span class="params">(v VM)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> v.Start(si.CCID, si.Args, si.Env, si.FilesToUpload, si.Builder)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//VM is an abstract virtual image for supporting arbitrary virual machines</span></span><br><span class="line"><span class="keyword">type</span> VM <span class="keyword">interface</span> &#123;</span><br><span class="line">	Start(ccid ccintf.CCID, args []<span class="keyword">string</span>, env []<span class="keyword">string</span>, filesToUpload <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">byte</span>, builder Builder) error</span><br><span class="line">	Stop(ccid ccintf.CCID, timeout <span class="keyword">uint</span>, dontkill <span class="keyword">bool</span>, dontremove <span class="keyword">bool</span>) error</span><br><span class="line">	Wait(ccid ccintf.CCID) (<span class="keyword">int</span>, error)</span><br><span class="line">	HealthCheck(context.Context) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DockerVM和InprocVM都实现了VM接口，本文只关注InprocVM类型，即SCC的。</p>
<p>InprocVM会得到一个容器实例ipc，用它来运行SCC。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Start starts a previously registered system codechain</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(vm *InprocVM)</span> <span class="title">Start</span><span class="params">(ccid ccintf.CCID, args []<span class="keyword">string</span>, env []<span class="keyword">string</span>, filesToUpload <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">byte</span>, builder container.Builder)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	path := ccid.GetName()</span><br><span class="line"></span><br><span class="line">	ipctemplate := vm.registry.getType(path)</span><br><span class="line">	<span class="keyword">if</span> ipctemplate == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(fmt.Sprintf(<span class="string">"%s not registered"</span>, path))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 即ccid.Name</span></span><br><span class="line">	instName := vm.GetVMName(ccid)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取容器实例</span></span><br><span class="line">	ipc, err := vm.getInstance(ipctemplate, instName, args, env)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(fmt.Sprintf(<span class="string">"could not create instance for %s"</span>, instName))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 已经在运行了，还部署个啥！</span></span><br><span class="line">	<span class="keyword">if</span> ipc.running &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(fmt.Sprintf(<span class="string">"chaincode running %s"</span>, path))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ipc.running = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">				inprocLogger.Criticalf(<span class="string">"caught panic from chaincode  %s"</span>, instName)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">		<span class="comment">// 启动进程级容器</span></span><br><span class="line">		ipc.launchInProc(instName, args, env)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>inprocContainer</code>开启2个goroutine：</p>
<ol>
<li>第一个调用<code>shimStartInProc</code>，即利用core.chaincode.shim启动InProc类型的容器。</li>
<li>第二个调用<code>HandleChaincodeStream</code>，处理peer和Inproc容器间的通信数据，此处的stream是peer端的。</li>
</ol>
<p>这里可以看到创建了2个通道<code>peerRcvCCSend</code>和<code>ccRcvPeerSend</code>，它们表明了peer和scc的链码容器是通过通道直接通信的。peer和docker链码容器之间是走gRPC通信的，这个到普通链码的时候再介绍。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从进程启动链码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ipc *inprocContainer)</span> <span class="title">launchInProc</span><span class="params">(id <span class="keyword">string</span>, args []<span class="keyword">string</span>, env []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> ipc.ChaincodeSupport == <span class="literal">nil</span> &#123;</span><br><span class="line">		inprocLogger.Panicf(<span class="string">"Chaincode support is nil, most likely you forgot to set it immediately after calling inproccontroller.NewRegsitry()"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 和调用链码的上层通信的2个通道</span></span><br><span class="line">	peerRcvCCSend := <span class="built_in">make</span>(<span class="keyword">chan</span> *pb.ChaincodeMessage)</span><br><span class="line">	ccRcvPeerSend := <span class="built_in">make</span>(<span class="keyword">chan</span> *pb.ChaincodeMessage)</span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	ccchan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">	ccsupportchan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">	shimStartInProc := _shimStartInProc <span class="comment">// shadow to avoid race in test</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(ccchan)</span><br><span class="line">		<span class="comment">// 启动链码</span></span><br><span class="line">		inprocLogger.Debugf(<span class="string">"chaincode started for %s"</span>, id)</span><br><span class="line">		<span class="keyword">if</span> args == <span class="literal">nil</span> &#123;</span><br><span class="line">			args = ipc.args</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> env == <span class="literal">nil</span> &#123;</span><br><span class="line">			env = ipc.env</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 利用shim启动</span></span><br><span class="line">		err := shimStartInProc(env, args, ipc.chaincode, ccRcvPeerSend, peerRcvCCSend)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			err = fmt.Errorf(<span class="string">"chaincode-support ended with err: %s"</span>, err)</span><br><span class="line">			_inprocLoggerErrorf(<span class="string">"%s"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		inprocLogger.Debugf(<span class="string">"chaincode ended for %s with err: %s"</span>, id, err)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// shadow function to avoid data race</span></span><br><span class="line">	inprocLoggerErrorf := _inprocLoggerErrorf</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(ccsupportchan)</span><br><span class="line">		<span class="comment">// 处理scc和外部通信的消息流</span></span><br><span class="line">		inprocStream := newInProcStream(peerRcvCCSend, ccRcvPeerSend)</span><br><span class="line">		inprocLogger.Debugf(<span class="string">"chaincode-support started for  %s"</span>, id)</span><br><span class="line">		err := ipc.ChaincodeSupport.HandleChaincodeStream(inprocStream)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			err = fmt.Errorf(<span class="string">"chaincode ended with err: %s"</span>, err)</span><br><span class="line">			inprocLoggerErrorf(<span class="string">"%s"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		inprocLogger.Debugf(<span class="string">"chaincode-support ended for %s with err: %s"</span>, id, err)</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="利用shim启动Inproc链码容器中的程序"><a href="#利用shim启动Inproc链码容器中的程序" class="headerlink" title="利用shim启动Inproc链码容器中的程序"></a>利用shim启动Inproc链码容器中的程序</h4><p>shim是chaincode提供给容器，运行链码的工具，它运行在容器里。</p>
<p>利用shim启动InprocVM使用的函数是<code>StartInProc</code>，提取一些<strong>运行链码</strong>需要的数据，比如又一个stream，此处的stream是容器端的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动SCC的入口</span></span><br><span class="line"><span class="comment">// StartInProc is an entry point for system chaincodes bootstrap. It is not an</span></span><br><span class="line"><span class="comment">// API for chaincodes.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StartInProc</span><span class="params">(env []<span class="keyword">string</span>, args []<span class="keyword">string</span>, cc Chaincode, recv &lt;-<span class="keyword">chan</span> *pb.ChaincodeMessage, send <span class="keyword">chan</span>&lt;- *pb.ChaincodeMessage)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// 有点奇怪，这些日志都没有看到，因为已经在shim，不属于peer日志了</span></span><br><span class="line">	chaincodeLogger.Debugf(<span class="string">"in proc %v"</span>, args)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从环境变量获取cc name</span></span><br><span class="line">	<span class="keyword">var</span> chaincodename <span class="keyword">string</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> env &#123;</span><br><span class="line">		<span class="keyword">if</span> strings.Index(v, <span class="string">"CORE_CHAINCODE_ID_NAME="</span>) == <span class="number">0</span> &#123;</span><br><span class="line">			p := strings.SplitAfter(v, <span class="string">"CORE_CHAINCODE_ID_NAME="</span>)</span><br><span class="line">			chaincodename = p[<span class="number">1</span>]</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> chaincodename == <span class="string">""</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">"error chaincode id not provided"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建peer和chaincode通信的通道</span></span><br><span class="line">	stream := newInProcStream(recv, send)</span><br><span class="line">	chaincodeLogger.Debugf(<span class="string">"starting chat with peer using name=%s"</span>, chaincodename)</span><br><span class="line">	<span class="comment">// 与peer进行通信</span></span><br><span class="line">	err := chatWithPeer(chaincodename, stream, cc)</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>chatWithPeer</code>是通用的，普通的链码也调用这个程序。它创建了一个handler，用来处理消息（发送和接收），以及操作（调用）链码。</p>
<p>这个过程，它会向peer发送REGISTER消息，和peer先“握手”，也会从peer读消息，消息的处理函数就是里面的for循环，这样链码容器就运行起来了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用，SCC和CC都使用这个函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chatWithPeer</span><span class="params">(chaincodename <span class="keyword">string</span>, stream PeerChaincodeStream, cc Chaincode)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// 把stream和cc交给handler，handler可以发送和接收数据，即读写通道</span></span><br><span class="line">	<span class="comment">// Create the shim handler responsible for all control logic</span></span><br><span class="line">	handler := newChaincodeHandler(stream, cc)</span><br><span class="line">	<span class="keyword">defer</span> stream.CloseSend()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Send the ChaincodeID during register.</span></span><br><span class="line">	chaincodeID := &amp;pb.ChaincodeID&#123;Name: chaincodename&#125;</span><br><span class="line">	payload, err := proto.Marshal(chaincodeID)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.Wrap(err, <span class="string">"error marshalling chaincodeID during chaincode registration"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在stream上向peer发送注册消息</span></span><br><span class="line">	<span class="comment">// Register on the stream</span></span><br><span class="line">	chaincodeLogger.Debugf(<span class="string">"Registering.. sending %s"</span>, pb.ChaincodeMessage_REGISTER)</span><br><span class="line">	<span class="keyword">if</span> err = handler.serialSend(&amp;pb.ChaincodeMessage&#123;Type: pb.ChaincodeMessage_REGISTER, Payload: payload&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.WithMessage(err, <span class="string">"error sending chaincode REGISTER"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// holds return values from gRPC Recv below</span></span><br><span class="line">	<span class="keyword">type</span> recvMsg <span class="keyword">struct</span> &#123;</span><br><span class="line">		msg *pb.ChaincodeMessage</span><br><span class="line">		err error</span><br><span class="line">	&#125;</span><br><span class="line">	msgAvail := <span class="built_in">make</span>(<span class="keyword">chan</span> *recvMsg, <span class="number">1</span>)</span><br><span class="line">	errc := <span class="built_in">make</span>(<span class="keyword">chan</span> error)</span><br><span class="line"></span><br><span class="line">	receiveMessage := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		in, err := stream.Recv()</span><br><span class="line">		msgAvail &lt;- &amp;recvMsg&#123;in, err&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 异步读取1个消息</span></span><br><span class="line">	<span class="keyword">go</span> receiveMessage()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 循环处理peer发送的消息</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> rmsg := &lt;-msgAvail:</span><br><span class="line">			<span class="keyword">switch</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> rmsg.err == io.EOF:</span><br><span class="line">				err = errors.Wrapf(rmsg.err, <span class="string">"received EOF, ending chaincode stream"</span>)</span><br><span class="line">				chaincodeLogger.Debugf(<span class="string">"%+v"</span>, err)</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			<span class="keyword">case</span> rmsg.err != <span class="literal">nil</span>:</span><br><span class="line">				err := errors.Wrap(rmsg.err, <span class="string">"receive failed"</span>)</span><br><span class="line">				chaincodeLogger.Errorf(<span class="string">"Received error from server, ending chaincode stream: %+v"</span>, err)</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			<span class="keyword">case</span> rmsg.msg == <span class="literal">nil</span>:</span><br><span class="line">				err := errors.New(<span class="string">"received nil message, ending chaincode stream"</span>)</span><br><span class="line">				chaincodeLogger.Debugf(<span class="string">"%+v"</span>, err)</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="comment">// 处理消息</span></span><br><span class="line">				chaincodeLogger.Debugf(<span class="string">"[%s]Received message %s from peer"</span>, shorttxid(rmsg.msg.Txid), rmsg.msg.Type)</span><br><span class="line">				err := handler.handleMessage(rmsg.msg, errc)</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					err = errors.WithMessage(err, <span class="string">"error handling message"</span>)</span><br><span class="line">					<span class="keyword">return</span> err</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 读取下一个消息</span></span><br><span class="line">				<span class="keyword">go</span> receiveMessage()</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> sendErr := &lt;-errc:</span><br><span class="line">			<span class="keyword">if</span> sendErr != <span class="literal">nil</span> &#123;</span><br><span class="line">				err := errors.Wrap(sendErr, <span class="string">"error sending"</span>)</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的消息处理函数，先跳过，回过头来，关注scc容器和peer的通信。</p>
<h4 id="SCC和Peer的通信通道"><a href="#SCC和Peer的通信通道" class="headerlink" title="SCC和Peer的通信通道"></a>SCC和Peer的通信通道</h4><p>链码容器和Peer之间使用Stream进行通信，Stream有2种实现：</p>
<ol>
<li>使用channel封装的Stream</li>
<li>gRPC的Stream</li>
</ol>
<p><img src="http://img.lessisbetter.site/2019-09-peer-cc-communication.png" alt=""></p>
<p>链码容器和Peer通信的接口是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PeerChaincodeStream interface for stream between Peer and chaincode instance.</span></span><br><span class="line"><span class="keyword">type</span> PeerChaincodeStream <span class="keyword">interface</span> &#123;</span><br><span class="line">	Send(*pb.ChaincodeMessage) error</span><br><span class="line">	Recv() (*pb.ChaincodeMessage, error)</span><br><span class="line">	CloseSend() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>普通链码使用gRPC：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> chaincodeSupportRegisterClient <span class="keyword">struct</span> &#123;</span><br><span class="line">	grpc.ClientStream</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>系统链码直接使用通道通信，发送和接收消息都在下面了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// peer和chaincode之间通信的通道</span></span><br><span class="line"><span class="comment">// PeerChaincodeStream interface for stream between Peer and chaincode instance.</span></span><br><span class="line"><span class="keyword">type</span> inProcStream <span class="keyword">struct</span> &#123;</span><br><span class="line">	recv &lt;-<span class="keyword">chan</span> *pb.ChaincodeMessage</span><br><span class="line">	send <span class="keyword">chan</span>&lt;- *pb.ChaincodeMessage</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newInProcStream</span><span class="params">(recv &lt;-<span class="keyword">chan</span> *pb.ChaincodeMessage, send <span class="keyword">chan</span>&lt;- *pb.ChaincodeMessage)</span> *<span class="title">inProcStream</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;inProcStream&#123;recv, send&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送其实就是向send写数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *inProcStream)</span> <span class="title">Send</span><span class="params">(msg *pb.ChaincodeMessage)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	err = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//send may happen on a closed channel when the system is</span></span><br><span class="line">	<span class="comment">//shutting down. Just catch the exception and return error</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">			err = SendPanicFailure(fmt.Sprintf(<span class="string">"%s"</span>, r))</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	s.send &lt;- msg</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收是从recv读数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *inProcStream)</span> <span class="title">Recv</span><span class="params">()</span> <span class="params">(*pb.ChaincodeMessage, error)</span></span> &#123;</span><br><span class="line">	msg, ok := &lt;-s.recv</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"channel is closed"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> msg, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *inProcStream)</span> <span class="title">CloseSend</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// 实际啥也没做</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Peer和链码容器的交互，完成链码容器启动"><a href="#Peer和链码容器的交互，完成链码容器启动" class="headerlink" title="Peer和链码容器的交互，完成链码容器启动"></a>Peer和链码容器的交互，完成链码容器启动</h3><p>部署链码需要Peer和链码容器交互，不然Peer怎么知道链码容器已经启动。以下是一份peer的DEBUG日志，在下面标注了启动容器和链码Init过程中的消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">2019-09-09 07:52:09.915 UTC [chaincode] LaunchConfig -&gt; DEBU 098 launchConfig: executable:&quot;chaincode&quot;,Args:[chaincode,-peer.address=peer0.org1.example.com:7052],Envs:[CORE_CHAINCODE_LOGGING_LEVEL=info,CORE_CHAINCODE_LOGGING_SHIM=warning,CORE_CHAINCODE_LOGGING_FORMAT=%&#123;color&#125;%&#123;time:2006-01-02 15:04:05.000 MST&#125; [%&#123;module&#125;] %&#123;shortfunc&#125; -&gt; %&#123;level:.4s&#125; %&#123;id:03x&#125;%&#123;color:reset&#125; %&#123;message&#125;,CORE_CHAINCODE_ID_NAME=lscc:1.4.3,CORE_PEER_TLS_ENABLED=true,CORE_TLS_CLIENT_KEY_PATH=/etc/hyperledger/fabric/client.key,CORE_TLS_CLIENT_CERT_PATH=/etc/hyperledger/fabric/client.crt,CORE_PEER_TLS_ROOTCERT_FILE=/etc/hyperledger/fabric/peer.crt],Files:[/etc/hyperledger/fabric/client.crt /etc/hyperledger/fabric/client.key /etc/hyperledger/fabric/peer.crt]</span><br><span class="line">2019-09-09 07:52:09.915 UTC [chaincode] Start -&gt; DEBU 099 start container: lscc:1.4.3</span><br><span class="line">2019-09-09 07:52:09.915 UTC [chaincode] Start -&gt; DEBU 09a start container with args: chaincode -peer.address=peer0.org1.example.com:7052</span><br><span class="line">2019-09-09 07:52:09.915 UTC [chaincode] Start -&gt; DEBU 09b start container with env:</span><br><span class="line">	CORE_CHAINCODE_LOGGING_LEVEL=info</span><br><span class="line">	CORE_CHAINCODE_LOGGING_SHIM=warning</span><br><span class="line">	CORE_CHAINCODE_LOGGING_FORMAT=%&#123;color&#125;%&#123;time:2006-01-02 15:04:05.000 MST&#125; [%&#123;module&#125;] %&#123;shortfunc&#125; -&gt; %&#123;level:.4s&#125; %&#123;id:03x&#125;%&#123;color:reset&#125; %&#123;message&#125;</span><br><span class="line">	CORE_CHAINCODE_ID_NAME=lscc:1.4.3</span><br><span class="line">	CORE_PEER_TLS_ENABLED=true</span><br><span class="line">	CORE_TLS_CLIENT_KEY_PATH=/etc/hyperledger/fabric/client.key</span><br><span class="line">	CORE_TLS_CLIENT_CERT_PATH=/etc/hyperledger/fabric/client.crt</span><br><span class="line">	CORE_PEER_TLS_ROOTCERT_FILE=/etc/hyperledger/fabric/peer.crt</span><br><span class="line">2019-09-09 07:52:09.915 UTC [container] lockContainer -&gt; DEBU 09c waiting for container(lscc-1.4.3) lock</span><br><span class="line">2019-09-09 07:52:09.915 UTC [container] lockContainer -&gt; DEBU 09d got container (lscc-1.4.3) lock</span><br><span class="line">2019-09-09 07:52:09.915 UTC [inproccontroller] getInstance -&gt; DEBU 09e chaincode instance created for lscc-1.4.3</span><br><span class="line">2019-09-09 07:52:09.915 UTC [container] unlockContainer -&gt; DEBU 09f container lock deleted(lscc-1.4.3)</span><br><span class="line">2019-09-09 07:52:09.915 UTC [container] lockContainer -&gt; DEBU 0a0 waiting for container(lscc-1.4.3) lock</span><br><span class="line">2019-09-09 07:52:09.915 UTC [container] lockContainer -&gt; DEBU 0a1 got container (lscc-1.4.3) lock</span><br><span class="line">2019-09-09 07:52:09.915 UTC [container] unlockContainer -&gt; DEBU 0a2 container lock deleted(lscc-1.4.3)</span><br><span class="line">2019-09-09 07:52:09.915 UTC [inproccontroller] func2 -&gt; DEBU 0a3 chaincode-support started for  lscc-1.4.3</span><br><span class="line">2019-09-09 07:52:09.915 UTC [inproccontroller] func1 -&gt; DEBU 0a4 chaincode started for lscc-1.4.3</span><br><span class="line">// 以上日志对应的代码流程在上文都讲到了</span><br><span class="line"></span><br><span class="line">// 以下是交互过程peer日志</span><br><span class="line">// peer收到容器的注册消息</span><br><span class="line">2019-09-09 07:52:09.916 UTC [chaincode] handleMessage -&gt; DEBU 0a5 [] Fabric side handling ChaincodeMessage of type: REGISTER in state created</span><br><span class="line">2019-09-09 07:52:09.916 UTC [chaincode] HandleRegister -&gt; DEBU 0a6 Received REGISTER in state created</span><br><span class="line">2019-09-09 07:52:09.916 UTC [chaincode] Register -&gt; DEBU 0a7 registered handler complete for chaincode lscc:1.4.3</span><br><span class="line">2019-09-09 07:52:09.916 UTC [chaincode] HandleRegister -&gt; DEBU 0a8 Got REGISTER for chaincodeID = name:&quot;lscc:1.4.3&quot; , sending back REGISTERED</span><br><span class="line">2019-09-09 07:52:09.920 UTC [grpc] HandleSubConnStateChange -&gt; DEBU 0a9 pickfirstBalancer: HandleSubConnStateChange: 0xc0026318c0, READY</span><br><span class="line">2019-09-09 07:52:09.923 UTC [chaincode] HandleRegister -&gt; DEBU 0aa Changed state to established for name:&quot;lscc:1.4.3&quot;</span><br><span class="line"></span><br><span class="line">// peer发送ready消息</span><br><span class="line">2019-09-09 07:52:09.923 UTC [chaincode] sendReady -&gt; DEBU 0ab sending READY for chaincode name:&quot;lscc:1.4.3&quot;</span><br><span class="line">2019-09-09 07:52:09.923 UTC [chaincode] sendReady -&gt; DEBU 0ac Changed to state ready for chaincode name:&quot;lscc:1.4.3&quot;</span><br><span class="line"></span><br><span class="line">// 已经完成启动容器</span><br><span class="line">2019-09-09 07:52:09.923 UTC [chaincode] Launch -&gt; DEBU 0ad launch complete</span><br><span class="line">2019-09-09 07:52:09.924 UTC [chaincode] Execute -&gt; DEBU 0ae Entry</span><br><span class="line">// 收到容器COMPLETED消息</span><br><span class="line">2019-09-09 07:52:09.925 UTC [chaincode] handleMessage -&gt; DEBU 0af [01b03aae] Fabric side handling ChaincodeMessage of type: COMPLETED in state ready</span><br><span class="line"></span><br><span class="line">// 通知scc，部署已经完成</span><br><span class="line">2019-09-09 07:52:09.925 UTC [chaincode] Notify -&gt; DEBU 0b0 [01b03aae] notifying Txid:01b03aae-17a6-4b63-874e-dc20d6f5df0c, channelID:</span><br><span class="line">2019-09-09 07:52:09.925 UTC [chaincode] Execute -&gt; DEBU 0b1 Exit</span><br><span class="line">2019-09-09 07:52:09.925 UTC [sccapi] deploySysCC -&gt; INFO 0b2 system chaincode lscc/(github.com/hyperledger/fabric/core/scc/lscc) deployed</span><br></pre></td></tr></table></figure>
<p>可以到REGISTER、READY、COMPLETED等消息，以及状态的改变：created、ready。</p>
<p>但前面还没有介绍Peer和链码容器之间的通信，所以不展示代码了，展示一下Peer和链码容器的消息交互图：</p>
<p><img src="http://img.lessisbetter.site/2019-09-deploycc-msg.png" alt=""></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2019/09/06/fabric-source-endorser-policy-flow/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="区块链、Go语言">
      <meta itemprop="image" content="http://img.lessisbetter.site/gzh-qrcode-logo-small.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Go语言充电站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/06/fabric-source-endorser-policy-flow/" class="post-title-link" itemprop="url">Fabric 1.4源码解读 1：背书策略是怎么使用的</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-09-06 16:39:45" itemprop="dateCreated datePublished" datetime="2019-09-06T16:39:45+08:00">2019-09-06</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-05 15:04:50" itemprop="dateModified" datetime="2019-12-05T15:04:50+08:00">2019-12-05</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://img.lessisbetter.site/2019-09-endorser-policy.png" alt="endorser policy"></p>
<p>背书策略是Fabric中的一个重要一环，想梳理一下背书策略的上链和使用流程。</p>
<p>背书策略是部署和升级链码时使用的，需要发送配置交易，所以尝试了从背书节点收到交易，然后处理交易的流程入手，找到背书策略的入口，结果毫无头绪。</p>
<p>换一种思路，从使用入手，向上追溯，这种就非常顺利了。</p>
<h2 id="从背书策略的使用入手"><a href="#从背书策略的使用入手" class="headerlink" title="从背书策略的使用入手"></a>从背书策略的使用入手</h2><p>VSCC会利用背书策略，并且背书策略不满足时会返回一个：背书策略不满足的错误，每一个上链的交易详细中都有这么一个Validation字段，为0代表有效交易，否则是无效交易，并用数字表示原因，背书策略不满足的序号就是10。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TxValidationCode <span class="keyword">int32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	...</span><br><span class="line">	TxValidationCode_ENDORSEMENT_POLICY_FAILURE   TxValidationCode = <span class="number">10</span></span><br><span class="line">	...</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><code>TxValidationCode_ENDORSEMENT_POLICY_FAILURE</code>被<code>VSCCValidateTx</code>使用，系统链码和普通链码都有背书策略需要满足，下面代码片是普通链码部分，可以发现调用<code>VSCCValidateTxForCC</code>验证交易。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// VSCCValidateTx executes vscc validation for transaction</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *VsccValidatorImpl)</span> <span class="title">VSCCValidateTx</span><span class="params">(seq <span class="keyword">int</span>, payload *common.Payload, envBytes []<span class="keyword">byte</span>, block *common.Block)</span> <span class="params">(error, peer.TxValidationCode)</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> err = v.VSCCValidateTxForCC(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> err.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> *commonerrors.VSCCEndorsementPolicyError:</span><br><span class="line">      <span class="keyword">return</span> err, peer.TxValidationCode_ENDORSEMENT_POLICY_FAILURE</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> err, peer.TxValidationCode_INVALID_OTHER_REASON</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个chaincode都会提供escc和vscc，现在都是默认的，也就是说escc和vscc都可以是具备可插拔的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode list -C mychannel --instantiated</span><br><span class="line">Get instantiated chaincodes on channel mychannel:</span><br><span class="line">Name: mycc, Version: 1.1, Path: github.com/chaincode/chaincode_example02/go/, Escc: escc, Vscc: vscc</span><br></pre></td></tr></table></figure>
<p><code>VSCCValidateTxForCC</code>会从交易的context中获取验证插件，然后利用插件验证交易。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *VsccValidatorImpl)</span> <span class="title">VSCCValidateTxForCC</span><span class="params">(ctx *Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	logger.Debug(<span class="string">"Validating"</span>, ctx, <span class="string">"with plugin"</span>)</span><br><span class="line">  <span class="comment">// 使用插件验证交易</span></span><br><span class="line">	err := v.pluginValidator.ValidateWithPlugin(ctx)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// If the error is a pluggable validation execution error, cast it to the common errors ExecutionFailureError.</span></span><br><span class="line">	<span class="keyword">if</span> e, isExecutionError := err.(*validation.ExecutionFailureError); isExecutionError &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;commonerrors.VSCCExecutionFailureError&#123;Err: e&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Else, treat it as an endorsement error.</span></span><br><span class="line">	<span class="keyword">return</span> &amp;commonerrors.VSCCEndorsementPolicyError&#123;Err: err&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pv *PluginValidator)</span> <span class="title">ValidateWithPlugin</span><span class="params">(ctx *Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// 获取vscc插件</span></span><br><span class="line">	plugin, err := pv.getOrCreatePlugin(ctx)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;validation.ExecutionFailureError&#123;</span><br><span class="line">			Reason: fmt.Sprintf(<span class="string">"plugin with name %s couldn't be used: %v"</span>, ctx.VSCCName, err),</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 利用插件验证</span></span><br><span class="line">	err = plugin.Validate(ctx.Block, ctx.Namespace, ctx.Seq, <span class="number">0</span>, SerializedPolicy(ctx.Policy))</span><br><span class="line">	validityStatus := <span class="string">"valid"</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		validityStatus = fmt.Sprintf(<span class="string">"invalid: %v"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	logger.Debug(<span class="string">"Transaction"</span>, ctx.TxID, <span class="string">"appears to be"</span>, validityStatus)</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Plugin validates transactions</span></span><br><span class="line"><span class="keyword">type</span> Plugin <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Validate returns nil if the action at the given position inside the transaction</span></span><br><span class="line">	<span class="comment">// at the given position in the given block is valid, or an error if not.</span></span><br><span class="line">	Validate(block *common.Block, namespace <span class="keyword">string</span>, txPosition <span class="keyword">int</span>, actionPosition <span class="keyword">int</span>, contextData ...ContextDatum) error</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Init injects dependencies into the instance of the Plugin</span></span><br><span class="line">	Init(dependencies ...Dependency) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当前验证插件有2种实现，<code>TxValidatorV1_2</code>和<code>V1_3Validation</code>,<code>Validate</code>还从context取出了序列化的背书策略，vscc会调用PolicyEvalutor交易的背书是否满足背书策略。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *DefaultValidation)</span> <span class="title">Validate</span><span class="params">(block *common.Block, namespace <span class="keyword">string</span>, txPosition <span class="keyword">int</span>, actionPosition <span class="keyword">int</span>, contextData ...validation.ContextDatum)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(contextData) == <span class="number">0</span> &#123;</span><br><span class="line">		logger.Panicf(<span class="string">"Expected to receive policy bytes in context data"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 拿到序列化后的policy</span></span><br><span class="line">	serializedPolicy, isSerializedPolicy := contextData[<span class="number">0</span>].(SerializedPolicy)</span><br><span class="line">	<span class="keyword">if</span> !isSerializedPolicy &#123;</span><br><span class="line">		logger.Panicf(<span class="string">"Expected to receive a serialized policy in the first context data"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> block == <span class="literal">nil</span> || block.Data == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">"empty block"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> txPosition &gt;= <span class="built_in">len</span>(block.Data.Data) &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.Errorf(<span class="string">"block has only %d transactions, but requested tx at position %d"</span>, <span class="built_in">len</span>(block.Data.Data), txPosition)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> block.Header == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.Errorf(<span class="string">"no block header"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用不同版本的validator进行验证</span></span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> v.Capabilities.V1_3Validation():</span><br><span class="line">		err = v.TxValidatorV1_3.Validate(block, namespace, txPosition, actionPosition, serializedPolicy.Bytes())</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> v.Capabilities.V1_2Validation():</span><br><span class="line">		<span class="keyword">fallthrough</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		err = v.TxValidatorV1_2.Validate(block, namespace, txPosition, actionPosition, serializedPolicy.Bytes())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	logger.Debugf(<span class="string">"block %d, namespace: %s, tx %d validation results is: %v"</span>, block.Header.Number, namespace, txPosition, err)</span><br><span class="line">	<span class="keyword">return</span> convertErrorTypeOrPanic(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证代码使用v2/validation_logic.go中的实现</span></span><br><span class="line"><span class="comment">// Validate validates the given envelope corresponding to a transaction with an endorsement</span></span><br><span class="line"><span class="comment">// policy as given in its serialized form</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(vscc *Validator)</span> <span class="title">Validate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	block *common.Block,</span></span></span><br><span class="line"><span class="function"><span class="params">	namespace <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	txPosition <span class="keyword">int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	actionPosition <span class="keyword">int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	policyBytes []<span class="keyword">byte</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="title">commonerrors</span>.<span class="title">TxValidationError</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// evaluate the signature set against the policy</span></span><br><span class="line">  err = vscc.policyEvaluator.Evaluate(policyBytes, signatureSet)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    logger.Warningf(<span class="string">"Endorsement policy failure for transaction txid=%s, err: %s"</span>, chdr.GetTxId(), err.Error())</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(signatureSet) &lt; <span class="built_in">len</span>(<span class="built_in">cap</span>.Action.Endorsements) &#123;</span><br><span class="line">      <span class="comment">// Warning: duplicated identities exist, endorsement failure might be cause by this reason</span></span><br><span class="line">      <span class="keyword">return</span> policyErr(errors.New(DUPLICATED_IDENTITY_ERROR))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> policyErr(fmt.Errorf(<span class="string">"VSCC error: endorsement policy failure, err: %s"</span>, err))</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PolicyEvaluator evaluates policies</span></span><br><span class="line"><span class="keyword">type</span> PolicyEvaluator <span class="keyword">interface</span> &#123;</span><br><span class="line">	validation.Dependency</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Evaluate takes a set of SignedData and evaluates whether this set of signatures satisfies</span></span><br><span class="line">	<span class="comment">// the policy with the given bytes</span></span><br><span class="line">	Evaluate(policyBytes []<span class="keyword">byte</span>, signatureSet []*common.SignedData) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Evaluate</code>会创建背书策略实例，然后利用背书策略验证背书签名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// Evaluate takes a set of SignedData and evaluates whether this set of signatures satisfies the policy</span><br><span class="line">func (id *PolicyEvaluator) Evaluate(policyBytes []byte, signatureSet []*common.SignedData) error &#123;</span><br><span class="line">	pp := cauthdsl.NewPolicyProvider(id.IdentityDeserializer)</span><br><span class="line">	policy, _, err := pp.NewPolicy(policyBytes)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return err</span><br><span class="line">	&#125;</span><br><span class="line">	return policy.Evaluate(signatureSet)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Policy is used to determine if a signature is valid</span><br><span class="line">type Policy interface &#123;</span><br><span class="line">	// Evaluate takes a set of SignedData and evaluates whether this set of signatures satisfies the policy</span><br><span class="line">	Evaluate(signatureSet []*cb.SignedData) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Evaluate takes a set of SignedData and evaluates whether this set of signatures satisfies the policy</span><br><span class="line">func (p *policy) Evaluate(signatureSet []*cb.SignedData) error &#123;</span><br><span class="line">	if p == nil &#123;</span><br><span class="line">		return fmt.Errorf(&quot;No such policy&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	idAndS := make([]IdentityAndSignature, len(signatureSet))</span><br><span class="line">	for i, sd := range signatureSet &#123;</span><br><span class="line">		idAndS[i] = &amp;deserializeAndVerify&#123;</span><br><span class="line">			signedData:   sd,</span><br><span class="line">			deserializer: p.deserializer,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ok := p.evaluator(deduplicate(idAndS), make([]bool, len(signatureSet)))</span><br><span class="line">	if !ok &#123;</span><br><span class="line">		return errors.New(&quot;signature set did not satisfy policy&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体背书验证签名的实现，当下就先不关心了。<strong>回过头来想一下，VSCC从哪拿到了背书策略？</strong></p>
<h2 id="VSCC的背书策略哪来的？"><a href="#VSCC的背书策略哪来的？" class="headerlink" title="VSCC的背书策略哪来的？"></a>VSCC的背书策略哪来的？</h2><p>回到上文第一次出现背书策略的地方：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func (pv *PluginValidator) ValidateWithPlugin(ctx *Context) error &#123;</span><br><span class="line">  err = plugin.Validate(ctx.Block, ctx.Namespace, ctx.Seq, 0, SerializedPolicy(ctx.Policy))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Context defines information about a transaction</span><br><span class="line">// that is being validated</span><br><span class="line">type Context struct &#123;</span><br><span class="line">	Seq       int</span><br><span class="line">	Envelope  []byte</span><br><span class="line">	TxID      string</span><br><span class="line">	Channel   string</span><br><span class="line">	VSCCName  string</span><br><span class="line">	Policy    []byte // 背书策略</span><br><span class="line">	Namespace string</span><br><span class="line">	Block     *common.Block</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>VSCCValidateTx</code>函数会创建Context，填写policy字段，其中policy是调用<code>GetInfoForValidate</code>获取的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *VsccValidatorImpl)</span> <span class="title">VSCCValidateTx</span><span class="params">(seq <span class="keyword">int</span>, payload *common.Payload, envBytes []<span class="keyword">byte</span>, block *common.Block)</span> <span class="params">(error, peer.TxValidationCode)</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 普通链码</span></span><br><span class="line">  <span class="keyword">if</span> !v.sccprovider.IsSysCC(ccID) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 获取policy、vscc等</span></span><br><span class="line">    <span class="comment">// Get latest chaincode version, vscc and validate policy</span></span><br><span class="line">    txcc, vscc, policy, err := v.GetInfoForValidate(chdr, ns)</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// do VSCC validation</span></span><br><span class="line">    ctx := &amp;Context&#123;</span><br><span class="line">      Seq:       seq,</span><br><span class="line">      Envelope:  envBytes,</span><br><span class="line">      Block:     block,</span><br><span class="line">      TxID:      chdr.TxId,</span><br><span class="line">      Channel:   chdr.ChannelId,</span><br><span class="line">      Namespace: ns,</span><br><span class="line">      Policy:    policy, <span class="comment">// Here</span></span><br><span class="line">      VSCCName:  vscc.ChaincodeName,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err = v.VSCCValidateTxForCC(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">switch</span> err.(<span class="keyword">type</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> *commonerrors.VSCCEndorsementPolicyError:</span><br><span class="line">        <span class="keyword">return</span> err, peer.TxValidationCode_ENDORSEMENT_POLICY_FAILURE</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> err, peer.TxValidationCode_INVALID_OTHER_REASON</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// SCC</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>GetInfoForValidate</code>先是获取了<code>ChaincodeDefinition</code>，它记录了peer对某个链码的proposal背书和验证的必要信息，然后利用<code>ChaincodeDefinition.Validation</code>获取了policy。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetInfoForValidate gets the ChaincodeInstance(with latest version) of tx, vscc and policy from lscc</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *VsccValidatorImpl)</span> <span class="title">GetInfoForValidate</span><span class="params">(chdr *common.ChannelHeader, ccID <span class="keyword">string</span>)</span> <span class="params">(*sysccprovider.ChaincodeInstance, *sysccprovider.ChaincodeInstance, []<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	cc := &amp;sysccprovider.ChaincodeInstance&#123;</span><br><span class="line">		ChainID:          chdr.ChannelId,</span><br><span class="line">		ChaincodeName:    ccID,</span><br><span class="line">		ChaincodeVersion: coreUtil.GetSysCCVersion(),</span><br><span class="line">	&#125;</span><br><span class="line">	vscc := &amp;sysccprovider.ChaincodeInstance&#123;</span><br><span class="line">		ChainID:          chdr.ChannelId,</span><br><span class="line">		ChaincodeName:    <span class="string">"vscc"</span>,                     <span class="comment">// default vscc for system chaincodes</span></span><br><span class="line">		ChaincodeVersion: coreUtil.GetSysCCVersion(), <span class="comment">// Get vscc version</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> policy []<span class="keyword">byte</span></span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	<span class="keyword">if</span> !v.sccprovider.IsSysCC(ccID) &#123;</span><br><span class="line">		<span class="comment">// when we are validating a chaincode that is not a</span></span><br><span class="line">		<span class="comment">// system CC, we need to ask the CC to give us the name</span></span><br><span class="line">		<span class="comment">// of VSCC and of the policy that should be used</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// obtain name of the VSCC and the policy</span></span><br><span class="line">		<span class="comment">// 获取cc 定义</span></span><br><span class="line">		cd, err := v.getCDataForCC(chdr.ChannelId, ccID)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			msg := fmt.Sprintf(<span class="string">"Unable to get chaincode data from ledger for txid %s, due to %s"</span>, chdr.TxId, err)</span><br><span class="line">			logger.Errorf(msg)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		cc.ChaincodeName = cd.CCName()</span><br><span class="line">		cc.ChaincodeVersion = cd.CCVersion()</span><br><span class="line">		<span class="comment">// 拿到policy</span></span><br><span class="line">		vscc.ChaincodeName, policy = cd.Validation()</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// when we are validating a system CC, we use the default</span></span><br><span class="line">		<span class="comment">// VSCC and a default policy that requires one signature</span></span><br><span class="line">		<span class="comment">// from any of the members of the channel</span></span><br><span class="line">		p := cauthdsl.SignedByAnyMember(v.support.GetMSPIDs(chdr.ChannelId))</span><br><span class="line">		policy, err = utils.Marshal(p)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> cc, vscc, policy, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------- ChaincodeDefinition - interface for ChaincodeData ------</span></span><br><span class="line"><span class="comment">// ChaincodeDefinition describes all of the necessary information for a peer to decide whether to endorse</span></span><br><span class="line"><span class="comment">// a proposal and whether to validate a transaction, for a particular chaincode.</span></span><br><span class="line"><span class="keyword">type</span> ChaincodeDefinition <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// CCName returns the name of this chaincode (the name it was put in the ChaincodeRegistry with).</span></span><br><span class="line">	CCName() <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Hash returns the hash of the chaincode.</span></span><br><span class="line">	Hash() []<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// CCVersion returns the version of the chaincode.</span></span><br><span class="line">	CCVersion() <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Validation returns how to validate transactions for this chaincode.</span></span><br><span class="line">	<span class="comment">// The string returned is the name of the validation method (usually 'vscc')</span></span><br><span class="line">	<span class="comment">// and the bytes returned are the argument to the validation (in the case of</span></span><br><span class="line">	<span class="comment">// 'vscc', this is a marshaled pb.VSCCArgs message).</span></span><br><span class="line">	Validation() (<span class="keyword">string</span>, []<span class="keyword">byte</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Endorsement returns how to endorse proposals for this chaincode.</span></span><br><span class="line">	<span class="comment">// The string returns is the name of the endorsement method (usually 'escc').</span></span><br><span class="line">	Endorsement() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ChaincodeData</code>实现了<code>ChaincodeDefinition</code>接口，<code>ChaincodeData</code>是LSCC保存的数据，它其中有1个字段就是Policy。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Validation returns how to validate transactions for this chaincode.</span></span><br><span class="line"><span class="comment">// The string returned is the name of the validation method (usually 'vscc')</span></span><br><span class="line"><span class="comment">// and the bytes returned are the argument to the validation (in the case of</span></span><br><span class="line"><span class="comment">// 'vscc', this is a marshaled pb.VSCCArgs message).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cd *ChaincodeData)</span> <span class="title">Validation</span><span class="params">()</span> <span class="params">(<span class="keyword">string</span>, []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> cd.Vscc, cd.Policy</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------- ChaincodeData is stored on the LSCC -------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ChaincodeData defines the datastructure for chaincodes to be serialized by proto</span></span><br><span class="line"><span class="comment">// Type provides an additional check by directing to use a specific package after instantiation</span></span><br><span class="line"><span class="comment">// Data is Type specifc (see CDSPackage and SignedCDSPackage)</span></span><br><span class="line"><span class="keyword">type</span> ChaincodeData <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Name of the chaincode</span></span><br><span class="line">	Name <span class="keyword">string</span> <span class="string">`protobuf:"bytes,1,opt,name=name"`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Version of the chaincode</span></span><br><span class="line">	Version <span class="keyword">string</span> <span class="string">`protobuf:"bytes,2,opt,name=version"`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Escc for the chaincode instance</span></span><br><span class="line">	Escc <span class="keyword">string</span> <span class="string">`protobuf:"bytes,3,opt,name=escc"`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Vscc for the chaincode instance</span></span><br><span class="line">	Vscc <span class="keyword">string</span> <span class="string">`protobuf:"bytes,4,opt,name=vscc"`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 背书策略</span></span><br><span class="line">	<span class="comment">// Policy endorsement policy for the chaincode instance</span></span><br><span class="line">	Policy []<span class="keyword">byte</span> <span class="string">`protobuf:"bytes,5,opt,name=policy,proto3"`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Data data specific to the package</span></span><br><span class="line">	Data []<span class="keyword">byte</span> <span class="string">`protobuf:"bytes,6,opt,name=data,proto3"`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Id of the chaincode that's the unique fingerprint for the CC This is not</span></span><br><span class="line">	<span class="comment">// currently used anywhere but serves as a good eyecatcher</span></span><br><span class="line">	Id []<span class="keyword">byte</span> <span class="string">`protobuf:"bytes,7,opt,name=id,proto3"`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// InstantiationPolicy for the chaincode</span></span><br><span class="line">	InstantiationPolicy []<span class="keyword">byte</span> <span class="string">`protobuf:"bytes,8,opt,name=instantiation_policy,proto3"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LSCC的Policy哪来的？"><a href="#LSCC的Policy哪来的？" class="headerlink" title="LSCC的Policy哪来的？"></a>LSCC的Policy哪来的？</h2><blockquote>
<p>提醒：链码实例化在代码里使用<strong>Deploy</strong>，而不是Instantiate，这样可以让代码更简洁，所以链码实例化也常称为链码部署。</p>
</blockquote>
<p><code>executeDeploy</code>为部署链码，也就是在部署链码的时候会保存背书策略。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// executeDeploy implements the "instantiate" Invoke transaction</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lscc *LifeCycleSysCC)</span> <span class="title">executeDeploy</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	stub shim.ChaincodeStubInterface,</span></span></span><br><span class="line"><span class="function"><span class="params">	chainname <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	cds *pb.ChaincodeDeploymentSpec,</span></span></span><br><span class="line"><span class="function"><span class="params">	policy []<span class="keyword">byte</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	escc []<span class="keyword">byte</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	vscc []<span class="keyword">byte</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	cdfs *ccprovider.ChaincodeData,</span></span></span><br><span class="line"><span class="function"><span class="params">	ccpackfs ccprovider.CCPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">	collectionConfigBytes []<span class="keyword">byte</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(*ccprovider.ChaincodeData, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">//just test for existence of the chaincode in the LSCC</span></span><br><span class="line">	chaincodeName := cds.ChaincodeSpec.ChaincodeId.Name</span><br><span class="line">	_, err := lscc.getCCInstance(stub, chaincodeName)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, ExistsErr(chaincodeName)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//retain chaincode specific data and fill channel specific ones</span></span><br><span class="line">	cdfs.Escc = <span class="keyword">string</span>(escc)</span><br><span class="line">	cdfs.Vscc = <span class="keyword">string</span>(vscc)</span><br><span class="line">	<span class="comment">// 保存背书策略</span></span><br><span class="line">	cdfs.Policy = policy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>executeDeployOrUpgrade</code>是执行链码实例化和升级时调用，它会传递Policy，在链码部署和升级时都会保存背书策略。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// executeDeployOrUpgrade routes the code path either to executeDeploy or executeUpgrade</span></span><br><span class="line"><span class="comment">// depending on its function argument</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lscc *LifeCycleSysCC)</span> <span class="title">executeDeployOrUpgrade</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	stub shim.ChaincodeStubInterface,</span></span></span><br><span class="line"><span class="function"><span class="params">	chainname <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	cds *pb.ChaincodeDeploymentSpec,</span></span></span><br><span class="line"><span class="function"><span class="params">	policy, escc, vscc, collectionConfigBytes []<span class="keyword">byte</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	function <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(*ccprovider.ChaincodeData, error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	chaincodeName := cds.ChaincodeSpec.ChaincodeId.Name</span><br><span class="line">	chaincodeVersion := cds.ChaincodeSpec.ChaincodeId.Version</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := lscc.isValidChaincodeName(chaincodeName); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := lscc.isValidChaincodeVersion(chaincodeName, chaincodeVersion); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ccpack, err := lscc.Support.GetChaincodeFromLocalStorage(chaincodeName, chaincodeVersion)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		retErrMsg := fmt.Sprintf(<span class="string">"cannot get package for chaincode (%s:%s)"</span>, chaincodeName, chaincodeVersion)</span><br><span class="line">		logger.Errorf(<span class="string">"%s-err:%s"</span>, retErrMsg, err)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"%s"</span>, retErrMsg)</span><br><span class="line">	&#125;</span><br><span class="line">	cd := ccpack.GetChaincodeData()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> function &#123;</span><br><span class="line">	<span class="keyword">case</span> DEPLOY:</span><br><span class="line">		<span class="keyword">return</span> lscc.executeDeploy(stub, chainname, cds, policy, escc, vscc, cd, ccpack, collectionConfigBytes)</span><br><span class="line">	<span class="keyword">case</span> UPGRADE:</span><br><span class="line">		<span class="keyword">return</span> lscc.executeUpgrade(stub, chainname, cds, policy, escc, vscc, cd, ccpack, collectionConfigBytes)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		logger.Panicf(<span class="string">"Programming error, unexpected function '%s'"</span>, function)</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">""</span>) <span class="comment">// unreachable code</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LSCC也实现了ChainCode接口，与普通链码的实现并没有区别，只不过LSCC并不运行在容器中。<code>LifeCycleSysCC.Invoke</code>会根据参数调用不同的函数，而部署和升级时，会调用<code>executeDeployOrUpgrade</code>部署链码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Invoke implements lifecycle functions "deploy", "start", "stop", "upgrade".</span></span><br><span class="line"><span class="comment">// Deploy's arguments -  &#123;[]byte("deploy"), []byte(&lt;chainname&gt;), &lt;unmarshalled pb.ChaincodeDeploymentSpec&gt;&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Invoke also implements some query-like functions</span></span><br><span class="line"><span class="comment">// Get chaincode arguments -  &#123;[]byte("getid"), []byte(&lt;chainname&gt;), []byte(&lt;chaincodename&gt;)&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lscc *LifeCycleSysCC)</span> <span class="title">Invoke</span><span class="params">(stub shim.ChaincodeStubInterface)</span> <span class="title">pb</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">switch</span> function &#123;</span><br><span class="line">    <span class="keyword">case</span> INSTALL:</span><br><span class="line">      ...</span><br><span class="line">    <span class="keyword">case</span> DEPLOY, UPGRADE:</span><br><span class="line">      <span class="comment">// 提取背书策略</span></span><br><span class="line">      <span class="comment">// optional arguments here (they can each be nil and may or may not be present)</span></span><br><span class="line">      <span class="comment">// args[3] is a marshalled SignaturePolicyEnvelope representing the endorsement policy</span></span><br><span class="line">      <span class="comment">// args[4] is the name of escc</span></span><br><span class="line">      <span class="comment">// args[5] is the name of vscc</span></span><br><span class="line">      <span class="comment">// args[6] is a marshalled CollectionConfigPackage struct</span></span><br><span class="line">      <span class="keyword">var</span> EP []<span class="keyword">byte</span></span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">len</span>(args) &gt; <span class="number">3</span> &amp;&amp; <span class="built_in">len</span>(args[<span class="number">3</span>]) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        EP = args[<span class="number">3</span>]</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p := cauthdsl.SignedByAnyMember(peer.GetMSPIDs(channel))</span><br><span class="line">        EP, err = utils.Marshal(p)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> shim.Error(err.Error())</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">      cd, err := lscc.executeDeployOrUpgrade(stub, channel, cds, EP, escc, vscc, collectionsConfig, function)</span><br><span class="line">      ...</span><br><span class="line">    <span class="keyword">case</span> ...:</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们终于知道Policy是哪来的，又是如何被使用的了。管理和查看链码信息，本质是创建一个调用LSCC的Proposal或者交易，链码的信息会保存在LSCC，当VSCC验证链码的交易时，会从LSCC获取信息，包括背书策略、vscc插件等，以验证交易。</p>
<p>最后，ESCC、VSCC也是进行了可插拔设计的。</p>
<p><img src="http://img.lessisbetter.site/2019-09-endorser-policy.png" alt="endorser policy"></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2019/09/05/etcd-raft-sources-structs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="区块链、Go语言">
      <meta itemprop="image" content="http://img.lessisbetter.site/gzh-qrcode-logo-small.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Go语言充电站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/05/etcd-raft-sources-structs/" class="post-title-link" itemprop="url">Etcd Raft架构设计和源码剖析3：重要结构体定义</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-09-05 21:59:35" itemprop="dateCreated datePublished" datetime="2019-09-05T21:59:35+08:00">2019-09-05</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-01-08 19:24:11" itemprop="dateModified" datetime="2020-01-08T19:24:11+08:00">2020-01-08</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>etcd raft定义了一些重要的结构体，来传递和表示raft使用到的数据。</p>
<p>在介绍各结构体之前，先澄清一下raft、log和state machine的关系，它们三个是独立的，没有隶属关系，尤其是state machine并不属于raft。</p>
<p><img src="http://img.lessisbetter.site/2019-08-raft-%E5%9B%BE1.png" alt="State machine"></p>
<p>Consensus Module指raft算法，它输出一致的Log Entry序列，State machine指应用Entry后得到的状态，状态机是并不是raft的一部分，而是用来存储数据的模块。</p>
<h2 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h2><p>每个Raft集群节点都是一个状态机，每个节点都使用相同的log entry序列修改状态机的数据，Entry就是每一个操作项，<strong>raft的核心能力就是为应用层提供序列相同的entry</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Entry <span class="keyword">struct</span> &#123;</span><br><span class="line">	Term             <span class="keyword">uint64</span>    <span class="string">`protobuf:"varint,2,opt,name=Term" json:"Term"`</span></span><br><span class="line">	Index            <span class="keyword">uint64</span>    <span class="string">`protobuf:"varint,3,opt,name=Index" json:"Index"`</span></span><br><span class="line">	Type             EntryType <span class="string">`protobuf:"varint,1,opt,name=Type,enum=raftpb.EntryType" json:"Type"`</span></span><br><span class="line">	Data             []<span class="keyword">byte</span>    <span class="string">`protobuf:"bytes,4,opt,name=Data" json:"Data,omitempty"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> EntryType <span class="keyword">int32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	EntryNormal       EntryType = <span class="number">0</span></span><br><span class="line">	EntryConfChange   EntryType = <span class="number">1</span></span><br><span class="line">	EntryConfChangeV2 EntryType = <span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>每一个Entry，都可以使用(Term, Index)进行唯一标记，相当于Entry的ID：</p>
<ul>
<li>Term：即raft论文中的Term，表明了当前Entry所属的Term。raft不使用绝对时间，而是使用相对时间，它把时间分割成了大小不等的term，每一轮选举都会开启一个新的term，term值会连续累加。如果当前的节点已经是Term 10缺收到了Term 8的Entry，Term 8的Entry已经过时，会被丢弃。</li>
<li>Index：每一个Entry都有一个的Index，代表当前Entry在log entry序列中的位置，每个index上最终只有1个达成共识的Entry。</li>
</ul>
<p>除了用于达成一致的Term和Index外，Entry还携带了数据：</p>
<ul>
<li>Type：表明当前Entry的类型，<code>EntryNormal</code>代表是Entry携带的是修改状态机的操作数据，<code>EntryConfChange</code>和<code>EntryConfChangeV2</code>代表的是Entry携带的是修改当前raft集群的配置。</li>
<li>Data：是序列化的数据，不同的Type类型，对应不同的Data。</li>
</ul>
<h2 id="Snapshot"><a href="#Snapshot" class="headerlink" title="Snapshot"></a>Snapshot</h2><p>在Entry特别多的场景下，会存在一些问题，比如现在有1亿条已经达成一致Entry，后面还有源源不断的Entry产生，是否有以下问题：</p>
<ol>
<li>这些Entry占用了大量的磁盘空间，但实际上过去的Entry已经对已经拥有这些Entry的节点没有意义了，只对那些没有Entry的节点有意义，leader把Entry发送给没有这些Entry节点，以让这些节点最终能和leader保持一致的状态。</li>
<li>有些follower非常慢，或者刚启动，或者重启过，与leader的当前状态已经严重脱节，让他们从Entry 0开始同步，然后应用到状态机，这种操作时间效率是不是非常慢？然后每一个Entry都会产生一个历史的状态，当产生新的状态之后，历史状态对当前节点也没有意义。</li>
</ol>
<p>解决这种问题的办法就是快照，比如虚拟机的快照，或者docker镜像（镜像本质也是一种快照），有了快照就可以把状态机快速恢复到快照时的状态，<strong>空间和时间上效率都能提高很多</strong>。</p>
<p>Raft可以定期产生一些快照，然后在这些快照上按序应用快照之后的Entry就能得到一致的状态。1亿个Entry + 1亿01个Entry得到的状态，跟第1亿个Entry后所产生的快照+1亿零1个Entry得到的状态是一致的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Snapshot <span class="keyword">struct</span> &#123;</span><br><span class="line">	Data             []<span class="keyword">byte</span>           <span class="string">`protobuf:"bytes,1,opt,name=data" json:"data,omitempty"`</span></span><br><span class="line">	Metadata         SnapshotMetadata <span class="string">`protobuf:"bytes,2,opt,name=metadata" json:"metadata"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SnapshotMetadata <span class="keyword">struct</span> &#123;</span><br><span class="line">	ConfState        ConfState <span class="string">`protobuf:"bytes,1,opt,name=conf_state,json=confState" json:"conf_state"`</span></span><br><span class="line">	Index            <span class="keyword">uint64</span>    <span class="string">`protobuf:"varint,2,opt,name=index" json:"index"`</span></span><br><span class="line">	Term             <span class="keyword">uint64</span>    <span class="string">`protobuf:"varint,3,opt,name=term" json:"term"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Data：是状态机中状态的快照。</li>
<li>Metadata：是快照自身相关的数据。<ul>
<li>ConfState：是快照时，当前raft的配置状态，这些状态数据并不在状态机中，所以需要进行保存。</li>
<li>Index、Term：快照所依据的Entry所在的Index和Term。</li>
</ul>
</li>
</ul>
<h2 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h2><p>Raft集群节点之间的通信只使用了1个结构体<code>Message</code>，Message中有一个<code>Type</code>成员，表明了当前的Message是哪种消息，比如可以是Raft论文中提到的AppendEntries，RequestVotes等，目前实际可以容纳19种类型的消息，每种消息对Raft都有不同的作用，具体见<a href="https://zhuanlan.zhihu.com/p/51065416" target="_blank" rel="noopener">这篇文章</a>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不同的Message类型会用到不同的字段</span></span><br><span class="line"><span class="keyword">type</span> Message <span class="keyword">struct</span> &#123;</span><br><span class="line">	Type             MessageType <span class="string">`protobuf:"varint,1,opt,name=type,enum=raftpb.MessageType" json:"type"`</span></span><br><span class="line">	To               <span class="keyword">uint64</span>      <span class="string">`protobuf:"varint,2,opt,name=to" json:"to"`</span></span><br><span class="line">	From             <span class="keyword">uint64</span>      <span class="string">`protobuf:"varint,3,opt,name=from" json:"from"`</span></span><br><span class="line">	Term             <span class="keyword">uint64</span>      <span class="string">`protobuf:"varint,4,opt,name=term" json:"term"`</span></span><br><span class="line">	LogTerm          <span class="keyword">uint64</span>      <span class="string">`protobuf:"varint,5,opt,name=logTerm" json:"logTerm"`</span></span><br><span class="line">	Index            <span class="keyword">uint64</span>      <span class="string">`protobuf:"varint,6,opt,name=index" json:"index"`</span></span><br><span class="line">	Entries          []Entry     <span class="string">`protobuf:"bytes,7,rep,name=entries" json:"entries"`</span></span><br><span class="line">	Commit           <span class="keyword">uint64</span>      <span class="string">`protobuf:"varint,8,opt,name=commit" json:"commit"`</span></span><br><span class="line">	Snapshot         Snapshot    <span class="string">`protobuf:"bytes,9,opt,name=snapshot" json:"snapshot"`</span></span><br><span class="line">	Reject           <span class="keyword">bool</span>        <span class="string">`protobuf:"varint,10,opt,name=reject" json:"reject"`</span></span><br><span class="line">	RejectHint       <span class="keyword">uint64</span>      <span class="string">`protobuf:"varint,11,opt,name=rejectHint" json:"rejectHint"`</span></span><br><span class="line">	Context          []<span class="keyword">byte</span>      <span class="string">`protobuf:"bytes,12,opt,name=context" json:"context,omitempty"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Message中包含了很多字段，不同的消息类型使用的字段组合不相同，可以从不同消息的处理逻辑中看出来。</p>
<ul>
<li>To, From：是消息的接收节点和发送节点的的Raft ID。</li>
<li>Term：创建Message时，发送节点所在的Term。</li>
<li>LogTerm：创建Message时，发送节点本地所保存的log entry序列中最大的Term，在选举的时候会使用。</li>
<li>Index：不同的消息类型，Index的含义不同。Term和Index与Entry中的Term和Index不一定会相同，因为某个follower可能比较慢，leader向follower发送已经committed的Entry。</li>
<li>Entries：发送给follower，待follower处理的Entry。</li>
<li>Commit：创建Message时，不同消息含义不同，Append时是发送节点本地已committed的Index，Heartbeat时是committed Index或者与follower匹配的Index。</li>
<li>Snapshot：leader传递给follower的snapshot。</li>
<li>Reject：投票和Append的响应消息使用，Reject表示拒绝leader发来的消息。</li>
<li>RejectHint：拒绝Append消息的响应消息使用，用来给leader提示，发送follower已有的最后一个Index。</li>
<li>Context：某些消息的附加信息，即用来存储通用的数据。比如竞选时，存放<code>campaignTransfer</code>。</li>
</ul>
<h2 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h2><p>etcd/raft不负责<strong>持久化数据存储</strong>和网络通信，网络数据都是通过Node接口的函数传入和传出raft。持久化数据存储由创建raft.Node的应用层负责，包含：</p>
<ul>
<li>应用层使用Entry生成的状态机，即一致的应用数据。</li>
<li>WAL：Write Ahead Log，历史的Entry（包含还未达成一致的Entry）和快照数据。</li>
</ul>
<p>Snapshot是已在节点间达成一致Entry的快照，快照之前的Entry必然都是已经达成一致的，而快照之后，有达成一致的，也有写入磁盘还未达成一致的Entry。etcd/raft会使用到这些Entry和快照，而<code>Storage</code>接口，就是用来读这些数据的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Storage is an interface that may be implemented by the application</span></span><br><span class="line"><span class="comment">// to retrieve log entries from storage.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If any Storage method returns an error, the raft instance will</span></span><br><span class="line"><span class="comment">// become inoperable and refuse to participate in elections; the</span></span><br><span class="line"><span class="comment">// application is responsible for cleanup and recovery in this case.</span></span><br><span class="line"><span class="keyword">type</span> Storage <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// TODO(tbg): split this into two interfaces, LogStorage and StateStorage.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// InitialState returns the saved HardState and ConfState information.</span></span><br><span class="line">	InitialState() (pb.HardState, pb.ConfState, error)</span><br><span class="line">	<span class="comment">// Entries returns a slice of log entries in the range [lo,hi).</span></span><br><span class="line">	<span class="comment">// MaxSize limits the total size of the log entries returned, but</span></span><br><span class="line">	<span class="comment">// Entries returns at least one entry if any.</span></span><br><span class="line">	Entries(lo, hi, maxSize <span class="keyword">uint64</span>) ([]pb.Entry, error)</span><br><span class="line">	<span class="comment">// Term returns the term of entry i, which must be in the range</span></span><br><span class="line">	<span class="comment">// [FirstIndex()-1, LastIndex()]. The term of the entry before</span></span><br><span class="line">	<span class="comment">// FirstIndex is retained for matching purposes even though the</span></span><br><span class="line">	<span class="comment">// rest of that entry may not be available.</span></span><br><span class="line">	Term(i <span class="keyword">uint64</span>) (<span class="keyword">uint64</span>, error)</span><br><span class="line">	<span class="comment">// LastIndex returns the index of the last entry in the log.</span></span><br><span class="line">	LastIndex() (<span class="keyword">uint64</span>, error)</span><br><span class="line">	<span class="comment">// FirstIndex returns the index of the first log entry that is</span></span><br><span class="line">	<span class="comment">// possibly available via Entries (older entries have been incorporated</span></span><br><span class="line">	<span class="comment">// into the latest Snapshot; if storage only contains the dummy entry the</span></span><br><span class="line">	<span class="comment">// first log entry is not available).</span></span><br><span class="line">	FirstIndex() (<span class="keyword">uint64</span>, error)</span><br><span class="line">	<span class="comment">// Snapshot returns the most recent snapshot.</span></span><br><span class="line">	<span class="comment">// If snapshot is temporarily unavailable, it should return ErrSnapshotTemporarilyUnavailable,</span></span><br><span class="line">	<span class="comment">// so raft state machine could know that Storage needs some time to prepare</span></span><br><span class="line">	<span class="comment">// snapshot and call Snapshot later.</span></span><br><span class="line">	Snapshot() (pb.Snapshot, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用这个接口，从应用层读取：</p>
<ul>
<li>InitialState：HardState和配置状态Confstate</li>
<li>Entries：根据Index获取连续的Entry</li>
<li>Term：获取某个Entry所在的Term</li>
<li>LastIndex：获取本节点已存储的最新的Entry的Index</li>
<li>FirstIndex：获取本节点已存储的第一个Entry的Index</li>
<li>Snapshot：获取本节点最近生成的Snapshot，Snapshot是由应用层创建的，并暂时保存起来，raft调用此接口读取</li>
</ul>
<p>每次都从磁盘文件读取这些数据，效率必然是不高的，所以etcd/raft内定义了<code>MemoryStorage</code>，它实现了<code>Storage</code>接口，并且提供了函数来维护最新快照后的Entry，关于<code>MemoryStorage</code>见<a href="#raftLog">raftLog</a>小节，其中的<code>storage</code>即为<code>MemoryStorage</code>。</p>
<h2 id="unstable"><a href="#unstable" class="headerlink" title="unstable"></a>unstable</h2><p>因为Entry的存储是由应用层负责的，所以raft需要暂时存储还未存到Storage中的Entry或者Snapshot，在创建Ready时，Entry和Snapshot会被封装到Ready，由应用层写入到storage。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unstable.entries[i] has raft log position i+unstable.offset.</span></span><br><span class="line"><span class="comment">// Note that unstable.offset may be less than the highest log</span></span><br><span class="line"><span class="comment">// position in storage; this means that the next write to storage</span></span><br><span class="line"><span class="comment">// might need to truncate the log before persisting unstable.entries.</span></span><br><span class="line"><span class="keyword">type</span> unstable <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// the incoming unstable snapshot, if any.</span></span><br><span class="line">	snapshot *pb.Snapshot</span><br><span class="line">	<span class="comment">// all entries that have not yet been written to storage.</span></span><br><span class="line">	entries []pb.Entry</span><br><span class="line">	offset  <span class="keyword">uint64</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Snapshot：是follower从leader收到的最新的Snapshot。</li>
<li>entries：对leader而已，是raft刚利用请求创建的Entry，对follower而言是从leader收到的Entry。</li>
<li>offset：Entries[i].Index = i + offset。</li>
</ul>
<h2 id="raftLog"><a href="#raftLog" class="headerlink" title="raftLog"></a>raftLog</h2><p>raft使用raftLog来管理当前Entry序列和Snapshot等信息，它由Storage、unstable、committed和applied组成。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> raftLog <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// storage contains all stable entries since the last snapshot.</span></span><br><span class="line">	storage Storage</span><br><span class="line"></span><br><span class="line">	<span class="comment">// unstable contains all unstable entries and snapshot.</span></span><br><span class="line">	<span class="comment">// they will be saved into storage.</span></span><br><span class="line">	unstable unstable</span><br><span class="line"></span><br><span class="line">	<span class="comment">// committed和applied是storage的2个整数下标</span></span><br><span class="line">	<span class="comment">// committed到applied需要Ready</span></span><br><span class="line">	<span class="comment">// committed is the highest log position that is known to be in</span></span><br><span class="line">	<span class="comment">// stable storage on a quorum of nodes.</span></span><br><span class="line">	committed <span class="keyword">uint64</span></span><br><span class="line">	<span class="comment">// applied is the highest log position that the application has</span></span><br><span class="line">	<span class="comment">// been instructed to apply to its state machine.</span></span><br><span class="line">	<span class="comment">// Invariant: applied &lt;= committed</span></span><br><span class="line">	applied <span class="keyword">uint64</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Storage和unstable前面已经介绍过了，所以介绍下committed和applied。</p>
<p>committed指最后一个在raft集群多数节点之间达成一致的Entry Index。</p>
<p>applied指当前节点被应用层应用到状态机的最后一个Entry Index。applied和committed之间的Entry就是等待被应用层应用到状态机的Entry。</p>
<p>前面提到Storage接口可以获取第一个索引firstIdx，最后一个索引lastIdx，在生成snapshot之后签名的Entry就可以删除了，所以firstidx是storage中snapshot后的第一个Entry的Index，lastIndex是storage中保存的最后一个Entry的Index，这个Entry可能还没有在raft集群多数节点之间达成一致，所以在committed之后，这些Entry是等待commit的Entry，leader发现某个Entry Index已经在多数节点之间达成一致，就会把committed移动到该Entry Index。</p>
<p><img src="http://img.lessisbetter.site/2019-08-raftLog.png" alt="raftLog"></p>
<h2 id="SoftState"><a href="#SoftState" class="headerlink" title="SoftState"></a>SoftState</h2><p>SoftState指易变的状态数据，记录了<strong>当前</strong>的Leader的Node ID，以及当前节点的角色。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SoftState provides state that is useful for logging and debugging.</span></span><br><span class="line"><span class="comment">// The state is volatile and does not need to be persisted to the WAL.</span></span><br><span class="line"><span class="keyword">type</span> SoftState <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// leader的Node ID</span></span><br><span class="line">	Lead <span class="keyword">uint64</span> <span class="comment">// must use atomic operations to access; keep 64-bit aligned.</span></span><br><span class="line">	<span class="comment">// 节点是什么角色：leader、follower...</span></span><br><span class="line">	RaftState StateType</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// StateType represents the role of a node in a cluster.</span></span><br><span class="line"><span class="keyword">type</span> StateType <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stmap = [...]<span class="keyword">string</span>&#123;</span><br><span class="line">	<span class="string">"StateFollower"</span>,</span><br><span class="line">	<span class="string">"StateCandidate"</span>,</span><br><span class="line">	<span class="string">"StateLeader"</span>,</span><br><span class="line">	<span class="string">"StatePreCandidate"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="HardState"><a href="#HardState" class="headerlink" title="HardState"></a>HardState</h2><p>HardState是写入到WAL（存储Entry的文件）的状态，可以在节点重启时恢复raft的状态，它了记录：</p>
<ul>
<li>Term：节点当前所在的Term。</li>
<li>Vote：节点在竞选期间所投的候选节点ID。</li>
<li>Commit：当前已经committed Entry Index。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HardState <span class="keyword">struct</span> &#123;</span><br><span class="line">	Term             <span class="keyword">uint64</span> <span class="string">`protobuf:"varint,1,opt,name=term" json:"term"`</span></span><br><span class="line">	Vote             <span class="keyword">uint64</span> <span class="string">`protobuf:"varint,2,opt,name=vote" json:"vote"`</span></span><br><span class="line">	Commit           <span class="keyword">uint64</span> <span class="string">`protobuf:"varint,3,opt,name=commit" json:"commit"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Ready"><a href="#Ready" class="headerlink" title="Ready"></a>Ready</h2><p>终于到etcd raft最重要的一个结构体了。raft使用Ready结构体对外传递数据，是多种数据的打包。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ready encapsulates the entries and messages that are ready to read,</span></span><br><span class="line"><span class="comment">// be saved to stable storage, committed or sent to other peers.</span></span><br><span class="line"><span class="comment">// All fields in Ready are read-only.</span></span><br><span class="line"><span class="keyword">type</span> Ready <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// The current volatile state of a Node.</span></span><br><span class="line">	<span class="comment">// SoftState will be nil if there is no update.</span></span><br><span class="line">	<span class="comment">// It is not required to consume or store SoftState.</span></span><br><span class="line">	*SoftState</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The current state of a Node to be saved to stable storage BEFORE</span></span><br><span class="line">	<span class="comment">// Messages are sent.</span></span><br><span class="line">	<span class="comment">// HardState will be equal to empty state if there is no update.</span></span><br><span class="line">	pb.HardState</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ReadStates can be used for node to serve linearizable read requests locally</span></span><br><span class="line">	<span class="comment">// when its applied index is greater than the index in ReadState.</span></span><br><span class="line">	<span class="comment">// Note that the readState will be returned when raft receives msgReadIndex.</span></span><br><span class="line">	<span class="comment">// The returned is only valid for the request that requested to read.</span></span><br><span class="line">	ReadStates []ReadState</span><br><span class="line"></span><br><span class="line">	<span class="comment">// unstable的entry，即待写入到storage的entry</span></span><br><span class="line">	<span class="comment">// Entries specifies entries to be saved to stable storage BEFORE</span></span><br><span class="line">	<span class="comment">// Messages are sent.</span></span><br><span class="line">	Entries []pb.Entry</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Snapshot specifies the snapshot to be saved to stable storage.</span></span><br><span class="line">	Snapshot pb.Snapshot</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 待applied的entry</span></span><br><span class="line">	<span class="comment">// CommittedEntries specifies entries to be committed to a</span></span><br><span class="line">	<span class="comment">// store/state-machine. These have previously been committed to stable</span></span><br><span class="line">	<span class="comment">// store.</span></span><br><span class="line">	CommittedEntries []pb.Entry</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Messages specifies outbound messages to be sent AFTER Entries are</span></span><br><span class="line">	<span class="comment">// committed to stable storage.</span></span><br><span class="line">	<span class="comment">// If it contains a MsgSnap message, the application MUST report back to raft</span></span><br><span class="line">	<span class="comment">// when the snapshot has been received or has failed by calling ReportSnapshot.</span></span><br><span class="line">	Messages []pb.Message</span><br><span class="line"></span><br><span class="line">	<span class="comment">// MustSync indicates whether the HardState and Entries must be synchronously</span></span><br><span class="line">	<span class="comment">// written to disk or if an asynchronous write is permissible.</span></span><br><span class="line">	MustSync <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SoftState、HardState、Entry、Snapshot、Message都已经介绍过，不再单独介绍含义。</p>
<p>Entries和CommittedEntries的区别是，Entries保存的是从unstable读取的Entry，它们即将被应用层写入storage，CommittedEntries是已经被Committed，还没有applied，应用层会把他们应用到状态机。</p>
<p>ReadStates用来处理读请求，MustSync用来指明应用层是否采用异步的方式写数据。</p>
<p>应用层在接收到Ready后，应当处理Ready中的每一个有效字段，处理完毕后，调用<code>Advance()</code>通知raft Ready已处理完毕。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2019/09/03/fabric-problem-of-peers-using-different-language-chaincode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="区块链、Go语言">
      <meta itemprop="image" content="http://img.lessisbetter.site/gzh-qrcode-logo-small.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Go语言充电站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/03/fabric-problem-of-peers-using-different-language-chaincode/" class="post-title-link" itemprop="url">Fabric 1.4不同peer使用不同语言链码的问题</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-09-03 11:50:31" itemprop="dateCreated datePublished" datetime="2019-09-03T11:50:31+08:00">2019-09-03</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-09-11 14:27:33" itemprop="dateModified" datetime="2019-09-11T14:27:33+08:00">2019-09-11</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>社区里在讨论一个问题，是由官方的文档引发的，文档上讲不同的peer可以使用不同语言的链码，前提是2份链码功能、接口等必须一致。</p>
<p><img src="http://img.lessisbetter.site/2019-09-fabric-chaincode-error.png" alt="fabric chaincode error"></p>
<p>大家的问题是：</p>
<blockquote>
<p>一个链码可以采用不同的语言实现，不同peer上使用不同的链码真的可行吗？</p>
</blockquote>
<p>经过实证，这是不可行的。</p>
<p>分2种情况，2种都有问题：</p>
<ol>
<li>不同peer安装不同语言链码，然后同时实例化：实例化后，只能启动发送实例化交易的peer拥有的语言的链码</li>
<li>部分peer先实例化，另外peer再安装不同语言链码：调用链码时报指纹不匹配错误</li>
</ol>
<h2 id="不同peer安装不同语言链码，然后同时实例化"><a href="#不同peer安装不同语言链码，然后同时实例化" class="headerlink" title="不同peer安装不同语言链码，然后同时实例化"></a>不同peer安装不同语言链码，然后同时实例化</h2><p>1、修改BFYN，只在peer0.org1和peer0.org2上安装Go语言链码，不进行后续操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Installing chaincode on peer0.org1...</span><br><span class="line">+ peer chaincode install -n mycc -v 1.0 -l golang -p github.com/chaincode/chaincode_example02/go/</span><br><span class="line">+ res=0</span><br><span class="line">+ set +x</span><br><span class="line">2019-09-03 02:08:43.813 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc</span><br><span class="line">2019-09-03 02:08:43.813 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc</span><br><span class="line">2019-09-03 02:08:44.108 UTC [chaincodeCmd] install -&gt; INFO 003 Installed remotely response:&lt;status:200 payload:&quot;OK&quot; &gt;</span><br><span class="line">===================== Chaincode is installed on peer0.org1 =====================</span><br><span class="line"></span><br><span class="line">Install chaincode on peer0.org2...</span><br><span class="line">+ peer chaincode install -n mycc -v 1.0 -l golang -p github.com/chaincode/chaincode_example02/go/</span><br><span class="line">+ res=0</span><br><span class="line">+ set +x</span><br><span class="line">2019-09-03 02:08:44.260 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc</span><br><span class="line">2019-09-03 02:08:44.260 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc</span><br><span class="line">2019-09-03 02:08:44.529 UTC [chaincodeCmd] install -&gt; INFO 003 Installed remotely response:&lt;status:200 payload:&quot;OK&quot; &gt;</span><br><span class="line">===================== Chaincode is installed on peer0.org2 =====================</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">========= All GOOD, BYFN execution completed ===========</span><br></pre></td></tr></table></figure>
<p>2、在peer1.org1上安装Java语言链码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@6cec20eb7502:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer chaincode install -n mycc -v 1.0 -l java -p /opt/gopath/src/github.com/chaincode/chaincode_example02/java/</span><br><span class="line">2019-09-03 03:19:44.710 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc</span><br><span class="line">2019-09-03 03:19:44.711 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc</span><br><span class="line">2019-09-03 03:19:44.754 UTC [chaincodeCmd] install -&gt; INFO 003 Installed remotely response:&lt;status:200 payload:&quot;OK&quot; &gt;</span><br></pre></td></tr></table></figure>
<p>3、在peer1.org1上发起实例化链码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@6cec20eb7502:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer chaincode instantiate -o orderer.example.com:7050 --tls true --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C mychannel -n mycc -l golang -v 1.0 -c &apos;&#123;&quot;Args&quot;:[&quot;init&quot;,&quot;a&quot;,&quot;100&quot;,&quot;b&quot;,&quot;200&quot;]&#125;&apos; -P &apos;OR (&apos;\&apos;&apos;Org1MSP.peer&apos;\&apos;&apos;,&apos;\&apos;&apos;Org2MSP.peer&apos;\&apos;&apos;)&apos;</span><br><span class="line">2019-09-03 03:22:12.430 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc</span><br><span class="line">2019-09-03 03:22:12.431 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc</span><br></pre></td></tr></table></figure>
<p>4、查看链码容器，只有peer1.org1的链码容器，peer0.org1和peer0.org2的链码容器都没有起来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  fabric-sdk-go-sample git:(master) ✗ docker ps</span><br><span class="line">CONTAINER ID        IMAGE                                                                                                  COMMAND                  CREATED             STATUS              PORTS                      NAMES</span><br><span class="line">f8f6aa8b5da6        dev-peer1.org1.example.com-mycc-1.0-cd123150154e6bf2df7ce682e0b1bcbea40499416f37a6da3aae14c4eb51b08d   &quot;/root/chaincode-jav…&quot;   37 seconds ago      Up 36 seconds                                  dev-peer1.org1.example.com-mycc-1.0</span><br><span class="line">6cec20eb7502        hyperledger/fabric-tools:latest                                                                        &quot;/bin/bash&quot;              About an hour ago   Up About an hour                               cli</span><br><span class="line">7e134fe7e8e9        hyperledger/fabric-peer:latest                                                                         &quot;peer node start&quot;        About an hour ago   Up About an hour    0.0.0.0:8051-&gt;8051/tcp     peer1.org1.example.com</span><br><span class="line">ed6f5511d938        hyperledger/fabric-peer:latest                                                                         &quot;peer node start&quot;        About an hour ago   Up About an hour    0.0.0.0:10051-&gt;10051/tcp   peer1.org2.example.com</span><br><span class="line">025a71178777        hyperledger/fabric-peer:latest                                                                         &quot;peer node start&quot;        About an hour ago   Up About an hour    0.0.0.0:7051-&gt;7051/tcp     peer0.org1.example.com</span><br><span class="line">8687dfd14e7b        hyperledger/fabric-peer:latest                                                                         &quot;peer node start&quot;        About an hour ago   Up About an hour    0.0.0.0:9051-&gt;9051/tcp     peer0.org2.example.com</span><br><span class="line">e9cc8b410d7f        hyperledger/fabric-orderer:latest                                                                      &quot;orderer&quot;                About an hour ago   Up About an hour    0.0.0.0:7050-&gt;7050/tcp     orderer.example.com</span><br></pre></td></tr></table></figure>
<h2 id="部分peer先实例化，另外peer再安装不同语言链码"><a href="#部分peer先实例化，另外peer再安装不同语言链码" class="headerlink" title="部分peer先实例化，另外peer再安装不同语言链码"></a>部分peer先实例化，另外peer再安装不同语言链码</h2><p>不改造BYFN，原生启动。peer0.org1，peer0.org2，peer1.org2都已经实例化了Go语言链码。</p>
<p>然后在peer1.org1上安装Java语言的链码，在执行Invoke或者查询，报指纹不匹配-数据不匹配的错误。</p>
<p>原因分析：操作链码时，会调用LSCC的<code>LifeCycleSysCC.getCCCode</code>获取链码，一份链码是从数据库取的，即当前链码容器的，一份链码是本地存储的，会对2份进行匹配，如果不匹配就会报指纹不匹配错误。</p>
<p>匹配函数为<code>CDSPackage.ValidateCC</code>，匹配项为：</p>
<ol>
<li>名称、版本</li>
<li>CodeHash、元数据Hash</li>
</ol>
<p>调用链码时报的指纹不匹配错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@d0533ffe1864:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer chaincode install -n mycc -v 1.0 -l java -p /opt/gopath/src/github.com/chaincode/chaincode_example02/java/</span><br><span class="line">2019-09-03 01:52:15.714 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc</span><br><span class="line">2019-09-03 01:52:15.714 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vscc</span><br><span class="line">2019-09-03 01:52:15.755 UTC [chaincodeCmd] install -&gt; INFO 003 Installed remotely response:&lt;status:200 payload:&quot;OK&quot; &gt;</span><br><span class="line">root@d0533ffe1864:/opt/gopath/src/github.com/hyperledger/fabric/peer#</span><br><span class="line">root@d0533ffe1864:/opt/gopath/src/github.com/hyperledger/fabric/peer#</span><br><span class="line">root@d0533ffe1864:/opt/gopath/src/github.com/hyperledger/fabric/peer#</span><br><span class="line">root@d0533ffe1864:/opt/gopath/src/github.com/hyperledger/fabric/peer#</span><br><span class="line">root@d0533ffe1864:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer chaincode query -C mychannel -n mycc -c &apos;&#123;&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]&#125;&apos;</span><br><span class="line">Error: endorsement failure during query. response: status:500 message:&quot;failed to execute transaction b8b740aab0e6dd10cfe62416240ef94bfb90a55358904233c4d60dd5a39e6fe3: [channel mychannel] failed to get chaincode container info for mycc:1.0: could not get chaincode code: chaincode fingerprint mismatch: data mismatch&quot;</span><br><span class="line">root@d0533ffe1864:/opt/gopath/src/github.com/hyperledger/fabric/peer#</span><br><span class="line">root@d0533ffe1864:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer chaincode invoke -o orderer.example.com:7050 --tls true --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C mychannel -n mycc --peerAddresses peer1.org1.example.com:8051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/tls/ca.crt  -c &apos;&#123;&quot;Args&quot;:[&quot;invoke&quot;,&quot;a&quot;,&quot;b&quot;,&quot;50&quot;]&#125;&apos;</span><br><span class="line">Error: endorsement failure during invoke. response: status:500 message:&quot;failed to execute transaction aec5a0ccbcf86032774dc80220b90419d2816cc3f050a104c1cfcde55a2247cb: [channel mychannel] failed to get chaincode container info for mycc:1.0: could not get chaincode code: chaincode fingerprint mismatch: data mismatch&quot;</span><br></pre></td></tr></table></figure>
<h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><p>另外，社区里的hucg编写了一篇源码文章：<a href="https://blog.csdn.net/love_feng_forever/article/details/100532324" target="_blank" rel="noopener">https://blog.csdn.net/love_feng_forever/article/details/100532324</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2019/09/02/hyperledger-projects/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="区块链、Go语言">
      <meta itemprop="image" content="http://img.lessisbetter.site/gzh-qrcode-logo-small.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Go语言充电站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/02/hyperledger-projects/" class="post-title-link" itemprop="url">Hyperledger项目介绍</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-09-02 15:04:06" itemprop="dateCreated datePublished" datetime="2019-09-02T15:04:06+08:00">2019-09-02</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-09-04 10:58:38" itemprop="dateModified" datetime="2019-09-04T10:58:38+08:00">2019-09-04</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Hyperledger下有许多区块链相关的项目，曾以为它们分别是不同的类别，专注不同的功能，梳理一下其实并不是这样，比如光区块链框架就有Fabric、Iroha和Sawtooth。</p>
<p><img src="http://img.lessisbetter.site/2019-09-hyperledger-projects.png" alt="hyperledger projects"></p>
<p>各项目的简要介绍以及TWGC的介绍，一定要看看Baohua Yang大佬的<a href="https://github.com/dWChina/ibm-opentech-ma/blob/master/fabric1.4LTS/02_Hyperledger_Overview.pdf" target="_blank" rel="noopener">PPT</a>，ppt介绍Hyperledger社区的现状，各子项目概览，以及发展方向，以及Hyperledger 中国技术工作组的最新动态。。</p>
<p>做Fabric相关的工作，需要关注Fabric、Cello、Caliper、Explorer等几个项目。</p>
<p><img src="http://img.lessisbetter.site/2019-09-fabric-projects-archs.png" alt="fabric projects arch"></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2019/09/02/fabric-sdk-go-chaincode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="区块链、Go语言">
      <meta itemprop="image" content="http://img.lessisbetter.site/gzh-qrcode-logo-small.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Go语言充电站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/02/fabric-sdk-go-chaincode/" class="post-title-link" itemprop="url">使用fabric-sdk-go操作链码</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-09-02 14:55:16" itemprop="dateCreated datePublished" datetime="2019-09-02T14:55:16+08:00">2019-09-02</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-09-05 11:45:15" itemprop="dateModified" datetime="2019-09-05T11:45:15+08:00">2019-09-05</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文把与fabric网络交互的baas、应用程序、客户端统称成为客户端，它们可以使用sdk和fabric网络进行交互，sdk调用grpc可以与指定的peer和orderer进行通信，本文的目的是在BYFN搭建的fabric网络的基础之上，展示如何使用fabric-sdk-go操作链码。</p>
<p><img src="http://img.lessisbetter.site/2019-09-fabric-sdk.png" alt="fabric sdk"></p>
<h2 id="fabric-sdk-go项目简介"><a href="#fabric-sdk-go项目简介" class="headerlink" title="fabric-sdk-go项目简介"></a>fabric-sdk-go项目简介</h2><p><a href="https://github.com/hyperledger/fabric-sdk-go" target="_blank" rel="noopener">fabric-sdk-go</a>是Fabric官方的Go语言SDK，它的目录结构如下：</p>
<p><img src="http://img.lessisbetter.site/2019-09-fabric-sd-go.png" alt="fabric sdk go"></p>
<p>有2个目录需要注意一下，internal和third_party，它们两个包含了sdk依赖的一些代码，来自于fabric、fabric-ca，当使用到fabric的一些类型时，应当使用以下的方式，而不是直接导入fabric或者fabric-ca：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"github.com/hyperledger/fabric-sdk-go/third_party/github.com/hyperledger/fabric/xxx"</span></span><br></pre></td></tr></table></figure>
<p>pkg目录是sdk的主要实现，<a href="https://godoc.org/github.com/hyperledger/fabric-sdk-go" target="_blank" rel="noopener">doc 文档</a>介绍了不同目录所提供的功能，以及给出了接口调用样例：</p>
<ul>
<li>pkg/fabsdk：主package，主要用来生成fabsdk以及各种其他pkg使用的option context。</li>
<li>pkg/client/channel：主要用来调用、查询链码，或者注册链码事件。</li>
<li>pkg/client/resmgmt：主要用来fabric网络的管理，比如创建、加入通道，安装、实例化和升级链码。</li>
<li>pkg/client/event:配合channel模块来进行链码事件注册和过滤。</li>
<li>pkg/client/ledger：主要用来账本的查询，查询区块、交易、配置等。</li>
<li>pkg/client/msp：主要用来管理fabric的成员关系。</li>
</ul>
<blockquote>
<p>想用好fabric-go-sdk，建议仔细看看<a href="https://godoc.org/github.com/hyperledger/fabric-sdk-go" target="_blank" rel="noopener">doc 文档</a>。</p>
</blockquote>
<h2 id="使用SDK步骤"><a href="#使用SDK步骤" class="headerlink" title="使用SDK步骤"></a>使用SDK步骤</h2><ol>
<li>为client编写配置文件config.yaml</li>
<li>为client创建fabric sdk实例fabsdk</li>
<li>为client创建resource manage client，<strong>简称RC</strong>，RC用来进行管理操作的client，比如通道的创建，链码的安装、实例化和升级等</li>
<li>为client创建channel client，<strong>简称CC</strong>，CC用来链码的调用、查询以及链码事件的注册和取消注册</li>
</ol>
<h2 id="SDK配置文件config-yaml"><a href="#SDK配置文件config-yaml" class="headerlink" title="SDK配置文件config.yaml"></a>SDK配置文件config.yaml</h2><p>client使用sdk与fabric网络交互，需要告诉sdk两类信息：</p>
<ol>
<li>我是谁：即当前client的信息，包含所属组织、密钥和证书文件的路径等，这是每个client专用的信息。</li>
<li>对方是谁：即fabric网络结构的信息，channel、org、orderer和peer等的怎么组合起当前fabric网络的，这些结构信息应当与<code>configytx.yaml</code>中是一致的。这是通用配置，每个客户端都可以拿来使用。另外，这部分信息并不需要是完整fabric网络信息，如果当前client只和部分节点交互，那配置文件中只需要包含所使用到的网络信息。</li>
</ol>
<p><img src="http://img.lessisbetter.site/2019-09-fabric-sdk-config.yaml.png" alt="fabric sdk config"></p>
<p>这里提供一个适合<a href="https://github.com/hyperledger/fabric-samples/tree/release-1.4/first-network" target="_blank" rel="noopener">BFYN</a>的精简配置文件<a href="https://github.com/Shitaibin/fabric-sdk-go-sample/blob/master/config/config.yaml" target="_blank" rel="noopener">fabric-sdk-go-sample/config.yaml</a>。</p>
<h2 id="使用go-mod管理依赖"><a href="#使用go-mod管理依赖" class="headerlink" title="使用go mod管理依赖"></a>使用go mod管理依赖</h2><p>fabric-sdk-go目前本身使用go modules管理依赖，从<a href="https://github.com/hyperledger/fabric-sdk-go/blob/master/go.mod" target="_blank" rel="noopener">go.mod</a>可知，依赖的一些包指定了具体的版本，如果项目依赖的版本和sdk依赖的版本不同，会产生编译问题。</p>
<p>建议项目也使用go moudles管理依赖，然后相同的软件包可以使用相同的版本，可以这样操作：</p>
<ol>
<li>go mod init初始化好项目的go.mod文件。</li>
<li>编写代码，完成后运行go mod run，会自动下载依赖的项目，但版本可能与fabric-sdk-go中的依赖版本不同，编译存在问题。</li>
<li>把<a href="https://github.com/hyperledger/fabric-sdk-go/blob/master/go.mod" target="_blank" rel="noopener">go.mod</a>中的内容复制到项目的go.mod中，然后保存，go mod会自动合并相同的依赖，运行go mod tidy，会自动添加新的依赖或删除不需要的依赖。</li>
</ol>
<p>项目的go mod样例可以参考<a href="https://github.com/securekey/fabric-examples/blob/master/fabric-cli/cmd/fabric-cli/go.mod" target="_blank" rel="noopener">securekey/fabric-examples … /go.mod</a>，<a href="https://github.com/Shitaibin/fabric-sdk-go-sample/blob/master/go.mod" target="_blank" rel="noopener">shitaibin/fabric-sdk-go-sample/go.mod</a>。</p>
<h2 id="创建Client"><a href="#创建Client" class="headerlink" title="创建Client"></a>创建Client</h2><h3 id="利用config-yaml创建fabsdk"><a href="#利用config-yaml创建fabsdk" class="headerlink" title="利用config.yaml创建fabsdk"></a>利用config.yaml创建fabsdk</h3><p>通过<code>config.FromFile</code>解析配置文件，然后通过<code>fabsdk.New</code>创建sdk实例。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"github.com/hyperledger/fabric-sdk-go/pkg/core/config"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"github.com/hyperledger/fabric-sdk-go/pkg/fabsdk"</span></span><br><span class="line"></span><br><span class="line">sdk, err := fabsdk.New(config.FromFile(c.ConfigPath))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  log.Panicf(<span class="string">"failed to create fabric sdk: %s"</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建RC"><a href="#创建RC" class="headerlink" title="创建RC"></a>创建RC</h3><p>管理员账号才能进行fabric网络的管理操作，所以创建rc一定要使用管理员账号。</p>
<p>通过<code>fabsdk.WithOrg(&quot;Org1&quot;)</code>和<code>fabsdk.WithUser(&quot;Admin&quot;)</code>指定Org1的Admin账户，使用<code>sdk.Context</code>创建<strong>clientProvider</strong>，然后通过<code>resmgmt.New</code>创建rc。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> 	<span class="string">"github.com/hyperledger/fabric-sdk-go/pkg/client/resmgmt"</span></span><br><span class="line"></span><br><span class="line">rcp := sdk.Context(fabsdk.WithUser(<span class="string">"Admin"</span>), fabsdk.WithOrg(<span class="string">"Org1"</span>))</span><br><span class="line">rc, err := resmgmt.New(rcp)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  log.Panicf(<span class="string">"failed to create resource client: %s"</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建CC"><a href="#创建CC" class="headerlink" title="创建CC"></a>创建CC</h3><p>创建cc使用用户账号，进行链码的调用和查询，使用<code>sdk.ChannelContext</code>创建<strong>channelProvider</strong>，需要指定channelID和用户User1，然后通过<code>channel.New</code>创建cc，此cc就是调用channelID对应channel上链码的channel client。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> 	<span class="string">"github.com/hyperledger/fabric-sdk-go/pkg/client/channel"</span></span><br><span class="line"></span><br><span class="line">ccp := sdk.ChannelContext(ChannelID, fabsdk.WithUser(<span class="string">"User1"</span>))</span><br><span class="line">cc, err := channel.New(ccp)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  log.Panicf(<span class="string">"failed to create channel client: %s"</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="管理操作"><a href="#管理操作" class="headerlink" title="管理操作"></a>管理操作</h2><h3 id="安装链码"><a href="#安装链码" class="headerlink" title="安装链码"></a>安装链码</h3><p>安装链码使用<code>rc.InstallCC</code>接口，需要指定<code>resmgmt.InstallCCRequest</code>以及在哪些peers上面安装。<code>resmgmt.InstallCCRequest</code>指明了链码ID、链码路径、链码版本以及打包后的链码。</p>
<p>打包链码需要使用到链码路径<code>CCPath</code>和<code>GoPath</code>，<code>GoPath</code>即本机的<code>$GOPATH</code>，<code>CCPath</code>是相对于<code>GoPath</code>的<strong>相对路径</strong>，如果路径设置不对，会造成sdk找不到链码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pack the chaincode</span></span><br><span class="line">ccPkg, err := gopackager.NewCCPackage(<span class="string">"github.com/hyperledger/fabric-samples/chaincode/chaincode_example02/go/"</span>, <span class="string">"/Users/shitaibin/go"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> errors.WithMessage(err, <span class="string">"pack chaincode error"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new request of installing chaincode</span></span><br><span class="line">req := resmgmt.InstallCCRequest&#123;</span><br><span class="line">  Name:    c.CCID,</span><br><span class="line">  Path:    c.CCPath,</span><br><span class="line">  Version: v,</span><br><span class="line">  Package: ccPkg,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reqPeers := resmgmt.WithTargetEndpoints(<span class="string">"peer0.org1.example.com"</span>)</span><br><span class="line">resps, err := rc.InstallCC(req, reqPeers)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> errors.WithMessage(err, <span class="string">"installCC error"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实例化链码"><a href="#实例化链码" class="headerlink" title="实例化链码"></a>实例化链码</h3><p>实例化链码需要使用<code>rc.InstantiateCC</code>接口，需要通过ChannelID、<code>resmgmt.InstantiateCCRequest</code>和peers，指明在哪个channel上实例化链码，请求包含了链码的ID、路径、版本，以及初始化参数和背书策略，背书策略可以通过<code>cauthdsl.FromString</code>生成。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// endorser policy</span></span><br><span class="line">org1OrOrg2 := <span class="string">"OR('Org1MSP.member','Org2MSP.member')"</span></span><br><span class="line">ccPolicy, err := cauthdsl.FromString(org1OrOrg2)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> errors.WithMessage(err, <span class="string">"gen policy from string error"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new request</span></span><br><span class="line">args := packArgs([]<span class="keyword">string</span>&#123;<span class="string">"init"</span>, <span class="string">"a"</span>, <span class="string">"100"</span>, <span class="string">"b"</span>, <span class="string">"200"</span>&#125;)</span><br><span class="line">req := resmgmt.InstantiateCCRequest&#123;</span><br><span class="line">  Name:    c.CCID,</span><br><span class="line">  Path:    c.CCPath,</span><br><span class="line">  Version: v,</span><br><span class="line">  Args:    args,</span><br><span class="line">  Policy:  ccPolicy,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// send request and handle response</span></span><br><span class="line">reqPeers := resmgmt.WithTargetEndpoints(<span class="string">"peer0.org1.example.com"</span>)</span><br><span class="line">resp, err := rc.InstantiateCC(ChannelID, req, reqPeers)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> errors.WithMessage(err, <span class="string">"instantiate chaincode error"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="升级链码"><a href="#升级链码" class="headerlink" title="升级链码"></a>升级链码</h3><p>升级链码和实例化链码是非常相似的，不同点只在请求是<code>resmgmt.UpgradeCCRequest</code>，调用的接口是<code>rc.UpgradeCC</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// endorser policy</span></span><br><span class="line">org1AndOrg2 := <span class="string">"AND('Org1MSP.member','Org2MSP.member')"</span></span><br><span class="line">ccPolicy, err := c.genPolicy(org1AndOrg2)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> errors.WithMessage(err, <span class="string">"gen policy from string error"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new request</span></span><br><span class="line">args := packArgs([]<span class="keyword">string</span>&#123;<span class="string">"init"</span>, <span class="string">"a"</span>, <span class="string">"100"</span>, <span class="string">"b"</span>, <span class="string">"200"</span>&#125;)</span><br><span class="line">req := resmgmt.UpgradeCCRequest&#123;</span><br><span class="line">  Name:    c.CCID,</span><br><span class="line">  Path:    c.CCPath,</span><br><span class="line">  Version: v,</span><br><span class="line">  Args:    args,</span><br><span class="line">  Policy:  ccPolicy,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// send request and handle response</span></span><br><span class="line">reqPeers := resmgmt.WithTargetEndpoints(<span class="string">"peer0.org1.example.com"</span>)</span><br><span class="line">resp, err := rc.UpgradeCC(ChannelID, req, reqPeers)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> errors.WithMessage(err, <span class="string">"instantiate chaincode error"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h2><h3 id="调用链码"><a href="#调用链码" class="headerlink" title="调用链码"></a>调用链码</h3><p>调用链码使用<code>cc.Execute</code>接口，使用入参<code>channel.Request</code>和peers指明要让哪些peer上执行链码，进行背书。<code>channel.Request</code>指明了要调用的链码，以及链码内要Invoke的函数args，args是序列化的结果，序列化是自定义的，只要链码能够按相同的规则进行反序列化即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new channel request for invoke</span></span><br><span class="line">args := packArgs([]<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"10"</span>&#125;)</span><br><span class="line">req := channel.Request&#123;</span><br><span class="line">  ChaincodeID: c.CCID,</span><br><span class="line">  Fcn:         <span class="string">"invoke"</span>,</span><br><span class="line">  Args:        args,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// send request and handle response</span></span><br><span class="line"><span class="comment">// peers is needed</span></span><br><span class="line">reqPeers := channel.WithTargetEndpoints(<span class="string">"peer0.org1.example.com"</span>)</span><br><span class="line">resp, err := cc.Execute(req, reqPeers)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> errors.WithMessage(err, <span class="string">"invoke chaincode error"</span>)</span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">"invoke chaincode tx: %s"</span>, resp.TransactionID)</span><br></pre></td></tr></table></figure>
<h3 id="查询链码"><a href="#查询链码" class="headerlink" title="查询链码"></a>查询链码</h3><p>查询和调用链码是非常相似的，使用相同的<code>channel.Request</code>，指明了Invoke链码中的<code>query</code>函数，然后调用<code>cc.Query</code>进行查询操作，这样节点不会对请求进行背书。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new channel request for query</span></span><br><span class="line">req := channel.Request&#123;</span><br><span class="line">  ChaincodeID: c.CCID,</span><br><span class="line">  Fcn:         <span class="string">"query"</span>,</span><br><span class="line">  Args:        packArgs([]<span class="keyword">string</span>&#123;keys&#125;),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// send request and handle response</span></span><br><span class="line">reqPeers := channel.WithTargetEndpoints(peer)</span><br><span class="line">resp, err := cc.Query(req, reqPeers)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> errors.WithMessage(err, <span class="string">"query chaincode error"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">"query chaincode tx: %s"</span>, resp.TransactionID)</span><br><span class="line">log.Printf(<span class="string">"result: %v"</span>, <span class="keyword">string</span>(resp.Payload))</span><br></pre></td></tr></table></figure>
<h2 id="示例项目"><a href="#示例项目" class="headerlink" title="示例项目"></a>示例项目</h2><p>本文的基础是创建了一个结合fabric byfn的示例项目，在byfn的基础之上对链码进行安装、实例化、升级，调用和查询等操作，项目的使用可见项目<a href="https://github.com/Shitaibin/fabric-sdk-go-sample" target="_blank" rel="noopener">README文档</a>，项目地址：<a href="https://github.com/Shitaibin/fabric-sdk-go-sample" target="_blank" rel="noopener">https://github.com/Shitaibin/fabric-sdk-go-sample</a> ，项目样例执行后，可见新部署和升级成功的链码容器，操作日志可见项目。</p>
<p><img src="http://img.lessisbetter.site/2019-09-byfn-sdk.png" alt="byfn-sdk"></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2019/08/27/protobuf-in-go-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="区块链、Go语言">
      <meta itemprop="image" content="http://img.lessisbetter.site/gzh-qrcode-logo-small.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Go语言充电站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/27/protobuf-in-go-2/" class="post-title-link" itemprop="url">Go是如何实现protobuf的编解码的(2)：源码</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-27 20:27:13" itemprop="dateCreated datePublished" datetime="2019-08-27T20:27:13+08:00">2019-08-27</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-09-12 17:46:55" itemprop="dateModified" datetime="2019-09-12T17:46:55+08:00">2019-09-12</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这是一篇姊妹篇文章，浅析一下Go是如何实现protobuf编解码的：</p>
<ol>
<li><a href="http://lessisbetter.site/2019/08/26/protobuf-in-go/">Go是如何实现protobuf的编解码的(1): 原理</a></li>
<li><a href="http://lessisbetter.site/2019/08/27/protobuf-in-go-2/">Go是如何实现protobuf的编解码的(2): 源码</a></li>
</ol>
<p>本编是第二篇。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇文章<a href="http://lessisbetter.site/2019/08/26/protobuf-in-go/">Go是如何实现protobuf的编解码的（1）：原理</a><br>中已经指出了<strong>Go语言数据和Protobuf数据的编解码是由包<code>github.com/golang/protobuf/proto</code>完成的</strong>，本编就来分析一下proto包是如何实现编解码的。</p>
<p><img src="http://img.lessisbetter.site/2019-09-marshal-unmarshal.png" alt=""></p>
<h2 id="编解码原理"><a href="#编解码原理" class="headerlink" title="编解码原理"></a>编解码原理</h2><p>编解码包都有支持的编解码类型，我们暂且把这些类型称为底层类型，编解码的本质是：</p>
<ol>
<li>为每一个底层类型配备一个或多个编解码函数</li>
<li>把一个结构体的字段，递归的拆解成底层类型，然后选择合适的函数进行编码或解码操作</li>
</ol>
<p><img src="http://img.lessisbetter.site/2019-09-protobuf-marshal.png" alt=""></p>
<p>接下来先看编码，再看解码。</p>
<h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><blockquote>
<p>约定：以下所有的代码片，如果是request.pb.go或main.go中的代码，会在第一行标记文件名，否则都是proto包的源码。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"./types"</span></span><br><span class="line">	<span class="string">"github.com/golang/protobuf/proto"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	req := &amp;types.Request&#123;Data: <span class="string">"Hello Dabin"</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Marshal</span></span><br><span class="line">	encoded, err := proto.Marshal(req)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"Encode to protobuf data error: %v"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编码调用的是<code>proto.Marshal</code>函数，它可以完成的是Go语言数据序列化成protobuf数据，返回序列化结果或错误。</p>
<p>proto编译成的Go结构体都是符合<code>Message</code>接口的，从<code>Marshal</code>可知Go结构体有3种序列化方式：</p>
<ol>
<li><code>pb Message</code>满足<code>newMarshaler</code>接口，则调用<code>XXX_Marshal()</code>进行序列化。</li>
<li><code>pb</code>满足<code>Marshaler</code>接口，则调用<code>Marshal()</code>进行序列化，这种方式适合某类型自定义序列化规则的情况。</li>
<li>否则，使用默认的序列化方式，创建一个Warpper，利用wrapper对<code>pb</code>进行序列化，后面会介绍方式1实际就是使用方式3。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Marshal takes a protocol buffer message</span></span><br><span class="line"><span class="comment">// and encodes it into the wire format, returning the data.</span></span><br><span class="line"><span class="comment">// This is the main entry point.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Marshal</span><span class="params">(pb Message)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> m, ok := pb.(newMarshaler); ok &#123;</span><br><span class="line">		siz := m.XXX_Size()</span><br><span class="line">		b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">0</span>, siz)</span><br><span class="line">		<span class="keyword">return</span> m.XXX_Marshal(b, <span class="literal">false</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> m, ok := pb.(Marshaler); ok &#123;</span><br><span class="line">		<span class="comment">// If the message can marshal itself, let it do it, for compatibility.</span></span><br><span class="line">		<span class="comment">// <span class="doctag">NOTE:</span> This is not efficient.</span></span><br><span class="line">		<span class="keyword">return</span> m.Marshal()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// in case somehow we didn't generate the wrapper</span></span><br><span class="line">	<span class="keyword">if</span> pb == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, ErrNil</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> info InternalMessageInfo</span><br><span class="line">	siz := info.Size(pb)</span><br><span class="line">	b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">0</span>, siz)</span><br><span class="line">	<span class="keyword">return</span> info.Marshal(b, pb, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>newMarshaler</code>和<code>Marshaler</code>如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// newMarshaler is the interface representing objects that can marshal themselves.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This exists to support protoc-gen-go generated messages.</span></span><br><span class="line"><span class="comment">// The proto package will stop type-asserting to this interface in the future.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// DO NOT DEPEND ON THIS.</span></span><br><span class="line"><span class="keyword">type</span> newMarshaler <span class="keyword">interface</span> &#123;</span><br><span class="line">	XXX_Size() <span class="keyword">int</span></span><br><span class="line">	XXX_Marshal(b []<span class="keyword">byte</span>, deterministic <span class="keyword">bool</span>) ([]<span class="keyword">byte</span>, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Marshaler is the interface representing objects that can marshal themselves.</span></span><br><span class="line"><span class="keyword">type</span> Marshaler <span class="keyword">interface</span> &#123;</span><br><span class="line">	Marshal() ([]<span class="keyword">byte</span>, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Request</code>实现了<code>newMarshaler</code>接口，<code>XXX_Marshal</code>实现如下，它实际是调用了<code>xxx_messageInfo_Request.Marshal</code>，<code>xxx_messageInfo_Request</code>是定义在<code>request.pb.go</code>中的一个全局变量，类型就是<code>InternalMessageInfo</code>，实际就是前文提到的wrapper。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// request.pb.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Request)</span> <span class="title">XXX_Marshal</span><span class="params">(b []<span class="keyword">byte</span>, deterministic <span class="keyword">bool</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"Called xxx marshal\n"</span>)</span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">"I want see stack trace"</span>)</span><br><span class="line">	<span class="keyword">return</span> xxx_messageInfo_Request.Marshal(b, m, deterministic)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xxx_messageInfo_Request proto.InternalMessageInfo</span><br></pre></td></tr></table></figure>
<p>本质上，<code>XXX_Marshal</code>也是wrapper，后面才是真正序列化的主体函数在proto包中。</p>
<p><code>InternalMessageInfo</code>主要是用来缓存序列化和反序列化需要用到的信息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InternalMessageInfo is a type used internally by generated .pb.go files.</span></span><br><span class="line"><span class="comment">// This type is not intended to be used by non-generated code.</span></span><br><span class="line"><span class="comment">// This type is not subject to any compatibility guarantee.</span></span><br><span class="line"><span class="keyword">type</span> InternalMessageInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">	marshal   *marshalInfo   <span class="comment">// marshal信息</span></span><br><span class="line">	unmarshal *unmarshalInfo <span class="comment">// unmarshal信息</span></span><br><span class="line">	merge     *mergeInfo</span><br><span class="line">	discard   *discardInfo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>InternalMessageInfo.Marshal</code>首先是获取待序列化类型的序列化信息<code>u marshalInfo</code>，然后利用<code>u.marshal</code>进行序列化。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Marshal is the entry point from generated code,</span></span><br><span class="line"><span class="comment">// and should be ONLY called by generated code.</span></span><br><span class="line"><span class="comment">// It marshals msg to the end of b.</span></span><br><span class="line"><span class="comment">// a is a pointer to a place to store cached marshal info.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *InternalMessageInfo)</span> <span class="title">Marshal</span><span class="params">(b []<span class="keyword">byte</span>, msg Message, deterministic <span class="keyword">bool</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 获取该message类型的MarshalInfo，这些信息都缓存起来了</span></span><br><span class="line">	<span class="comment">// 大量并发时无需重复创建</span></span><br><span class="line">	u := getMessageMarshalInfo(msg, a)</span><br><span class="line">	<span class="comment">// 入参校验</span></span><br><span class="line">	ptr := toPointer(&amp;msg)</span><br><span class="line">	<span class="keyword">if</span> ptr.isNil() &#123;</span><br><span class="line">		<span class="comment">// We get here if msg is a typed nil ((*SomeMessage)(nil)),</span></span><br><span class="line">		<span class="comment">// so it satisfies the interface, and msg == nil wouldn't</span></span><br><span class="line">		<span class="comment">// catch it. We don't want crash in this case.</span></span><br><span class="line">		<span class="keyword">return</span> b, ErrNil</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 根据MarshalInfo对数据进行marshal</span></span><br><span class="line">	<span class="keyword">return</span> u.marshal(b, ptr, deterministic)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于每种类型的序列化信息是一致的，所以<code>getMessageMarshalInfo</code>对序列化信息进行了缓存，缓存在<code>a.marshal</code>中，如果a中不存在marshal信息，则去生成，但不进行初始化，然后保存到a中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMessageMarshalInfo</span><span class="params">(msg <span class="keyword">interface</span>&#123;&#125;, a *InternalMessageInfo)</span> *<span class="title">marshalInfo</span></span> &#123;</span><br><span class="line">	<span class="comment">// u := a.marshal, but atomically.</span></span><br><span class="line">	<span class="comment">// We use an atomic here to ensure memory consistency.</span></span><br><span class="line">	<span class="comment">// 从InternalMessageInfo中读取</span></span><br><span class="line">	u := atomicLoadMarshalInfo(&amp;a.marshal)</span><br><span class="line">	<span class="comment">// 读取不到代表未保存过</span></span><br><span class="line">	<span class="keyword">if</span> u == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Get marshal information from type of message.</span></span><br><span class="line">		t := reflect.ValueOf(msg).Type()</span><br><span class="line">		<span class="keyword">if</span> t.Kind() != reflect.Ptr &#123;</span><br><span class="line">			<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"cannot handle non-pointer message type %v"</span>, t))</span><br><span class="line">		&#125;</span><br><span class="line">		u = getMarshalInfo(t.Elem())</span><br><span class="line">		<span class="comment">// Store it in the cache for later users.</span></span><br><span class="line">		<span class="comment">// a.marshal = u, but atomically.</span></span><br><span class="line">		atomicStoreMarshalInfo(&amp;a.marshal, u)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> u</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>getMarshalInfo</code>只是创建了一个<code>marshalInfo</code>对象，填充了字段<code>typ</code>，剩余的字段未填充。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// getMarshalInfo returns the information to marshal a given type of message.</span><br><span class="line">// The info it returns may not necessarily initialized.</span><br><span class="line">// t is the type of the message (NOT the pointer to it).</span><br><span class="line">// 获取MarshalInfo结构体，如果不存在则使用message类型t创建1个</span><br><span class="line">func getMarshalInfo(t reflect.Type) *marshalInfo &#123;</span><br><span class="line">	marshalInfoLock.Lock()</span><br><span class="line">	u, ok := marshalInfoMap[t]</span><br><span class="line">	if !ok &#123;</span><br><span class="line">		u = &amp;marshalInfo&#123;typ: t&#125;</span><br><span class="line">		marshalInfoMap[t] = u</span><br><span class="line">	&#125;</span><br><span class="line">	marshalInfoLock.Unlock()</span><br><span class="line">	return u</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// marshalInfo is the information used for marshaling a message.</span><br><span class="line">type marshalInfo struct &#123;</span><br><span class="line">	typ          reflect.Type</span><br><span class="line">	fields       []*marshalFieldInfo</span><br><span class="line">	unrecognized field                      // offset of XXX_unrecognized</span><br><span class="line">	extensions   field                      // offset of XXX_InternalExtensions</span><br><span class="line">	v1extensions field                      // offset of XXX_extensions</span><br><span class="line">	sizecache    field                      // offset of XXX_sizecache</span><br><span class="line">	initialized  int32                      // 0 -- only typ is set, 1 -- fully initialized</span><br><span class="line">	messageset   bool                       // uses message set wire format</span><br><span class="line">	hasmarshaler bool                       // has custom marshaler</span><br><span class="line">	sync.RWMutex                            // protect extElems map, also for initialization</span><br><span class="line">	extElems     map[int32]*marshalElemInfo // info of extension elements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>marshalInfo.marshal</code>是Marshal真实主体，会判断u是否已经初始化，如果未初始化调用<code>computeMarshalInfo</code>计算Marshal需要的信息，实际就是填充<code>marshalInfo</code>中的各种字段。</p>
<p><code>u.hasmarshaler</code>代表当前类型是否实现了<code>Marshaler</code>接口，直接调用Marshal函数进行序列化。可以确定Marshal函数的序列化方式2，即实现<code>Marshaler</code>接口的方法，最后肯定也会调用<code>marshalInfo.marshal</code>。</p>
<p>该函数的主体是一个for循环，依次遍历该类型的每一个字段，对required属性进行校验，然后按字段类型，调用<code>f.marshaler</code>对该字段类型进行序列化。这个<code>f.marshaler</code>哪来的呢？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// marshal is the main function to marshal a message. It takes a byte slice and appends</span></span><br><span class="line"><span class="comment">// the encoded data to the end of the slice, returns the slice and error (if any).</span></span><br><span class="line"><span class="comment">// ptr is the pointer to the message.</span></span><br><span class="line"><span class="comment">// If deterministic is true, map is marshaled in deterministic order.</span></span><br><span class="line"><span class="comment">// 该函数是Marshal的主体函数，把消息编码为数据后，追加到b之后，最后返回b。</span></span><br><span class="line"><span class="comment">// deterministic为true代表map会以确定的顺序进行编码。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *marshalInfo)</span> <span class="title">marshal</span><span class="params">(b []<span class="keyword">byte</span>, ptr pointer, deterministic <span class="keyword">bool</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 初始化marshalInfo的基础信息</span></span><br><span class="line">	<span class="comment">// 主要是根据已有信息填充该结构体的一些字段</span></span><br><span class="line">	<span class="keyword">if</span> atomic.LoadInt32(&amp;u.initialized) == <span class="number">0</span> &#123;</span><br><span class="line">		u.computeMarshalInfo()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If the message can marshal itself, let it do it, for compatibility.</span></span><br><span class="line">	<span class="comment">// <span class="doctag">NOTE:</span> This is not efficient.</span></span><br><span class="line">	<span class="comment">// 如果该类型实现了Marshaler接口，即能够对自己Marshal，则自行Marshal</span></span><br><span class="line">	<span class="comment">// 结果追加到b</span></span><br><span class="line">	<span class="keyword">if</span> u.hasmarshaler &#123;</span><br><span class="line">		m := ptr.asPointerTo(u.typ).Interface().(Marshaler)</span><br><span class="line">		b1, err := m.Marshal()</span><br><span class="line">		b = <span class="built_in">append</span>(b, b1...)</span><br><span class="line">		<span class="keyword">return</span> b, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> err, errLater error</span><br><span class="line">	<span class="comment">// The old marshaler encodes extensions at beginning.</span></span><br><span class="line">	<span class="comment">// 检查扩展字段，把message的扩展字段追加到b</span></span><br><span class="line">	<span class="keyword">if</span> u.extensions.IsValid() &#123;</span><br><span class="line">		<span class="comment">// offset函数用来根据指针偏移量获取message的指定字段</span></span><br><span class="line">		e := ptr.offset(u.extensions).toExtensions()</span><br><span class="line">		<span class="keyword">if</span> u.messageset &#123;</span><br><span class="line">			b, err = u.appendMessageSet(b, e, deterministic)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			b, err = u.appendExtensions(b, e, deterministic)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> b, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> u.v1extensions.IsValid() &#123;</span><br><span class="line">		m := *ptr.offset(u.v1extensions).toOldExtensions()</span><br><span class="line">		b, err = u.appendV1Extensions(b, m, deterministic)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> b, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历message的每一个字段，检查并做编码，然后追加到b</span></span><br><span class="line">	<span class="keyword">for</span> _, f := <span class="keyword">range</span> u.fields &#123;</span><br><span class="line">		<span class="keyword">if</span> f.required &#123;</span><br><span class="line">			<span class="comment">// 如果required的字段未设置，则记录错误，所有的marshal工作完成后再处理</span></span><br><span class="line">			<span class="keyword">if</span> ptr.offset(f.field).getPointer().isNil() &#123;</span><br><span class="line">				<span class="comment">// Required field is not set.</span></span><br><span class="line">				<span class="comment">// We record the error but keep going, to give a complete marshaling.</span></span><br><span class="line">				<span class="keyword">if</span> errLater == <span class="literal">nil</span> &#123;</span><br><span class="line">					errLater = &amp;RequiredNotSetError&#123;f.name&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 字段为指针类型，并且为nil，代表未设置，该字段无需编码</span></span><br><span class="line">		<span class="keyword">if</span> f.isPointer &amp;&amp; ptr.offset(f.field).getPointer().isNil() &#123;</span><br><span class="line">			<span class="comment">// nil pointer always marshals to nothing</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 利用这个字段的marshaler进行编码</span></span><br><span class="line">		b, err = f.marshaler(b, ptr.offset(f.field), f.wiretag, deterministic)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err1, ok := err.(*RequiredNotSetError); ok &#123;</span><br><span class="line">				<span class="comment">// required字段但未设置错误</span></span><br><span class="line">				<span class="comment">// Required field in submessage is not set.</span></span><br><span class="line">				<span class="comment">// We record the error but keep going, to give a complete marshaling.</span></span><br><span class="line">				<span class="keyword">if</span> errLater == <span class="literal">nil</span> &#123;</span><br><span class="line">					errLater = &amp;RequiredNotSetError&#123;f.name + <span class="string">"."</span> + err1.field&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// “动态数组”中包含nil元素</span></span><br><span class="line">			<span class="keyword">if</span> err == errRepeatedHasNil &#123;</span><br><span class="line">				err = errors.New(<span class="string">"proto: repeated field "</span> + f.name + <span class="string">" has nil element"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> err == errInvalidUTF8 &#123;</span><br><span class="line">				<span class="keyword">if</span> errLater == <span class="literal">nil</span> &#123;</span><br><span class="line">					fullName := revProtoTypes[reflect.PtrTo(u.typ)] + <span class="string">"."</span> + f.name</span><br><span class="line">					errLater = &amp;invalidUTF8Error&#123;fullName&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> b, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 为识别的类型字段，直接转为bytes，追加到b</span></span><br><span class="line">	<span class="comment">// computeMarshalInfo中已经收集这些字段</span></span><br><span class="line">	<span class="keyword">if</span> u.unrecognized.IsValid() &#123;</span><br><span class="line">		s := *ptr.offset(u.unrecognized).toBytes()</span><br><span class="line">		b = <span class="built_in">append</span>(b, s...)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b, errLater</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>computeMarshalInfo</code>实际上就是对要序列化的类型，进行一次全面检查，设置好序列化要使用的数据，这其中就包含了各字段的序列化函数<code>f.marshaler</code>。我们就重点关注下这部分，struct的每一个字段都会分配一个<code>marshalFieldInfo</code>，代表这个字段序列化需要的信息，会调用<code>computeMarshalFieldInfo</code>会填充这个对象。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// computeMarshalInfo initializes the marshal info.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *marshalInfo)</span> <span class="title">computeMarshalInfo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 加锁，代表了不能同时计算marshal信息</span></span><br><span class="line">	u.Lock()</span><br><span class="line">	<span class="keyword">defer</span> u.Unlock()</span><br><span class="line">	<span class="comment">// 计算1次即可</span></span><br><span class="line">	<span class="keyword">if</span> u.initialized != <span class="number">0</span> &#123; <span class="comment">// non-atomic read is ok as it is protected by the lock</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取要marshal的message类型</span></span><br><span class="line">	t := u.typ</span><br><span class="line">	u.unrecognized = invalidField</span><br><span class="line">	u.extensions = invalidField</span><br><span class="line">	u.v1extensions = invalidField</span><br><span class="line">	u.sizecache = invalidField</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If the message can marshal itself, let it do it, for compatibility.</span></span><br><span class="line">	<span class="comment">// 判断当前类型是否实现了Marshal接口，如果实现标记为类型自有marshaler</span></span><br><span class="line">	<span class="comment">// 没用类型断言是因为t是Type类型，不是保存在某个接口的变量</span></span><br><span class="line">	<span class="comment">// <span class="doctag">NOTE:</span> This is not efficient.</span></span><br><span class="line">	<span class="keyword">if</span> reflect.PtrTo(t).Implements(marshalerType) &#123;</span><br><span class="line">		u.hasmarshaler = <span class="literal">true</span></span><br><span class="line">		atomic.StoreInt32(&amp;u.initialized, <span class="number">1</span>)</span><br><span class="line">		<span class="comment">// 可以直接返回了，后面使用自有的marshaler编码</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// get oneof implementers</span></span><br><span class="line">	<span class="comment">// 看*t实现了以下哪个接口，oneof特性</span></span><br><span class="line">	<span class="keyword">var</span> oneofImplementers []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">switch</span> m := reflect.Zero(reflect.PtrTo(t)).Interface().(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> oneofFuncsIface:</span><br><span class="line">		_, _, _, oneofImplementers = m.XXX_OneofFuncs()</span><br><span class="line">	<span class="keyword">case</span> oneofWrappersIface:</span><br><span class="line">		oneofImplementers = m.XXX_OneofWrappers()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	n := t.NumField()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// deal with XXX fields first</span></span><br><span class="line">	<span class="comment">// 遍历t的每一个XXX字段</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">		f := t.Field(i)</span><br><span class="line">		<span class="comment">// 跳过非XXX开头的字段</span></span><br><span class="line">		<span class="keyword">if</span> !strings.HasPrefix(f.Name, <span class="string">"XXX_"</span>) &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 处理以下几个protobuf自带的字段</span></span><br><span class="line">		<span class="keyword">switch</span> f.Name &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">"XXX_sizecache"</span>:</span><br><span class="line">			u.sizecache = toField(&amp;f)</span><br><span class="line">		<span class="keyword">case</span> <span class="string">"XXX_unrecognized"</span>:</span><br><span class="line">			u.unrecognized = toField(&amp;f)</span><br><span class="line">		<span class="keyword">case</span> <span class="string">"XXX_InternalExtensions"</span>:</span><br><span class="line">			u.extensions = toField(&amp;f)</span><br><span class="line">			u.messageset = f.Tag.Get(<span class="string">"protobuf_messageset"</span>) == <span class="string">"1"</span></span><br><span class="line">		<span class="keyword">case</span> <span class="string">"XXX_extensions"</span>:</span><br><span class="line">			u.v1extensions = toField(&amp;f)</span><br><span class="line">		<span class="keyword">case</span> <span class="string">"XXX_NoUnkeyedLiteral"</span>:</span><br><span class="line">			<span class="comment">// nothing to do</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">"unknown XXX field: "</span> + f.Name)</span><br><span class="line">		&#125;</span><br><span class="line">		n--</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// normal fields</span></span><br><span class="line">	<span class="comment">// 处理message的普通字段</span></span><br><span class="line">	fields := <span class="built_in">make</span>([]marshalFieldInfo, n) <span class="comment">// batch allocation</span></span><br><span class="line">	u.fields = <span class="built_in">make</span>([]*marshalFieldInfo, <span class="number">0</span>, n)</span><br><span class="line">	<span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="number">0</span>; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">		f := t.Field(i)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 跳过XXX字段</span></span><br><span class="line">		<span class="keyword">if</span> strings.HasPrefix(f.Name, <span class="string">"XXX_"</span>) &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 取fields的下一个有效字段，指针类型</span></span><br><span class="line">		<span class="comment">// j代表了fields有效字段数量，n是包含了XXX字段的总字段数量</span></span><br><span class="line">		field := &amp;fields[j]</span><br><span class="line">		j++</span><br><span class="line">		field.name = f.Name</span><br><span class="line">		<span class="comment">// 填充到u.fields</span></span><br><span class="line">		u.fields = <span class="built_in">append</span>(u.fields, field)</span><br><span class="line">		<span class="comment">// 字段的tag里包含“protobuf_oneof”特殊处理</span></span><br><span class="line">		<span class="keyword">if</span> f.Tag.Get(<span class="string">"protobuf_oneof"</span>) != <span class="string">""</span> &#123;</span><br><span class="line">			field.computeOneofFieldInfo(&amp;f, oneofImplementers)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 字段里不包含“protobuf”，代表不是protoc自动生成的字段</span></span><br><span class="line">		<span class="keyword">if</span> f.Tag.Get(<span class="string">"protobuf"</span>) == <span class="string">""</span> &#123;</span><br><span class="line">			<span class="comment">// field has no tag (not in generated message), ignore it</span></span><br><span class="line">			<span class="comment">// 删除刚刚保存的字段信息</span></span><br><span class="line">			u.fields = u.fields[:<span class="built_in">len</span>(u.fields)<span class="number">-1</span>]</span><br><span class="line">			j--</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 填充字段的marshal信息</span></span><br><span class="line">		field.computeMarshalFieldInfo(&amp;f)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// fields are marshaled in tag order on the wire.</span></span><br><span class="line">	<span class="comment">// 字段排序</span></span><br><span class="line">	sort.Sort(byTag(u.fields))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化完成</span></span><br><span class="line">	atomic.StoreInt32(&amp;u.initialized, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回顾一下<code>Request</code>的定义，它包含1个字段Data，后面<code>protobuf:...</code>描述了protobuf要使用的信息，<code>&quot;bytes,...&quot;</code>这段被称为tags，用逗号进行分割后，其中：</p>
<ul>
<li>tags[0]: bytes，代表Data类型的数据要被转换为bytes</li>
<li>tags[1]: 1，代表了字段的ID</li>
<li>tags[2]: opt，代表可行，非必须</li>
<li>tags[3]: name=data，proto文件中的名称</li>
<li>tags[4]: proto3，代表使用的protobuf版本</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// request.pb.go</span></span><br><span class="line"><span class="keyword">type</span> Request <span class="keyword">struct</span>&#123;</span><br><span class="line">	Data                 <span class="keyword">string</span>   <span class="string">`protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>computeMarshalFieldInfo</code>首先要获取字段ID和要转换的类型，填充到<code>marshalFieldInfo</code>，然后调用<code>setMarshaler</code>利用字段f和tags获取该字段类型的序列化函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// computeMarshalFieldInfo fills up the information to marshal a field.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fi *marshalFieldInfo)</span> <span class="title">computeMarshalFieldInfo</span><span class="params">(f *reflect.StructField)</span></span> &#123;</span><br><span class="line">	<span class="comment">// parse protobuf tag of the field.</span></span><br><span class="line">	<span class="comment">// tag has format of "bytes,49,opt,name=foo,def=hello!"</span></span><br><span class="line">	<span class="comment">// 获取"protobuf"的完整tag，然后使用，分割，得到上面的格式</span></span><br><span class="line">	tags := strings.Split(f.Tag.Get(<span class="string">"protobuf"</span>), <span class="string">","</span>)</span><br><span class="line">	<span class="keyword">if</span> tags[<span class="number">0</span>] == <span class="string">""</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// tag的编号，即message中设置的string name = x，则x就是这个字段的tag id</span></span><br><span class="line">	tag, err := strconv.Atoi(tags[<span class="number">1</span>])</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"tag is not an integer"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 要转换成的类型，bytes，varint等等</span></span><br><span class="line">	wt := wiretype(tags[<span class="number">0</span>])</span><br><span class="line">	<span class="comment">// 设置字段是required还是opt</span></span><br><span class="line">	<span class="keyword">if</span> tags[<span class="number">2</span>] == <span class="string">"req"</span> &#123;</span><br><span class="line">		fi.required = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 设置field和tag信息到marshalFieldInfo</span></span><br><span class="line">	fi.setTag(f, tag, wt)</span><br><span class="line">	<span class="comment">// 根据当前的tag信息（类型等），选择marshaler函数</span></span><br><span class="line">	fi.setMarshaler(f, tags)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>setMarshaler</code>的重点是<code>typeMarshaler</code>，<code>typeMarshaler</code>这个函数非常长，其实就是根据类型设置返回对于的序列化函数，比如Bool、Int32、Uint32…，如果是结构体、切片等复合类型，就可以形成递归了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setMarshaler fills up the sizer and marshaler in the info of a field.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fi *marshalFieldInfo)</span> <span class="title">setMarshaler</span><span class="params">(f *reflect.StructField, tags []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// map类型字段特殊处理</span></span><br><span class="line">	<span class="keyword">switch</span> f.Type.Kind() &#123;</span><br><span class="line">	<span class="keyword">case</span> reflect.Map:</span><br><span class="line">		<span class="comment">// map field</span></span><br><span class="line">		fi.isPointer = <span class="literal">true</span></span><br><span class="line">		fi.sizer, fi.marshaler = makeMapMarshaler(f)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	<span class="keyword">case</span> reflect.Ptr, reflect.Slice:</span><br><span class="line">		<span class="comment">// 指针字段和切片字段标记指针类型</span></span><br><span class="line">		fi.isPointer = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据字段类型和tag选择marshaler</span></span><br><span class="line">	fi.sizer, fi.marshaler = typeMarshaler(f.Type, tags, <span class="literal">true</span>, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// typeMarshaler returns the sizer and marshaler of a given field.</span></span><br><span class="line"><span class="comment">// t is the type of the field.</span></span><br><span class="line"><span class="comment">// tags is the generated "protobuf" tag of the field.</span></span><br><span class="line"><span class="comment">// If nozero is true, zero value is not marshaled to the wire.</span></span><br><span class="line"><span class="comment">// If oneof is true, it is a oneof field.</span></span><br><span class="line"><span class="comment">// 函数非常长，省略内容</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">typeMarshaler</span><span class="params">(t reflect.Type, tags []<span class="keyword">string</span>, nozero, oneof <span class="keyword">bool</span>)</span> <span class="params">(sizer, marshaler)</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">switch</span> t.Kind() &#123;</span><br><span class="line">	<span class="keyword">case</span> reflect.Bool:</span><br><span class="line">		<span class="keyword">if</span> pointer &#123;</span><br><span class="line">			<span class="keyword">return</span> sizeBoolPtr, appendBoolPtr</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> slice &#123;</span><br><span class="line">			<span class="keyword">if</span> packed &#123;</span><br><span class="line">				<span class="keyword">return</span> sizeBoolPackedSlice, appendBoolPackedSlice</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> sizeBoolSlice, appendBoolSlice</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> nozero &#123;</span><br><span class="line">			<span class="keyword">return</span> sizeBoolValueNoZero, appendBoolValueNoZero</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sizeBoolValue, appendBoolValue</span><br><span class="line">	<span class="keyword">case</span> reflect.Uint32:</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">case</span> reflect.Int32:</span><br><span class="line">	....</span><br><span class="line">	<span class="keyword">case</span> reflect.Struct:</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下是Bool和String类型的2个序列化函数示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendBoolValue</span><span class="params">(b []<span class="keyword">byte</span>, ptr pointer, wiretag <span class="keyword">uint64</span>, _ <span class="keyword">bool</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	v := *ptr.toBool()</span><br><span class="line">	b = appendVarint(b, wiretag)</span><br><span class="line">	<span class="keyword">if</span> v &#123;</span><br><span class="line">		b = <span class="built_in">append</span>(b, <span class="number">1</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		b = <span class="built_in">append</span>(b, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendStringValue</span><span class="params">(b []<span class="keyword">byte</span>, ptr pointer, wiretag <span class="keyword">uint64</span>, _ <span class="keyword">bool</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	v := *ptr.toString()</span><br><span class="line">	b = appendVarint(b, wiretag)</span><br><span class="line">	b = appendVarint(b, <span class="keyword">uint64</span>(<span class="built_in">len</span>(v)))</span><br><span class="line">	b = <span class="built_in">append</span>(b, v...)</span><br><span class="line">	<span class="keyword">return</span> b, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以序列化后的<code>[]byte</code>，应当是符合这种模式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| wiretag | data | wiretag | data | ... | data |</span><br></pre></td></tr></table></figure>
<p>OK，以上就是编码的主要流程，简单回顾一下：</p>
<ol>
<li><code>proto.Marshal</code>会调用<code>*.pb.go</code>中自动生成的Wrapper函数，Wrapper函数会调用<code>InternalMessageInfo</code>进行序列化，然后才步入序列化的正题</li>
<li>首先获取要序列化类型的marshal信息u，如果u没有初始化，则进行初始化，即设置好结构体每个字段的序列化函数，以及其他信息</li>
<li>遍历结构体的每个字段，使用u中的信息为每个字段进行编码，并把加过追加到<code>[]byte</code>，所以字段编码完成，则返回序列化的结果<code>[]byte</code>或者错误。</li>
</ol>
<h3 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h3><p><strong>解码的流程其实与编码很类似</strong>，会是上面回顾的3大步骤，主要的区别在步骤2：它要获取的是序列化类型的unmarshal信息u，如果u没有初始化，会进行初始化，设置的是结构体每个字段的反序列化函数，以及其他信息。</p>
<p>所以解码的函数解析会简要的过一遍，不再有编码那么详细的解释。</p>
<p>下面是proto包中反序列化的接口和函数定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unmarshaler is the interface representing objects that can</span></span><br><span class="line"><span class="comment">// unmarshal themselves.  The argument points to data that may be</span></span><br><span class="line"><span class="comment">// overwritten, so implementations should not keep references to the</span></span><br><span class="line"><span class="comment">// buffer.</span></span><br><span class="line"><span class="comment">// Unmarshal implementations should not clear the receiver.</span></span><br><span class="line"><span class="comment">// Any unmarshaled data should be merged into the receiver.</span></span><br><span class="line"><span class="comment">// Callers of Unmarshal that do not want to retain existing data</span></span><br><span class="line"><span class="comment">// should Reset the receiver before calling Unmarshal.</span></span><br><span class="line"><span class="keyword">type</span> Unmarshaler <span class="keyword">interface</span> &#123;</span><br><span class="line">	Unmarshal([]<span class="keyword">byte</span>) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// newUnmarshaler is the interface representing objects that can</span></span><br><span class="line"><span class="comment">// unmarshal themselves. The semantics are identical to Unmarshaler.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This exists to support protoc-gen-go generated messages.</span></span><br><span class="line"><span class="comment">// The proto package will stop type-asserting to this interface in the future.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// DO NOT DEPEND ON THIS.</span></span><br><span class="line"><span class="keyword">type</span> newUnmarshaler <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// 实现了XXX_Unmarshal</span></span><br><span class="line">	XXX_Unmarshal([]<span class="keyword">byte</span>) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unmarshal parses the protocol buffer representation in buf and places the</span></span><br><span class="line"><span class="comment">// decoded result in pb.  If the struct underlying pb does not match</span></span><br><span class="line"><span class="comment">// the data in buf, the results can be unpredictable.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Unmarshal resets pb before starting to unmarshal, so any</span></span><br><span class="line"><span class="comment">// existing data in pb is always removed. Use UnmarshalMerge</span></span><br><span class="line"><span class="comment">// to preserve and append to existing data.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unmarshal</span><span class="params">(buf []<span class="keyword">byte</span>, pb Message)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	pb.Reset()</span><br><span class="line">	<span class="comment">// pb自己有unmarshal函数，实现了newUnmarshaler接口</span></span><br><span class="line">	<span class="keyword">if</span> u, ok := pb.(newUnmarshaler); ok &#123;</span><br><span class="line">		<span class="keyword">return</span> u.XXX_Unmarshal(buf)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// pb自己有unmarshal函数，实现了Unmarshaler接口</span></span><br><span class="line">	<span class="keyword">if</span> u, ok := pb.(Unmarshaler); ok &#123;</span><br><span class="line">		<span class="keyword">return</span> u.Unmarshal(buf)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 使用默认的Unmarshal</span></span><br><span class="line">	<span class="keyword">return</span> NewBuffer(buf).Unmarshal(pb)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Request</code>实现了<code>Unmarshaler</code>接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// request.pb.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Request)</span> <span class="title">XXX_Unmarshal</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> xxx_messageInfo_Request.Unmarshal(m, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反序列化也是使用<code>InternalMessageInfo</code>进行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unmarshal is the entry point from the generated .pb.go files.</span></span><br><span class="line"><span class="comment">// This function is not intended to be used by non-generated code.</span></span><br><span class="line"><span class="comment">// This function is not subject to any compatibility guarantee.</span></span><br><span class="line"><span class="comment">// msg contains a pointer to a protocol buffer struct.</span></span><br><span class="line"><span class="comment">// b is the data to be unmarshaled into the protocol buffer.</span></span><br><span class="line"><span class="comment">// a is a pointer to a place to store cached unmarshal information.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *InternalMessageInfo)</span> <span class="title">Unmarshal</span><span class="params">(msg Message, b []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// Load the unmarshal information for this message type.</span></span><br><span class="line">	<span class="comment">// The atomic load ensures memory consistency.</span></span><br><span class="line">	<span class="comment">// 获取保存在a中的unmarshal信息</span></span><br><span class="line">	u := atomicLoadUnmarshalInfo(&amp;a.unmarshal)</span><br><span class="line">	<span class="keyword">if</span> u == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Slow path: find unmarshal info for msg, update a with it.</span></span><br><span class="line">		u = getUnmarshalInfo(reflect.TypeOf(msg).Elem())</span><br><span class="line">		atomicStoreUnmarshalInfo(&amp;a.unmarshal, u)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Then do the unmarshaling.</span></span><br><span class="line">	<span class="comment">// 执行unmarshal</span></span><br><span class="line">	err := u.unmarshal(toPointer(&amp;msg), b)</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下是反序列化的主题函数，u未初始化时会调用<code>computeUnmarshalInfo</code>设置反序列化需要的信息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unmarshal does the main work of unmarshaling a message.</span></span><br><span class="line"><span class="comment">// u provides type information used to unmarshal the message.</span></span><br><span class="line"><span class="comment">// m is a pointer to a protocol buffer message.</span></span><br><span class="line"><span class="comment">// b is a byte stream to unmarshal into m.</span></span><br><span class="line"><span class="comment">// This is top routine used when recursively unmarshaling submessages.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *unmarshalInfo)</span> <span class="title">unmarshal</span><span class="params">(m pointer, b []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> atomic.LoadInt32(&amp;u.initialized) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 为u填充unmarshal信息，以及设置每个字段类型的unmarshaler函数</span></span><br><span class="line">		u.computeUnmarshalInfo()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> u.isMessageSet &#123;</span><br><span class="line">		<span class="keyword">return</span> unmarshalMessageSet(b, m.offset(u.extensions).toExtensions())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> reqMask <span class="keyword">uint64</span> <span class="comment">// bitmask of required fields we've seen.</span></span><br><span class="line">	<span class="keyword">var</span> errLater error</span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(b) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// Read tag and wire type.</span></span><br><span class="line">		<span class="comment">// Special case 1 and 2 byte varints.</span></span><br><span class="line">		<span class="keyword">var</span> x <span class="keyword">uint64</span></span><br><span class="line">		<span class="keyword">if</span> b[<span class="number">0</span>] &lt; <span class="number">128</span> &#123;</span><br><span class="line">			x = <span class="keyword">uint64</span>(b[<span class="number">0</span>])</span><br><span class="line">			b = b[<span class="number">1</span>:]</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(b) &gt;= <span class="number">2</span> &amp;&amp; b[<span class="number">1</span>] &lt; <span class="number">128</span> &#123;</span><br><span class="line">			x = <span class="keyword">uint64</span>(b[<span class="number">0</span>]&amp;<span class="number">0x7f</span>) + <span class="keyword">uint64</span>(b[<span class="number">1</span>])&lt;&lt;<span class="number">7</span></span><br><span class="line">			b = b[<span class="number">2</span>:]</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">var</span> n <span class="keyword">int</span></span><br><span class="line">			x, n = decodeVarint(b)</span><br><span class="line">			<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> io.ErrUnexpectedEOF</span><br><span class="line">			&#125;</span><br><span class="line">			b = b[n:]</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 获取tag和wire标记</span></span><br><span class="line">		tag := x &gt;&gt; <span class="number">3</span></span><br><span class="line">		wire := <span class="keyword">int</span>(x) &amp; <span class="number">7</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// Dispatch on the tag to one of the unmarshal* functions below.</span></span><br><span class="line">		<span class="comment">// 根据tag选择该类型的unmarshalFieldInfo：f</span></span><br><span class="line">		<span class="keyword">var</span> f unmarshalFieldInfo</span><br><span class="line">		<span class="keyword">if</span> tag &lt; <span class="keyword">uint64</span>(<span class="built_in">len</span>(u.dense)) &#123;</span><br><span class="line">			f = u.dense[tag]</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			f = u.sparse[tag]</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果该类型有unmarshaler函数，则执行解码和错误处理</span></span><br><span class="line">		<span class="keyword">if</span> fn := f.unmarshal; fn != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">var</span> err error</span><br><span class="line">			<span class="comment">// 从b解析，然后填充到f的对应字段</span></span><br><span class="line">			b, err = fn(b, m.offset(f.field), wire)</span><br><span class="line">			<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">				reqMask |= f.reqMask</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> r, ok := err.(*RequiredNotSetError); ok &#123;</span><br><span class="line">				<span class="comment">// Remember this error, but keep parsing. We need to produce</span></span><br><span class="line">				<span class="comment">// a full parse even if a required field is missing.</span></span><br><span class="line">				<span class="keyword">if</span> errLater == <span class="literal">nil</span> &#123;</span><br><span class="line">					errLater = r</span><br><span class="line">				&#125;</span><br><span class="line">				reqMask |= f.reqMask</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> err != errInternalBadWireType &#123;</span><br><span class="line">				<span class="keyword">if</span> err == errInvalidUTF8 &#123;</span><br><span class="line">					<span class="keyword">if</span> errLater == <span class="literal">nil</span> &#123;</span><br><span class="line">						fullName := revProtoTypes[reflect.PtrTo(u.typ)] + <span class="string">"."</span> + f.name</span><br><span class="line">						errLater = &amp;invalidUTF8Error&#123;fullName&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Fragments with bad wire type are treated as unknown fields.</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Unknown tag.</span></span><br><span class="line">		<span class="comment">// 跳过未知tag，可能是proto中的message定义升级了，增加了一些字段，使用老版本的，就不识别新的字段</span></span><br><span class="line">		<span class="keyword">if</span> !u.unrecognized.IsValid() &#123;</span><br><span class="line">			<span class="comment">// Don't keep unrecognized data; just skip it.</span></span><br><span class="line">			<span class="keyword">var</span> err error</span><br><span class="line">			b, err = skipField(b, wire)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 检查未识别字段是不是extension</span></span><br><span class="line">		<span class="comment">// Keep unrecognized data around.</span></span><br><span class="line">		<span class="comment">// maybe in extensions, maybe in the unrecognized field.</span></span><br><span class="line">		z := m.offset(u.unrecognized).toBytes()</span><br><span class="line">		<span class="keyword">var</span> emap <span class="keyword">map</span>[<span class="keyword">int32</span>]Extension</span><br><span class="line">		<span class="keyword">var</span> e Extension</span><br><span class="line">		<span class="keyword">for</span> _, r := <span class="keyword">range</span> u.extensionRanges &#123;</span><br><span class="line">			<span class="keyword">if</span> <span class="keyword">uint64</span>(r.Start) &lt;= tag &amp;&amp; tag &lt;= <span class="keyword">uint64</span>(r.End) &#123;</span><br><span class="line">				<span class="keyword">if</span> u.extensions.IsValid() &#123;</span><br><span class="line">					mp := m.offset(u.extensions).toExtensions()</span><br><span class="line">					emap = mp.extensionsWrite()</span><br><span class="line">					e = emap[<span class="keyword">int32</span>(tag)]</span><br><span class="line">					z = &amp;e.enc</span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> u.oldExtensions.IsValid() &#123;</span><br><span class="line">					p := m.offset(u.oldExtensions).toOldExtensions()</span><br><span class="line">					emap = *p</span><br><span class="line">					<span class="keyword">if</span> emap == <span class="literal">nil</span> &#123;</span><br><span class="line">						emap = <span class="keyword">map</span>[<span class="keyword">int32</span>]Extension&#123;&#125;</span><br><span class="line">						*p = emap</span><br><span class="line">					&#125;</span><br><span class="line">					e = emap[<span class="keyword">int32</span>(tag)]</span><br><span class="line">					z = &amp;e.enc</span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="built_in">panic</span>(<span class="string">"no extensions field available"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Use wire type to skip data.</span></span><br><span class="line">		<span class="keyword">var</span> err error</span><br><span class="line">		b0 := b</span><br><span class="line">		b, err = skipField(b, wire)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		*z = encodeVarint(*z, tag&lt;&lt;<span class="number">3</span>|<span class="keyword">uint64</span>(wire))</span><br><span class="line">		*z = <span class="built_in">append</span>(*z, b0[:<span class="built_in">len</span>(b0)-<span class="built_in">len</span>(b)]...)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> emap != <span class="literal">nil</span> &#123;</span><br><span class="line">			emap[<span class="keyword">int32</span>(tag)] = e</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 校验解析到的required字段的数量，如果与u中记录的不匹配，则报错</span></span><br><span class="line">	<span class="keyword">if</span> reqMask != u.reqMask &amp;&amp; errLater == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// A required field of this message is missing.</span></span><br><span class="line">		<span class="keyword">for</span> _, n := <span class="keyword">range</span> u.reqFields &#123;</span><br><span class="line">			<span class="keyword">if</span> reqMask&amp;<span class="number">1</span> == <span class="number">0</span> &#123;</span><br><span class="line">				errLater = &amp;RequiredNotSetError&#123;n&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			reqMask &gt;&gt;= <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> errLater</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置字段反序列化函数的过程不看了，看一下怎么选函数的，<code>typeUnmarshaler</code>是为字段类型，选择反序列化函数，这些函数选择与序列化函数是一一对应的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// typeUnmarshaler returns an unmarshaler for the given field type / field tag pair.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">typeUnmarshaler</span><span class="params">(t reflect.Type, tags <span class="keyword">string</span>)</span> <span class="title">unmarshaler</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Figure out packaging (pointer, slice, or both)</span></span><br><span class="line">	slice := <span class="literal">false</span></span><br><span class="line">	pointer := <span class="literal">false</span></span><br><span class="line">	<span class="keyword">if</span> t.Kind() == reflect.Slice &amp;&amp; t.Elem().Kind() != reflect.Uint8 &#123;</span><br><span class="line">		slice = <span class="literal">true</span></span><br><span class="line">		t = t.Elem()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> t.Kind() == reflect.Ptr &#123;</span><br><span class="line">		pointer = <span class="literal">true</span></span><br><span class="line">		t = t.Elem()</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">switch</span> t.Kind() &#123;</span><br><span class="line">	<span class="keyword">case</span> reflect.Bool:</span><br><span class="line">		<span class="keyword">if</span> pointer &#123;</span><br><span class="line">			<span class="keyword">return</span> unmarshalBoolPtr</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> slice &#123;</span><br><span class="line">			<span class="keyword">return</span> unmarshalBoolSlice</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">return</span> unmarshalBoolValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>unmarshalBoolValue</code>是默认的Bool类型反序列化函数，会把protobuf数据b解码，然后转换为bool类型v，最后赋值给字段f。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unmarshalBoolValue</span><span class="params">(b []<span class="keyword">byte</span>, f pointer, w <span class="keyword">int</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> w != WireVarint &#123;</span><br><span class="line">		<span class="keyword">return</span> b, errInternalBadWireType</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Note: any length varint is allowed, even though any sane</span></span><br><span class="line">	<span class="comment">// encoder will use one byte.</span></span><br><span class="line">	<span class="comment">// See https://github.com/golang/protobuf/issues/76</span></span><br><span class="line">	x, n := decodeVarint(b)</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, io.ErrUnexpectedEOF</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> check if x&gt;1? Tests seem to indicate no.</span></span><br><span class="line">    <span class="comment">// toBool是返回bool类型的指针</span></span><br><span class="line">	<span class="comment">// 完成对字段f的赋值</span></span><br><span class="line">	v := x != <span class="number">0</span></span><br><span class="line">	*f.toBool() = v</span><br><span class="line">	<span class="keyword">return</span> b[n:], <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文分析了Go语言protobuf数据的序列化和反序列过程，可以简要概括为：</p>
<ol>
<li><code>proto.Marshal</code>和<code>proto.Unmarshal</code>会调用<code>*.pb.go</code>中自动生成的Wrapper函数，Wrapper函数会调用<code>InternalMessageInfo</code>进行(反)序列化，然后才步入(反)序列化的正题</li>
<li>首先获取要目标类型的(un)marshal信息u，如果u没有初始化，则进行初始化，即设置好结构体每个字段的(反)序列化函数，以及其他信息</li>
<li>遍历结构体的每个字段，使用u中的信息为每个字段进行编码，生成序列化的结果，或进行解码，给结构体成员进行赋值</li>
</ol>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>以下参考文章都值得阅读：</p>
<ul>
<li><a href="https://tech.meituan.com/2015/02/26/serialization-vs-deserialization.html" target="_blank" rel="noopener">https://tech.meituan.com/2015/02/26/serialization-vs-deserialization.html</a><br>《序列化和反序列化》出自美团技术团队，值得一读。</li>
<li><a href="https://github.com/golang/protobuf" target="_blank" rel="noopener">https://github.com/golang/protobuf</a><br>Go支持protocol buffer的仓库，Readme，值得详读。</li>
<li><a href="https://developers.google.com/protocol-buffers/docs/gotutorial" target="_blank" rel="noopener">https://developers.google.com/protocol-buffers/docs/gotutorial</a><br>Google Protocol Buffers的Go语言tutorial，值得详细阅读和实操。</li>
<li><a href="https://developers.google.com/protocol-buffers/docs/overview" target="_blank" rel="noopener">https://developers.google.com/protocol-buffers/docs/overview</a><br>Google Protocol Buffers的Overview，介绍了什么是Protocol Buffers，它的原理、历史（起源），以及和XML的对比，必读。</li>
<li><a href="https://developers.google.com/protocol-buffers/docs/proto3" target="_blank" rel="noopener">https://developers.google.com/protocol-buffers/docs/proto3</a><br>《Language Guide (proto3)》这篇文章介绍了proto3的定义，也可以理解为<code>.proto</code>文件的语法，就如同Go语言的语法，不懂语法怎么编写<code>.proto</code>文件？读这篇文章会了解很多原理，以及可以少踩坑，必读。</li>
<li><a href="https://developers.google.com/protocol-buffers/docs/reference/go-generated" target="_blank" rel="noopener">https://developers.google.com/protocol-buffers/docs/reference/go-generated</a><br>《Go Generated Code》这篇文章详细介绍了protoc是怎么用<code>.protoc</code>生成<code>.pb.go</code>的，可选。</li>
<li><a href="https://developers.google.com/protocol-buffers/docs/encoding#" target="_blank" rel="noopener">https://developers.google.com/protocol-buffers/docs/encoding#</a><br>《Protocol Buffers Encoding》这篇介绍编码原理，可选。</li>
<li><a href="https://godoc.org/github.com/golang/protobuf/proto" target="_blank" rel="noopener">https://godoc.org/github.com/golang/protobuf/proto</a><br>《package proto文档》可以把proto包当做Go语言操作protobuf数据的SDK，它实现了结构体和protobuf数据的转换，它和<code>.pb.go</code>文件配合使用。</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="http://img.lessisbetter.site/gzh-qrcode-logo-small.png"
                alt="大彬" />
            
              <p class="site-author-name" itemprop="name">大彬</p>
              <p class="site-description motion-element" itemprop="description">区块链、Go语言</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives">
                
                    <span class="site-state-item-count">115</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">63</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="http://img.lessisbetter.site/gzh-qrcode-logo-small.png" title="公众号 &rarr; http://img.lessisbetter.site/gzh-qrcode-logo-small.png" rel="noopener" target="_blank"><i class="fa fa-fw fa-wechat"></i>公众号</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/shitaibin" title="GitHub &rarr; https://github.com/shitaibin" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://segmentfault.com/u/lessisbetter" title="SegmentFault &rarr; https://segmentfault.com/u/lessisbetter" rel="noopener" target="_blank"><i class="fa fa-fw fa-crosshairs"></i>SegmentFault</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://www.jianshu.com/u/947f3ccdd481" title="简书 &rarr; https://www.jianshu.com/u/947f3ccdd481" rel="noopener" target="_blank"><i class="fa fa-fw fa-heartbeat"></i>简书</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://stackoverflow.com/users/4296218/james-shi" title="StackOverflow &rarr; https://stackoverflow.com/users/4296218/james-shi" rel="noopener" target="_blank"><i class="fa fa-fw fa-stack-overflow"></i>StackOverflow</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:hz_stb@163.com" title="E-Mail &rarr; mailto:hz_stb@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友链
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://xargin.com" title="https://xargin.com" rel="noopener" target="_blank">Xargin曹大博客</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://pingcap.com/blog-cn/" title="https://pingcap.com/blog-cn/" rel="noopener" target="_blank">PingCap技术博客</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://qcrao.github.io/" title="https://qcrao.github.io/" rel="noopener" target="_blank">码农桃花源博客</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://book.eddycjy.com/golang/" title="https://book.eddycjy.com/golang/" rel="noopener" target="_blank">煎鱼的迷之博客</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://dave.cheney.net" title="https://dave.cheney.net" rel="noopener" target="_blank">Dave Cheney的博客</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">[object Object]</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v6.6.0</div>


<a href="http://www.beian.miit.gov.cn"> 浙ICP备18051706号</a> 



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv" title="总访客量">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="site-pv" title="总访问量">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









  <div style="display: none;">
    <script src="//s95.cnzz.com/z_stat.php?id=1275814754&web_id=1275814754" language="JavaScript"></script>
  </div>



        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script src="/js/src/utils.js?v=6.6.0"></script>

  <script src="/js/src/motion.js?v=6.6.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.6.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.6.0"></script>



  

  


  <script src="/js/src/bootstrap.js?v=6.6.0"></script>



  



  











  





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  

  
  

  

  

  

  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  <script>
    $('.highlight').each(function (i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap');
      $(e).after($wrap);
      $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function (e) {
        var code = $(this).parent().find('.code').find('.line').map(function (i, e) {
          return $(e).text();
        }).toArray().join('\n');
        var ta = document.createElement('textarea');
        var range = document.createRange(); //For Chrome
        var sel = window.getSelection(); //For Chrome
        var yPosition = window.pageYOffset || document.documentElement.scrollTop;
        ta.style.top = yPosition + 'px'; //Prevent page scroll
        ta.style.position = 'absolute';
        ta.style.opacity = '0';
        ta.value = code;
        ta.textContent = code; //For FireFox
        ta.contentEditable = true;
        ta.readOnly = false;
        document.body.appendChild(ta);
        range.selectNode(ta);
        sel.removeAllRanges();
        sel.addRange(range);
        ta.setSelectionRange(0, code.length);
        var result = document.execCommand('copy');
        
        ta.blur(); //For iOS
        $(this).blur();
      })).on('mouseleave', function (e) {
        var $b = $(this).find('.copy-btn');
        setTimeout(function () {
          $b.text('复制');
        }, 300);
      }).append(e);
    })
  </script>


  

</body>
</html>
